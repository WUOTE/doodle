var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Application"] = "application";
  ExtensionType2["WebGLPipes"] = "webgl-pipes";
  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
  ExtensionType2["WebGLSystem"] = "webgl-system";
  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
  ExtensionType2["WebGPUSystem"] = "webgpu-system";
  ExtensionType2["CanvasSystem"] = "canvas-system";
  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
  ExtensionType2["CanvasPipes"] = "canvas-pipes";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  ExtensionType2["MaskEffect"] = "mask-effect";
  ExtensionType2["BlendMode"] = "blend-mode";
  ExtensionType2["TextureSource"] = "texture-source";
  ExtensionType2["Environment"] = "environment";
  ExtensionType2["ShapeBuilder"] = "shape-builder";
  ExtensionType2["Batcher"] = "batcher";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed. Can be:
   * - Extension class with static `extension` property
   * - Extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns {extensions} this for chaining
   * @example
   * ```ts
   * // Remove a single extension
   * extensions.remove(MyRendererPlugin);
   *
   * // Remove multiple extensions
   * extensions.remove(
   *     MyRendererPlugin,
   *     MySystemPlugin
   * );
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   */
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => this._removeHandlers[type]?.(ext));
    });
    return this;
  },
  /**
   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
   * - As a class with a static `extension` property
   * - As an extension format object
   * - As multiple extensions passed as separate arguments
   * @param extensions - Extensions to add to PixiJS. Each can be:
   * - A class with static `extension` property
   * - An extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns This extensions instance for chaining
   * @example
   * ```ts
   * // Register a simple extension
   * extensions.add(MyRendererPlugin);
   *
   * // Register multiple extensions
   * extensions.add(
   *     MyRendererPlugin,
   *     MySystemPlugin,
   * });
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   * @see {@link extensions.remove} For removing registered extensions
   */
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type) => {
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type]) {
          queue[type] = queue[type] || [];
          queue[type]?.push(ext);
        } else {
          handlers[type]?.(ext);
        }
      });
    });
    return this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns this for chaining.
   * @internal
   * @ignore
   */
  handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw new Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    const queue = this._queue;
    if (queue[type]) {
      queue[type]?.forEach((ext) => onAdd(ext));
      delete queue[type];
    }
    return this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns this for chaining.
   * @ignore
   */
  handleByMap(type, map) {
    return this.handle(
      type,
      (extension) => {
        if (extension.name) {
          map[extension.name] = extension.ref;
        }
      },
      (extension) => {
        if (extension.name) {
          delete map[extension.name];
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns this for chaining.
   * @ignore
   */
  handleByNamedList(type, map, defaultPriority = -1) {
    return this.handle(
      type,
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index >= 0) return;
        map.push({ name: extension.name, value: extension.ref });
        map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority));
      },
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index !== -1) {
          map.splice(index, 1);
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns this for chaining.
   * @ignore
   */
  handleByList(type, list, defaultPriority = -1) {
    return this.handle(
      type,
      (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        if (index !== -1) {
          list.splice(index, 1);
        }
      }
    );
  },
  /**
   * Mixin the source object(s) properties into the target class's prototype.
   * Copies all property descriptors from source objects to the target's prototype.
   * @param Target - The target class to mix properties into
   * @param sources - One or more source objects containing properties to mix in
   * @example
   * ```ts
   * // Create a mixin with shared properties
   * const moveable = {
   *     x: 0,
   *     y: 0,
   *     move(x: number, y: number) {
   *         this.x += x;
   *         this.y += y;
   *     }
   * };
   *
   * // Create a mixin with computed properties
   * const scalable = {
   *     scale: 1,
   *     get scaled() {
   *         return this.scale > 1;
   *     }
   * };
   *
   * // Apply mixins to a class
   * extensions.mixin(Sprite, moveable, scalable);
   *
   * // Use mixed-in properties
   * const sprite = new Sprite();
   * sprite.move(10, 20);
   * console.log(sprite.x, sprite.y); // 10, 20
   * ```
   * @remarks
   * - Copies all properties including getters/setters
   * - Does not modify source objects
   * - Preserves property descriptors
   * @see {@link Object.defineProperties} For details on property descriptors
   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
   */
  mixin(Target, ...sources) {
    for (const source of sources) {
      Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));
    }
  }
};

const browserExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await Promise.resolve().then(function () { return browserAll; });
  }
};

const webworkerExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await Promise.resolve().then(function () { return webworkerAll; });
  }
};

class ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(observer, x, y) {
    this._x = x || 0;
    this._y = y || 0;
    this._observer = observer;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(observer) {
    return new ObservablePoint(observer ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(x = 0, y = x) {
    if (this._x !== x || this._y !== y) {
      this._x = x;
      this._y = y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(p) {
    if (this._x !== p.x || this._y !== p.y) {
      this._x = p.x;
      this._y = p.y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(p) {
    p.set(this._x, this._y);
    return p;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(p) {
    return p.x === this._x && p.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    if (this._x !== value) {
      this._x = value;
      this._observer._onUpdate(this);
    }
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    if (this._y !== value) {
      this._y = value;
      this._observer._onUpdate(this);
    }
  }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var eventemitter3 = {exports: {}};

var hasRequiredEventemitter3;

function requireEventemitter3 () {
	if (hasRequiredEventemitter3) return eventemitter3.exports;
	hasRequiredEventemitter3 = 1;
	(function (module) {

		var has = Object.prototype.hasOwnProperty
		  , prefix = '~';

		/**
		 * Constructor to create a storage for our `EE` objects.
		 * An `Events` instance is a plain object whose properties are event names.
		 *
		 * @constructor
		 * @private
		 */
		function Events() {}

		//
		// We try to not inherit from `Object.prototype`. In some engines creating an
		// instance in this way is faster than calling `Object.create(null)` directly.
		// If `Object.create(null)` is not supported we prefix the event names with a
		// character to make sure that the built-in object properties are not
		// overridden or used as an attack vector.
		//
		if (Object.create) {
		  Events.prototype = Object.create(null);

		  //
		  // This hack is needed because the `__proto__` property is still inherited in
		  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
		  //
		  if (!new Events().__proto__) prefix = false;
		}

		/**
		 * Representation of a single event listener.
		 *
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
		 * @constructor
		 * @private
		 */
		function EE(fn, context, once) {
		  this.fn = fn;
		  this.context = context;
		  this.once = once || false;
		}

		/**
		 * Add a listener for a given event.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} context The context to invoke the listener with.
		 * @param {Boolean} once Specify if the listener is a one-time listener.
		 * @returns {EventEmitter}
		 * @private
		 */
		function addListener(emitter, event, fn, context, once) {
		  if (typeof fn !== 'function') {
		    throw new TypeError('The listener must be a function');
		  }

		  var listener = new EE(fn, context || emitter, once)
		    , evt = prefix ? prefix + event : event;

		  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
		  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
		  else emitter._events[evt] = [emitter._events[evt], listener];

		  return emitter;
		}

		/**
		 * Clear event by name.
		 *
		 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
		 * @param {(String|Symbol)} evt The Event name.
		 * @private
		 */
		function clearEvent(emitter, evt) {
		  if (--emitter._eventsCount === 0) emitter._events = new Events();
		  else delete emitter._events[evt];
		}

		/**
		 * Minimal `EventEmitter` interface that is molded against the Node.js
		 * `EventEmitter` interface.
		 *
		 * @constructor
		 * @public
		 */
		function EventEmitter() {
		  this._events = new Events();
		  this._eventsCount = 0;
		}

		/**
		 * Return an array listing the events for which the emitter has registered
		 * listeners.
		 *
		 * @returns {Array}
		 * @public
		 */
		EventEmitter.prototype.eventNames = function eventNames() {
		  var names = []
		    , events
		    , name;

		  if (this._eventsCount === 0) return names;

		  for (name in (events = this._events)) {
		    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
		  }

		  if (Object.getOwnPropertySymbols) {
		    return names.concat(Object.getOwnPropertySymbols(events));
		  }

		  return names;
		};

		/**
		 * Return the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Array} The registered listeners.
		 * @public
		 */
		EventEmitter.prototype.listeners = function listeners(event) {
		  var evt = prefix ? prefix + event : event
		    , handlers = this._events[evt];

		  if (!handlers) return [];
		  if (handlers.fn) return [handlers.fn];

		  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
		    ee[i] = handlers[i].fn;
		  }

		  return ee;
		};

		/**
		 * Return the number of listeners listening to a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Number} The number of listeners.
		 * @public
		 */
		EventEmitter.prototype.listenerCount = function listenerCount(event) {
		  var evt = prefix ? prefix + event : event
		    , listeners = this._events[evt];

		  if (!listeners) return 0;
		  if (listeners.fn) return 1;
		  return listeners.length;
		};

		/**
		 * Calls each of the listeners registered for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @returns {Boolean} `true` if the event had listeners, else `false`.
		 * @public
		 */
		EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return false;

		  var listeners = this._events[evt]
		    , len = arguments.length
		    , args
		    , i;

		  if (listeners.fn) {
		    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

		    switch (len) {
		      case 1: return listeners.fn.call(listeners.context), true;
		      case 2: return listeners.fn.call(listeners.context, a1), true;
		      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
		      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
		      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
		      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
		    }

		    for (i = 1, args = new Array(len -1); i < len; i++) {
		      args[i - 1] = arguments[i];
		    }

		    listeners.fn.apply(listeners.context, args);
		  } else {
		    var length = listeners.length
		      , j;

		    for (i = 0; i < length; i++) {
		      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

		      switch (len) {
		        case 1: listeners[i].fn.call(listeners[i].context); break;
		        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
		        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
		        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
		        default:
		          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
		            args[j - 1] = arguments[j];
		          }

		          listeners[i].fn.apply(listeners[i].context, args);
		      }
		    }
		  }

		  return true;
		};

		/**
		 * Add a listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.on = function on(event, fn, context) {
		  return addListener(this, event, fn, context, false);
		};

		/**
		 * Add a one-time listener for a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn The listener function.
		 * @param {*} [context=this] The context to invoke the listener with.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.once = function once(event, fn, context) {
		  return addListener(this, event, fn, context, true);
		};

		/**
		 * Remove the listeners of a given event.
		 *
		 * @param {(String|Symbol)} event The event name.
		 * @param {Function} fn Only remove the listeners that match this function.
		 * @param {*} context Only remove the listeners that have this context.
		 * @param {Boolean} once Only remove one-time listeners.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
		  var evt = prefix ? prefix + event : event;

		  if (!this._events[evt]) return this;
		  if (!fn) {
		    clearEvent(this, evt);
		    return this;
		  }

		  var listeners = this._events[evt];

		  if (listeners.fn) {
		    if (
		      listeners.fn === fn &&
		      (!once || listeners.once) &&
		      (!context || listeners.context === context)
		    ) {
		      clearEvent(this, evt);
		    }
		  } else {
		    for (var i = 0, events = [], length = listeners.length; i < length; i++) {
		      if (
		        listeners[i].fn !== fn ||
		        (once && !listeners[i].once) ||
		        (context && listeners[i].context !== context)
		      ) {
		        events.push(listeners[i]);
		      }
		    }

		    //
		    // Reset the array, or remove it completely if we have no more listeners.
		    //
		    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
		    else clearEvent(this, evt);
		  }

		  return this;
		};

		/**
		 * Remove all listeners, or those of the specified event.
		 *
		 * @param {(String|Symbol)} [event] The event name.
		 * @returns {EventEmitter} `this`.
		 * @public
		 */
		EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
		  var evt;

		  if (event) {
		    evt = prefix ? prefix + event : event;
		    if (this._events[evt]) clearEvent(this, evt);
		  } else {
		    this._events = new Events();
		    this._eventsCount = 0;
		  }

		  return this;
		};

		//
		// Alias methods names because people roll like that.
		//
		EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
		EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		//
		// Expose the prefix.
		//
		EventEmitter.prefixed = prefix;

		//
		// Allow `EventEmitter` to be imported as module namespace.
		//
		EventEmitter.EventEmitter = EventEmitter;

		//
		// Expose the module.
		//
		{
		  module.exports = EventEmitter;
		} 
	} (eventemitter3));
	return eventemitter3.exports;
}

var eventemitter3Exports = requireEventemitter3();
var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;

class Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x = 0, y = 0) {
    /**
     * Position of the point on the x axis
     * @example
     * ```ts
     * // Set x position
     * const point = new Point();
     * point.x = 100;
     *
     * // Use in calculations
     * const width = rightPoint.x - leftPoint.x;
     * ```
     */
    this.x = 0;
    /**
     * Position of the point on the y axis
     * @example
     * ```ts
     * // Set y position
     * const point = new Point();
     * point.y = 200;
     *
     * // Use in calculations
     * const height = bottomPoint.y - topPoint.y;
     * ```
     */
    this.y = 0;
    this.x = x;
    this.y = y;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new Point(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(p) {
    this.set(p.x, p.y);
    return this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(p) {
    p.set(this.x, this.y);
    return p;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(p) {
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(x = 0, y = x) {
    this.x = x;
    this.y = y;
    return this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    tempPoint.x = 0;
    tempPoint.y = 0;
    return tempPoint;
  }
}
const tempPoint = new Point();

class Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
    /**
     * Array representation of the matrix.
     * Only populated when `toArray()` is called.
     * @default null
     * @see {@link Matrix.toArray} For filling this array
     */
    this.array = null;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(transpose, out) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x = pos.x;
    const y = pos.y;
    newPos.x = this.a * x + this.c * y + this.tx;
    newPos.y = this.b * x + this.d * y + this.ty;
    return newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const tx = this.tx;
    const ty = this.ty;
    const id = 1 / (a * d + c * -b);
    const x = pos.x;
    const y = pos.y;
    newPos.x = d * id * x + -c * id * y + (ty * c - tx * d) * id;
    newPos.y = a * id * y + -b * id * x + (-ty * a + tx * b) * id;
    return newPos;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(x, y) {
    this.tx += x;
    this.ty += y;
    return this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(x, y) {
    this.a *= x;
    this.d *= y;
    this.c *= x;
    this.b *= y;
    this.tx *= x;
    this.ty *= y;
    return this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(a, b) {
    const a1 = a.a;
    const b1 = a.b;
    const c1 = a.c;
    const d1 = a.d;
    const tx = a.tx;
    const ty = a.ty;
    const a2 = b.a;
    const b2 = b.b;
    const c2 = b.c;
    const d2 = b.d;
    this.a = a1 * a2 + b1 * c2;
    this.b = a1 * b2 + b1 * d2;
    this.c = c1 * a2 + d1 * c2;
    this.d = c1 * b2 + d1 * d2;
    this.tx = tx * a2 + ty * c2 + b.tx;
    this.ty = tx * b2 + ty * d2 + b.ty;
    return this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x - (pivotX * this.a + pivotY * this.c);
    this.ty = y - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(transform) {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const d = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c, d);
    const skewY = Math.atan2(b, a);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a * a + b * b);
    transform.scale.y = Math.sqrt(c * c + d * d);
    transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
    transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
    return transform;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original â‰ˆ point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n = a1 * d1 - b1 * c1;
    this.a = d1 / n;
    this.b = -b1 / n;
    this.c = -c1 / n;
    this.d = a1 / n;
    this.tx = (c1 * this.ty - d1 * tx1) / n;
    this.ty = -(a1 * this.ty - b1 * tx1) / n;
    return this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(matrix) {
    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return identityMatrix$1.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return tempMatrix$6.identity();
  }
}
const tempMatrix$6 = new Matrix();
const identityMatrix$1 = new Matrix();

const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i = 0; i < 16; i++) {
    const row = [];
    rotationCayley.push(row);
    for (let j = 0; j < 16; j++) {
      const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);
      const _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);
      const _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);
      const _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
      for (let k = 0; k < 16; k++) {
        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
          row.push(k);
          break;
        }
      }
    }
  }
  for (let i = 0; i < 16; i++) {
    const mat = new Matrix();
    mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0Â°       | East      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45Â°â†»     | Southeast |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90Â°â†»     | South     |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135Â°â†»    | Southwest |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180Â°     | West      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135Â°/225Â°â†» | Northwest    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90Â°/270Â°â†»  | North        |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45Â°/315Â°â†»  | Northeast    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @group groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @group groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @group groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @group groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   * @param {number} dw - sprite width
   * @param {number} dh - sprite height
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0, dw = 0, dh = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    const a = mat.a;
    const b = mat.b;
    const c = mat.c;
    const d = mat.d;
    const finalTx = tx - Math.min(0, a * dw, c * dh, a * dw + c * dh);
    const finalTy = ty - Math.min(0, b * dw, d * dh, b * dw + d * dh);
    const a1 = matrix.a;
    const b1 = matrix.b;
    const c1 = matrix.c;
    const d1 = matrix.d;
    matrix.a = a * a1 + b * c1;
    matrix.b = a * b1 + b * d1;
    matrix.c = c * a1 + d * c1;
    matrix.d = c * b1 + d * d1;
    matrix.tx = finalTx * a1 + finalTy * c1 + matrix.tx;
    matrix.ty = finalTx * b1 + finalTy * d1 + matrix.ty;
  },
  /**
   * Transforms rectangle coordinates based on texture packer rotation.
   * Used when texture atlas pages are rotated and coordinates need to be adjusted.
   * @group groupD8
   * @param {RectangleLike} rect - Rectangle with original coordinates to transform
   * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
   * @param {GD8Symmetry} rotation - The groupD8 rotation value
   * @param {Rectangle} out - Rectangle to store the result
   * @returns {Rectangle} Transformed coordinates (includes source frame offset)
   */
  transformRectCoords: (rect, sourceFrame, rotation, out) => {
    const { x, y, width, height } = rect;
    const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;
    if (rotation === groupD8.E) {
      out.set(x + frameX, y + frameY, width, height);
      return out;
    } else if (rotation === groupD8.S) {
      return out.set(
        frameWidth - y - height + frameX,
        x + frameY,
        height,
        width
      );
    } else if (rotation === groupD8.W) {
      return out.set(
        frameWidth - x - width + frameX,
        frameHeight - y - height + frameY,
        width,
        height
      );
    } else if (rotation === groupD8.N) {
      return out.set(
        y + frameX,
        frameHeight - x - width + frameY,
        height,
        width
      );
    }
    return out.set(x + frameX, y + frameY, width, height);
  }
};

const tempPoints = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x = 0, y = 0, width = 0, height = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @example
     * ```ts
     * // Check shape type
     * const shape = new Rectangle(0, 0, 100, 100);
     * console.log(shape.type); // 'rectangle'
     *
     * // Use in type guards
     * if (shape.type === 'rectangle') {
     *     console.log(shape.width, shape.height);
     * }
     * ```
     * @readonly
     * @default 'rectangle'
     * @see {@link SHAPE_PRIMITIVE} For all shape types
     */
    this.type = "rectangle";
    this.x = Number(x);
    this.y = Number(y);
    this.width = Number(width);
    this.height = Number(height);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(bounds) {
    this.x = bounds.minX;
    this.y = bounds.minY;
    this.width = bounds.maxX - bounds.minX;
    this.height = bounds.maxY - bounds.minY;
    return this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x < this.x + this.width) {
      if (y >= this.y && y < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const { width, height } = this;
    if (width <= 0 || height <= 0) return false;
    const _x = this.x;
    const _y = this.y;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const outerLeft = _x - strokeWidthOuter;
    const outerRight = _x + width + strokeWidthOuter;
    const outerTop = _y - strokeWidthOuter;
    const outerBottom = _y + height + strokeWidthOuter;
    const innerLeft = _x + strokeWidthInner;
    const innerRight = _x + width - strokeWidthInner;
    const innerTop = _y + strokeWidthInner;
    const innerBottom = _y + height - strokeWidthInner;
    return x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s * (lb.y - lt.y);
    const ny = s * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s * (lt.y - rt.y);
    const my = s * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(resolution = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
    this.x = Math.floor((this.x + eps) * resolution) / resolution;
    this.y = Math.floor((this.y + eps) * resolution) / resolution;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  /**
   * Scales the rectangle's dimensions and position by the specified factors.
   * @example
   * ```ts
   * const rect = new Rectangle(50, 50, 100, 100);
   *
   * // Scale uniformly
   * rect.scale(0.5, 0.5);
   * // rect is now: x=25, y=25, width=50, height=50
   *
   * // non-uniformly
   * rect.scale(0.5, 1);
   * // rect is now: x=25, y=50, width=50, height=100
   * ```
   * @param x - The factor by which to scale the horizontal properties (x, width).
   * @param y - The factor by which to scale the vertical properties (y, height).
   * @returns Returns itself
   */
  scale(x, y = x) {
    this.x *= x;
    this.y *= y;
    this.width *= x;
    this.height *= y;
    return this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(out) {
    out || (out = new Rectangle());
    out.copyFrom(this);
    return out;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(other) {
    if (this.width <= 0 || this.height <= 0) return false;
    const x1 = other.x;
    const y1 = other.y;
    const x2 = other.x + other.width;
    const y2 = other.y + other.height;
    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    return this;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}

const uidCache = {
  default: -1
};
function uid$1(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}

const warnings = /* @__PURE__ */ new Set();
const v8_0_0 = "8.0.0";
const v8_3_4 = "8.3.4";
const deprecationState = {
  quiet: false,
  noColor: false
};
const deprecation = ((version, message, ignoreDepth = 3) => {
  if (deprecationState.quiet || warnings.has(message)) return;
  let stack = new Error().stack;
  const deprecationMessage = `${message}
Deprecated since v${version}`;
  const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (useGroup) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        deprecationMessage
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
      console.warn(stack);
    }
  }
  warnings.add(message);
});
Object.defineProperties(deprecation, {
  quiet: {
    get: () => deprecationState.quiet,
    set: (value) => {
      deprecationState.quiet = value;
    },
    enumerable: true,
    configurable: false
  },
  noColor: {
    get: () => deprecationState.noColor,
    set: (value) => {
      deprecationState.noColor = value;
    },
    enumerable: true,
    configurable: false
  }
});

const NOOP$1 = () => {
};

function nextPow2(v) {
  v += v === 0 ? 1 : 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}
function isPow2(v) {
  return !(v & v - 1) && !!v;
}

function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0) {
      result[key] = obj[key];
    }
  }
  return result;
}

const idHash$1 = /* @__PURE__ */ Object.create(null);
function createResourceIdFromString(value) {
  const id = idHash$1[value];
  if (id === void 0) {
    idHash$1[value] = uid$1("resource");
  }
  return id;
}
const _TextureStyle = class _TextureStyle extends EventEmitter {
  /**
   * @param options - options for the style
   */
  constructor(options = {}) {
    super();
    /** @internal */
    this._resourceType = "textureSampler";
    /** @internal */
    this._touched = 0;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler.
     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will
     * be clamped to the maximum value that the platform supports.
     * @internal
     */
    this._maxAnisotropy = 1;
    /**
     * Has the style been destroyed?
     * @readonly
     */
    this.destroyed = false;
    options = { ..._TextureStyle.defaultOptions, ...options };
    this.addressMode = options.addressMode;
    this.addressModeU = options.addressModeU ?? this.addressModeU;
    this.addressModeV = options.addressModeV ?? this.addressModeV;
    this.addressModeW = options.addressModeW ?? this.addressModeW;
    this.scaleMode = options.scaleMode;
    this.magFilter = options.magFilter ?? this.magFilter;
    this.minFilter = options.minFilter ?? this.minFilter;
    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
    this.lodMinClamp = options.lodMinClamp;
    this.lodMaxClamp = options.lodMaxClamp;
    this.compare = options.compare;
    this.maxAnisotropy = options.maxAnisotropy ?? 1;
  }
  set addressMode(value) {
    this.addressModeU = value;
    this.addressModeV = value;
    this.addressModeW = value;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(value) {
    deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
    this.addressMode = value;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(value) {
    this.magFilter = value;
    this.minFilter = value;
    this.mipmapFilter = value;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(value) {
    this._maxAnisotropy = Math.min(value, 16);
    if (this._maxAnisotropy > 1) {
      this.scaleMode = "linear";
    }
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this._sharedResourceId = null;
    this.emit("change", this);
  }
  _generateResourceId() {
    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    this._sharedResourceId = createResourceIdFromString(bigKey);
    return this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    this.removeAllListeners();
  }
};
/** default options for the style */
_TextureStyle.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let TextureStyle = _TextureStyle;

const _TextureSource = class _TextureSource extends EventEmitter {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(options = {}) {
    super();
    this.options = options;
    /** @internal */
    this._gpuData = /* @__PURE__ */ Object.create(null);
    /** @internal */
    this._gcLastUsed = -1;
    /** unique id for this Texture source */
    this.uid = uid$1("textureSource");
    /**
     * The resource type used by this TextureSource. This is used by the bind groups to determine
     * how to handle this resource.
     * @internal
     */
    this._resourceType = "textureSource";
    /**
     * i unique resource id, used by the bind group systems.
     * This can change if the texture is resized or its resource changes
     * @internal
     */
    this._resourceId = uid$1("resource");
    /**
     * this is how the backends know how to upload this texture to the GPU
     * It changes depending on the resource type. Classes that extend TextureSource
     * should override this property.
     * @internal
     */
    this.uploadMethodId = "unknown";
    /** @internal */
    this._resolution = 1;
    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */
    this.pixelWidth = 1;
    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */
    this.pixelHeight = 1;
    /**
     * the width of this texture source, accounting for resolution
     * eg pixelWidth 200, resolution 2, then width will be 100
     */
    this.width = 1;
    /**
     * the height of this texture source, accounting for resolution
     * eg pixelHeight 200, resolution 2, then height will be 100
     */
    this.height = 1;
    /**
     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.
     * To enable multisample for a texture, set antialias to true
     * @internal
     */
    this.sampleCount = 1;
    /**
     * The number of mip levels to generate for this texture.
     * this is overridden if autoGenerateMipmaps is true. it is read only!
     */
    this.mipLevelCount = 1;
    /**
     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps
     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but
     * can look better when scaled down.
     *
     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.
     * If you do, make sure to call `updateMipmaps` after you update the texture.
     */
    this.autoGenerateMipmaps = false;
    /** the format that the texture data has */
    this.format = "rgba8unorm";
    /** how many dimensions does this texture have? currently v8 only supports 2d */
    this.dimension = "2d";
    /** how this texture is viewed/sampled by shaders (WebGPU view dimension) */
    this.viewDimension = "2d";
    /** how many array layers this texture has (WebGPU depthOrArrayLayers) */
    this.arrayLayerCount = 1;
    /**
     * Only really affects RenderTextures.
     * Should we use antialiasing for this texture. It will look better, but may impact performance as a
     * Blit operation will be required to resolve the texture.
     */
    this.antialias = false;
    /**
     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
     * @protected
     */
    this._touched = 0;
    /**
     * Used by the batcher to build texture batches. faster to have the variable here!
     * @protected
     */
    this._batchTick = -1;
    /**
     * A temporary batch location for the texture batching. Here for performance reasons only!
     * @protected
     */
    this._textureBindLocation = -1;
    options = { ..._TextureSource.defaultOptions, ...options };
    this.label = options.label ?? "";
    this.resource = options.resource;
    this.autoGarbageCollect = options.autoGarbageCollect;
    this._resolution = options.resolution;
    if (options.width) {
      this.pixelWidth = options.width * this._resolution;
    } else {
      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
    }
    if (options.height) {
      this.pixelHeight = options.height * this._resolution;
    } else {
      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
    }
    this.width = this.pixelWidth / this._resolution;
    this.height = this.pixelHeight / this._resolution;
    this.format = options.format;
    this.dimension = options.dimensions;
    this.viewDimension = options.viewDimension ?? options.dimensions;
    this.arrayLayerCount = options.arrayLayerCount;
    this.mipLevelCount = options.mipLevelCount;
    this.autoGenerateMipmaps = options.autoGenerateMipmaps;
    this.sampleCount = options.sampleCount;
    this.antialias = options.antialias;
    this.alphaMode = options.alphaMode;
    this.style = new TextureStyle(definedProps(options));
    this.destroyed = false;
    this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(value) {
    if (this.style === value) return;
    this._style?.off("change", this._onStyleChange, this);
    this._style = value;
    this._style?.on("change", this._onStyleChange, this);
    this._onStyleChange();
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(value) {
    this._style.maxAnisotropy = value;
  }
  get maxAnisotropy() {
    return this._style.maxAnisotropy;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(value) {
    this._style.addressMode = value;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(value) {
    this._style.addressMode = value;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(value) {
    this._style.magFilter = value;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(value) {
    this._style.minFilter = value;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(value) {
    this._style.mipmapFilter = value;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(value) {
    this._style.lodMinClamp = value;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(value) {
    this._style.lodMaxClamp = value;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const resolution = this._resolution;
      const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
      if (didResize) return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = true;
    this.unload();
    this.emit("destroy", this);
    if (this._style) {
      this._style.destroy();
      this._style = null;
    }
    this.uploadMethodId = null;
    this.resource = null;
    this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = uid$1("resource");
    this.emit("change", this);
    this.emit("unload", this);
    for (const key in this._gpuData) {
      this._gpuData[key]?.destroy?.();
    }
    this._gpuData = /* @__PURE__ */ Object.create(null);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource } = this;
    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource } = this;
    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(resolution) {
    if (this._resolution === resolution) return;
    this._resolution = resolution;
    this.width = this.pixelWidth / resolution;
    this.height = this.pixelHeight / resolution;
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(width, height, resolution) {
    resolution || (resolution = this._resolution);
    width || (width = this.width);
    height || (height = this.height);
    const newPixelWidth = Math.round(width * resolution);
    const newPixelHeight = Math.round(height * resolution);
    this.width = newPixelWidth / resolution;
    this.height = newPixelHeight / resolution;
    this._resolution = resolution;
    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
      return false;
    }
    this._refreshPOT();
    this.pixelWidth = newPixelWidth;
    this.pixelHeight = newPixelHeight;
    this.emit("resize", this);
    this._resourceId = uid$1("resource");
    this.emit("change", this);
    return true;
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
      this.emit("updateMipmaps", this);
    }
  }
  set wrapMode(value) {
    this._style.wrapMode = value;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(value) {
    this._style.scaleMode = value;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
  }
  static test(_resource) {
    throw new Error("Unimplemented");
  }
};
/** The default options used when creating a new TextureSource. override these to add your own defaults */
_TextureSource.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  viewDimension: "2d",
  arrayLayerCount: 1,
  mipLevelCount: 1,
  autoGenerateMipmaps: false,
  sampleCount: 1,
  antialias: false,
  autoGarbageCollect: false
};
let TextureSource = _TextureSource;

class BufferImageSource extends TextureSource {
  constructor(options) {
    const buffer = options.resource || new Float32Array(options.width * options.height * 4);
    let format = options.format;
    if (!format) {
      if (buffer instanceof Float32Array) {
        format = "rgba32float";
      } else if (buffer instanceof Int32Array) {
        format = "rgba32uint";
      } else if (buffer instanceof Uint32Array) {
        format = "rgba32uint";
      } else if (buffer instanceof Int16Array) {
        format = "rgba16uint";
      } else if (buffer instanceof Uint16Array) {
        format = "rgba16uint";
      } else if (buffer instanceof Int8Array) {
        format = "bgra8unorm";
      } else {
        format = "bgra8unorm";
      }
    }
    super({
      ...options,
      resource: buffer,
      format
    });
    this.uploadMethodId = "buffer";
  }
  static test(resource) {
    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
  }
}
BufferImageSource.extension = ExtensionType.TextureSource;

const tempMat = new Matrix();
class TextureMatrix {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    if (typeof clampMargin === "undefined") {
      this.clampMargin = texture.width < 10 ? 0 : 0.5;
    } else {
      this.clampMargin = clampMargin;
    }
    this.isSimple = false;
    this.texture = texture;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this.texture === value) return;
    this._texture?.removeListener("update", this.update, this);
    this._texture = value;
    this._texture.addListener("update", this.update, this);
    this.update();
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out) {
    if (out === void 0) {
      out = uvs;
    }
    const mat = this.mapCoord;
    for (let i = 0; i < uvs.length; i += 2) {
      const x = uvs[i];
      const y = uvs[i + 1];
      out[i] = x * mat.a + y * mat.c + mat.tx;
      out[i + 1] = x * mat.b + y * mat.d + mat.ty;
    }
    return out;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const tex = this._texture;
    this._updateID++;
    const uvs = tex.uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(
        orig.width / trim.width,
        0,
        0,
        orig.height / trim.height,
        -trim.x / trim.width,
        -trim.y / trim.height
      );
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.source;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase._resolution;
    const offset = this.clampOffset / texBase._resolution;
    frame[0] = (tex.frame.x + margin + offset) / texBase.width;
    frame[1] = (tex.frame.y + margin + offset) / texBase.height;
    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}

class Texture extends EventEmitter {
  /**
   * @param {TextureOptions} options - Options for the texture
   */
  constructor({
    source,
    label,
    frame,
    orig,
    trim,
    defaultAnchor,
    defaultBorders,
    rotate,
    dynamic
  } = {}) {
    super();
    /** unique id for this texture */
    this.uid = uid$1("texture");
    /** A uvs object based on the given frame and the texture source */
    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
    /**
     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
     */
    this.frame = new Rectangle();
    /**
     * Does this Texture have any frame data assigned to it?
     *
     * This mode is enabled automatically if no frame was passed inside constructor.
     *
     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.
     *
     * Beware, after loading or resize of baseTexture event can fired two times!
     * If you want more control, subscribe on baseTexture itself.
     * @example
     * texture.on('update', () => {});
     */
    this.noFrame = false;
    /**
     * Set to true if you plan on modifying the uvs of this texture.
     * When this is the case, sprites and other objects using the texture will
     * make sure to listen for changes to the uvs and update their vertices accordingly.
     */
    this.dynamic = false;
    /** is it a texture? yes! used for type checking */
    this.isTexture = true;
    this.label = label;
    this.source = source?.source ?? new TextureSource();
    this.noFrame = !frame;
    if (frame) {
      this.frame.copyFrom(frame);
    } else {
      const { width, height } = this._source;
      this.frame.width = width;
      this.frame.height = height;
    }
    this.orig = orig || this.frame;
    this.trim = trim;
    this.rotate = rotate ?? 0;
    this.defaultAnchor = defaultAnchor;
    this.defaultBorders = defaultBorders;
    this.destroyed = false;
    this.dynamic = dynamic || false;
    this.updateUvs();
  }
  set source(value) {
    if (this._source) {
      this._source.off("resize", this.update, this);
    }
    this._source = value;
    value.on("resize", this.update, this);
    this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    if (!this._textureMatrix) {
      this._textureMatrix = new TextureMatrix(this);
    }
    return this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs, frame } = this;
    const { width, height } = this._source;
    const nX = frame.x / width;
    const nY = frame.y / height;
    const nW = frame.width / width;
    const nH = frame.height / height;
    let rotate = this.rotate;
    if (rotate) {
      const w2 = nW / 2;
      const h2 = nH / 2;
      const cX = nX + w2;
      const cY = nY + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      uvs.x0 = cX + w2 * groupD8.uX(rotate);
      uvs.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x1 = cX + w2 * groupD8.uX(rotate);
      uvs.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x2 = cX + w2 * groupD8.uX(rotate);
      uvs.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x3 = cX + w2 * groupD8.uX(rotate);
      uvs.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      uvs.x0 = nX;
      uvs.y0 = nY;
      uvs.x1 = nX + nW;
      uvs.y1 = nY;
      uvs.x2 = nX + nW;
      uvs.y2 = nY + nH;
      uvs.x3 = nX;
      uvs.y3 = nY + nH;
    }
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(destroySource = false) {
    if (this._source) {
      this._source.off("resize", this.update, this);
      if (destroySource) {
        this._source.destroy();
        this._source = null;
      }
    }
    this._textureMatrix = null;
    this.destroyed = true;
    this.emit("destroy", this);
    this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    if (this.noFrame) {
      this.frame.width = this._source.width;
      this.frame.height = this._source.height;
    }
    this.updateUvs();
    this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
    return this._source;
  }
}
Texture.EMPTY = new Texture({
  label: "EMPTY",
  source: new TextureSource({
    label: "EMPTY"
  })
});
Texture.EMPTY.destroy = NOOP$1;
Texture.WHITE = new Texture({
  source: new BufferImageSource({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
Texture.WHITE.destroy = NOOP$1;

function updateQuadBounds(bounds, anchor, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
}

const defaultMatrix = new Matrix();
class Bounds {
  /**
   * Creates a new Bounds object.
   * @param minX - The minimum X coordinate of the bounds.
   * @param minY - The minimum Y coordinate of the bounds.
   * @param maxX - The maximum X coordinate of the bounds.
   * @param maxY - The maximum Y coordinate of the bounds.
   */
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    /**
     * The minimum X coordinate of the bounds.
     * Represents the leftmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set left edge
     * bounds.minX = 100;
     * ```
     * @default Infinity
     */
    this.minX = Infinity;
    /**
     * The minimum Y coordinate of the bounds.
     * Represents the topmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set top edge
     * bounds.minY = 100;
     * ```
     * @default Infinity
     */
    this.minY = Infinity;
    /**
     * The maximum X coordinate of the bounds.
     * Represents the rightmost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set right edge
     * bounds.maxX = 200;
     * // Get width
     * const width = bounds.maxX - bounds.minX;
     * ```
     * @default -Infinity
     */
    this.maxX = -Infinity;
    /**
     * The maximum Y coordinate of the bounds.
     * Represents the bottommost edge of the bounding box.
     * @example
     * ```ts
     * const bounds = new Bounds();
     * // Set bottom edge
     * bounds.maxY = 200;
     * // Get height
     * const height = bounds.maxY - bounds.minY;
     * ```
     * @default -Infinity
     */
    this.maxY = -Infinity;
    /**
     * The transformation matrix applied to this bounds object.
     * Used when calculating bounds with transforms.
     * @example
     * ```ts
     * const bounds = new Bounds();
     *
     * // Apply translation matrix
     * bounds.matrix = new Matrix()
     *     .translate(100, 100);
     *
     * // Combine transformations
     * bounds.matrix = new Matrix()
     *     .translate(50, 50)
     *     .rotate(Math.PI / 4)
     *     .scale(2, 2);
     *
     * // Use in bounds calculations
     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix
     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix
     * ```
     * @advanced
     */
    this.matrix = defaultMatrix;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if bounds are empty, meaning either width or height is zero or negative.
   * Empty bounds occur when min values exceed max values on either axis.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Check if newly created bounds are empty
   * console.log(bounds.isEmpty()); // true, default bounds are empty
   *
   * // Add frame and check again
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false, bounds now have area
   *
   * // Clear bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true, bounds are empty again
   * ```
   * @returns True if bounds are empty (have no area)
   * @see {@link Bounds#clear} For resetting bounds
   * @see {@link Bounds#isValid} For checking validity
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /**
   * The bounding rectangle representation of these bounds.
   * Lazily creates and updates a Rectangle instance based on the current bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Get rectangle representation
   * const rect = bounds.rectangle;
   * console.log(rect.x, rect.y, rect.width, rect.height);
   *
   * // Use for hit testing
   * if (bounds.rectangle.contains(mouseX, mouseY)) {
   *     console.log('Mouse is inside bounds!');
   * }
   * ```
   * @see {@link Rectangle} For rectangle methods
   * @see {@link Bounds.isEmpty} For bounds validation
   */
  get rectangle() {
    if (!this._rectangle) {
      this._rectangle = new Rectangle();
    }
    const rectangle = this._rectangle;
    if (this.minX > this.maxX || this.minY > this.maxY) {
      rectangle.x = 0;
      rectangle.y = 0;
      rectangle.width = 0;
      rectangle.height = 0;
    } else {
      rectangle.copyFromBounds(this);
    }
    return rectangle;
  }
  /**
   * Clears the bounds and resets all coordinates to their default values.
   * Resets the transformation matrix back to identity.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false
   * // Clear the bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true
   * ```
   * @returns This bounds object for chaining
   */
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    return this;
  }
  /**
   * Sets the bounds directly using coordinate values.
   * Provides a way to set all bounds values at once.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(0, 0, 100, 100);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @see {@link Bounds#addFrame} For matrix-aware bounds setting
   * @see {@link Bounds#clear} For resetting bounds
   */
  set(x0, y0, x1, y1) {
    this.minX = x0;
    this.minY = y0;
    this.maxX = x1;
    this.maxY = y1;
  }
  /**
   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the new frame coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.addFrame(0, 0, 100, 100);
   *
   * // Add transformed frame
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addFrame(0, 0, 100, 100, matrix);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addRect} For adding Rectangle objects
   * @see {@link Bounds#addBounds} For adding other Bounds
   */
  addFrame(x0, y0, x1, y1, matrix) {
    matrix || (matrix = this.matrix);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x = a * x0 + c * y0 + tx;
    let y = b * x0 + d * y0 + ty;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    x = a * x1 + c * y0 + tx;
    y = b * x1 + d * y0 + ty;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    x = a * x0 + c * y1 + tx;
    y = b * x0 + d * y1 + ty;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    x = a * x1 + c * y1 + tx;
    y = b * x1 + d * y1 + ty;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Adds a rectangle to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the given rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * // Add simple rectangle
   * const rect = new Rectangle(0, 0, 100, 100);
   * bounds.addRect(rect);
   *
   * // Add transformed rectangle
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addRect(rect, matrix);
   * ```
   * @param rect - The rectangle to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addBounds} For adding other bounds
   */
  addRect(rect, matrix) {
    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
  }
  /**
   * Adds another bounds object to this one, optionally transformed by a matrix.
   * Expands the bounds to include the given bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add child bounds
   * const childBounds = sprite.getBounds();
   * bounds.addBounds(childBounds);
   *
   * // Add transformed bounds
   * const matrix = new Matrix()
   *     .scale(2, 2);
   * bounds.addBounds(childBounds, matrix);
   * ```
   * @param bounds - The bounds to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addRect} For adding rectangles
   */
  addBounds(bounds, matrix) {
    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
  }
  /**
   * Adds other Bounds as a mask, creating an intersection of the two bounds.
   * Only keeps the overlapping region between current bounds and mask bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Create mask bounds
   * const mask = new Bounds();
   * mask.addFrame(50, 50, 150, 150);
   * // Apply mask - results in bounds of (50,50,100,100)
   * bounds.addBoundsMask(mask);
   * ```
   * @param mask - The Bounds to use as a mask
   * @see {@link Bounds#addBounds} For union operation
   * @see {@link Bounds#fit} For fitting to rectangle
   */
  addBoundsMask(mask) {
    this.minX = this.minX > mask.minX ? this.minX : mask.minX;
    this.minY = this.minY > mask.minY ? this.minY : mask.minY;
    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
  }
  /**
   * Applies a transformation matrix to the bounds, updating its coordinates.
   * Transforms all corners of the bounds using the given matrix.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Apply translation
   * const translateMatrix = new Matrix()
   *     .translate(50, 50);
   * bounds.applyMatrix(translateMatrix);
   * ```
   * @param matrix - The matrix to apply to the bounds
   * @see {@link Matrix} For matrix operations
   * @see {@link Bounds#addFrame} For adding transformed frames
   */
  applyMatrix(matrix) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    const { a, b, c, d, tx, ty } = matrix;
    let x = a * minX + c * minY + tx;
    let y = b * minX + d * minY + ty;
    this.minX = x;
    this.minY = y;
    this.maxX = x;
    this.maxY = y;
    x = a * maxX + c * minY + tx;
    y = b * maxX + d * minY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
    x = a * minX + c * maxY + tx;
    y = b * minX + d * maxY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
    x = a * maxX + c * maxY + tx;
    y = b * maxX + d * maxY + ty;
    this.minX = x < this.minX ? x : this.minX;
    this.minY = y < this.minY ? y : this.minY;
    this.maxX = x > this.maxX ? x : this.maxX;
    this.maxY = y > this.maxY ? y : this.maxY;
  }
  /**
   * Resizes the bounds object to fit within the given rectangle.
   * Clips the bounds if they extend beyond the rectangle's edges.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit within viewport
   * const viewport = new Rectangle(50, 50, 100, 100);
   * bounds.fit(viewport);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param rect - The rectangle to fit within
   * @returns This bounds object for chaining
   * @see {@link Bounds#addBoundsMask} For intersection
   * @see {@link Bounds#pad} For expanding bounds
   */
  fit(rect) {
    if (this.minX < rect.left) this.minX = rect.left;
    if (this.maxX > rect.right) this.maxX = rect.right;
    if (this.minY < rect.top) this.minY = rect.top;
    if (this.maxY > rect.bottom) this.maxY = rect.bottom;
    return this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * Similar to fit() but works with raw coordinate values instead of a Rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit to specific coordinates
   * bounds.fitBounds(50, 150, 50, 150);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param left - The left value of the bounds
   * @param right - The right value of the bounds
   * @param top - The top value of the bounds
   * @param bottom - The bottom value of the bounds
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For fitting to Rectangle
   * @see {@link Bounds#addBoundsMask} For intersection
   */
  fitBounds(left, right, top, bottom) {
    if (this.minX < left) this.minX = left;
    if (this.maxX > right) this.maxX = right;
    if (this.minY < top) this.minY = top;
    if (this.maxY > bottom) this.maxY = bottom;
    return this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Add equal padding
   * bounds.pad(10);
   * // bounds are now (-10, -10, 110, 110)
   *
   * // Add different padding for x and y
   * bounds.pad(20, 10);
   * // bounds are now (-30, -20, 130, 120)
   * ```
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For constraining bounds
   * @see {@link Bounds#scale} For uniform scaling
   */
  pad(paddingX, paddingY = paddingX) {
    this.minX -= paddingX;
    this.maxX += paddingX;
    this.minY -= paddingY;
    this.maxY += paddingY;
    return this;
  }
  /**
   * Ceils the bounds by rounding up max values and rounding down min values.
   * Useful for pixel-perfect calculations and avoiding fractional pixels.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(10.2, 10.9, 50.1, 50.8);
   *
   * // Round to whole pixels
   * bounds.ceil();
   * // bounds are now (10, 10, 51, 51)
   * ```
   * @returns This bounds object for chaining
   * @see {@link Bounds#scale} For size adjustments
   * @see {@link Bounds#fit} For constraining bounds
   */
  ceil() {
    this.minX = Math.floor(this.minX);
    this.minY = Math.floor(this.minY);
    this.maxX = Math.ceil(this.maxX);
    this.maxY = Math.ceil(this.maxY);
    return this;
  }
  /**
   * Creates a new Bounds instance with the same values.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Create a copy
   * const copy = bounds.clone();
   *
   * // Original and copy are independent
   * bounds.pad(10);
   * console.log(copy.width === bounds.width); // false
   * ```
   * @returns A new Bounds instance with the same values
   * @see {@link Bounds#copyFrom} For reusing existing bounds
   */
  clone() {
    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values, adjusting all edges proportionally.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Scale uniformly
   * bounds.scale(2);
   * // bounds are now (0, 0, 200, 200)
   *
   * // Scale non-uniformly
   * bounds.scale(0.5, 2);
   * // bounds are now (0, 0, 100, 400)
   * ```
   * @param x - The X value to scale by
   * @param y - The Y value to scale by (defaults to x)
   * @returns This bounds object for chaining
   * @see {@link Bounds#pad} For adding padding
   * @see {@link Bounds#fit} For constraining size
   */
  scale(x, y = x) {
    this.minX *= x;
    this.minY *= y;
    this.maxX *= x;
    this.maxY *= y;
    return this;
  }
  /**
   * The x position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its width.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get x position
   * console.log(bounds.x); // 0
   *
   * // Move bounds horizontally
   * bounds.x = 50;
   * console.log(bounds.minX, bounds.maxX); // 50, 150
   *
   * // Width stays the same
   * console.log(bounds.width); // Still 100
   * ```
   */
  get x() {
    return this.minX;
  }
  set x(value) {
    const width = this.maxX - this.minX;
    this.minX = value;
    this.maxX = value + width;
  }
  /**
   * The y position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its height.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get y position
   * console.log(bounds.y); // 0
   *
   * // Move bounds vertically
   * bounds.y = 50;
   * console.log(bounds.minY, bounds.maxY); // 50, 150
   *
   * // Height stays the same
   * console.log(bounds.height); // Still 100
   * ```
   */
  get y() {
    return this.minY;
  }
  set y(value) {
    const height = this.maxY - this.minY;
    this.minY = value;
    this.maxY = value + height;
  }
  /**
   * The width value of the bounds.
   * Represents the distance between minX and maxX coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get width
   * console.log(bounds.width); // 100
   * // Resize width
   * bounds.width = 200;
   * console.log(bounds.maxX - bounds.minX); // 200
   * ```
   */
  get width() {
    return this.maxX - this.minX;
  }
  set width(value) {
    this.maxX = this.minX + value;
  }
  /**
   * The height value of the bounds.
   * Represents the distance between minY and maxY coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get height
   * console.log(bounds.height); // 100
   * // Resize height
   * bounds.height = 150;
   * console.log(bounds.maxY - bounds.minY); // 150
   * ```
   */
  get height() {
    return this.maxY - this.minY;
  }
  set height(value) {
    this.maxY = this.minY + value;
  }
  /**
   * The left edge coordinate of the bounds.
   * Alias for minX.
   * @example
   * ```ts
   * const bounds = new Bounds(50, 0, 150, 100);
   * console.log(bounds.left); // 50
   * console.log(bounds.left === bounds.minX); // true
   * ```
   * @readonly
   */
  get left() {
    return this.minX;
  }
  /**
   * The right edge coordinate of the bounds.
   * Alias for maxX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.right); // 100
   * console.log(bounds.right === bounds.maxX); // true
   * ```
   * @readonly
   */
  get right() {
    return this.maxX;
  }
  /**
   * The top edge coordinate of the bounds.
   * Alias for minY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 25, 100, 125);
   * console.log(bounds.top); // 25
   * console.log(bounds.top === bounds.minY); // true
   * ```
   * @readonly
   */
  get top() {
    return this.minY;
  }
  /**
   * The bottom edge coordinate of the bounds.
   * Alias for maxY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 200);
   * console.log(bounds.bottom); // 200
   * console.log(bounds.bottom === bounds.maxY); // true
   * ```
   * @readonly
   */
  get bottom() {
    return this.maxY;
  }
  /**
   * Whether the bounds has positive width and height.
   * Checks if both dimensions are greater than zero.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Check if bounds are positive
   * console.log(bounds.isPositive); // true
   *
   * // Negative bounds
   * bounds.maxX = bounds.minX;
   * console.log(bounds.isPositive); // false, width is 0
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isValid} For checking validity
   */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  /**
   * Whether the bounds has valid coordinates.
   * Checks if the bounds has been initialized with real values.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * console.log(bounds.isValid); // false, default state
   *
   * // Set valid bounds
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isValid); // true
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isPositive} For checking dimensions
   */
  get isValid() {
    return this.minX + this.minY !== Infinity;
  }
  /**
   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
   * Used for efficiently updating bounds from raw vertex data.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add vertices from geometry
   * const vertices = new Float32Array([
   *     0, 0,    // Vertex 1
   *     100, 0,  // Vertex 2
   *     100, 100 // Vertex 3
   * ]);
   * bounds.addVertexData(vertices, 0, 6);
   *
   * // Add transformed vertices
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addVertexData(vertices, 0, 6, matrix);
   *
   * // Add subset of vertices
   * bounds.addVertexData(vertices, 2, 4); // Only second vertex
   * ```
   * @param vertexData - The array of vertices to add
   * @param beginOffset - Starting index in the vertex array
   * @param endOffset - Ending index in the vertex array (excluded)
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding rectangular frames
   * @see {@link Matrix} For transformation details
   */
  addVertexData(vertexData, beginOffset, endOffset, matrix) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    matrix || (matrix = this.matrix);
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    for (let i = beginOffset; i < endOffset; i += 2) {
      const localX = vertexData[i];
      const localY = vertexData[i + 1];
      const x = a * localX + c * localY + tx;
      const y = b * localX + d * localY + ty;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if a point is contained within the bounds.
   * Returns true if the point's coordinates fall within the bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Basic point check
   * console.log(bounds.containsPoint(50, 50)); // true
   * console.log(bounds.containsPoint(150, 150)); // false
   *
   * // Check edges
   * console.log(bounds.containsPoint(0, 0));   // true, includes edges
   * console.log(bounds.containsPoint(100, 100)); // true, includes edges
   * ```
   * @param x - x coordinate to check
   * @param y - y coordinate to check
   * @returns True if the point is inside the bounds
   * @see {@link Bounds#isPositive} For valid bounds check
   * @see {@link Bounds#rectangle} For Rectangle representation
   */
  containsPoint(x, y) {
    if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y) {
      return true;
    }
    return false;
  }
  /**
   * Returns a string representation of the bounds.
   * Useful for debugging and logging bounds information.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
   * ```
   * @returns A string describing the bounds
   * @see {@link Bounds#copyFrom} For copying bounds
   * @see {@link Bounds#clone} For creating a new instance
   */
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  /**
   * Copies the bounds from another bounds object.
   * Useful for reusing bounds objects and avoiding allocations.
   * @example
   * ```ts
   * const sourceBounds = new Bounds(0, 0, 100, 100);
   * // Copy bounds
   * const targetBounds = new Bounds();
   * targetBounds.copyFrom(sourceBounds);
   * ```
   * @param bounds - The bounds to copy from
   * @returns This bounds object for chaining
   * @see {@link Bounds#clone} For creating new instances
   */
  copyFrom(bounds) {
    this.minX = bounds.minX;
    this.minY = bounds.minY;
    this.maxX = bounds.maxX;
    this.maxY = bounds.maxY;
    return this;
  }
}

var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return "string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return (r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return {r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return {r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return {h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return {r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return {h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return {h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e;},c=function(r){return {h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u;},l=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},"hsl"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return {h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return [e,t[n][1]]}return [null,void 0]},x=function(r){return "string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=c(r);return {h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return (299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return {h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1};}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):"","#"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i;},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";var r,t,n,e,u;},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";var r,t,n,e,u;},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r;},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r;},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return "number"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t;},r.prototype.hue=function(r){var t=c(this.rgba);return "number"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r));});};

function namesPlugin(e,f){var a={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return "transparent";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b="black";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g);}return b}};f.string.push([function(f){var r=f.toLowerCase(),d="transparent"===r?"#0000":a[r];return d?new e(d).toRgb():null},"name"]);}

k([namesPlugin]);
const _Color = class _Color {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value;
  }
  /**
   * Get the red component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.red); // 1
   *
   * const green = new Color('#00ff00');
   * console.log(green.red); // 0
   * ```
   */
  get red() {
    return this._components[0];
  }
  /**
   * Get the green component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('lime');
   * console.log(color.green); // 1
   *
   * const red = new Color('#ff0000');
   * console.log(red.green); // 0
   * ```
   */
  get green() {
    return this._components[1];
  }
  /**
   * Get the blue component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('blue');
   * console.log(color.blue); // 1
   *
   * const yellow = new Color('#ffff00');
   * console.log(yellow.blue); // 0
   * ```
   */
  get blue() {
    return this._components[2];
  }
  /**
   * Get the alpha component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.alpha); // 1 (fully opaque)
   *
   * const transparent = new Color('rgba(255, 0, 0, 0.5)');
   * console.log(transparent.alpha); // 0.5 (semi-transparent)
   * ```
   */
  get alpha() {
    return this._components[3];
  }
  /**
   * Sets the color value and returns the instance for chaining.
   *
   * This is a chainable version of setting the `value` property.
   * @param value - The color to set. Accepts various formats:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA values (arrays, objects)
   * - CSS color names
   * - HSL/HSLA values
   * - HSV/HSVA values
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic usage
   * const color = new Color();
   * color.setValue('#ff0000')
   *     .setAlpha(0.5)
   *     .premultiply(0.8);
   *
   * // Different formats
   * color.setValue(0xff0000);          // Hex number
   * color.setValue('#ff0000');         // Hex string
   * color.setValue([1, 0, 0]);         // RGB array
   * color.setValue([1, 0, 0, 0.5]);    // RGBA array
   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
   *
   * // Copy from another color
   * const red = new Color('red');
   * color.setValue(red);
   * ```
   * @throws {Error} If the color value is invalid or null
   * @see {@link Color.value} For the underlying value property
   */
  setValue(value) {
    this.value = value;
    return this;
  }
  /**
   * The current color source. This property allows getting and setting the color value
   * while preserving the original format where possible.
   * @remarks
   * When setting:
   * - Setting to a `Color` instance copies its source and components
   * - Setting to other valid sources normalizes and stores the value
   * - Setting to `null` throws an Error
   * - The color remains unchanged if normalization fails
   *
   * When getting:
   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
   * - Otherwise returns the original color source
   * @example
   * ```ts
   * // Setting different color formats
   * const color = new Color();
   *
   * color.value = 0xff0000;         // Hex number
   * color.value = '#ff0000';        // Hex string
   * color.value = [1, 0, 0];        // RGB array
   * color.value = [1, 0, 0, 0.5];   // RGBA array
   * color.value = { r: 1, g: 0, b: 0 }; // RGB object
   *
   * // Copying from another color
   * const red = new Color('red');
   * color.value = red;  // Copies red's components
   *
   * // Getting the value
   * console.log(color.value);  // Returns original format
   *
   * // After modifications
   * color.multiply([0.5, 0.5, 0.5]);
   * console.log(color.value);  // Returns null
   * ```
   * @throws {Error} When attempting to set `null`
   */
  set value(value) {
    if (value instanceof _Color) {
      this._value = this._cloneSource(value._value);
      this._int = value._int;
      this._components.set(value._components);
    } else if (value === null) {
      throw new Error("Cannot set Color#value to null");
    } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
      this._value = this._cloneSource(value);
      this._normalize(this._value);
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(value) {
    if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
      return value;
    } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      return value.slice(0);
    } else if (typeof value === "object" && value !== null) {
      return { ...value };
    }
    return value;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v, i) => v === value2[i]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key) => value1[key] === value2[key]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object with normalized components (0-1).
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA objects
   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
   *
   * // With transparency
   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
   * ```
   * @returns An RGBA object with normalized components
   */
  toRgba() {
    const [r, g, b, a] = this._components;
    return { r, g, b, a };
  }
  /**
   * Convert to a RGB color object with normalized components (0-1).
   *
   * Alpha component is omitted in the output.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGB objects
   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
   *
   * // Alpha is ignored
   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
   * ```
   * @returns An RGB object with normalized components
   */
  toRgb() {
    const [r, g, b] = this._components;
    return { r, g, b };
  }
  /**
   * Convert to a CSS-style rgba string representation.
   *
   * RGB components are scaled to 0-255 range, alpha remains 0-1.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA strings
   * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
   * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
   *
   * // With transparency
   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
   * ```
   * @returns A CSS-compatible rgba string
   */
  toRgbaString() {
    const [r, g, b] = this.toUint8RgbArray();
    return `rgba(${r},${g},${b},${this.alpha})`;
  }
  /**
   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as integers between 0-255
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Uint8Array(3);
   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
   *
   * // Using different array types
   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
   * ```
   * @remarks
   * - Output values are always clamped between 0-255
   * - Alpha component is not included in output
   * - Reuses internal cache array if no output array provided
   */
  toUint8RgbArray(out) {
    const [r, g, b] = this._components;
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    out[0] = Math.round(r * 255);
    out[1] = Math.round(g * 255);
    out[2] = Math.round(b * 255);
    return out;
  }
  /**
   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGBA components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toArray();  // returns [1, 1, 1, 1]
   * new Color('red').toArray();    // returns [1, 0, 0, 1]
   *
   * // With alpha
   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
   *
   * // Using custom output array
   * const rgba = new Float32Array(4);
   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Includes alpha component as the fourth value
   * - Reuses internal cache array if no output array provided
   */
  toArray(out) {
    if (!this._arrayRgba) {
      this._arrayRgba = [];
    }
    out || (out = this._arrayRgba);
    const [r, g, b, a] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    out[3] = a;
    return out;
  }
  /**
   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toRgbArray(); // returns [1, 1, 1]
   * new Color('red').toRgbArray();   // returns [1, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Float32Array(3);
   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Alpha component is omitted from output
   * - Reuses internal cache array if no output array provided
   */
  toRgbArray(out) {
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out || (out = this._arrayRgb);
    const [r, g, b] = this._components;
    out[0] = r;
    out[1] = g;
    out[2] = b;
    return out;
  }
  /**
   * Convert to a hexadecimal number.
   * @returns The color as a 24-bit RGB integer
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toNumber(); // returns 0xffffff
   * new Color('red').toNumber();   // returns 0xff0000
   *
   * // Store as hex
   * const color = new Color('blue');
   * const hex = color.toNumber(); // 0x0000ff
   * ```
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number.
   *
   * Useful for platforms that expect colors in BGR format.
   * @returns The color as a 24-bit BGR integer
   * @example
   * ```ts
   * // Convert RGB to BGR
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   *
   * // Common use case: platform-specific color format
   * const color = new Color('orange');
   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
   * ```
   * @remarks
   * This swaps the red and blue channels compared to the normal RGB format:
   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
   */
  toBgrNumber() {
    const [r, g, b] = this.toUint8RgbArray();
    return (b << 16) + (g << 8) + r;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   *
   * Useful for platforms that expect colors in little endian byte order.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert RGB color to little endian format
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   *
   * // Common use cases:
   * const color = new Color('orange');
   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
   *
   * // Multiple conversions
   * const colors = {
   *     normal: 0xffcc99,
   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
   * };
   * ```
   * @remarks
   * - Swaps R and B channels in the color value
   * - RGB 0xRRGGBB becomes 0xBBGGRR
   * - Useful for systems that use little endian byte order
   * - Can be used to convert back and forth between formats
   * @returns The color as a number in little endian format (BBGGRR)
   * @see {@link Color.toBgrNumber} For BGR format without byte swapping
   */
  toLittleEndianNumber() {
    const value = this._int;
    return (value >> 16) + (value & 65280) + ((value & 255) << 16);
  }
  /**
   * Multiply with another color.
   *
   * This action is destructive and modifies the original color.
   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
   * - Color objects ({ r: 1, g: 0, b: 0 })
   * - CSS color names ('red', 'blue')
   * @returns this - The Color instance for chaining
   * @example
   * ```ts
   * // Basic multiplication
   * const color = new Color('#ff0000');
   * color.multiply(0x808080); // 50% darker red
   *
   * // With transparency
   * color.multiply([1, 1, 1, 0.5]); // 50% transparent
   *
   * // Chain operations
   * color
   *     .multiply('#808080')
   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
   * ```
   * @remarks
   * - Multiplies each RGB component and alpha separately
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  multiply(value) {
    const [r, g, b, a] = _Color._temp.setValue(value)._components;
    this._components[0] *= r;
    this._components[1] *= g;
    this._components[2] *= b;
    this._components[3] *= a;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Converts color to a premultiplied alpha format.
   *
   * This action is destructive and modifies the original color.
   * @param alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {Color} The Color instance for chaining
   * @example
   * ```ts
   * // Basic premultiplication
   * const color = new Color('red');
   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
   *
   * // Alpha only (RGB unchanged)
   * color.premultiply(0.5, false); // 50% transparent, original RGB
   *
   * // Chain with other operations
   * color
   *     .multiply(0x808080)
   *     .premultiply(0.5)
   *     .toNumber();
   * ```
   * @remarks
   * - RGB channels are multiplied by alpha when applyToRGB is true
   * - Alpha is always set to the provided value
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Returns the color as a 32-bit premultiplied alpha integer.
   *
   * Format: 0xAARRGGBB
   * @param {number} alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {number} The premultiplied color as a 32-bit integer
   * @example
   * ```ts
   * // Convert to premultiplied format
   * const color = new Color('red');
   *
   * // Full opacity (0xFFRRGGBB)
   * color.toPremultiplied(1.0); // 0xFFFF0000
   *
   * // 50% transparency with premultiplied RGB
   * color.toPremultiplied(0.5); // 0x7F7F0000
   *
   * // 50% transparency without RGB premultiplication
   * color.toPremultiplied(0.5, false); // 0x7FFF0000
   * ```
   * @remarks
   * - Returns full opacity (0xFF000000) when alpha is 1.0
   * - Returns 0 when alpha is 0.0 and applyToRGB is true
   * - RGB values are rounded during premultiplication
   */
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r = this._int >> 16 & 255;
    let g = this._int >> 8 & 255;
    let b = this._int & 255;
    if (applyToRGB) {
      r = r * alpha + 0.5 | 0;
      g = g * alpha + 0.5 | 0;
      b = b * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r << 16) + (g << 8) + b;
  }
  /**
   * Convert to a hexadecimal string (6 characters).
   * @returns A CSS-compatible hex color string (e.g., "#ff0000")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Basic colors
   * new Color('red').toHex();    // returns "#ff0000"
   * new Color('white').toHex();  // returns "#ffffff"
   * new Color('black').toHex();  // returns "#000000"
   *
   * // From different formats
   * new Color(0xff0000).toHex(); // returns "#ff0000"
   * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
   * ```
   * @remarks
   * - Always returns a 6-character hex string
   * - Includes leading "#" character
   * - Alpha channel is ignored
   * - Values are rounded to nearest hex value
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexadecimal string with alpha (8 characters).
   * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Fully opaque colors
   * new Color('red').toHexa();   // returns "#ff0000ff"
   * new Color('white').toHexa(); // returns "#ffffffff"
   *
   * // With transparency
   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
   * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
   * ```
   * @remarks
   * - Returns an 8-character hex string
   * - Includes leading "#" character
   * - Alpha is encoded in last two characters
   * - Values are rounded to nearest hex value
   */
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha (transparency) value while preserving color components.
   *
   * Provides a chainable interface for setting alpha.
   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic alpha setting
   * const color = new Color('red');
   * color.setAlpha(0.5);  // 50% transparent red
   *
   * // Chain with other operations
   * color
   *     .setValue('#ff0000')
   *     .setAlpha(0.8)    // 80% opaque
   *     .premultiply(0.5); // Further modify alpha
   *
   * // Reset to fully opaque
   * color.setAlpha(1);
   * ```
   * @remarks
   * - Alpha value is clamped between 0-1
   * - Can be chained with other color operations
   */
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(value) {
    let r;
    let g;
    let b;
    let a;
    if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
      const int = value;
      r = (int >> 16 & 255) / 255;
      g = (int >> 8 & 255) / 255;
      b = (int & 255) / 255;
      a = 1;
    } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value);
      [r, g, b, a = 1] = value;
    } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
      value = this._clamp(value, 0, 255);
      [r, g, b, a = 255] = value;
      r /= 255;
      g /= 255;
      b /= 255;
      a /= 255;
    } else if (typeof value === "string" || typeof value === "object") {
      if (typeof value === "string") {
        const match = _Color.HEX_PATTERN.exec(value);
        if (match) {
          value = `#${match[2]}`;
        }
      }
      const color = w(value);
      if (color.isValid()) {
        ({ r, g, b, a } = color.rgba);
        r /= 255;
        g /= 255;
        b /= 255;
      }
    }
    if (r !== void 0) {
      this._components[0] = r;
      this._components[1] = g;
      this._components[2] = b;
      this._components[3] = a;
      this._refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value}`);
    }
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [r, g, b] = this._components;
    this._int = (r * 255 << 16) + (g * 255 << 8) + (b * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value, min = 0, max = 1) {
    if (typeof value === "number") {
      return Math.min(Math.max(value, min), max);
    }
    value.forEach((v, i) => {
      value[i] = Math.min(Math.max(v, min), max);
    });
    return value;
  }
  /**
   * Check if a value can be interpreted as a valid color format.
   * Supports all color formats that can be used with the Color class.
   * @param value - Value to check
   * @returns True if the value can be used as a color
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // CSS colors and hex values
   * Color.isColorLike('red');          // true
   * Color.isColorLike('#ff0000');      // true
   * Color.isColorLike(0xff0000);       // true
   *
   * // Arrays (RGB/RGBA)
   * Color.isColorLike([1, 0, 0]);      // true
   * Color.isColorLike([1, 0, 0, 0.5]); // true
   *
   * // TypedArrays
   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
   *
   * // Object formats
   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
   *
   * // Color instances
   * Color.isColorLike(new Color('red')); // true
   *
   * // Invalid values
   * Color.isColorLike(null);           // false
   * Color.isColorLike(undefined);      // false
   * Color.isColorLike({});             // false
   * Color.isColorLike([]);             // false
   * Color.isColorLike('not-a-color');  // false
   * ```
   * @remarks
   * Checks for the following formats:
   * - Numbers (0x000000 to 0xffffff)
   * - CSS color strings
   * - RGB/RGBA arrays and objects
   * - HSL/HSLA objects
   * - HSV/HSVA objects
   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
   * - Color instances
   * @see {@link ColorSource} For supported color format types
   * @see {@link Color.setValue} For setting color values
   * @category utility
   */
  static isColorLike(value) {
    return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
  }
};
/**
 * Static shared Color instance used for utility operations. This is a singleton color object
 * that can be reused to avoid creating unnecessary Color instances.
 * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be
 * > changed by any code that uses it.
 * >
 * > It is best used for one-off color operations or temporary transformations.
 * > For persistent colors, create your own Color instance instead.
 * @example
 * ```ts
 * import { Color } from 'pixi.js';
 *
 * // Use shared instance for one-off color operations
 * Color.shared.setValue(0xff0000);
 * const redHex = Color.shared.toHex();     // "#ff0000"
 * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]
 *
 * // Temporary color transformations
 * const colorNumber = Color.shared
 *     .setValue('#ff0000')     // Set to red
 *     .setAlpha(0.5)          // Make semi-transparent
 *     .premultiply(0.8)       // Apply premultiplication
 *     .toNumber();            // Convert to number
 *
 * // Chain multiple operations
 * const result = Color.shared
 *     .setValue(someColor)
 *     .multiply(tintColor)
 *     .toPremultiplied(alpha);
 * ```
 * @remarks
 * - This is a shared instance - be careful about multiple code paths using it simultaneously
 * - Use for temporary color operations to avoid allocating new Color instances
 * - The value is preserved between operations, so reset if needed
 * - For persistent colors, create your own Color instance instead
 */
_Color.shared = new _Color();
/**
 * Temporary Color object for static uses internally.
 * As to not conflict with Color.shared.
 * @ignore
 */
_Color._temp = new _Color();
/** Pattern for hex strings */
// eslint-disable-next-line @typescript-eslint/naming-convention
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;

const cullingMixin = {
  cullArea: null,
  cullable: false,
  cullableChildren: true
};

let warnCount = 0;
const maxWarnings = 500;
function warn$2(...args) {
  if (warnCount === maxWarnings) return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}

const GlobalResourceRegistry = {
  /**
   * Set of registered pools and cleanable objects.
   * @private
   */
  _registeredResources: /* @__PURE__ */ new Set(),
  /**
   * Registers a pool or cleanable object for cleanup.
   * @param {Cleanable} pool - The pool or object to register.
   */
  register(pool) {
    this._registeredResources.add(pool);
  },
  /**
   * Unregisters a pool or cleanable object from cleanup.
   * @param {Cleanable} pool - The pool or object to unregister.
   */
  unregister(pool) {
    this._registeredResources.delete(pool);
  },
  /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
  release() {
    this._registeredResources.forEach((pool) => pool.clear());
  },
  /**
   * Gets the number of registered pools and cleanable objects.
   * @returns {number} The count of registered items.
   */
  get registeredCount() {
    return this._registeredResources.size;
  },
  /**
   * Checks if a specific pool or cleanable object is registered.
   * @param {Cleanable} pool - The pool or object to check.
   * @returns {boolean} True if the item is registered, false otherwise.
   */
  isRegistered(pool) {
    return this._registeredResources.has(pool);
  },
  /**
   * Removes all registrations without clearing the pools.
   * Useful if you want to reset the collector without affecting the pools.
   */
  reset() {
    this._registeredResources.clear();
  }
};

class Pool {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(ClassType, initialSize) {
    this._pool = [];
    this._count = 0;
    this._index = 0;
    this._classType = ClassType;
    if (initialSize) {
      this.prepopulate(initialSize);
    }
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(total) {
    for (let i = 0; i < total; i++) {
      this._pool[this._index++] = new this._classType();
    }
    this._count += total;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {I} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(data) {
    let item;
    if (this._index > 0) {
      item = this._pool[--this._index];
    } else {
      item = new this._classType();
      this._count++;
    }
    item.init?.(data);
    return item;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(item) {
    item.reset?.();
    this._pool[this._index++] = item;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool */
  clear() {
    if (this._pool.length > 0 && this._pool[0].destroy) {
      for (let i = 0; i < this._index; i++) {
        this._pool[i].destroy();
      }
    }
    this._pool.length = 0;
    this._count = 0;
    this._index = 0;
  }
}

class PoolGroupClass {
  constructor() {
    /**
     * A map to store the pools by their class type.
     * @private
     */
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(Class, total) {
    const classPool = this.getPool(Class);
    classPool.prepopulate(total);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(Class, data) {
    const pool = this.getPool(Class);
    return pool.get(data);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(item) {
    const pool = this.getPool(item.constructor);
    pool.return(item);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(ClassType) {
    if (!this._poolsByClass.has(ClassType)) {
      this._poolsByClass.set(ClassType, new Pool(ClassType));
    }
    return this._poolsByClass.get(ClassType);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const stats = {};
    this._poolsByClass.forEach((pool) => {
      const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
      stats[name] = {
        free: pool.totalFree,
        used: pool.totalUsed,
        size: pool.totalSize
      };
    });
    return stats;
  }
  /** Clears all pools in the group. This will reset all pools and free their resources. */
  clear() {
    this._poolsByClass.forEach((pool) => pool.clear());
    this._poolsByClass.clear();
  }
}
const BigPool = new PoolGroupClass();
GlobalResourceRegistry.register(BigPool);

const cacheAsTextureMixin = {
  get isCachedAsTexture() {
    return !!this.renderGroup?.isCachedAsTexture;
  },
  cacheAsTexture(val) {
    if (typeof val === "boolean" && val === false) {
      this.disableRenderGroup();
    } else {
      this.enableRenderGroup();
      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
    }
  },
  updateCacheTexture() {
    this.renderGroup?.updateCacheTexture();
  },
  get cacheAsBitmap() {
    return this.isCachedAsTexture;
  },
  set cacheAsBitmap(val) {
    deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
    this.cacheAsTexture(val);
  }
};

function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i = startIdx; i < len; ++i) {
    arr[i] = arr[i + removeCount];
  }
  arr.length = len;
}

const childrenHelperMixin = {
  allowChildren: true,
  removeChildren(beginIndex = 0, endIndex) {
    const end = endIndex ?? this.children.length;
    const range = end - beginIndex;
    const removed = [];
    if (range > 0 && range <= end) {
      for (let i = end - 1; i >= beginIndex; i--) {
        const child = this.children[i];
        if (!child) continue;
        removed.push(child);
        child.parent = null;
      }
      removeItems(this.children, beginIndex, end);
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.removeChildren(removed);
      }
      for (let i = 0; i < removed.length; ++i) {
        const child = removed[i];
        child.parentRenderLayer?.detach(child);
        this.emit("childRemoved", child, this, i);
        removed[i].emit("removed", this);
      }
      if (removed.length > 0) {
        this._didViewChangeTick++;
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return removed;
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  removeChildAt(index) {
    const child = this.getChildAt(index);
    return this.removeChild(child);
  },
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  },
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    this.getChildIndex(child);
    this.addChildAt(child, index);
  },
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied Container must be a child of the caller");
    }
    return index;
  },
  addChildAt(child, index) {
    if (!this.allowChildren) {
      deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    }
    const { children } = this;
    if (index < 0 || index > children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
    }
    if (child.parent) {
      const currentIndex = child.parent.children.indexOf(child);
      if (child.parent === this && currentIndex === index) {
        return child;
      }
      if (currentIndex !== -1) {
        child.parent.children.splice(currentIndex, 1);
      }
    }
    if (index === children.length) {
      children.push(child);
    } else {
      children.splice(index, 0, child);
    }
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    if (this.sortableChildren) this.sortDirty = true;
    this.emit("childAdded", child, this, index);
    child.emit("added", this);
    return child;
  },
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
    this._didContainerChangeTick++;
  },
  removeFromParent() {
    this.parent?.removeChild(this);
  },
  reparentChild(...child) {
    if (child.length === 1) {
      return this.reparentChildAt(child[0], this.children.length);
    }
    child.forEach((c) => this.reparentChildAt(c, this.children.length));
    return child[0];
  },
  reparentChildAt(child, index) {
    if (child.parent === this) {
      this.setChildIndex(child, index);
      return child;
    }
    const childMat = child.worldTransform.clone();
    child.removeFromParent();
    this.addChildAt(child, index);
    const newMatrix = this.worldTransform.clone();
    newMatrix.invert();
    childMat.prepend(newMatrix);
    child.setFromMatrix(childMat);
    return child;
  },
  replaceChild(oldChild, newChild) {
    oldChild.updateLocalTransform();
    this.addChildAt(newChild, this.getChildIndex(oldChild));
    newChild.setFromMatrix(oldChild.localTransform);
    newChild.updateLocalTransform();
    this.removeChild(oldChild);
  }
};

const collectRenderablesMixin = {
  collectRenderables(instructionSet, renderer, currentLayer) {
    if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild) return;
    if (this.sortableChildren) {
      this.sortChildren();
    }
    if (this.isSimple) {
      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    } else if (this.renderGroup) {
      renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
    } else {
      this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
    }
  },
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      children[i].collectRenderables(instructionSet, renderer, currentLayer);
    }
  },
  collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
    const { renderPipes } = renderer;
    for (let i = 0; i < this.effects.length; i++) {
      const effect = this.effects[i];
      const pipe = renderPipes[effect.pipe];
      pipe.push(effect, this, instructionSet);
    }
    this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    for (let i = this.effects.length - 1; i >= 0; i--) {
      const effect = this.effects[i];
      const pipe = renderPipes[effect.pipe];
      pipe.pop(effect, this, instructionSet);
    }
  }
};

class FilterEffect {
  constructor() {
    /** the pipe that knows how to handle this effect */
    this.pipe = "filter";
    /** the priority of this effect */
    this.priority = 1;
  }
  destroy() {
    for (let i = 0; i < this.filters.length; i++) {
      this.filters[i].destroy();
    }
    this.filters = null;
    this.filterArea = null;
  }
}

class MaskEffectManagerClass {
  constructor() {
    /** @private */
    this._effectClasses = [];
    this._tests = [];
    this._initialized = false;
  }
  init() {
    if (this._initialized) return;
    this._initialized = true;
    this._effectClasses.forEach((test) => {
      this.add({
        test: test.test,
        maskClass: test
      });
    });
  }
  add(test) {
    this._tests.push(test);
  }
  getMaskEffect(item) {
    if (!this._initialized) this.init();
    for (let i = 0; i < this._tests.length; i++) {
      const test = this._tests[i];
      if (test.test(item)) {
        return BigPool.get(test.maskClass, item);
      }
    }
    return item;
  }
  returnMaskEffect(effect) {
    BigPool.return(effect);
  }
}
const MaskEffectManager = new MaskEffectManagerClass();
extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);

const effectsMixin = {
  _maskEffect: null,
  _maskOptions: {
    inverse: false
  },
  _filterEffect: null,
  effects: [],
  _markStructureAsChanged() {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
  },
  addEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index !== -1) return;
    this.effects.push(effect);
    this.effects.sort((a, b) => a.priority - b.priority);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  removeEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index === -1) return;
    this.effects.splice(index, 1);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  set mask(value) {
    const effect = this._maskEffect;
    if (effect?.mask === value) return;
    if (effect) {
      this.removeEffect(effect);
      MaskEffectManager.returnMaskEffect(effect);
      this._maskEffect = null;
    }
    if (value === null || value === void 0) return;
    this._maskEffect = MaskEffectManager.getMaskEffect(value);
    this.addEffect(this._maskEffect);
  },
  get mask() {
    return this._maskEffect?.mask;
  },
  setMask(options) {
    this._maskOptions = {
      ...this._maskOptions,
      ...options
    };
    if (options.mask) {
      this.mask = options.mask;
    }
    this._markStructureAsChanged();
  },
  set filters(value) {
    if (!Array.isArray(value) && value) value = [value];
    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
    value = value;
    const hasFilters = value?.length > 0;
    const hadFilters = effect.filters?.length > 0;
    const didChange = hasFilters !== hadFilters;
    value = Array.isArray(value) ? value.slice(0) : value;
    effect.filters = Object.freeze(value);
    if (didChange) {
      if (hasFilters) {
        this.addEffect(effect);
      } else {
        this.removeEffect(effect);
        effect.filters = value ?? null;
      }
    }
  },
  get filters() {
    return this._filterEffect?.filters;
  },
  set filterArea(value) {
    this._filterEffect || (this._filterEffect = new FilterEffect());
    this._filterEffect.filterArea = value;
  },
  get filterArea() {
    return this._filterEffect?.filterArea;
  }
};

const findMixin = {
  label: null,
  get name() {
    deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
    return this.label;
  },
  set name(value) {
    deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
    this.label = value;
  },
  getChildByName(name, deep = false) {
    return this.getChildByLabel(name, deep);
  },
  getChildByLabel(label, deep = false) {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.label === label || label instanceof RegExp && label.test(child.label)) return child;
    }
    if (deep) {
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const found = child.getChildByLabel(label, true);
        if (found) {
          return found;
        }
      }
    }
    return null;
  },
  getChildrenByLabel(label, deep = false, out = []) {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.label === label || label instanceof RegExp && label.test(child.label)) {
        out.push(child);
      }
    }
    if (deep) {
      for (let i = 0; i < children.length; i++) {
        children[i].getChildrenByLabel(label, true, out);
      }
    }
    return out;
  }
};

const matrixPool = BigPool.getPool(Matrix);
const boundsPool = BigPool.getPool(Bounds);

const tempMatrix$5 = new Matrix();
const getFastGlobalBoundsMixin = {
  getFastGlobalBounds(factorRenderLayers, bounds) {
    bounds || (bounds = new Bounds());
    bounds.clear();
    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    bounds.applyMatrix(renderGroup.worldTransform);
    return bounds;
  },
  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
    let localBounds = bounds;
    if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;
    if (this.localDisplayStatus !== 7 || !this.measurable) {
      return;
    }
    const manageEffects = !!this.effects.length;
    if (this.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (this.boundsArea) {
      bounds.addRect(this.boundsArea, this.worldTransform);
    } else {
      if (this.renderPipeId) {
        const viewBounds = this.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          this.groupTransform
        );
      }
      const children = this.children;
      for (let i = 0; i < children.length; i++) {
        children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
      }
    }
    if (manageEffects) {
      let advanced = false;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      for (let i = 0; i < this.effects.length; i++) {
        if (this.effects[i].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(renderGroup.worldTransform);
          }
          this.effects[i].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix$5).invert());
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (this.renderGroup) {
      bounds.addBounds(localBounds, this.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
};

function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable) return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    const renderableBounds = target.bounds;
    if (renderableBounds && !renderableBounds.isEmpty()) {
      bounds.matrix = worldTransform;
      bounds.addBounds(renderableBounds);
    }
    for (let i = 0; i < target.children.length; i++) {
      _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i = 0; i < target.effects.length; i++) {
      target.effects[i].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    parent.updateLocalTransform();
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}

function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2) return color2;
  if (color2 === 16777215 || !color1) return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r = r1 * r2 / 255 | 0;
  const g = g1 * g2 / 255 | 0;
  const b = b1 * b2 / 255 | 0;
  return (r << 16) + (g << 8) + b;
}

const WHITE_BGR = 16777215;
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return multiplyHexColors(localBGRColor, parentBGRColor);
}

function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
const getGlobalMixin = {
  getGlobalAlpha(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return this.renderGroup.worldAlpha;
      }
      if (this.parentRenderGroup) {
        return this.parentRenderGroup.worldAlpha * this.alpha;
      }
      return this.alpha;
    }
    let alpha = this.alpha;
    let current = this.parent;
    while (current) {
      alpha *= current.alpha;
      current = current.parent;
    }
    return alpha;
  },
  getGlobalTransform(matrix = new Matrix(), skipUpdate) {
    if (skipUpdate) {
      return matrix.copyFrom(this.worldTransform);
    }
    this.updateLocalTransform();
    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
    matrix.appendFrom(this.localTransform, parentTransform);
    matrixPool.return(parentTransform);
    return matrix;
  },
  getGlobalTint(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return bgr2rgb(this.renderGroup.worldColor);
      }
      if (this.parentRenderGroup) {
        return bgr2rgb(
          multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
        );
      }
      return this.tint;
    }
    let color = this.localColor;
    let parent = this.parent;
    while (parent) {
      color = multiplyColors(color, parent.localColor);
      parent = parent.parent;
    }
    return bgr2rgb(color);
  }
};

function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable) return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i = 0; i < children.length; i++) {
      _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i = 0; i < target.effects.length; i++) {
      target.effects[i].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}

function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    const uid = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}

const tempMatrix$4 = new Matrix();
const measureMixin = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(value, localWidth) {
    const sign = Math.sign(this.scale.x) || 1;
    if (localWidth !== 0) {
      this.scale.x = value / localWidth * sign;
    } else {
      this.scale.x = sign;
    }
  },
  _setHeight(value, localHeight) {
    const sign = Math.sign(this.scale.y) || 1;
    if (localHeight !== 0) {
      this.scale.y = value / localHeight * sign;
    } else {
      this.scale.y = sign;
    }
  },
  getLocalBounds() {
    if (!this._localBoundsCacheData) {
      this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new Bounds()
      };
    }
    const localBoundsCacheData = this._localBoundsCacheData;
    localBoundsCacheData.index = 1;
    localBoundsCacheData.didChange = false;
    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
      localBoundsCacheData.didChange = true;
      localBoundsCacheData.data[0] = this._didViewChangeTick;
    }
    checkChildrenDidChange(this, localBoundsCacheData);
    if (localBoundsCacheData.didChange) {
      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix$4);
    }
    return localBoundsCacheData.localBounds;
  },
  getBounds(skipUpdate, bounds) {
    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
  }
};

const onRenderMixin = {
  _onRender: null,
  set onRender(func) {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (!func) {
      if (this._onRender) {
        renderGroup?.removeOnRender(this);
      }
      this._onRender = null;
      return;
    }
    if (!this._onRender) {
      renderGroup?.addOnRender(this);
    }
    this._onRender = func;
  },
  get onRender() {
    return this._onRender;
  }
};

const sortMixin = {
  _zIndex: 0,
  sortDirty: false,
  sortableChildren: false,
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(value) {
    if (this._zIndex === value) return;
    this._zIndex = value;
    this.depthOfChildModified();
  },
  depthOfChildModified() {
    if (this.parent) {
      this.parent.sortableChildren = true;
      this.parent.sortDirty = true;
    }
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
  },
  sortChildren() {
    if (!this.sortDirty) return;
    this.sortDirty = false;
    this.children.sort(sortChildren);
  }
};
function sortChildren(a, b) {
  return a._zIndex - b._zIndex;
}

const toLocalGlobalMixin = {
  getGlobalPosition(point = new Point(), skipUpdate = false) {
    if (this.parent) {
      this.parent.toGlobal(this._position, point, skipUpdate);
    } else {
      point.x = this._position.x;
      point.y = this._position.y;
    }
    return point;
  },
  toGlobal(position, point, skipUpdate = false) {
    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
    point = globalMatrix.apply(position, point);
    matrixPool.return(globalMatrix);
    return point;
  },
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
    point = globalMatrix.applyInverse(position, point);
    matrixPool.return(globalMatrix);
    return point;
  }
};

class InstructionSet {
  constructor() {
    /** a unique id for this instruction set used through the renderer */
    this.uid = uid$1("instructionSet");
    /** the array of instructions */
    this.instructions = [];
    /** the actual size of the array (any instructions passed this should be ignored) */
    this.instructionSize = 0;
    this.renderables = [];
    /** used by the garbage collector to track when the instruction set was last used */
    this.gcTick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0;
  }
  /**
   * Destroy the instruction set, clearing the instructions and renderables.
   * @internal
   */
  destroy() {
    this.instructions.length = 0;
    this.renderables.length = 0;
    this.renderPipes = null;
    this.gcTick = 0;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(instruction) {
    this.instructions[this.instructionSize++] = instruction;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   */
  log() {
    this.instructions.length = this.instructionSize;
    console.table(this.instructions, ["type", "action"]);
  }
}

let count = 0;
class TexturePoolClass {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(textureOptions) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null);
    this._texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this.textureStyle = new TextureStyle(this.textureOptions);
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(pixelWidth, pixelHeight, antialias) {
    const textureSource = new TextureSource({
      ...this.textureOptions,
      width: pixelWidth,
      height: pixelHeight,
      resolution: 1,
      antialias,
      autoGarbageCollect: false
    });
    return new Texture({
      source: textureSource,
      label: `texturePool_${count++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
    po2Width = nextPow2(po2Width);
    po2Height = nextPow2(po2Height);
    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
    if (!this._texturePool[key]) {
      this._texturePool[key] = [];
    }
    let texture = this._texturePool[key].pop();
    if (!texture) {
      texture = this.createTexture(po2Width, po2Height, antialias);
    }
    texture.source._resolution = resolution;
    texture.source.width = po2Width / resolution;
    texture.source.height = po2Height / resolution;
    texture.source.pixelWidth = po2Width;
    texture.source.pixelHeight = po2Height;
    texture.frame.x = 0;
    texture.frame.y = 0;
    texture.frame.width = frameWidth;
    texture.frame.height = frameHeight;
    texture.updateUvs();
    this._poolKeyHash[texture.uid] = key;
    return texture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(texture, antialias = false) {
    const source = texture.source;
    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);
  }
  /**
   * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
   * useful if you modified the style of the texture after getting it from the pool.
   * @param renderTexture - The renderTexture to free
   * @param resetStyle - Whether to reset the style of the texture to the default texture style
   */
  returnTexture(renderTexture, resetStyle = false) {
    const key = this._poolKeyHash[renderTexture.uid];
    if (resetStyle) {
      renderTexture.source.style = this.textureStyle;
    }
    this._texturePool[key].push(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i in this._texturePool) {
        const textures = this._texturePool[i];
        if (textures) {
          for (let j = 0; j < textures.length; j++) {
            textures[j].destroy(true);
          }
        }
      }
    }
    this._texturePool = {};
  }
}
const TexturePool = new TexturePoolClass();
GlobalResourceRegistry.register(TexturePool);

class RenderGroup {
  constructor() {
    this.renderPipeId = "renderGroup";
    this.root = null;
    this.canBundle = false;
    this.renderGroupParent = null;
    this.renderGroupChildren = [];
    this.worldTransform = new Matrix();
    this.worldColorAlpha = 4294967295;
    this.worldColor = 16777215;
    this.worldAlpha = 1;
    // these updates are transform changes..
    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
    this.updateTick = 0;
    this.gcTick = 0;
    // these update are renderable changes..
    this.childrenRenderablesToUpdate = { list: [], index: 0 };
    // other
    this.structureDidChange = true;
    this.instructionSet = new InstructionSet();
    this._onRenderContainers = [];
    /**
     * Indicates if the cached texture needs to be updated.
     * @default true
     */
    this.textureNeedsUpdate = true;
    /**
     * Indicates if the container should be cached as a texture.
     * @default false
     */
    this.isCachedAsTexture = false;
    this._matrixDirty = 7;
  }
  init(root) {
    this.root = root;
    if (root._onRender) this.addOnRender(root);
    root.didChange = true;
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      child._updateFlags = 15;
      this.addChild(child);
    }
  }
  enableCacheAsTexture(options = {}) {
    this.textureOptions = options;
    this.isCachedAsTexture = true;
    this.textureNeedsUpdate = true;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = false;
    if (this.texture) {
      TexturePool.returnTexture(this.texture, true);
      this.texture = null;
    }
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = true;
    const cachedParent = this._parentCacheAsTextureRenderGroup;
    if (cachedParent && !cachedParent.textureNeedsUpdate) {
      cachedParent.updateCacheTexture();
    }
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const i in this.childrenToUpdate) {
      const childrenAtDepth = this.childrenToUpdate[i];
      childrenAtDepth.list.fill(null);
      childrenAtDepth.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0;
    this.childrenRenderablesToUpdate.list.fill(null);
    this.root = null;
    this.updateTick = 0;
    this.structureDidChange = true;
    this._onRenderContainers.length = 0;
    this.renderGroupParent = null;
    this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(renderGroupChild) {
    if (renderGroupChild.renderGroupParent) {
      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
    }
    renderGroupChild.renderGroupParent = this;
    this.renderGroupChildren.push(renderGroupChild);
  }
  _removeRenderGroupChild(renderGroupChild) {
    const index = this.renderGroupChildren.indexOf(renderGroupChild);
    if (index > -1) {
      this.renderGroupChildren.splice(index, 1);
    }
    renderGroupChild.renderGroupParent = null;
  }
  addChild(child) {
    this.structureDidChange = true;
    child.parentRenderGroup = this;
    child.updateTick = -1;
    if (child.parent === this.root) {
      child.relativeRenderGroupDepth = 1;
    } else {
      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
    }
    child.didChange = true;
    this.onChildUpdate(child);
    if (child.renderGroup) {
      this.addRenderGroupChild(child.renderGroup);
      return;
    }
    if (child._onRender) this.addOnRender(child);
    const children = child.children;
    for (let i = 0; i < children.length; i++) {
      this.addChild(children[i]);
    }
  }
  removeChild(child) {
    this.structureDidChange = true;
    if (child._onRender) {
      if (!child.renderGroup) {
        this.removeOnRender(child);
      }
    }
    child.parentRenderGroup = null;
    if (child.renderGroup) {
      this._removeRenderGroupChild(child.renderGroup);
      return;
    }
    const children = child.children;
    for (let i = 0; i < children.length; i++) {
      this.removeChild(children[i]);
    }
  }
  removeChildren(children) {
    for (let i = 0; i < children.length; i++) {
      this.removeChild(children[i]);
    }
  }
  onChildUpdate(child) {
    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
    if (!childrenToUpdate) {
      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      };
    }
    childrenToUpdate.list[childrenToUpdate.index++] = child;
  }
  updateRenderable(renderable) {
    if (renderable.globalDisplayStatus < 7) return;
    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
    renderable.didViewUpdate = false;
  }
  onChildViewUpdate(child) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(container) {
    this._onRenderContainers.push(container);
  }
  removeOnRender(container) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
  }
  runOnRender(renderer) {
    for (let i = 0; i < this._onRenderContainers.length; i++) {
      this._onRenderContainers[i]._onRender(renderer);
    }
  }
  destroy() {
    this.disableCacheAsTexture();
    this.renderGroupParent = null;
    this.root = null;
    this.childrenRenderablesToUpdate = null;
    this.childrenToUpdate = null;
    this.renderGroupChildren = null;
    this._onRenderContainers = null;
    this.instructionSet = null;
  }
  getChildren(out = []) {
    const children = this.root.children;
    for (let i = 0; i < children.length; i++) {
      this._getChildren(children[i], out);
    }
    return out;
  }
  _getChildren(container, out = []) {
    out.push(container);
    if (container.renderGroup) return out;
    const children = container.children;
    for (let i = 0; i < children.length; i++) {
      this._getChildren(children[i], out);
    }
    return out;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */
  get inverseWorldTransform() {
    if ((this._matrixDirty & 1) === 0) return this._inverseWorldTransform;
    this._matrixDirty &= -2;
    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
  }
  /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */
  get textureOffsetInverseTransform() {
    if ((this._matrixDirty & 2) === 0) return this._textureOffsetInverseTransform;
    this._matrixDirty &= -3;
    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
      -this._textureBounds.x,
      -this._textureBounds.y
    );
  }
  /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0) return this._inverseParentTextureTransform;
    this._matrixDirty &= -5;
    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
    if (parentCacheAsTexture) {
      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
        -parentCacheAsTexture._textureBounds.x,
        -parentCacheAsTexture._textureBounds.y
      );
    }
    return this.worldTransform;
  }
  /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */
  get cacheToLocalTransform() {
    if (this.isCachedAsTexture) {
      return this.textureOffsetInverseTransform;
    }
    if (!this._parentCacheAsTextureRenderGroup) return null;
    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
  }
}

function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== void 0) {
      target[key] = options[key];
    }
  }
}

const defaultSkew = new ObservablePoint(null);
const defaultPivot = new ObservablePoint(null);
const defaultScale = new ObservablePoint(null, 1, 1);
const defaultOrigin = new ObservablePoint(null);
const UPDATE_COLOR = 1;
const UPDATE_BLEND = 2;
const UPDATE_VISIBLE = 4;
class Container extends EventEmitter {
  constructor(options = {}) {
    super();
    /**
     * unique id for this container
     * @internal
     */
    this.uid = uid$1("renderable");
    /** @private */
    this._updateFlags = 15;
    // the render group this container owns
    /** @private */
    this.renderGroup = null;
    // the render group this container belongs to
    /** @private */
    this.parentRenderGroup = null;
    // the index of the container in the render group
    /** @private */
    this.parentRenderGroupIndex = 0;
    // set to true if the container has changed. It is reset once the changes have been applied
    // by the transform system
    // its here to stop ensure that when things change, only one update gets registers with the transform system
    /** @private */
    this.didChange = false;
    // same as above, but for the renderable
    /** @private */
    this.didViewUpdate = false;
    // how deep is the container relative to its render group..
    // unless the element is the root render group - it will be relative to its parent
    /** @private */
    this.relativeRenderGroupDepth = 0;
    /**
     * The array of children of this container. Each child must be a Container or extend from it.
     *
     * The array is read-only, but its contents can be modified using Container methods.
     * @example
     * ```ts
     * // Access children
     * const firstChild = container.children[0];
     * const lastChild = container.children[container.children.length - 1];
     * ```
     * @readonly
     * @see {@link Container#addChild} For adding children
     * @see {@link Container#removeChild} For removing children
     */
    this.children = [];
    /**
     * The display object container that contains this display object.
     * This represents the parent-child relationship in the display tree.
     * @example
     * ```ts
     * // Basic parent access
     * const parent = sprite.parent;
     *
     * // Walk up the tree
     * let current = sprite;
     * while (current.parent) {
     *     console.log('Level up:', current.parent.constructor.name);
     *     current = current.parent;
     * }
     * ```
     * @readonly
     * @see {@link Container#addChild} For adding to a parent
     * @see {@link Container#removeChild} For removing from parent
     */
    this.parent = null;
    // used internally for changing up the render order.. mainly for masks and filters
    // TODO setting this should cause a rebuild??
    /** @private */
    this.includeInBuild = true;
    /** @private */
    this.measurable = true;
    /** @private */
    this.isSimple = true;
    /**
     * The RenderLayer this container belongs to, if any.
     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.
     * @readonly
     * @advanced
     */
    this.parentRenderLayer = null;
    // / /////////////Transform related props//////////////
    // used by the transform system to check if a container needs to be updated that frame
    // if the tick matches the current transform system tick, it is not updated again
    /** @internal */
    this.updateTick = -1;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     * This matrix represents the local transformation without any parent influence.
     * @example
     * ```ts
     * // Basic transform access
     * const localMatrix = sprite.localTransform;
     * console.log(localMatrix.toString());
     * ```
     * @readonly
     * @see {@link Container#worldTransform} For global transform
     * @see {@link Container#groupTransform} For render group transform
     */
    this.localTransform = new Matrix();
    /**
     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent
     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).
     * If this container is is self a render group matrix will be relative to its parent render group
     * @readonly
     * @advanced
     */
    this.relativeGroupTransform = new Matrix();
    /**
     * The group transform is a transform relative to the render group it belongs too.
     * If this container is render group then this will be an identity matrix. other wise it
     * will be the same as the relativeGroupTransform.
     * Use this value when actually rendering things to the screen
     * @readonly
     * @advanced
     */
    this.groupTransform = this.relativeGroupTransform;
    /**
     * Whether this object has been destroyed. If true, the object should no longer be used.
     * After an object is destroyed, all of its functionality is disabled and references are removed.
     * @example
     * ```ts
     * // Cleanup with destroy
     * sprite.destroy();
     * console.log(sprite.destroyed); // true
     * ```
     * @default false
     * @see {@link Container#destroy} For destroying objects
     */
    this.destroyed = false;
    // transform data..
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * @internal
     */
    this._position = new ObservablePoint(this, 0, 0);
    /**
     * The scale factor of the object.
     * @internal
     */
    this._scale = defaultScale;
    /**
     * The pivot point of the container that it rotates around.
     * @internal
     */
    this._pivot = defaultPivot;
    /**
     * The origin point around which the container rotates and scales.
     * Unlike pivot, changing origin will not move the container's position.
     * @private
     */
    this._origin = defaultOrigin;
    /**
     * The skew amount, on the x and y axis.
     * @internal
     */
    this._skew = defaultSkew;
    /**
     * The X-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     */
    this._cx = 1;
    /**
     * The Y-coordinate value of the normalized local X axis,
     * the first column of the local transformation matrix without a scale.
     * @internal
     */
    this._sx = 0;
    /**
     * The X-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     */
    this._cy = 0;
    /**
     * The Y-coordinate value of the normalized local Y axis,
     * the second column of the local transformation matrix without a scale.
     * @internal
     */
    this._sy = 1;
    /**
     * The rotation amount.
     * @internal
     */
    this._rotation = 0;
    // / COLOR related props //////////////
    // color stored as ABGR
    /** @internal */
    this.localColor = 16777215;
    /** @internal */
    this.localAlpha = 1;
    /** @internal */
    this.groupAlpha = 1;
    // A
    /** @internal */
    this.groupColor = 16777215;
    // BGR
    /** @internal */
    this.groupColorAlpha = 4294967295;
    // ABGR
    // / BLEND related props //////////////
    /** @internal */
    this.localBlendMode = "inherit";
    /** @internal */
    this.groupBlendMode = "normal";
    // / VISIBILITY related props //////////////
    // visibility
    // 0b11
    // first bit is visible, second bit is renderable
    /**
     * This property holds three bits: culled, visible, renderable
     * the third bit represents culling (0 = culled, 1 = not culled) 0b100
     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010
     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001
     * @internal
     */
    this.localDisplayStatus = 7;
    // 0b11 | 0b10 | 0b01 | 0b00
    /** @internal */
    this.globalDisplayStatus = 7;
    /**
     * A value that increments each time the containe is modified
     * eg children added, removed etc
     * @ignore
     */
    this._didContainerChangeTick = 0;
    /**
     * A value that increments each time the container view is modified
     * eg texture swap, geometry change etc
     * @ignore
     */
    this._didViewChangeTick = 0;
    /**
     * property that tracks if the container transform has changed
     * @ignore
     */
    this._didLocalTransformChangeId = -1;
    this.effects = [];
    assignWithIgnore(this, options, {
      children: true,
      parent: true,
      effects: true
    });
    options.children?.forEach((child) => this.addChild(child));
    options.parent?.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */
  static mixin(source) {
    deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
    extensions.mixin(Container, source);
  }
  // = 'default';
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(value) {
    this._didViewChangeTick = value >> 12 & 4095;
    this._didContainerChangeTick = value & 4095;
  }
  /** @ignore */
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   * The children will be rendered as part of this container's display list.
   * @example
   * ```ts
   * // Add a single child
   * container.addChild(sprite);
   *
   * // Add multiple children
   * container.addChild(background, player, foreground);
   *
   * // Add with type checking
   * const sprite = container.addChild<Sprite>(new Sprite(texture));
   * sprite.tint = 'red';
   * ```
   * @param children - The Container(s) to add to the container
   * @returns The first child that was added
   * @see {@link Container#removeChild} For removing children
   * @see {@link Container#addChildAt} For adding at specific index
   */
  addChild(...children) {
    if (!this.allowChildren) {
      deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
    }
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.addChild(children[i]);
      }
      return children[0];
    }
    const child = children[0];
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (child.parent === this) {
      this.children.splice(this.children.indexOf(child), 1);
      this.children.push(child);
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      return child;
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    this.children.push(child);
    if (this.sortableChildren) this.sortDirty = true;
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    this.emit("childAdded", child, this, this.children.length - 1);
    child.emit("added", this);
    this._didViewChangeTick++;
    if (child._zIndex !== 0) {
      child.depthOfChildModified();
    }
    return child;
  }
  /**
   * Removes one or more children from the container.
   * When removing multiple children, events will be triggered for each child in sequence.
   * @example
   * ```ts
   * // Remove a single child
   * const removed = container.removeChild(sprite);
   *
   * // Remove multiple children
   * const bg = container.removeChild(background, player, userInterface);
   *
   * // Remove with type checking
   * const sprite = container.removeChild<Sprite>(childSprite);
   * sprite.texture = newTexture;
   * ```
   * @param children - The Container(s) to remove
   * @returns The first child that was removed
   * @see {@link Container#addChild} For adding children
   * @see {@link Container#removeChildren} For removing multiple children
   */
  removeChild(...children) {
    if (children.length > 1) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
      return children[0];
    }
    const child = children[0];
    const index = this.children.indexOf(child);
    if (index > -1) {
      this._didViewChangeTick++;
      this.children.splice(index, 1);
      if (this.renderGroup) {
        this.renderGroup.removeChild(child);
      } else if (this.parentRenderGroup) {
        this.parentRenderGroup.removeChild(child);
      }
      if (child.parentRenderLayer) {
        child.parentRenderLayer.detach(child);
      }
      child.parent = null;
      this.emit("childRemoved", child, this, index);
      child.emit("removed", this);
    }
    return child;
  }
  /** @ignore */
  _onUpdate(point) {
    if (point) {
      if (point === this._skew) {
        this._updateSkew();
      }
    }
    this._didContainerChangeTick++;
    if (this.didChange) return;
    this.didChange = true;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.onChildUpdate(this);
    }
  }
  set isRenderGroup(value) {
    if (!!this.renderGroup === value) return;
    if (value) {
      this.enableRenderGroup();
    } else {
      this.disableRenderGroup();
    }
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   * @advanced
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   * @advanced
   */
  enableRenderGroup() {
    if (this.renderGroup) return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup?.removeChild(this);
    this.renderGroup = BigPool.get(RenderGroup, this);
    this.groupTransform = Matrix.IDENTITY;
    parentRenderGroup?.addChild(this);
    this._updateIsSimple();
  }
  /**
   * This will disable the render group for this container.
   * @advanced
   */
  disableRenderGroup() {
    if (!this.renderGroup) return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup?.removeChild(this);
    BigPool.return(this.renderGroup);
    this.renderGroup = null;
    this.groupTransform = this.relativeGroupTransform;
    parentRenderGroup?.addChild(this);
    this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   *
   * This matrix represents the absolute transformation in the scene graph.
   * @example
   * ```ts
   * // Get world position
   * const worldPos = container.worldTransform;
   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
   * ```
   * @readonly
   * @see {@link Container#localTransform} For local space transform
   */
  get worldTransform() {
    this._worldTransform || (this._worldTransform = new Matrix());
    if (this.renderGroup) {
      this._worldTransform.copyFrom(this.renderGroup.worldTransform);
    } else if (this.parentRenderGroup) {
      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
    }
    return this._worldTransform;
  }
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   *
   * An alias to position.x
   * @example
   * ```ts
   * // Basic position
   * container.x = 100;
   * ```
   */
  get x() {
    return this._position.x;
  }
  set x(value) {
    this._position.x = value;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   *
   * An alias to position.y
   * @example
   * ```ts
   * // Basic position
   * container.y = 200;
   * ```
   */
  get y() {
    return this._position.y;
  }
  set y(value) {
    this._position.y = value;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @example
   * ```ts
   * // Basic position setting
   * container.position.set(100, 200);
   * container.position.set(100); // Sets both x and y to 100
   * // Using point data
   * container.position = { x: 50, y: 75 };
   * ```
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position.copyFrom(value);
  }
  /**
   * The rotation of the object in radians.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   *
   * // Convert from degrees
   * const degrees = 45;
   * container.rotation = degrees * Math.PI / 180;
   *
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   *
   * // Rotate around center with origin
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   * ```
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (this._rotation !== value) {
      this._rotation = value;
      this._onUpdate(this._skew);
    }
  }
  /**
   * The angle of the object in degrees.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic angle rotation
   * sprite.angle = 45; // 45 degrees
   *
   * // Rotate around center
   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Rotate around center with origin
   * sprite.origin.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Reset rotation
   * sprite.angle = 0;
   * ```
   */
  get angle() {
    return this.rotation * RAD_TO_DEG;
  }
  set angle(value) {
    this.rotation = value * DEG_TO_RAD;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space.
   * The `position` is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @example
   * ```ts
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   * ```
   * @since 4.0.0
   */
  get pivot() {
    if (this._pivot === defaultPivot) {
      this._pivot = new ObservablePoint(this, 0, 0);
    }
    return this._pivot;
  }
  set pivot(value) {
    if (this._pivot === defaultPivot) {
      this._pivot = new ObservablePoint(this, 0, 0);
      if (this._origin !== defaultOrigin) {
        warn$2(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
      }
    }
    typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
  }
  /**
   * The skew factor for the object in radians. Skewing is a transformation that distorts
   * the object by rotating it differently at each point, creating a non-uniform shape.
   * @example
   * ```ts
   * // Basic skewing
   * container.skew.set(0.5, 0); // Skew horizontally
   * container.skew.set(0, 0.5); // Skew vertically
   *
   * // Skew with point data
   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
   *
   * // Reset skew
   * container.skew.set(0, 0);
   *
   * // Animate skew
   * app.ticker.add(() => {
   *     // Create wave effect
   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
   * });
   *
   * // Combine with rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   * container.skew.set(0.2, 0.2); // Skew the rotated object
   * ```
   * @since 4.0.0
   * @type {ObservablePoint} Point-like object with x/y properties in radians
   * @default {x: 0, y: 0}
   */
  get skew() {
    if (this._skew === defaultSkew) {
      this._skew = new ObservablePoint(this, 0, 0);
    }
    return this._skew;
  }
  set skew(value) {
    if (this._skew === defaultSkew) {
      this._skew = new ObservablePoint(this, 0, 0);
    }
    this._skew.copyFrom(value);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @example
   * ```ts
   * // Basic scaling
   * container.scale.set(2, 2); // Scales to double size
   * container.scale.set(2); // Scales uniformly to double size
   * container.scale = 2; // Scales uniformly to double size
   * // Scale to a specific width and height
   * container.setSize(200, 100); // Sets width to 200 and height to 100
   * ```
   * @since 4.0.0
   */
  get scale() {
    if (this._scale === defaultScale) {
      this._scale = new ObservablePoint(this, 1, 1);
    }
    return this._scale;
  }
  set scale(value) {
    if (this._scale === defaultScale) {
      this._scale = new ObservablePoint(this, 0, 0);
    }
    if (typeof value === "string") {
      value = parseFloat(value);
    }
    typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
  }
  /**
   * @experimental
   * The origin point around which the container rotates and scales without affecting its position.
   * Unlike pivot, changing the origin will not move the container's position.
   * @example
   * ```ts
   * // Rotate around center point
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   *
   * // Reset origin
   * container.origin.set(0, 0);
   * ```
   */
  get origin() {
    if (this._origin === defaultOrigin) {
      this._origin = new ObservablePoint(this, 0, 0);
    }
    return this._origin;
  }
  set origin(value) {
    if (this._origin === defaultOrigin) {
      this._origin = new ObservablePoint(this, 0, 0);
      if (this._pivot !== defaultPivot) {
        warn$2(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
      }
    }
    typeof value === "number" ? this._origin.set(value) : this._origin.copyFrom(value);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic width setting
   * container.width = 100;
   * // Optimized width setting
   * container.setSize(100, 100);
   * ```
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(value) {
    const localWidth = this.getLocalBounds().width;
    this._setWidth(value, localWidth);
  }
  /**
   * The height of the Container,
   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic height setting
   * container.height = 200;
   * // Optimized height setting
   * container.setSize(100, 200);
   * ```
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(value) {
    const localHeight = this.getLocalBounds().height;
    this._setHeight(value, localHeight);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   *
   * This is faster than get the width and height separately.
   * @example
   * ```ts
   * // Basic size retrieval
   * const size = container.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * container.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in.
   * @returns The size of the container.
   */
  getSize(out) {
    if (!out) {
      out = {};
    }
    const bounds = this.getLocalBounds();
    out.width = Math.abs(this.scale.x * bounds.width);
    out.height = Math.abs(this.scale.y * bounds.height);
    return out;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is more efficient than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * container.setSize(100, 200);
   *
   * // Set uniform size
   * container.setSize(100); // Sets both width and height to 100
   * ```
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    const size = this.getLocalBounds();
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, size.width);
    height !== void 0 && this._setHeight(height, size.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const rotation = this._rotation;
    const skew = this._skew;
    this._cx = Math.cos(rotation + skew._y);
    this._sx = Math.sin(rotation + skew._y);
    this._cy = -Math.sin(rotation - skew._x);
    this._sy = Math.cos(rotation - skew._x);
  }
  /**
   * Updates the transform properties of the container.
   * Allows partial updates of transform properties for optimized manipulation.
   * @example
   * ```ts
   * // Basic transform update
   * container.updateTransform({
   *     x: 100,
   *     y: 200,
   *     rotation: Math.PI / 4
   * });
   *
   * // Scale and rotate around center
   * sprite.updateTransform({
   *     pivotX: sprite.width / 2,
   *     pivotY: sprite.height / 2,
   *     scaleX: 2,
   *     scaleY: 2,
   *     rotation: Math.PI
   * });
   *
   * // Update position only
   * button.updateTransform({
   *     x: button.x + 10, // Move right
   *     y: button.y      // Keep same y
   * });
   * ```
   * @param opts - Transform options to update
   * @param opts.x - The x position
   * @param opts.y - The y position
   * @param opts.scaleX - The x-axis scale factor
   * @param opts.scaleY - The y-axis scale factor
   * @param opts.rotation - The rotation in radians
   * @param opts.skewX - The x-axis skew factor
   * @param opts.skewY - The y-axis skew factor
   * @param opts.pivotX - The x-axis pivot point
   * @param opts.pivotY - The y-axis pivot point
   * @returns This container, for chaining
   * @see {@link Container#setFromMatrix} For matrix-based transforms
   * @see {@link Container#position} For direct position access
   */
  updateTransform(opts) {
    this.position.set(
      typeof opts.x === "number" ? opts.x : this.position.x,
      typeof opts.y === "number" ? opts.y : this.position.y
    );
    this.scale.set(
      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
    );
    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
    this.skew.set(
      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
      typeof opts.skewY === "number" ? opts.skewY : this.skew.y
    );
    this.pivot.set(
      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
    );
    this.origin.set(
      typeof opts.originX === "number" ? opts.originX : this.origin.x,
      typeof opts.originY === "number" ? opts.originY : this.origin.y
    );
    return this;
  }
  /**
   * Updates the local transform properties by decomposing the given matrix.
   * Extracts position, scale, rotation, and skew from a transformation matrix.
   * @example
   * ```ts
   * // Basic matrix transform
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * container.setFromMatrix(matrix);
   *
   * // Copy transform from another container
   * const source = new Container();
   * source.position.set(100, 100);
   * source.rotation = Math.PI / 2;
   *
   * target.setFromMatrix(source.localTransform);
   *
   * // Reset transform
   * container.setFromMatrix(Matrix.IDENTITY);
   * ```
   * @param matrix - The matrix to use for updating the transform
   * @see {@link Container#updateTransform} For property-based updates
   * @see {@link Matrix#decompose} For matrix decomposition details
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const localTransformChangeId = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === localTransformChangeId) return;
    this._didLocalTransformChangeId = localTransformChangeId;
    const lt = this.localTransform;
    const scale = this._scale;
    const pivot = this._pivot;
    const origin = this._origin;
    const position = this._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    const ox = -origin._x;
    const oy = -origin._y;
    lt.a = this._cx * sx;
    lt.b = this._sx * sx;
    lt.c = this._cy * sy;
    lt.d = this._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
    lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
  }
  // / ///// color related stuff
  set alpha(value) {
    if (value === this.localAlpha) return;
    this.localAlpha = value;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /**
   * The opacity of the object relative to its parent's opacity.
   * Value ranges from 0 (fully transparent) to 1 (fully opaque).
   * @example
   * ```ts
   * // Basic transparency
   * sprite.alpha = 0.5; // 50% opacity
   *
   * // Inherited opacity
   * container.alpha = 0.5;
   * const child = new Sprite(texture);
   * child.alpha = 0.5;
   * container.addChild(child);
   * // child's effective opacity is 0.25 (0.5 * 0.5)
   * ```
   * @default 1
   * @see {@link Container#visible} For toggling visibility
   * @see {@link Container#renderable} For render control
   */
  get alpha() {
    return this.localAlpha;
  }
  set tint(value) {
    const tempColor = Color.shared.setValue(value ?? 16777215);
    const bgr = tempColor.toBgrNumber();
    if (bgr === this.localColor) return;
    this.localColor = bgr;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /**
   * The tint applied to the sprite.
   *
   * This can be any valid {@link ColorSource}.
   * @example
   * ```ts
   * // Basic color tinting
   * container.tint = 0xff0000; // Red tint
   * container.tint = 'red';    // Same as above
   * container.tint = '#00ff00'; // Green
   * container.tint = 'rgb(0,0,255)'; // Blue
   *
   * // Remove tint
   * container.tint = 0xffffff; // White = no tint
   * container.tint = null;     // Also removes tint
   * ```
   * @default 0xFFFFFF
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#visible} For visibility control
   */
  get tint() {
    return bgr2rgb(this.localColor);
  }
  // / //////////////// blend related stuff
  set blendMode(value) {
    if (this.localBlendMode === value) return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_BLEND;
    this.localBlendMode = value;
    this._onUpdate();
  }
  /**
   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
   *
   * Setting to 'normal' will reset to default blending.
   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
   * @example
   * ```ts
   * // Basic blend modes
   * sprite.blendMode = 'add';        // Additive blending
   * sprite.blendMode = 'multiply';   // Multiply colors
   * sprite.blendMode = 'screen';     // Screen blend
   *
   * // Reset blend mode
   * sprite.blendMode = 'normal';     // Normal blending
   * ```
   * @default 'normal'
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#tint} For color adjustments
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /**
   * The visibility of the object. If false the object will not be drawn,
   * and the transform will not be updated.
   * @example
   * ```ts
   * // Basic visibility toggle
   * sprite.visible = false; // Hide sprite
   * sprite.visible = true;  // Show sprite
   * ```
   * @default true
   * @see {@link Container#renderable} For render-only control
   * @see {@link Container#alpha} For transparency
   */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(value) {
    const valueNumber = value ? 2 : 0;
    if ((this.localDisplayStatus & 2) === valueNumber) return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 2;
    this._onUpdate();
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(value) {
    const valueNumber = value ? 0 : 4;
    if ((this.localDisplayStatus & 4) === valueNumber) return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 4;
    this._onUpdate();
  }
  /**
   * Controls whether this object can be rendered. If false the object will not be drawn,
   * but the transform will still be updated. This is different from visible, which skips
   * transform updates.
   * @example
   * ```ts
   * // Basic render control
   * sprite.renderable = false; // Skip rendering
   * sprite.renderable = true;  // Enable rendering
   * ```
   * @default true
   * @see {@link Container#visible} For skipping transform updates
   * @see {@link Container#alpha} For transparency
   */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(value) {
    const valueNumber = value ? 1 : 0;
    if ((this.localDisplayStatus & 1) === valueNumber) return;
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 1;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._onUpdate();
  }
  /**
   * Whether or not the object should be rendered.
   * @advanced
   */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * ```ts
   * container.destroy();
   * container.destroy(true);
   * container.destroy({ children: true });
   * container.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */
  destroy(options = false) {
    if (this.destroyed) return;
    this.destroyed = true;
    let oldChildren;
    if (this.children.length) {
      oldChildren = this.removeChildren(0, this.children.length);
    }
    this.removeFromParent();
    this.parent = null;
    this._maskEffect = null;
    this._filterEffect = null;
    this.effects = null;
    this._position = null;
    this._scale = null;
    this._pivot = null;
    this._origin = null;
    this._skew = null;
    this.emit("destroyed", this);
    this.removeAllListeners();
    const destroyChildren = typeof options === "boolean" ? options : options?.children;
    if (destroyChildren && oldChildren) {
      for (let i = 0; i < oldChildren.length; ++i) {
        oldChildren[i].destroy(options);
      }
    }
    this.renderGroup?.destroy();
    this.renderGroup = null;
  }
}
extensions.mixin(
  Container,
  childrenHelperMixin,
  getFastGlobalBoundsMixin,
  toLocalGlobalMixin,
  onRenderMixin,
  measureMixin,
  effectsMixin,
  findMixin,
  sortMixin,
  cullingMixin,
  cacheAsTextureMixin,
  getGlobalMixin,
  collectRenderablesMixin
);

class ViewContainer extends Container {
  constructor(options) {
    super(options);
    /** @internal */
    this.canBundle = true;
    /** @internal */
    this.allowChildren = false;
    /** @internal */
    this._roundPixels = 0;
    /** @internal */
    this._lastUsed = -1;
    /** @internal */
    this._gpuData = /* @__PURE__ */ Object.create(null);
    /** If set to true, the resource will be garbage collected automatically when it is not used. */
    this.autoGarbageCollect = true;
    /** @internal */
    this._gcLastUsed = -1;
    this._bounds = new Bounds(0, 1, 0, 0);
    this._boundsDirty = true;
    this.autoGarbageCollect = options.autoGarbageCollect ?? true;
  }
  /**
   * The local bounds of the view in its own coordinate space.
   * Bounds are automatically updated when the view's content changes.
   * @example
   * ```ts
   * // Get bounds dimensions
   * const bounds = view.bounds;
   * console.log(`Width: ${bounds.maxX - bounds.minX}`);
   * console.log(`Height: ${bounds.maxY - bounds.minY}`);
   * ```
   * @returns The rectangular bounds of the view
   * @see {@link Bounds} For bounds operations
   */
  get bounds() {
    if (!this._boundsDirty) return this._bounds;
    this.updateBounds();
    this._boundsDirty = false;
    return this._bounds;
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @example
   * ```ts
   * // Enable pixel rounding for crisp rendering
   * view.roundPixels = true;
   * ```
   * @default false
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(value) {
    this._roundPixels = value ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the view's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = view.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the view's bounds
   * @see {@link ViewContainer#bounds} For the bounds used in hit testing
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(point) {
    const bounds = this.bounds;
    const { x, y } = point;
    return x >= bounds.minX && x <= bounds.maxX && y >= bounds.minY && y <= bounds.maxY;
  }
  /** @private */
  onViewUpdate() {
    this._didViewChangeTick++;
    this._boundsDirty = true;
    if (this.didViewUpdate) return;
    this.didViewUpdate = true;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.onChildViewUpdate(this);
    }
  }
  /** Unloads the GPU data from the view. */
  unload() {
    this.emit("unload", this);
    for (const key in this._gpuData) {
      this._gpuData[key]?.destroy();
    }
    this._gpuData = /* @__PURE__ */ Object.create(null);
    this.onViewUpdate();
  }
  destroy(options) {
    this.unload();
    super.destroy(options);
    this._bounds = null;
  }
  /**
   * Collects renderables for the view container.
   * @param instructionSet - The instruction set to collect renderables for.
   * @param renderer - The renderer to collect renderables for.
   * @param currentLayer - The current render layer.
   * @internal
   */
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const { renderPipes } = renderer;
    renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
    const rp = renderPipes;
    const pipe = rp[this.renderPipeId];
    if (pipe?.addRenderable) {
      pipe.addRenderable(this, instructionSet);
    }
    this.didViewUpdate = false;
    const children = this.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      children[i].collectRenderables(instructionSet, renderer, currentLayer);
    }
    renderPipes.blendMode.popBlendMode(instructionSet);
  }
}

class Sprite extends ViewContainer {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(options = Texture.EMPTY) {
    if (options instanceof Texture) {
      options = { texture: options };
    }
    const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
    super({
      label: "Sprite",
      ...rest
    });
    /** @internal */
    this.renderPipeId = "sprite";
    /** @internal */
    this.batched = true;
    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor) {
      this.anchor = anchor;
    } else if (texture.defaultAnchor) {
      this.anchor = texture.defaultAnchor;
    }
    this.texture = texture;
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0) this.width = width;
    if (height !== void 0) this.height = height;
  }
  /**
   * Creates a new sprite based on a source texture, image, video, or canvas element.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create from path or URL
   * const sprite = Sprite.from('assets/image.png');
   *
   * // Create from existing texture
   * const sprite = Sprite.from(texture);
   *
   * // Create from canvas
   * const canvas = document.createElement('canvas');
   * const sprite = Sprite.from(canvas, true); // Skip caching new texture
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image, a texture,
   * or any valid texture source (canvas, video, etc.)
   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
   * @returns A new sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */
  static from(source, skipCache = false) {
    if (source instanceof Texture) {
      return new Sprite(source);
    }
    return new Sprite(Texture.from(source, skipCache));
  }
  set texture(value) {
    value || (value = Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value) return;
    if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic) value.on("update", this.onViewUpdate, this);
    this._texture = value;
    if (this._width) {
      this._setWidth(this._width, this._texture.orig.width);
    }
    if (this._height) {
      this._setHeight(this._height, this._texture.orig.height);
    }
    this.onViewUpdate();
  }
  /**
   * The texture that is displayed by the sprite. When changed, automatically updates
   * the sprite dimensions and manages texture event listeners.
   * @example
   * ```ts
   * // Create sprite with texture
   * const sprite = new Sprite({
   *     texture: Texture.from('sprite.png')
   * });
   *
   * // Update texture
   * sprite.texture = Texture.from('newSprite.png');
   *
   * // Use texture from spritesheet
   * const sheet = await Assets.load('spritesheet.json');
   * sprite.texture = sheet.textures['frame1.png'];
   *
   * // Reset to empty texture
   * sprite.texture = Texture.EMPTY;
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link Assets} For asset loading
   */
  get texture() {
    return this._texture;
  }
  /**
   * The bounds of the sprite, taking into account the texture's trim area.
   * @example
   * ```ts
   * const texture = new Texture({
   *     source: new TextureSource({ width: 300, height: 300 }),
   *     frame: new Rectangle(196, 66, 58, 56),
   *     trim: new Rectangle(4, 4, 58, 56),
   *     orig: new Rectangle(0, 0, 64, 64),
   *     rotate: 2,
   * });
   * const sprite = new Sprite(texture);
   * const visualBounds = sprite.visualBounds;
   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
   */
  get visualBounds() {
    updateQuadBounds(this._visualBounds, this._anchor, this._texture);
    return this._visualBounds;
  }
  /**
   * @deprecated
   * @ignore
   */
  get sourceBounds() {
    deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
    return this.visualBounds;
  }
  /** @private */
  updateBounds() {
    const anchor = this._anchor;
    const texture = this._texture;
    const bounds = this._bounds;
    const { width, height } = texture.orig;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * sprite.destroy();
   * sprite.destroy(true);
   * sprite.destroy({ texture: true, textureSource: true });
   */
  destroy(options = false) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
    this._visualBounds = null;
    this._bounds = null;
    this._anchor = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * sprite.width = 200;
   * console.log(sprite.scale.x); // Scale adjusted to match width
   *
   * // Set width while preserving aspect ratio
   * const ratio = sprite.height / sprite.width;
   * sprite.width = 300;
   * sprite.height = 300 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.width = sprite.texture.orig.width;
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value) {
    this._setWidth(value, this._texture.orig.width);
    this._width = value;
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * sprite.height = 150;
   * console.log(sprite.scale.y); // Scale adjusted to match height
   *
   * // Set height while preserving aspect ratio
   * const ratio = sprite.width / sprite.height;
   * sprite.height = 200;
   * sprite.width = 200 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.height = sprite.texture.orig.height;
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value) {
    this._setHeight(value, this._texture.orig.height);
    this._height = value;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Sprite#width} For getting just the width
   * @see {@link Sprite#height} For getting just the height
   * @see {@link Sprite#setSize} For setting both width and height
   */
  getSize(out) {
    out || (out = {});
    out.width = Math.abs(this.scale.x) * this._texture.orig.width;
    out.height = Math.abs(this.scale.y) * this._texture.orig.height;
    return out;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * sprite.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * sprite.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * sprite.setSize({
   *     width: 200,
   *     height: 300
   * });
   *
   * // Reset to texture size
   * sprite.setSize(
   *     sprite.texture.orig.width,
   *     sprite.texture.orig.height
   * );
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Sprite#width} For setting width only
   * @see {@link Sprite#height} For setting height only
   * @see {@link Sprite#texture} For the source dimensions
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, this._texture.orig.width);
    height !== void 0 && this._setHeight(height, this._texture.orig.height);
  }
}

const tempBounds$2 = new Bounds();
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds$2;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}

function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn$2("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}

class AlphaMask {
  constructor(options) {
    this.priority = 0;
    this.inverse = false;
    this.pipe = "alphaMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.renderMaskToTexture = !(mask instanceof Sprite);
    this.mask.renderable = this.renderMaskToTexture;
    this.mask.includeInBuild = !this.renderMaskToTexture;
    this.mask.measurable = false;
  }
  reset() {
    if (this.mask === null) return;
    this.mask.measurable = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    if (!this.inverse) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Sprite;
  }
}
AlphaMask.extension = ExtensionType.MaskEffect;

class ColorMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "colorMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
  }
  destroy() {
  }
  static test(mask) {
    return typeof mask === "number";
  }
}
ColorMask.extension = ExtensionType.MaskEffect;

class StencilMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "stencilMask";
    if (options?.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.mask.includeInBuild = false;
    this.mask.measurable = false;
  }
  reset() {
    if (this.mask === null) return;
    this.mask.measurable = true;
    this.mask.includeInBuild = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    addMaskBounds(this.mask, bounds, skipUpdateTransform);
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Container;
  }
}
StencilMask.extension = ExtensionType.MaskEffect;

const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  createImage: () => new Image(),
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};

let currentAdapter = BrowserAdapter;
const DOMAdapter = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return currentAdapter;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(adapter) {
    currentAdapter = adapter;
  }
};

class CanvasSource extends TextureSource {
  constructor(options) {
    if (!options.resource) {
      options.resource = DOMAdapter.get().createCanvas();
    }
    if (!options.width) {
      options.width = options.resource.width;
      if (!options.autoDensity) {
        options.width /= options.resolution;
      }
    }
    if (!options.height) {
      options.height = options.resource.height;
      if (!options.autoDensity) {
        options.height /= options.resolution;
      }
    }
    super(options);
    this.uploadMethodId = "image";
    this.autoDensity = options.autoDensity;
    this.resizeCanvas();
    this.transparent = !!options.transparent;
  }
  resizeCanvas() {
    if (this.autoDensity && "style" in this.resource) {
      this.resource.style.width = `${this.width}px`;
      this.resource.style.height = `${this.height}px`;
    }
    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
      this.resource.width = this.pixelWidth;
      this.resource.height = this.pixelHeight;
    }
  }
  resize(width = this.width, height = this.height, resolution = this._resolution) {
    const didResize = super.resize(width, height, resolution);
    if (didResize) {
      this.resizeCanvas();
    }
    return didResize;
  }
  static test(resource) {
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
CanvasSource.extension = ExtensionType.TextureSource;

class ImageSource extends TextureSource {
  constructor(options) {
    super(options);
    this.uploadMethodId = "image";
    this.autoGarbageCollect = true;
  }
  static test(resource) {
    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
  }
}
ImageSource.extension = ExtensionType.TextureSource;

var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});

class TickerListener {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context = null, priority = 0, once = false) {
    /** The next item in chain. */
    this.next = null;
    /** The previous item in chain. */
    this.previous = null;
    /** `true` if this listener has been destroyed already. */
    this._destroyed = false;
    this._fn = fn;
    this._context = context;
    this.priority = priority;
    this._once = once;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context = null) {
    return this._fn === fn && this._context === context;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(ticker) {
    if (this._fn) {
      if (this._context) {
        this._fn.call(this._context, ticker);
      } else {
        this._fn(ticker);
      }
    }
    const redirect = this.next;
    if (this._once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = false) {
    this._destroyed = true;
    this._fn = null;
    this._context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}

const _Ticker = class _Ticker {
  constructor() {
    /**
     * Whether or not this ticker should invoke the method {@link Ticker#start|start}
     * automatically when a listener is added.
     * @example
     * ```ts
     * // Default behavior (manual start)
     * const ticker = new Ticker();
     * ticker.autoStart = false;
     * ticker.add(() => {
     *     // Won't run until ticker.start() is called
     * });
     *
     * // Auto-start behavior
     * const autoTicker = new Ticker();
     * autoTicker.autoStart = true;
     * autoTicker.add(() => {
     *     // Runs immediately when added
     * });
     * ```
     * @default false
     * @see {@link Ticker#start} For manually starting the ticker
     * @see {@link Ticker#stop} For manually stopping the ticker
     */
    this.autoStart = false;
    /**
     * Scalar representing the delta time factor.
     * This is a dimensionless value representing the fraction of a frame at the target framerate.
     * At 60 FPS, this value is typically around 1.0.
     *
     * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.
     * For actual milliseconds, use {@link Ticker#deltaMS}.
     * @example
     * ```ts
     * // Frame-independent animation using deltaTime scalar
     * ticker.add((ticker) => {
     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime
     *     sprite.rotation += 0.1 * ticker.deltaTime;
     * });
     * ```
     */
    this.deltaTime = 1;
    /**
     * The last time update was invoked, in milliseconds since epoch.
     * Similar to performance.now() timestamp format.
     *
     * Used internally for calculating time deltas between frames.
     * @example
     * ```ts
     * ticker.add((ticker) => {
     *     const currentTime = performance.now();
     *     const timeSinceLastFrame = currentTime - ticker.lastTime;
     *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);
     * });
     * ```
     */
    this.lastTime = -1;
    /**
     * Factor of current {@link Ticker#deltaTime|deltaTime}.
     * Used to scale time for slow motion or fast-forward effects.
     * @example
     * ```ts
     * // Basic speed adjustment
     * ticker.speed = 0.5; // Half speed (slow motion)
     * ticker.speed = 2.0; // Double speed (fast forward)
     *
     * // Temporary speed changes
     * function slowMotion() {
     *     const normalSpeed = ticker.speed;
     *     ticker.speed = 0.2;
     *     setTimeout(() => {
     *         ticker.speed = normalSpeed;
     *     }, 1000);
     * }
     * ```
     */
    this.speed = 1;
    /**
     * Whether or not this ticker has been started.
     *
     * `true` if {@link Ticker#start|start} has been called.
     * `false` if {@link Ticker#stop|Stop} has been called.
     *
     * While `false`, this value may change to `true` in the
     * event of {@link Ticker#autoStart|autoStart} being `true`
     * and a listener is added.
     * @example
     * ```ts
     * // Check ticker state
     * const ticker = new Ticker();
     * console.log(ticker.started); // false
     *
     * // Start and verify
     * ticker.start();
     * console.log(ticker.started); // true
     * ```
     */
    this.started = false;
    /** Internal current frame request ID */
    this._requestId = null;
    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the maximum allowed milliseconds between updates.
     */
    this._maxElapsedMS = 100;
    /**
     * Internal value managed by minFPS property setter and getter.
     * This is the minimum allowed milliseconds between updates.
     */
    this._minElapsedMS = 0;
    /** If enabled, deleting is disabled.*/
    this._protected = false;
    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker.targetFPMS;
    this.elapsedMS = 1 / _Ticker.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   */
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  /** Conditionally cancels a pending animation frame. */
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   */
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  /**
   * Register a handler for tick events.
   * @param fn - The listener function to add. Receives the Ticker instance as parameter
   * @param context - The context for the listener
   * @param priority - The priority of the listener
   * @example
   * ```ts
   * // Access time properties through the ticker parameter
   * ticker.add((ticker) => {
   *     // Use deltaTime (dimensionless scalar) for frame-independent animations
   *     sprite.rotation += 0.1 * ticker.deltaTime;
   *
   *     // Use deltaMS (milliseconds) for time-based calculations
   *     const progress = ticker.deltaMS / animationDuration;
   *
   *     // Use elapsedMS for raw timing measurements
   *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
   * });
   * ```
   */
  add(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority));
  }
  /**
   * Add a handler for the tick event which is only executed once on the next frame.
   * @example
   * ```ts
   * // Basic one-time update
   * ticker.addOnce(() => {
   *     console.log('Runs next frame only');
   * });
   *
   * // With specific context
   * const game = {
   *     init(ticker) {
   *         this.loadResources();
   *         console.log('Game initialized');
   *     }
   * };
   * ticker.addOnce(game.init, game);
   *
   * // With priority
   * ticker.addOnce(
   *     () => {
   *         // High priority one-time setup
   *         physics.init();
   *     },
   *     undefined,
   *     UPDATE_PRIORITY.HIGH
   * );
   * ```
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For continuous updates
   * @see {@link Ticker#remove} For removing handlers
   */
  addOnce(fn, context, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context, priority, true));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @example
   * ```ts
   * // Basic removal
   * const onTick = () => {
   *     sprite.rotation += 0.1;
   * };
   * ticker.add(onTick);
   * ticker.remove(onTick);
   *
   * // Remove with context
   * const game = {
   *     update(ticker) {
   *         this.physics.update(ticker.deltaTime);
   *     }
   * };
   * ticker.add(game.update, game);
   * ticker.remove(game.update, game);
   *
   * // Remove all matching handlers
   * // (if same function was added multiple times)
   * ticker.add(onTick);
   * ticker.add(onTick);
   * ticker.remove(onTick); // Removes all instances
   * ```
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For adding handlers
   * @see {@link Ticker#addOnce} For one-time handlers
   */
  remove(fn, context) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list.
   * @example
   * ```ts
   * // Check number of active listeners
   * const ticker = new Ticker();
   * console.log(ticker.count); // 0
   *
   * // Add some listeners
   * ticker.add(() => {});
   * ticker.add(() => {});
   * console.log(ticker.count); // 2
   *
   * // Check after cleanup
   * ticker.destroy();
   * console.log(ticker.count); // 0
   * ```
   * @readonly
   * @see {@link Ticker#add} For adding listeners
   * @see {@link Ticker#remove} For removing listeners
   */
  get count() {
    if (!this._head) {
      return 0;
    }
    let count = 0;
    let current = this._head;
    while (current = current.next) {
      count++;
    }
    return count;
  }
  /**
   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
   * @example
   * ```ts
   * // Basic manual start
   * const ticker = new Ticker();
   * ticker.add(() => {
   *     // Animation code here
   * });
   * ticker.start();
   * ```
   * @see {@link Ticker#stop} For stopping the ticker
   * @see {@link Ticker#autoStart} For automatic starting
   * @see {@link Ticker#started} For checking ticker state
   */
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  /**
   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
   * @example
   * ```ts
   * // Basic stop
   * const ticker = new Ticker();
   * ticker.stop();
   * ```
   * @see {@link Ticker#start} For starting the ticker
   * @see {@link Ticker#started} For checking ticker state
   * @see {@link Ticker#destroy} For cleaning up the ticker
   */
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  /**
   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
   * @example
   * ```ts
   * // Clean up with active listeners
   * const ticker = new Ticker();
   * ticker.add(() => {});
   * ticker.destroy(); // Removes all listeners
   * ```
   * @see {@link Ticker#stop} For stopping without destroying
   * @see {@link Ticker#remove} For removing specific listeners
   */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  /**
   * Triggers an update.
   *
   * An update entails setting the
   * current {@link Ticker#elapsedMS|elapsedMS},
   * the current {@link Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   *
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @example
   * ```ts
   * // Basic manual update
   * const ticker = new Ticker();
   * ticker.update(performance.now());
   * ```
   * @param currentTime - The current time of execution (defaults to performance.now())
   * @see {@link Ticker#deltaTime} For frame delta value
   * @see {@link Ticker#elapsedMS} For raw elapsed time
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * > [!NOTE] This does not factor in the value of
   * > {@link Ticker#speed|speed}, which is specific
   * > to scaling {@link Ticker#deltaTime|deltaTime}.
   * @example
   * ```ts
   * // Basic FPS monitoring
   * ticker.add(() => {
   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
   * });
   * ```
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This value is used to cap {@link Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.minFPS = 30; // Never go below 30 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on minFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This will effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.maxFPS = 60; // Never go above 60 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on maxFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 0
   */
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoSource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @type {Ticker}
   * @readonly
   */
  static get shared() {
    if (!_Ticker._shared) {
      const shared = _Ticker._shared = new _Ticker();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker._shared;
  }
  /**
   * The system ticker instance used by {@link PrepareBase} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @type {Ticker}
   * @readonly
   * @advanced
   */
  static get system() {
    if (!_Ticker._system) {
      const system = _Ticker._system = new _Ticker();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker._system;
  }
};
/**
 * Target frame rate in frames per millisecond.
 * Used for converting deltaTime to a scalar time delta.
 * @example
 * ```ts
 * // Default is 0.06 (60 FPS)
 * console.log(Ticker.targetFPMS); // 0.06
 *
 * // Calculate target frame duration
 * const frameDuration = 1 / Ticker.targetFPMS; // â‰ˆ 16.67ms
 *
 * // Use in custom timing calculations
 * const deltaTime = elapsedMS * Ticker.targetFPMS;
 * ```
 * @remarks
 * - Default is 0.06 (equivalent to 60 FPS)
 * - Used in deltaTime calculations
 * - Affects all ticker instances
 * @default 0.06
 * @see {@link Ticker#deltaTime} For time scaling
 * @see {@link Ticker#FPS} For actual frame rate
 */
_Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;

let promise;
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = DOMAdapter.get().createCanvas(1, 1);
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}

const _VideoSource = class _VideoSource extends TextureSource {
  constructor(options) {
    super(options);
    // Public
    /** Whether or not the video is ready to play. */
    this.isReady = false;
    /** The upload method for this texture. */
    this.uploadMethodId = "video";
    options = {
      ..._VideoSource.defaultOptions,
      ...options
    };
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
    this._videoFrameRequestCallbackHandle = null;
    this._load = null;
    this._resolve = null;
    this._reject = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
    this._onError = this._onError.bind(this);
    this._onPlayStart = this._onPlayStart.bind(this);
    this._onPlayStop = this._onPlayStop.bind(this);
    this._onSeeked = this._onSeeked.bind(this);
    if (options.autoLoad !== false) {
      void this.load();
    }
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (this.destroyed) {
      return;
    }
    if (this._updateFPS) {
      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
    }
    if (!this._updateFPS || this._msToNextUpdate <= 0) {
      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
    }
    if (this.isValid) {
      this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame();
    if (this.destroyed) {
      this._videoFrameRequestCallbackHandle = null;
    } else {
      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
        this._videoFrameRequestCallback
      );
    }
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load) {
      return this._load;
    }
    const source = this.resource;
    const options = this.options;
    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {
      source.complete = true;
    }
    source.addEventListener("play", this._onPlayStart);
    source.addEventListener("pause", this._onPlayStop);
    source.addEventListener("seeked", this._onSeeked);
    if (!this._isSourceReady()) {
      if (!options.preload) {
        source.addEventListener("canplay", this._onCanPlay);
      }
      source.addEventListener("canplaythrough", this._onCanPlayThrough);
      source.addEventListener("error", this._onError, true);
    } else {
      this._mediaReady();
    }
    this.alphaMode = await detectVideoAlphaMode();
    this._load = new Promise((resolve, reject) => {
      if (this.isValid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        this._reject = reject;
        if (options.preloadTimeoutMs !== void 0) {
          this._preloadTimeout = setTimeout(() => {
            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
          });
        }
        source.load();
      }
    });
    return this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(event) {
    this.resource.removeEventListener("error", this._onError, true);
    this.emit("error", event);
    if (this._reject) {
      this._reject(event);
      this._reject = null;
      this._resolve = null;
    }
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const source = this.resource;
    return !source.paused && !source.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    const source = this.resource;
    return source.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    if (!this.isValid) {
      this._mediaReady();
    }
    this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    if (this._autoUpdate && !this._isSourcePlaying()) {
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
    }
  }
  _onCanPlay() {
    const source = this.resource;
    source.removeEventListener("canplay", this._onCanPlay);
    this._mediaReady();
  }
  _onCanPlayThrough() {
    const source = this.resource;
    source.removeEventListener("canplaythrough", this._onCanPlay);
    if (this._preloadTimeout) {
      clearTimeout(this._preloadTimeout);
      this._preloadTimeout = void 0;
    }
    this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const source = this.resource;
    if (this.isValid) {
      this.isReady = true;
      this.resize(source.videoWidth, source.videoHeight);
    }
    this._msToNextUpdate = 0;
    this.updateFrame();
    this._msToNextUpdate = 0;
    if (this._resolve) {
      this._resolve(this);
      this._resolve = null;
      this._reject = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      void this.resource.play();
    }
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const source = this.resource;
    if (source) {
      source.removeEventListener("play", this._onPlayStart);
      source.removeEventListener("pause", this._onPlayStop);
      source.removeEventListener("seeked", this._onSeeked);
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlayThrough);
      source.removeEventListener("error", this._onError, true);
      source.pause();
      source.src = "";
      source.load();
    }
    super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value) {
    if (value !== this._autoUpdate) {
      this._autoUpdate = value;
      this._configureAutoUpdate();
    }
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value) {
    if (value !== this._updateFPS) {
      this._updateFPS = value;
      this._configureAutoUpdate();
    }
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    if (this._autoUpdate && this._isSourcePlaying()) {
      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.updateFrame, this);
          this._isConnectedToTicker = false;
          this._msToNextUpdate = 0;
        }
        if (this._videoFrameRequestCallbackHandle === null) {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      } else {
        if (this._videoFrameRequestCallbackHandle !== null) {
          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
          this._videoFrameRequestCallbackHandle = null;
        }
        if (!this._isConnectedToTicker) {
          Ticker.shared.add(this.updateFrame, this);
          this._isConnectedToTicker = true;
          this._msToNextUpdate = 0;
        }
      }
    } else {
      if (this._videoFrameRequestCallbackHandle !== null) {
        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
        this._videoFrameRequestCallbackHandle = null;
      }
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.updateFrame, this);
        this._isConnectedToTicker = false;
        this._msToNextUpdate = 0;
      }
    }
  }
  static test(resource) {
    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
  }
};
_VideoSource.extension = ExtensionType.TextureSource;
/** The default options for video sources. */
_VideoSource.defaultOptions = {
  ...TextureSource.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: true,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: true,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: true,
  /** If true, the video will loop when it ends. */
  loop: false,
  /** If true, the video will be muted. */
  muted: true,
  /** If true, the video will play inline. */
  playsinline: true,
  /** If true, the video will be preloaded. */
  preload: false
};
/**
 * Map of video MIME types that can't be directly derived from file extensions.
 * @readonly
 */
_VideoSource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let VideoSource = _VideoSource;

const convertToList = (input, transform, forceTransform = false) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string" || forceTransform) {
      return transform(item);
    }
    return item;
  });
};

class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(key) {
    return this._cache.has(key);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(key) {
    const result = this._cache.get(key);
    if (!result) {
      warn$2(`[Assets] Asset id ${key} was not found in the Cache`);
    }
    return result;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(key, value) {
    const keys = convertToList(key);
    let cacheableAssets;
    for (let i = 0; i < this.parsers.length; i++) {
      const parser = this.parsers[i];
      if (parser.test(value)) {
        cacheableAssets = parser.getCacheableAssets(keys, value);
        break;
      }
    }
    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
    if (!cacheableAssets) {
      keys.forEach((key2) => {
        cacheableMap.set(key2, value);
      });
    }
    const cacheKeys = [...cacheableMap.keys()];
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key2) => {
      this._cacheMap.set(key2, cachedAssets);
    });
    cacheKeys.forEach((key2) => {
      const val = cacheableAssets ? cacheableAssets[key2] : value;
      if (this._cache.has(key2) && this._cache.get(key2) !== val) {
        warn$2("[Cache] already has key:", key2);
      }
      this._cache.set(key2, cacheableMap.get(key2));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(key) {
    if (!this._cacheMap.has(key)) {
      warn$2(`[Assets] Asset id ${key} was not found in the Cache`);
      return;
    }
    const cacheMap = this._cacheMap.get(key);
    const cacheKeys = cacheMap.cacheKeys;
    cacheKeys.forEach((key2) => {
      this._cache.delete(key2);
    });
    cacheMap.keys.forEach((key2) => {
      this._cacheMap.delete(key2);
    });
  }
  /**
   * All loader parsers registered
   * @advanced
   */
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();

const sources = [];
extensions.handleByList(ExtensionType.TextureSource, sources);
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i = 0; i < sources.length; i++) {
    const Source = sources[i];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id, skipCache = false) {
  if (typeof id === "string") {
    return Cache.get(id);
  } else if (id instanceof TextureSource) {
    return new Texture({ source: id });
  }
  return resourceToTexture(id, skipCache);
}
Texture.from = textureFrom;
TextureSource.from = textureSourceFrom;

extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);

var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});

function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i = 0; i <= path2.length; ++i) {
    if (i < path2.length) {
      code = path2.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) ; else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i)}`;
        } else {
          res = path2.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   * @example
   * ```ts
   * // Convert a Windows path to POSIX format
   * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
   * // -> 'C:/Users/User/Documents/file.txt'
   * ```
   */
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a URL
   * path.isUrl('http://www.example.com');
   * // -> true
   * path.isUrl('C:/Users/User/Documents/file.txt');
   * // -> false
   * ```
   */
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a data URL
   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
   * // -> true
   * ```
   */
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a blob URL
   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
   * // -> true
   * ```
   */
  isBlobUrl(path2) {
    return path2.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path has a protocol
   * path.hasProtocol('http://www.example.com');
   * // -> true
   * path.hasProtocol('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   * @example
   * ```ts
   * // Get the protocol from a URL
   * path.getProtocol('http://www.example.com/path/to/resource');
   * // -> 'http://'
   * // Get the protocol from a file path
   * path.getProtocol('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    if (matchFile) {
      return matchFile[0];
    }
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
    if (matchProtocol) {
      return matchProtocol[0];
    }
    return "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   * @example
   * ```ts
   * // Convert a relative URL to an absolute path
   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
   * // -> 'http://example.com/assets/images/texture.png'
   * ```
   */
  toAbsolute(url, customBaseUrl, customRootUrl) {
    assertPath(url);
    if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   * @example
   * ```ts
   * // Normalize a path with relative segments
   * path.normalize('http://www.example.com/foo/bar/../baz');
   * // -> 'http://www.example.com/foo/baz'
   * // Normalize a file path with relative segments
   * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
   * // -> 'C:/Users/User/file.txt'
   * ```
   */
  normalize(path2) {
    assertPath(path2);
    if (path2.length === 0) return ".";
    if (this.isDataUrl(path2) || this.isBlobUrl(path2)) return path2;
    path2 = this.toPosix(path2);
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2);
    if (path2.length > 0 && trailingSeparator) path2 += "/";
    if (isAbsolute) return `/${path2}`;
    return protocol + path2;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   * @example
   * ```ts
   * // Check if a path is absolute
   * path.isAbsolute('http://www.example.com/foo/bar');
   * // -> true
   * path.isAbsolute('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2)) return true;
    return path2.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   * @example
   * ```ts
   * // Join multiple path segments
   * path.join('assets', 'images', 'sprite.png');
   * // -> 'assets/images/sprite.png'
   * // Join with relative segments
   * path.join('assets', 'images', '../textures', 'sprite.png');
   * // -> 'assets/textures/sprite.png'
   * ```
   */
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0) joined = arg;
        else {
          const prevArg = segments[i - 1] ?? "";
          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the directory name of a path
   * path.dirname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/foo/bar'
   * // Get the directory name of a file path
   * path.dirname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/Users/User/Documents'
   * ```
   */
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0) return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; i >= 1; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1) return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1) return "//";
    return proto + path2.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the root of a URL
   * path.rootname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/'
   * // Get the root of a file path
   * path.rootname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/")) root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else root = path2;
      if (!root.endsWith("/")) root += "/";
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   * @example
   * ```ts
   * // Get the basename of a URL
   * path.basename('http://www.example.com/foo/bar/baz.png');
   * // -> 'baz.png'
   * // Get the basename of a file path
   * path.basename('C:/Users/User/Documents/file.txt');
   * // -> 'file.txt'
   * ```
   */
  basename(path2, ext) {
    assertPath(path2);
    if (ext) assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2) return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path2.length - 1; i >= 0; --i) {
        const code = path2.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) end = firstNonSlashEnd;
      else if (end === -1) end = path2.length;
      return path2.slice(start, end);
    }
    for (i = path2.length - 1; i >= 0; --i) {
      if (path2.charCodeAt(i) === 47) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
    }
    if (end === -1) return "";
    return path2.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the extension of a URL
   * path.extname('http://www.example.com/foo/bar/baz.png');
   * // -> '.png'
   * // Get the extension of a file path
   * path.extname('C:/Users/User/Documents/file.txt');
   * // -> '.txt'
   * ```
   */
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path2.length - 1; i >= 0; --i) {
      const code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) startDot = i;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Parse a URL
   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
   * // -> {
   * //   root: 'http://www.example.com/',
   * //   dir: 'http://www.example.com/foo/bar',
   * //   base: 'baz.png',
   * //   ext: '.png',
   * //   name: 'baz'
   * // }
   * // Parse a file path
   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
   * // -> {
   * //   root: 'C:/',
   * //   dir: 'C:/Users/User/Documents',
   * //   base: 'file.txt',
   * //   ext: '.txt',
   * //   name: 'file'
   * // }
   * ```
   */
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0) return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path2.length - 1;
    let preDotState = 0;
    for (; i >= start; --i) {
      code = path2.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) startDot = i;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path2.slice(1, end);
        else ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    return ret;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};

function processX(base, ids, depth, result, tags) {
  const id = ids[depth];
  for (let i = 0; i < id.length; i++) {
    const value = id[i];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}

const isSingleItem = (item) => !Array.isArray(item);

class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    /**
     * A function that generates a bundle asset id key from a bundleId and an assetId
     * @param bundleId - the bundleId
     * @param assetId  - the assetId
     * @returns the bundle asset id key
     */
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    /**
     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId
     * @param bundleId - the bundleId
     * @param assetBundleId - the bundle asset id key
     * @returns the assetId
     */
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, src } = asset;
    const aliasesToUse = convertToList(
      alias || src,
      (value) => {
        if (typeof value === "string") return value;
        if (Array.isArray(value)) return value.map((v) => v?.src ?? v);
        if (value?.src) return value.src;
        return value;
      },
      true
    );
    return aliasesToUse;
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    if (this._manifest) {
      warn$2("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    let convertedAssets = assets;
    if (!Array.isArray(assets)) {
      convertedAssets = Object.entries(assets).map(([alias, src]) => {
        if (typeof src === "string" || Array.isArray(src)) {
          return { alias, src };
        }
        return { alias, ...src };
      });
    }
    convertedAssets.forEach((asset) => {
      const srcs = asset.src;
      const aliases = asset.alias;
      let ids;
      if (typeof aliases === "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId);
        ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
        assetNames.push(...bundleIds);
        ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        ...{
          alias: ids,
          src: srcs
        }
      });
    });
    this._bundles[bundleId] = assetNames;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    let keyCheck;
    keyCheck = (key) => {
      if (this.hasKey(key)) {
        warn$2(`[Resolver] already has key: ${key} overwriting`);
      }
    };
    const assetArray = convertToList(assets);
    assetArray.forEach((asset) => {
      const { src } = asset;
      let {
        data,
        format,
        loadParser: userDefinedLoadParser,
        parser: userDefinedParser
      } = asset;
      const srcsToUse = convertToList(src).map((src2) => {
        if (typeof src2 === "string") {
          return createStringVariations(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      const parseUrl = (url) => {
        const parser = this._parsers.find((p) => p.test(url));
        return {
          src: url,
          ...parser?.parse(url)
        };
      };
      srcsToUse.forEach((srcs) => {
        srcs.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset = parseUrl(src2);
          } else {
            data = src2.data ?? data;
            format = src2.format ?? format;
            if (src2.loadParser || src2.parser) {
              userDefinedLoadParser = src2.loadParser ?? userDefinedLoadParser;
              userDefinedParser = src2.parser ?? userDefinedParser;
            }
            formattedAsset = {
              ...parseUrl(src2.src),
              ...src2
            };
          }
          if (!aliasesToUse) {
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          }
          formattedAsset = this._buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format,
            loadParser: userDefinedLoadParser,
            parser: userDefinedParser,
            progressSize: asset.progressSize
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key in results) {
          const asset = results[key];
          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
        }
        out[bundleId] = assets;
      }
    });
    return singleAsset ? out[bundleIds[0]] : out;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key) {
    const result = this.resolve(key);
    if (typeof key !== "string") {
      const out = {};
      for (const i in result) {
        out[i] = result[i].src;
      }
      return out;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key) => {
      if (!this._resolverHash[key]) {
        if (this._assetMap[key]) {
          let assets = this._assetMap[key];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder?.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key] = assets[0];
        } else {
          this._resolverHash[key] = this._buildResolvedAsset({
            alias: [key],
            src: key
          }, {});
        }
      }
      result[key] = this._resolverHash[key];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key) {
    return !!this._assetMap[key];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key) {
    return !!this._bundles[key];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i = 0; i < assets.length; i++) {
      const asset = assets[i];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams) return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.parser = parser ?? formattedAsset.parser;
    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
    if (progressSize !== void 0) {
      formattedAsset.progressSize = progressSize;
    }
    return formattedAsset;
  }
}
/**
 * The prefix that denotes a URL is for a retina asset.
 * @default /@([0-9\.]+)x/
 * @example `@2x`
 */
Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}

const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};

const _Spritesheet = class _Spritesheet {
  constructor(optionsOrTexture, arg1) {
    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */
    this.linkedSheets = [];
    let options = optionsOrTexture;
    if (optionsOrTexture?.source instanceof TextureSource) {
      options = {
        texture: optionsOrTexture,
        data: arg1
      };
    }
    const { texture, data, cachePrefix = "" } = options;
    this.cachePrefix = cachePrefix;
    this._texture = texture instanceof Texture ? texture : null;
    this.textureSource = texture.source;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const metaResolution = parseFloat(data.meta.scale);
    if (metaResolution) {
      this.resolution = metaResolution;
      texture.source.resolution = this.resolution;
    } else {
      this.resolution = texture.source._resolution;
    }
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  /**
   * Parse spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  /**
   * Parse spritesheet from loaded data. This is done synchronously
   * and is only suitable for smaller spritesheets (less than ~1000 frames)
   * or may cause too many Texture within a single process. However, synchronous parsing may be
   * more convenient since the called does not need to be asynchronous and is safe for
   * small-to-medium sized spritesheets.
   *
   * Other than being synchronous, `parseSync` is otherwise identical to `.parse()`.
   */
  parseSync() {
    this._processFrames(0, true);
    this._processAnimations();
    return this.textures;
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   * @param processAll - if true will process all frames in a single batch, ignoring BATCH_SIZE - this
   * is used for synchronous parsing.
   */
  _processFrames(initialFrameIndex, processAll = false) {
    let frameIndex = initialFrameIndex;
    const maxFrames = processAll ? Infinity : _Spritesheet.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i = this._frameKeys[frameIndex];
      const data = this._frames[i];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(
          0,
          0,
          Math.floor(sourceSize.w) / this.resolution,
          Math.floor(sourceSize.h) / this.resolution
        );
        if (data.rotated) {
          frame = new Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.h) / this.resolution,
            Math.floor(rect.w) / this.resolution
          );
        } else {
          frame = new Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(
            Math.floor(data.spriteSourceSize.x) / this.resolution,
            Math.floor(data.spriteSourceSize.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        this.textures[i] = new Texture({
          source: this.textureSource,
          frame,
          orig,
          trim,
          rotate: data.rotated ? 2 : 0,
          defaultAnchor: data.anchor,
          defaultBorders: data.borders,
          label: i.toString()
        });
      }
      frameIndex++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i = 0; i < animations[animName].length; i++) {
        const frameName = animations[animName][i];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(destroyBase = false) {
    for (const i in this.textures) {
      this.textures[i].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      this._texture?.destroy();
      this.textureSource.destroy();
    }
    this._texture = null;
    this.textureSource = null;
    this.linkedSheets = [];
  }
};
/**
 * The maximum number of Textures to build per process.
 * @advanced
 */
_Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;

const validImages = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out = {};
  keys.forEach((key) => {
    out[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out[`${asset.cachePrefix}${key}`] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i) => {
      const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);
      Object.assign(out, out2);
    });
  }
  return out;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (asset) => asset instanceof Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: ExtensionType.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (value) => {
      const tempURL = value.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value) => {
      const split = value.split(".");
      return {
        resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
        format: split[split.length - 2],
        src: value
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    /** used for deprecation purposes */
    name: "spritesheetLoader",
    id: "spritesheet",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal,
      name: "spritesheetLoader"
    },
    async testParse(asset, options) {
      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      const {
        texture: imageTexture,
        // if user need to use preloaded texture
        imageFilename,
        // if user need to use custom filename (not from jsonFile.meta.image)
        textureOptions,
        // if user need to set texture options on texture
        cachePrefix
        // if user need to use custom cache prefix
      } = options?.data ?? {};
      let basePath = path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let texture;
      if (imageTexture instanceof Texture) {
        texture = imageTexture;
      } else {
        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
        texture = assets[imagePath];
      }
      const spritesheet = new Spritesheet({
        texture: texture.source,
        data: asset,
        cachePrefix
      });
      await spritesheet.parse();
      const multiPacks = asset?.meta?.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if (options.data?.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              textureOptions,
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    async unload(spritesheet, _resolvedAsset, loader) {
      await loader.unload(spritesheet.textureSource._sourceOrigin);
      spritesheet.destroy(false);
    }
  }
};

extensions.add(spritesheetAsset);

class CanvasObserver {
  constructor(options) {
    /** A cached value of the last transform applied to the DOM element. */
    this._lastTransform = "";
    /** A ResizeObserver instance to observe changes in the canvas size. */
    this._observer = null;
    /** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */
    this._tickerAttached = false;
    /**
     * Updates the transform of the DOM element based on the canvas size and position.
     * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.
     */
    this.updateTranslation = () => {
      if (!this._canvas) return;
      const rect = this._canvas.getBoundingClientRect();
      const contentWidth = this._canvas.width;
      const contentHeight = this._canvas.height;
      const sx = rect.width / contentWidth * this._renderer.resolution;
      const sy = rect.height / contentHeight * this._renderer.resolution;
      const tx = rect.left;
      const ty = rect.top;
      const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;
      if (newTransform !== this._lastTransform) {
        this._domElement.style.transform = newTransform;
        this._lastTransform = newTransform;
      }
    };
    this._domElement = options.domElement;
    this._renderer = options.renderer;
    if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) return;
    this._canvas = this._renderer.canvas;
    this._attachObserver();
  }
  /** The canvas element that this CanvasObserver is associated with. */
  get canvas() {
    return this._canvas;
  }
  /** Attaches the DOM element to the canvas parent if it is not already attached. */
  ensureAttached() {
    if (!this._domElement.parentNode && this._canvas.parentNode) {
      this._canvas.parentNode.appendChild(this._domElement);
      this.updateTranslation();
    }
  }
  /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */
  _attachObserver() {
    if ("ResizeObserver" in globalThis) {
      if (this._observer) {
        this._observer.disconnect();
        this._observer = null;
      }
      this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.target !== this._canvas) {
            continue;
          }
          const contentWidth = this.canvas.width;
          const contentHeight = this.canvas.height;
          const sx = entry.contentRect.width / contentWidth * this._renderer.resolution;
          const sy = entry.contentRect.height / contentHeight * this._renderer.resolution;
          const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;
          if (needsUpdate) {
            this.updateTranslation();
            this._lastScaleX = sx;
            this._lastScaleY = sy;
          }
        }
      });
      this._observer.observe(this._canvas);
    } else if (!this._tickerAttached) {
      Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);
    }
  }
  /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */
  destroy() {
    if (this._observer) {
      this._observer.disconnect();
      this._observer = null;
    } else if (this._tickerAttached) {
      Ticker.shared.remove(this.updateTranslation);
    }
    this._domElement = null;
    this._renderer = null;
    this._canvas = null;
    this._tickerAttached = false;
    this._lastTransform = "";
    this._lastScaleX = null;
    this._lastScaleY = null;
  }
}

class FederatedEvent {
  /**
   * @param manager - The event boundary which manages this event. Propagation can only occur
   *  within the boundary's jurisdiction.
   */
  constructor(manager) {
    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */
    this.bubbles = true;
    /** @deprecated since 7.0.0 */
    this.cancelBubble = true;
    /**
     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always
     * false (for now).
     */
    this.cancelable = false;
    /**
     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events
     * API.
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     * @ignore
     */
    this.composed = false;
    /** Flags whether the default response of the user agent was prevent through this event. */
    this.defaultPrevented = false;
    /**
     * The propagation phase.
     * @default {@link FederatedEvent.NONE}
     */
    this.eventPhase = FederatedEvent.prototype.NONE;
    /** Flags whether propagation was stopped. */
    this.propagationStopped = false;
    /** Flags whether propagation was immediately stopped. */
    this.propagationImmediatelyStopped = false;
    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */
    this.layer = new Point();
    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */
    this.page = new Point();
    /**
     * The event propagation phase NONE that indicates that the event is not in any phase.
     * @default 0
     * @advanced
     */
    this.NONE = 0;
    /**
     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.
     * @default 1
     * @advanced
     */
    this.CAPTURING_PHASE = 1;
    /**
     * The event propagation phase AT_TARGET that indicates that the event is at the target.
     * @default 2
     * @advanced
     */
    this.AT_TARGET = 2;
    /**
     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.
     * @default 3
     * @advanced
     */
    this.BUBBLING_PHASE = 3;
    this.manager = manager;
  }
  /** @readonly */
  get layerX() {
    return this.layer.x;
  }
  /** @readonly */
  get layerY() {
    return this.layer.y;
  }
  /** @readonly */
  get pageX() {
    return this.page.x;
  }
  /** @readonly */
  get pageY() {
    return this.page.y;
  }
  /**
   * Fallback for the deprecated `InteractionEvent.data`.
   * @deprecated since 7.0.0
   */
  get data() {
    return this;
  }
  /**
   * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
   * @advanced
   */
  composedPath() {
    if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
      this.path = this.target ? this.manager.propagationPath(this.target) : [];
    }
    return this.path;
  }
  /**
   * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.
   * @deprecated
   * @ignore
   * @param _type
   * @param _bubbles
   * @param _cancelable
   */
  initEvent(_type, _bubbles, _cancelable) {
    throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.
   * @ignore
   * @deprecated
   * @param _typeArg
   * @param _bubblesArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   */
  initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
    throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
  }
  /**
   * Prevent default behavior of both PixiJS and the user agent.
   * @example
   * ```ts
   * sprite.on('click', (event) => {
   *     // Prevent both browser's default click behavior
   *     // and PixiJS's default handling
   *     event.preventDefault();
   *
   *     // Custom handling
   *     customClickHandler();
   * });
   * ```
   * @remarks
   * - Only works if the native event is cancelable
   * - Does not stop event propagation
   */
  preventDefault() {
    if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
      this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = true;
  }
  /**
   * Stop this event from propagating to any additional listeners, including those
   * on the current target and any following targets in the propagation path.
   * @example
   * ```ts
   * container.on('pointerdown', (event) => {
   *     // Stop all further event handling
   *     event.stopImmediatePropagation();
   *
   *     // These handlers won't be called:
   *     // - Other pointerdown listeners on this container
   *     // - Any pointerdown listeners on parent containers
   * });
   * ```
   * @remarks
   * - Immediately stops all event propagation
   * - Prevents other listeners on same target from being called
   * - More aggressive than stopPropagation()
   */
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  /**
   * Stop this event from propagating to the next target in the propagation path.
   * The rest of the listeners on the current target will still be notified.
   * @example
   * ```ts
   * child.on('pointermove', (event) => {
   *     // Handle event on child
   *     updateChild();
   *
   *     // Prevent parent handlers from being called
   *     event.stopPropagation();
   * });
   *
   * // This won't be called if child handles the event
   * parent.on('pointermove', (event) => {
   *     updateParent();
   * });
   * ```
   * @remarks
   * - Stops event bubbling to parent containers
   * - Does not prevent other listeners on same target
   * - Less aggressive than stopImmediatePropagation()
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}

var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = function (navigator) {
    return (typeof navigator !== 'undefined' &&
        navigator.platform === 'MacIntel' &&
        typeof navigator.maxTouchPoints === 'number' &&
        navigator.maxTouchPoints > 1 &&
        typeof MSStream === 'undefined');
};
function createMatch(userAgent) {
    return function (regex) { return regex.test(userAgent); };
}
function isMobile$1(param) {
    var nav = {
        userAgent: '',
        platform: '',
        maxTouchPoints: 0
    };
    if (!param && typeof navigator !== 'undefined') {
        nav = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        };
    }
    else if (typeof param === 'string') {
        nav.userAgent = param;
    }
    else if (param && param.userAgent) {
        nav = {
            userAgent: param.userAgent,
            platform: param.platform,
            maxTouchPoints: param.maxTouchPoints || 0
        };
    }
    var userAgent = nav.userAgent;
    var tmp = userAgent.split('[FBAN');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    tmp = userAgent.split('Twitter');
    if (typeof tmp[1] !== 'undefined') {
        userAgent = tmp[0];
    }
    var match = createMatch(userAgent);
    var result = {
        apple: {
            phone: match(appleIphone) && !match(windowsPhone),
            ipod: match(appleIpod),
            tablet: !match(appleIphone) &&
                (match(appleTablet) || isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone),
            universal: match(appleUniversal),
            device: (match(appleIphone) ||
                match(appleIpod) ||
                match(appleTablet) ||
                match(appleUniversal) ||
                isAppleTabletOnIos13(nav)) &&
                !match(windowsPhone)
        },
        amazon: {
            phone: match(amazonPhone),
            tablet: !match(amazonPhone) && match(amazonTablet),
            device: match(amazonPhone) || match(amazonTablet)
        },
        android: {
            phone: (!match(windowsPhone) && match(amazonPhone)) ||
                (!match(windowsPhone) && match(androidPhone)),
            tablet: !match(windowsPhone) &&
                !match(amazonPhone) &&
                !match(androidPhone) &&
                (match(amazonTablet) || match(androidTablet)),
            device: (!match(windowsPhone) &&
                (match(amazonPhone) ||
                    match(amazonTablet) ||
                    match(androidPhone) ||
                    match(androidTablet))) ||
                match(/\bokhttp\b/i)
        },
        windows: {
            phone: match(windowsPhone),
            tablet: match(windowsTablet),
            device: match(windowsPhone) || match(windowsTablet)
        },
        other: {
            blackberry: match(otherBlackBerry),
            blackberry10: match(otherBlackBerry10),
            opera: match(otherOpera),
            firefox: match(otherFirefox),
            chrome: match(otherChrome),
            device: match(otherBlackBerry) ||
                match(otherBlackBerry10) ||
                match(otherOpera) ||
                match(otherFirefox) ||
                match(otherChrome)
        },
        any: false,
        phone: false,
        tablet: false
    };
    result.any =
        result.apple.device ||
            result.android.device ||
            result.windows.device ||
            result.other.device;
    result.phone =
        result.apple.phone || result.android.phone || result.windows.phone;
    result.tablet =
        result.apple.tablet || result.android.tablet || result.windows.tablet;
    return result;
}

const isMobileCall = isMobile$1.default ?? isMobile$1;
const isMobile = isMobileCall(globalThis.navigator);

const KEY_CODE_TAB = 9;
const DIV_TOUCH_SIZE = 100;
const DIV_TOUCH_POS_X = 0;
const DIV_TOUCH_POS_Y = 0;
const DIV_TOUCH_ZINDEX = 2;
const DIV_HOOK_SIZE = 1;
const DIV_HOOK_POS_X = -1e3;
const DIV_HOOK_POS_Y = -1e3;
const DIV_HOOK_ZINDEX = 2;
const _AccessibilitySystem = class _AccessibilitySystem {
  // eslint-disable-next-line jsdoc/require-param
  /**
   * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
   */
  constructor(renderer, _mobileInfo = isMobile) {
    this._mobileInfo = _mobileInfo;
    /** Whether accessibility divs are visible for debugging */
    this.debug = false;
    /** Whether to activate on tab key press */
    this._activateOnTab = true;
    /** Whether to deactivate accessibility when mouse moves */
    this._deactivateOnMouseMove = true;
    /** Internal variable, see isActive getter. */
    this._isActive = false;
    /** Internal variable, see isMobileAccessibility getter. */
    this._isMobileAccessibility = false;
    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */
    this._div = null;
    /** A simple pool for storing divs. */
    this._pools = {};
    /** This is a tick used to check if an object is no longer being rendered. */
    this._renderId = 0;
    /** The array of currently active accessible items. */
    this._children = [];
    /** Count to throttle div updates on android devices. */
    this._androidUpdateCount = 0;
    /**  The frequency to update the div elements. */
    this._androidUpdateFrequency = 500;
    // eslint-disable-next-line @typescript-eslint/prefer-readonly
    this._isRunningTests = false;
    /** Bound function references for proper event listener removal */
    this._boundOnKeyDown = this._onKeyDown.bind(this);
    this._boundOnMouseMove = this._onMouseMove.bind(this);
    this._hookDiv = null;
    if (_mobileInfo.tablet || _mobileInfo.phone) {
      this._createTouchHook();
    }
    this._renderer = renderer;
  }
  /**
   * Value of `true` if accessibility is currently active and accessibility layers are showing.
   * @type {boolean}
   * @readonly
   */
  get isActive() {
    return this._isActive;
  }
  /**
   * Value of `true` if accessibility is enabled for touch devices.
   * @type {boolean}
   * @readonly
   */
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  /**
   * Button element for handling touch hooks.
   * @readonly
   */
  get hookDiv() {
    return this._hookDiv;
  }
  /**
   * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.
   * @readonly
   */
  get div() {
    return this._div;
  }
  /**
   * Creates the touch hooks.
   * @private
   */
  _createTouchHook() {
    const hookDiv = document.createElement("button");
    hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
    hookDiv.style.position = "absolute";
    hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
    hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
    hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
    hookDiv.style.backgroundColor = "#FF0000";
    hookDiv.title = "select to enable accessibility for this content";
    hookDiv.addEventListener("focus", () => {
      this._isMobileAccessibility = true;
      this._activate();
      this._destroyTouchHook();
    });
    document.body.appendChild(hookDiv);
    this._hookDiv = hookDiv;
  }
  /**
   * Destroys the touch hooks.
   * @private
   */
  _destroyTouchHook() {
    if (!this._hookDiv) {
      return;
    }
    document.body.removeChild(this._hookDiv);
    this._hookDiv = null;
  }
  /**
   * Activating will cause the Accessibility layer to be shown.
   * This is called when a user presses the tab key.
   * @private
   */
  _activate() {
    if (this._isActive) {
      return;
    }
    this._isActive = true;
    if (!this._div) {
      this._div = document.createElement("div");
      this._div.style.position = "absolute";
      this._div.style.top = `${DIV_TOUCH_POS_X}px`;
      this._div.style.left = `${DIV_TOUCH_POS_Y}px`;
      this._div.style.pointerEvents = "none";
      this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      this._canvasObserver = new CanvasObserver({
        domElement: this._div,
        renderer: this._renderer
      });
    }
    if (this._activateOnTab) {
      globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
    }
    if (this._deactivateOnMouseMove) {
      globalThis.document.addEventListener("mousemove", this._boundOnMouseMove, true);
    }
    const canvas = this._renderer.view.canvas;
    if (!canvas.parentNode) {
      const observer = new MutationObserver(() => {
        if (canvas.parentNode) {
          observer.disconnect();
          this._canvasObserver.ensureAttached();
          this._initAccessibilitySetup();
        }
      });
      observer.observe(document.body, { childList: true, subtree: true });
    } else {
      this._canvasObserver.ensureAttached();
      this._initAccessibilitySetup();
    }
  }
  // New method to handle initialization after div is ready
  _initAccessibilitySetup() {
    this._renderer.runners.postrender.add(this);
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
    }
  }
  /**
   * Deactivates the accessibility system. Removes listeners and accessibility elements.
   * @private
   */
  _deactivate() {
    if (!this._isActive || this._isMobileAccessibility) {
      return;
    }
    this._isActive = false;
    globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
    if (this._activateOnTab) {
      globalThis.addEventListener("keydown", this._boundOnKeyDown, false);
    }
    this._renderer.runners.postrender.remove(this);
    for (const child of this._children) {
      if (child._accessibleDiv?.parentNode) {
        child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
        child._accessibleDiv = null;
      }
      child._accessibleActive = false;
    }
    for (const accessibleType in this._pools) {
      const pool = this._pools[accessibleType];
      pool.forEach((div) => {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
      });
      delete this._pools[accessibleType];
    }
    if (this._div?.parentNode) {
      this._div.parentNode.removeChild(this._div);
    }
    this._pools = {};
    this._children = [];
  }
  /**
   * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
   * @private
   * @param {Container} container - The Container to check.
   */
  _updateAccessibleObjects(container) {
    if (!container.visible || !container.accessibleChildren) {
      return;
    }
    if (container.accessible) {
      if (!container._accessibleActive) {
        this._addChild(container);
      }
      container._renderId = this._renderId;
    }
    const children = container.children;
    if (children) {
      for (let i = 0; i < children.length; i++) {
        this._updateAccessibleObjects(children[i]);
      }
    }
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const defaultOpts = _AccessibilitySystem.defaultOptions;
    const mergedOptions = {
      accessibilityOptions: {
        ...defaultOpts,
        ...options?.accessibilityOptions || {}
      }
    };
    this.debug = mergedOptions.accessibilityOptions.debug;
    this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;
    this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;
    if (mergedOptions.accessibilityOptions.enabledByDefault) {
      this._activate();
    }
    this._renderer.runners.postrender.remove(this);
  }
  /**
   * Updates the accessibility layer during rendering.
   * - Removes divs for containers no longer in the scene
   * - Updates the position and dimensions of the root div
   * - Updates positions of active accessibility divs
   * Only fires while the accessibility system is active.
   * @ignore
   */
  postrender() {
    const now = performance.now();
    if (this._mobileInfo.android.device && now < this._androidUpdateCount) {
      return;
    }
    this._androidUpdateCount = now + this._androidUpdateFrequency;
    if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas) && !this._isRunningTests) {
      return;
    }
    const activeIds = /* @__PURE__ */ new Set();
    if (this._renderer.lastObjectRendered) {
      this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      for (const child of this._children) {
        if (child._renderId === this._renderId) {
          activeIds.add(this._children.indexOf(child));
        }
      }
    }
    for (let i = this._children.length - 1; i >= 0; i--) {
      const child = this._children[i];
      if (!activeIds.has(i)) {
        if (child._accessibleDiv && child._accessibleDiv.parentNode) {
          child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);
          const pool = this._getPool(child.accessibleType);
          pool.push(child._accessibleDiv);
          child._accessibleDiv = null;
        }
        child._accessibleActive = false;
        removeItems(this._children, i, 1);
      }
    }
    if (this._renderer.renderingToScreen) {
      this._canvasObserver.ensureAttached();
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      if (!child._accessibleActive || !child._accessibleDiv) {
        continue;
      }
      const div = child._accessibleDiv;
      const hitArea = child.hitArea || child.getBounds().rectangle;
      if (child.hitArea) {
        const wt = child.worldTransform;
        div.style.left = `${wt.tx + hitArea.x * wt.a}px`;
        div.style.top = `${wt.ty + hitArea.y * wt.d}px`;
        div.style.width = `${hitArea.width * wt.a}px`;
        div.style.height = `${hitArea.height * wt.d}px`;
      } else {
        this._capHitArea(hitArea);
        div.style.left = `${hitArea.x}px`;
        div.style.top = `${hitArea.y}px`;
        div.style.width = `${hitArea.width}px`;
        div.style.height = `${hitArea.height}px`;
      }
    }
    this._renderId++;
  }
  /**
   * private function that will visually add the information to the
   * accessibility div
   * @param {HTMLElement} div -
   */
  _updateDebugHTML(div) {
    div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
  }
  /**
   * Adjust the hit area based on the bounds of a display object
   * @param {Rectangle} hitArea - Bounds of the child
   */
  _capHitArea(hitArea) {
    if (hitArea.x < 0) {
      hitArea.width += hitArea.x;
      hitArea.x = 0;
    }
    if (hitArea.y < 0) {
      hitArea.height += hitArea.y;
      hitArea.y = 0;
    }
    const { width: viewWidth, height: viewHeight } = this._renderer;
    if (hitArea.x + hitArea.width > viewWidth) {
      hitArea.width = viewWidth - hitArea.x;
    }
    if (hitArea.y + hitArea.height > viewHeight) {
      hitArea.height = viewHeight - hitArea.y;
    }
  }
  /**
   * Creates or reuses a div element for a Container and adds it to the accessibility layer.
   * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.
   * @private
   * @param {Container} container - The child to make accessible.
   */
  _addChild(container) {
    const pool = this._getPool(container.accessibleType);
    let div = pool.pop();
    if (div) {
      div.innerHTML = "";
      div.removeAttribute("title");
      div.removeAttribute("aria-label");
      div.tabIndex = 0;
    } else {
      if (container.accessibleType === "button") {
        div = document.createElement("button");
      } else {
        div = document.createElement(container.accessibleType);
        div.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `;
        if (container.accessibleText) {
          div.innerText = container.accessibleText;
        }
      }
      div.style.width = `${DIV_TOUCH_SIZE}px`;
      div.style.height = `${DIV_TOUCH_SIZE}px`;
      div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
      div.style.position = "absolute";
      div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
      div.style.borderStyle = "none";
      if (navigator.userAgent.toLowerCase().includes("chrome")) {
        div.setAttribute("aria-live", "off");
      } else {
        div.setAttribute("aria-live", "polite");
      }
      if (navigator.userAgent.match(/rv:.*Gecko\//)) {
        div.setAttribute("aria-relevant", "additions");
      } else {
        div.setAttribute("aria-relevant", "text");
      }
      div.addEventListener("click", this._onClick.bind(this));
      div.addEventListener("focus", this._onFocus.bind(this));
      div.addEventListener("focusout", this._onFocusOut.bind(this));
    }
    div.style.pointerEvents = container.accessiblePointerEvents;
    div.type = container.accessibleType;
    if (container.accessibleTitle && container.accessibleTitle !== null) {
      div.title = container.accessibleTitle;
    } else if (!container.accessibleHint || container.accessibleHint === null) {
      div.title = `container ${container.tabIndex}`;
    }
    if (container.accessibleHint && container.accessibleHint !== null) {
      div.setAttribute("aria-label", container.accessibleHint);
    }
    if (container.interactive) {
      div.tabIndex = container.tabIndex;
    } else {
      div.tabIndex = 0;
    }
    if (this.debug) {
      this._updateDebugHTML(div);
    }
    container._accessibleActive = true;
    container._accessibleDiv = div;
    div.container = container;
    this._children.push(container);
    this._div.appendChild(container._accessibleDiv);
  }
  /**
   * Dispatch events with the EventSystem.
   * @param e
   * @param type
   * @private
   */
  _dispatchEvent(e, type) {
    const { container: target } = e.target;
    const boundary = this._renderer.events.rootBoundary;
    const event = Object.assign(new FederatedEvent(boundary), { target });
    boundary.rootTarget = this._renderer.lastObjectRendered;
    type.forEach((type2) => boundary.dispatchEvent(event, type2));
  }
  /**
   * Maps the div button press to pixi's EventSystem (click)
   * @private
   * @param {MouseEvent} e - The click event.
   */
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseover)
   * @private
   * @param {FocusEvent} e - The focus event.
   */
  _onFocus(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "assertive");
    }
    this._dispatchEvent(e, ["mouseover"]);
  }
  /**
   * Maps the div focus events to pixi's EventSystem (mouseout)
   * @private
   * @param {FocusEvent} e - The focusout event.
   */
  _onFocusOut(e) {
    if (!e.target.getAttribute("aria-live")) {
      e.target.setAttribute("aria-live", "polite");
    }
    this._dispatchEvent(e, ["mouseout"]);
  }
  /**
   * Is called when a key is pressed
   * @private
   * @param {KeyboardEvent} e - The keydown event.
   */
  _onKeyDown(e) {
    if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab) {
      return;
    }
    this._activate();
  }
  /**
   * Is called when the mouse moves across the renderer element
   * @private
   * @param {MouseEvent} e - The mouse event.
   */
  _onMouseMove(e) {
    if (e.movementX === 0 && e.movementY === 0) {
      return;
    }
    this._deactivate();
  }
  /**
   * Destroys the accessibility system. Removes all elements and listeners.
   * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.
   * > A typically user should not need to call this method directly.
   */
  destroy() {
    this._deactivate();
    this._destroyTouchHook();
    this._canvasObserver?.destroy();
    this._canvasObserver = null;
    this._div = null;
    this._pools = null;
    this._children = null;
    this._renderer = null;
    this._hookDiv = null;
    globalThis.removeEventListener("keydown", this._boundOnKeyDown);
    this._boundOnKeyDown = null;
    globalThis.document.removeEventListener("mousemove", this._boundOnMouseMove, true);
    this._boundOnMouseMove = null;
  }
  /**
   * Enables or disables the accessibility system.
   * @param enabled - Whether to enable or disable accessibility.
   * @example
   * ```js
   * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility
   * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility
   * ```
   */
  setAccessibilityEnabled(enabled) {
    if (enabled) {
      this._activate();
    } else {
      this._deactivate();
    }
  }
  _getPool(accessibleType) {
    if (!this._pools[accessibleType]) {
      this._pools[accessibleType] = [];
    }
    return this._pools[accessibleType];
  }
};
/** @ignore */
_AccessibilitySystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "accessibility"
};
/**
 * The default options used by the system.
 * You can set these before initializing the {@link Application} to change the default behavior.
 * @example
 * ```js
 * import { AccessibilitySystem } from 'pixi.js';
 *
 * AccessibilitySystem.defaultOptions.enabledByDefault = true;
 *
 * const app = new Application()
 * app.init()
 * ```
 */
_AccessibilitySystem.defaultOptions = {
  /**
   * Whether to enable accessibility features on initialization
   * @default false
   */
  enabledByDefault: false,
  /**
   * Whether to visually show the accessibility divs for debugging
   * @default false
   */
  debug: false,
  /**
   * Whether to activate accessibility when tab key is pressed
   * @default true
   */
  activateOnTab: true,
  /**
   * Whether to deactivate accessibility when mouse moves
   * @default true
   */
  deactivateOnMouseMove: true
};
let AccessibilitySystem = _AccessibilitySystem;

const accessibilityTarget = {
  accessible: false,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  accessibleType: "button",
  accessibleText: null,
  accessiblePointerEvents: "auto",
  accessibleChildren: true,
  _accessibleActive: false,
  _accessibleDiv: null,
  _renderId: -1
};

const idCounts = /* @__PURE__ */ Object.create(null);
const idHash = /* @__PURE__ */ Object.create(null);
function createIdFromString(value, groupId) {
  let id = idHash[value];
  if (id === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value] = id = idCounts[groupId]++;
  }
  return id;
}

let context;
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}

let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}

function addProgramDefines(src, isES300, isFragment) {
  if (isES300) return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}

function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}

function insertVersion(src, isES300) {
  if (!isES300) return src;
  return `#version 300 es
${src}`;
}

const fragmentNameCache = {};
const VertexNameCache = {};
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1) return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}

function stripVersion(src, isES300) {
  if (!isES300) return src;
  return src.replace("#version 300 es", "");
}

const processes = {
  // strips any version headers..
  stripVersion,
  // adds precision string if not already present
  ensurePrecision,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines,
  // add the program name to the shader
  setProgramName,
  // add the version string to the shader header
  insertVersion
};
const programCache$1 = /* @__PURE__ */ Object.create(null);
const _GlProgram = class _GlProgram {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(options) {
    options = { ..._GlProgram.defaultOptions, ...options };
    const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
    const preprocessorOptions = {
      stripVersion: isES300,
      ensurePrecision: {
        requestedFragmentPrecision: options.preferredFragmentPrecision,
        requestedVertexPrecision: options.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: getMaxFragmentPrecision()
      },
      setProgramName: {
        name: options.name
      },
      addProgramDefines: isES300,
      insertVersion: isES300
    };
    let fragment = options.fragment;
    let vertex = options.vertex;
    Object.keys(processes).forEach((processKey) => {
      const processOptions = preprocessorOptions[processKey];
      fragment = processes[processKey](fragment, processOptions, true);
      vertex = processes[processKey](vertex, processOptions, false);
    });
    this.fragment = fragment;
    this.vertex = vertex;
    this.transformFeedbackVaryings = options.transformFeedbackVaryings;
    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null;
    this.vertex = null;
    this._attributeData = null;
    this._uniformData = null;
    this._uniformBlockData = null;
    this.transformFeedbackVaryings = null;
    programCache$1[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key = `${options.vertex}:${options.fragment}`;
    if (!programCache$1[key]) {
      programCache$1[key] = new _GlProgram(options);
      programCache$1[key]._cacheKey = key;
    }
    return programCache$1[key];
  }
};
/** The default options used by the program. */
_GlProgram.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let GlProgram = _GlProgram;

const attributeFormatData = {
  uint8x2: { size: 2, stride: 2, normalised: false },
  uint8x4: { size: 4, stride: 4, normalised: false },
  sint8x2: { size: 2, stride: 2, normalised: false },
  sint8x4: { size: 4, stride: 4, normalised: false },
  unorm8x2: { size: 2, stride: 2, normalised: true },
  unorm8x4: { size: 4, stride: 4, normalised: true },
  snorm8x2: { size: 2, stride: 2, normalised: true },
  snorm8x4: { size: 4, stride: 4, normalised: true },
  uint16x2: { size: 2, stride: 4, normalised: false },
  uint16x4: { size: 4, stride: 8, normalised: false },
  sint16x2: { size: 2, stride: 4, normalised: false },
  sint16x4: { size: 4, stride: 8, normalised: false },
  unorm16x2: { size: 2, stride: 4, normalised: true },
  unorm16x4: { size: 4, stride: 8, normalised: true },
  snorm16x2: { size: 2, stride: 4, normalised: true },
  snorm16x4: { size: 4, stride: 8, normalised: true },
  float16x2: { size: 2, stride: 4, normalised: false },
  float16x4: { size: 4, stride: 8, normalised: false },
  float32: { size: 1, stride: 4, normalised: false },
  float32x2: { size: 2, stride: 8, normalised: false },
  float32x3: { size: 3, stride: 12, normalised: false },
  float32x4: { size: 4, stride: 16, normalised: false },
  uint32: { size: 1, stride: 4, normalised: false },
  uint32x2: { size: 2, stride: 8, normalised: false },
  uint32x3: { size: 3, stride: 12, normalised: false },
  uint32x4: { size: 4, stride: 16, normalised: false },
  sint32: { size: 1, stride: 4, normalised: false },
  sint32x2: { size: 2, stride: 8, normalised: false },
  sint32x3: { size: 3, stride: 12, normalised: false },
  sint32x4: { size: 4, stride: 16, normalised: false }
};
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}

const WGSL_TO_VERTEX_TYPES = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  vec2i: "sint32x2",
  vec3i: "sint32x3",
  vec4i: "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  vec2u: "uint32x2",
  vec3u: "uint32x3",
  vec4u: "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
const LOCATION_REGEX = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|\)|$)/g;
function parseLocations(str, results) {
  let match;
  while ((match = LOCATION_REGEX.exec(str)) !== null) {
    const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
    results[match[2]] = {
      location: parseInt(match[1], 10),
      format,
      stride: getAttributeInfoFromFormat(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  LOCATION_REGEX.lastIndex = 0;
}
function stripComments(source) {
  return source.replace(/\/\/.*$/gm, "").replace(/\/\*[\s\S]*?\*\//g, "");
}
function extractAttributesFromGpuProgram({ source, entryPoint }) {
  const results = {};
  const cleanSource = stripComments(source);
  const mainVertStart = cleanSource.indexOf(`fn ${entryPoint}(`);
  if (mainVertStart === -1) {
    return results;
  }
  const arrowFunctionStart = cleanSource.indexOf("->", mainVertStart);
  if (arrowFunctionStart === -1) {
    return results;
  }
  const functionArgsSubstring = cleanSource.substring(mainVertStart, arrowFunctionStart);
  parseLocations(functionArgsSubstring, results);
  if (Object.keys(results).length === 0) {
    const structMatch = functionArgsSubstring.match(/\(\s*\w+\s*:\s*(\w+)/);
    if (structMatch) {
      const structName = structMatch[1];
      const structRegex = new RegExp(`struct\\s+${structName}\\s*\\{([^}]+)\\}`, "s");
      const structBody = cleanSource.match(structRegex);
      if (structBody) {
        parseLocations(structBody[1], results);
      }
    }
  }
  return results;
}

function extractStructAndGroups(wgsl) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*([\w<>]+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type] = member.split(":");
      acc[name2.trim()] = type.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some(
    (group) => (
      // Handle both direct type matches and generic types like array<StructName>
      group.type === name || group.type.includes(`<${name}>`)
    )
  )) ?? [];
  return {
    groups,
    structs
  };
}

var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
  ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
  ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
  ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
  return ShaderStage2;
})(ShaderStage || {});

function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d" || group.type.startsWith("texture_2d<")) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    } else if (group.type === "texture_2d_array" || group.type.startsWith("texture_2d_array<")) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d-array",
          multisampled: false
        }
      });
    } else if (group.type === "texture_cube" || group.type.startsWith("texture_cube<")) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "cube",
          multisampled: false
        }
      });
    }
  }
  for (let i = 0; i < layout.length; i++) {
    layout[i] || (layout[i] = []);
  }
  return layout;
}

function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}

function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}

const programCache = /* @__PURE__ */ Object.create(null);
class GpuProgram {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(options) {
    /** @internal */
    this._layoutKey = 0;
    /** @internal */
    this._attributeLocationsKey = 0;
    const { fragment, vertex, layout, gpuLayout, name } = options;
    this.name = name;
    this.fragment = fragment;
    this.vertex = vertex;
    if (fragment.source === vertex.source) {
      const structsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = structsAndGroups;
    } else {
      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);
      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
    }
    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
    this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex, fragment } = this;
    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;
    this._layoutKey = createIdFromString(bigKey, "program");
  }
  get attributeData() {
    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
    return this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null;
    this.layout = null;
    this.structsAndGroups = null;
    this.fragment = null;
    this.vertex = null;
    programCache[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
    if (!programCache[key]) {
      programCache[key] = new GpuProgram(options);
      programCache[key]._cacheKey = key;
    }
    return programCache[key];
  }
}

const UNIFORM_TYPES_VALUES = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>",
  "vec2<i32>",
  "vec3<i32>",
  "vec4<i32>"
];
const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {
  acc[type] = true;
  return acc;
}, {});

function getDefaultUniformValue(type, size) {
  switch (type) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}

const _UniformGroup = class _UniformGroup {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(uniformStructures, options) {
    /**
     * used internally to know if a uniform group was used in the last render pass
     * @internal
     */
    this._touched = 0;
    /** a unique id for this uniform group used through the renderer */
    this.uid = uid$1("uniform");
    /**
     * a resource type, used to identify how to handle it when its in a bind group / shader resource
     * @internal
     */
    this._resourceType = "uniformGroup";
    /**
     * the resource id used internally by the renderer to build bind group keys
     * @internal
     */
    this._resourceId = uid$1("resource");
    /** used ito identify if this is a uniform group */
    this.isUniformGroup = true;
    /**
     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU
     * @internal
     */
    this._dirtyId = 0;
    // implementing the interface - UniformGroup are not destroyed
    this.destroyed = false;
    options = { ..._UniformGroup.defaultOptions, ...options };
    this.uniformStructures = uniformStructures;
    const uniforms = {};
    for (const i in uniformStructures) {
      const uniformData = uniformStructures[i];
      uniformData.name = i;
      uniformData.size = uniformData.size ?? 1;
      if (!UNIFORM_TYPES_MAP[uniformData.type]) {
        const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
        if (arrayMatch) {
          const [, innerType, size] = arrayMatch;
          throw new Error(
            `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`
          );
        }
        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
      }
      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
      uniforms[i] = uniformData.value;
    }
    this.uniforms = uniforms;
    this._dirtyId = 1;
    this.ubo = options.ubo;
    this.isStatic = options.isStatic;
    this._signature = createIdFromString(Object.keys(uniforms).map(
      (i) => `${i}-${uniformStructures[i].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
/** The default options used by the uniform group. */
_UniformGroup.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: false,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: false
};
let UniformGroup = _UniformGroup;

class BindGroup {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(resources) {
    /** The resources that are bound together for use by a shader. */
    this.resources = /* @__PURE__ */ Object.create(null);
    this._dirty = true;
    let index = 0;
    for (const i in resources) {
      const resource = resources[i];
      this.setResource(resource, index++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   */
  _updateKey() {
    if (!this._dirty) return;
    this._dirty = false;
    const keyParts = [];
    let index = 0;
    for (const i in this.resources) {
      keyParts[index++] = this.resources[i]._resourceId;
    }
    this._key = keyParts.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(resource, index) {
    const currentResource = this.resources[index];
    if (resource === currentResource) return;
    if (currentResource) {
      resource.off?.("change", this.onResourceChange, this);
    }
    resource.on?.("change", this.onResourceChange, this);
    this.resources[index] = resource;
    this._dirty = true;
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(index) {
    return this.resources[index];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param now - The current time in milliseconds.
   * @param tick - The current tick.
   * @internal
   */
  _touch(now, tick) {
    const resources = this.resources;
    for (const i in resources) {
      resources[i]._gcLastUsed = now;
      resources[i]._touched = tick;
    }
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    const resources = this.resources;
    for (const i in resources) {
      const resource = resources[i];
      resource?.off?.("change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(resource) {
    this._dirty = true;
    if (resource.destroyed) {
      const resources = this.resources;
      for (const i in resources) {
        if (resources[i] === resource) {
          resources[i] = null;
        }
      }
    } else {
      this._updateKey();
    }
  }
}

var RendererType = /* @__PURE__ */ ((RendererType2) => {
  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
  RendererType2[RendererType2["CANVAS"] = 4] = "CANVAS";
  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
  return RendererType2;
})(RendererType || {});

class Shader extends EventEmitter {
  constructor(options) {
    super();
    /** A unique identifier for the shader */
    this.uid = uid$1("shader");
    /**
     * A record of the uniform groups and resources used by the shader.
     * This is used by WebGL renderer to sync uniform data.
     * @internal
     */
    this._uniformBindMap = /* @__PURE__ */ Object.create(null);
    this._ownedBindGroups = [];
    /** @internal */
    this._destroyed = false;
    let {
      gpuProgram,
      glProgram,
      groups,
      resources,
      compatibleRenderers,
      groupMap
    } = options;
    this.gpuProgram = gpuProgram;
    this.glProgram = glProgram;
    if (compatibleRenderers === void 0) {
      compatibleRenderers = 0;
      if (gpuProgram) compatibleRenderers |= RendererType.WEBGPU;
      if (glProgram) compatibleRenderers |= RendererType.WEBGL;
    }
    this.compatibleRenderers = compatibleRenderers;
    const nameHash = {};
    if (!resources && !groups) {
      resources = {};
    }
    if (resources && groups) {
      throw new Error("[Shader] Cannot have both resources and groups");
    } else if (!gpuProgram && groups && !groupMap) {
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    } else if (!gpuProgram && groups && groupMap) {
      for (const i in groupMap) {
        for (const j in groupMap[i]) {
          const uniformName = groupMap[i][j];
          nameHash[uniformName] = {
            group: i,
            binding: j,
            name: uniformName
          };
        }
      }
    } else if (gpuProgram && groups && !groupMap) {
      const groupData = gpuProgram.structsAndGroups.groups;
      groupMap = {};
      groupData.forEach((data) => {
        groupMap[data.group] = groupMap[data.group] || {};
        groupMap[data.group][data.binding] = data.name;
        nameHash[data.name] = data;
      });
    } else if (resources) {
      groups = {};
      groupMap = {};
      if (gpuProgram) {
        const groupData = gpuProgram.structsAndGroups.groups;
        groupData.forEach((data) => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      }
      let bindTick = 0;
      for (const i in resources) {
        if (nameHash[i]) continue;
        if (!groups[99]) {
          groups[99] = new BindGroup();
          this._ownedBindGroups.push(groups[99]);
        }
        nameHash[i] = { group: 99, binding: bindTick, name: i };
        groupMap[99] = groupMap[99] || {};
        groupMap[99][bindTick] = i;
        bindTick++;
      }
      for (const i in resources) {
        const name = i;
        let value = resources[i];
        if (!value.source && !value._resourceType) {
          value = new UniformGroup(value);
        }
        const data = nameHash[name];
        if (data) {
          if (!groups[data.group]) {
            groups[data.group] = new BindGroup();
            this._ownedBindGroups.push(groups[data.group]);
          }
          groups[data.group].setResource(value, data.binding);
        }
      }
    }
    this.groups = groups;
    this._uniformBindMap = groupMap;
    this.resources = this._buildResourceAccessor(groups, nameHash);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(name, groupIndex, bindIndex) {
    var _a, _b;
    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
    if (!this.groups[groupIndex]) {
      this.groups[groupIndex] = new BindGroup();
      this._ownedBindGroups.push(this.groups[groupIndex]);
    }
  }
  _buildResourceAccessor(groups, nameHash) {
    const uniformsOut = {};
    for (const i in nameHash) {
      const data = nameHash[i];
      Object.defineProperty(uniformsOut, data.name, {
        get() {
          return groups[data.group].getResource(data.binding);
        },
        set(value) {
          groups[data.group].setResource(value, data.binding);
        }
      });
    }
    return uniformsOut;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(destroyPrograms = false) {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("destroy", this);
    if (destroyPrograms) {
      this.gpuProgram?.destroy();
      this.glProgram?.destroy();
    }
    this.gpuProgram = null;
    this.glProgram = null;
    this.removeAllListeners();
    this._uniformBindMap = null;
    this._ownedBindGroups.forEach((bindGroup) => {
      bindGroup.destroy();
    });
    this._ownedBindGroups = null;
    this.resources = null;
    this.groups = null;
  }
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = GlProgram.from(gl);
    }
    return new Shader({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
}

const blendModeIds = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
};
const BLEND$1 = 0;
const OFFSET$1 = 1;
const CULLING$1 = 2;
const DEPTH_TEST$1 = 3;
const WINDING$1 = 4;
const DEPTH_MASK$1 = 5;
const _State = class _State {
  constructor() {
    this.data = 0;
    this.blendMode = "normal";
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND$1);
  }
  set blend(value) {
    if (!!(this.data & 1 << BLEND$1) !== value) {
      this.data ^= 1 << BLEND$1;
    }
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET$1);
  }
  set offsets(value) {
    if (!!(this.data & 1 << OFFSET$1) !== value) {
      this.data ^= 1 << OFFSET$1;
    }
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(value) {
    if (value === "none") {
      this.culling = false;
      return;
    }
    this.culling = true;
    this.clockwiseFrontFace = value === "front";
  }
  get cullMode() {
    if (!this.culling) {
      return "none";
    }
    return this.clockwiseFrontFace ? "front" : "back";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING$1);
  }
  set culling(value) {
    if (!!(this.data & 1 << CULLING$1) !== value) {
      this.data ^= 1 << CULLING$1;
    }
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST$1);
  }
  set depthTest(value) {
    if (!!(this.data & 1 << DEPTH_TEST$1) !== value) {
      this.data ^= 1 << DEPTH_TEST$1;
    }
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK$1);
  }
  set depthMask(value) {
    if (!!(this.data & 1 << DEPTH_MASK$1) !== value) {
      this.data ^= 1 << DEPTH_MASK$1;
    }
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING$1);
  }
  set clockwiseFrontFace(value) {
    if (!!(this.data & 1 << WINDING$1) !== value) {
      this.data ^= 1 << WINDING$1;
    }
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value) {
    this.blend = value !== "none";
    this._blendMode = value;
    this._blendModeId = blendModeIds[value] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value) {
    this.offsets = !!value;
    this._polygonOffset = value;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const state = new _State();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
};
_State.default2d = _State.for2d();
let State = _State;

const _Filter = class _Filter extends Shader {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(options) {
    options = { ..._Filter.defaultOptions, ...options };
    super(options);
    /** If enabled is true the filter is applied, if false it will not. */
    this.enabled = true;
    /**
     * The gpu state the filter requires to render.
     * @internal
     */
    this._state = State.for2d();
    this.blendMode = options.blendMode;
    this.padding = options.padding;
    if (typeof options.antialias === "boolean") {
      this.antialias = options.antialias ? "on" : "off";
    } else {
      this.antialias = options.antialias;
    }
    this.resolution = options.resolution;
    this.blendRequired = options.blendRequired;
    this.clipToViewport = options.clipToViewport;
    this.addResource("uTexture", 0, 1);
    if (options.blendRequired) {
      this.addResource("uBackTexture", 0, 3);
    }
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(filterManager, input, output, clearMode) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(value) {
    this._state.blendMode = value;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = GlProgram.from(gl);
    }
    return new _Filter({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
};
/** The default filter settings */
_Filter.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: false,
  clipToViewport: true
};
let Filter = _Filter;

const environments = [];
extensions.handleByNamedList(ExtensionType.Environment, environments);
async function loadEnvironmentExtensions(skip) {
  if (skip) return;
  for (let i = 0; i < environments.length; i++) {
    const env = environments[i];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}

let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}

function earcut$1(data, holeIndices, dim = 2) {

    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    let minX, minY, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = data[0];
        minY = data[1];
        let maxX = minX;
        let maxY = minY;

        for (let i = dim; i < outerLen; i += dim) {
            const x = data[i];
            const y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    } else {
        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    let p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    let stop = ear;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        const prev = ear.prev;
        const next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i, ear.i, next.i); // cut off the triangle

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox
    const x0 = Math.min(ax, bx, cx),
        y0 = Math.min(ay, by, cy),
        x1 = Math.max(ax, bx, cx),
        y1 = Math.max(ay, by, cy);

    let p = c.next;
    while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    const a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;

    // triangle bbox
    const x0 = Math.min(ax, bx, cx),
        y0 = Math.min(ay, by, cy),
        x1 = Math.max(ax, bx, cx),
        y1 = Math.max(ay, by, cy);

    // z-order range for the current triangle bbox;
    const minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);

    let p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&
            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles) {
    let p = start;
    do {
        const a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects$1(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i, p.i, b.i);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a = start;
    do {
        let b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                let c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];

    for (let i = 0, len = holeIndices.length; i < len; i++) {
        const start = holeIndices[i] * dim;
        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        const list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareXYSlope);

    // process holes from left to right
    for (let i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
}

function compareXYSlope(a, b) {
    let result = a.x - b.x;
    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find
    // the bridge to the outer shell is always the point that they meet at.
    if (result === 0) {
        result = a.y - b.y;
        if (result === 0) {
            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);
            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);
            result = aSlope - bSlope;
        }
    }
    return result;
}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole(hole, outerNode) {
    const bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
        return outerNode;
    }

    const bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity;
    let m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    // unless they intersect at a vertex, then choose the vertex
    if (equals(hole, p)) return p;
    do {
        if (equals(hole, p.next)) return p.next;
        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                m = p.x < p.next.x ? p : p.next;
                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    const stop = m;
    const mx = m.x;
    const my = m.y;
    let tanMin = Infinity;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle$1(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let numMerges;
    let inSize = 1;

    do {
        let p = list;
        let e;
        list = null;
        let tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            let q = p;
            let pSize = 0;
            for (let i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            let qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle$1(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&
           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&
           (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a point lies within a convex triangle but false if its equal to the first point of the triangle
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
    return !(ax === px && ay === py) && pointInTriangle$1(ax, ay, bx, by, cx, cy, px, py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects$1(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    let p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects$1(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    let p = a;
    let inside = false;
    const px = (a.x + b.x) / 2;
    const py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    const a2 = createNode$1(a.i, a.x, a.y),
        b2 = createNode$1(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    const p = createNode$1(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function createNode$1(i, x, y) {
    return {
        i, // vertex index in coordinates array
        x, y, // vertex coordinates
        prev: null, // previous and next vertex nodes in a polygon ring
        next: null,
        z: 0, // z-order curve value
        prevZ: null, // previous and next nodes in z-order
        nextZ: null,
        steiner: false // indicates whether this is a steiner point
    };
}

function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

const earcut = earcut$1.default || earcut$1;

var CLEAR = /* @__PURE__ */ ((CLEAR2) => {
  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
  return CLEAR2;
})(CLEAR || {});

class SystemRunner {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name) {
    this.items = [];
    this._name = name;
  }
  /* jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /* jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    const { name, items } = this;
    for (let i = 0, len = items.length; i < len; i++) {
      items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```ts
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    if (item[this._name]) {
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
    return this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.indexOf(item) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    this.items.length = 0;
    return this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}

const defaultRunners = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "resetState",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
];
const _AbstractRenderer = class _AbstractRenderer extends EventEmitter {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(config) {
    super();
    /** The current tick of the renderer. */
    this.tick = 0;
    /** @internal */
    this.uid = uid$1("renderer");
    /** @internal */
    this.runners = /* @__PURE__ */ Object.create(null);
    /** @internal */
    this.renderPipes = /* @__PURE__ */ Object.create(null);
    this._initOptions = {};
    this._systemsHash = /* @__PURE__ */ Object.create(null);
    this.type = config.type;
    this.name = config.name;
    this.config = config;
    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
    this._addRunners(...combinedRunners);
    this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(options = {}) {
    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
    await loadEnvironmentExtensions(skip);
    this._addSystems(this.config.systems);
    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const systemName in this._systemsHash) {
      const system = this._systemsHash[systemName];
      const defaultSystemOptions = system.constructor.defaultOptions;
      options = { ...defaultSystemOptions, ...options };
    }
    options = { ..._AbstractRenderer.defaultOptions, ...options };
    this._roundPixels = options.roundPixels ? 1 : 0;
    for (let i = 0; i < this.runners.init.items.length; i++) {
      await this.runners.init.items[i].init(options);
    }
    this._initOptions = options;
  }
  render(args, deprecated) {
    this.tick++;
    let options = args;
    if (options instanceof Container) {
      options = { container: options };
      if (deprecated) {
        deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
        options.target = deprecated.renderTexture;
      }
    }
    options.target || (options.target = this.view.renderTarget);
    if (options.target === this.view.renderTarget) {
      this._lastObjectRendered = options.container;
      options.clearColor ?? (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = this.background.clearBeforeRender);
    }
    if (options.clearColor) {
      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
    }
    if (!options.transform) {
      options.container.updateLocalTransform();
      options.transform = options.container.localTransform;
    }
    if (!options.container.visible) {
      return;
    }
    options.container.enableRenderGroup();
    this.runners.prerender.emit(options);
    this.runners.renderStart.emit(options);
    this.runners.render.emit(options);
    this.runners.renderEnd.emit(options);
    this.runners.postrender.emit(options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(desiredScreenWidth, desiredScreenHeight, resolution) {
    const previousResolution = this.view.resolution;
    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
    this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
    if (resolution !== void 0 && resolution !== previousResolution) {
      this.runners.resolutionChange.emit(resolution);
    }
  }
  /**
   * Clears the render target.
   * @param options - The options to use when clearing the render target.
   * @param options.target - The render target to clear.
   * @param options.clearColor - The color to clear with.
   * @param options.clear - The clear mode to use.
   * @advanced
   */
  clear(options = {}) {
    const renderer = this;
    options.target || (options.target = renderer.renderTarget.renderTarget);
    options.clearColor || (options.clearColor = this.background.colorRgba);
    options.clear ?? (options.clear = CLEAR.ALL);
    const { clear, clearColor, target, mipLevel, layer } = options;
    Color.shared.setValue(clearColor ?? this.background.colorRgba);
    renderer.renderTarget.clear(target, clear, Color.shared.toArray(), mipLevel ?? 0, layer ?? 0);
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(value) {
    this.view.resolution = value;
    this.runners.resolutionChange.emit(value);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @type {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    const renderer = this;
    return renderer.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new SystemRunner(runnerId);
    });
  }
  _addSystems(systems) {
    let i;
    for (i in systems) {
      const val = systems[i];
      this._addSystem(val.value, val.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(ClassRef, name) {
    const system = new ClassRef(this);
    if (this[name]) {
      throw new Error(`Whoops! The name "${name}" is already in use`);
    }
    this[name] = system;
    this._systemsHash[name] = system;
    for (const i in this.runners) {
      this.runners[i].add(system);
    }
    return this;
  }
  _addPipes(pipes, pipeAdaptors) {
    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
      acc[adaptor.name] = adaptor.value;
      return acc;
    }, {});
    pipes.forEach((pipe) => {
      const PipeClass = pipe.value;
      const name = pipe.name;
      const Adaptor = adaptors[name];
      this.renderPipes[name] = new PipeClass(
        this,
        Adaptor ? new Adaptor() : null
      );
      this.runners.destroy.add(this.renderPipes[name]);
    });
  }
  destroy(options = false) {
    this.runners.destroy.items.reverse();
    this.runners.destroy.emit(options);
    if (options === true || typeof options === "object" && options.releaseGlobalResources) {
      GlobalResourceRegistry.release();
    }
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = null;
    this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(options) {
    return this.textureGenerator.generateTexture(options);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  /**
   * Resets the rendering state of the renderer.
   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
   * render will reset all internal caches and ensure it executes correctly.
   *
   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
   * ```js
   * // Reset Three.js state
   * threeRenderer.resetState();
   *
   * // Render a Three.js scene
   * threeRenderer.render(threeScene, threeCamera);
   *
   * // Reset PixiJS state since Three.js modified the WebGL context
   * pixiRenderer.resetState();
   *
   * // Now render Pixi content
   * pixiRenderer.render(pixiScene);
   * ```
   * @advanced
   */
  resetState() {
    this.runners.resetState.emit();
  }
};
/** The default options for the renderer. */
_AbstractRenderer.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: false,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: false
};
let AbstractRenderer = _AbstractRenderer;

let _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0) return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}

let _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0) return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}

const renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i = 0; i < preferredOrder.length; i++) {
    const rendererType = preferredOrder[i];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer } = await Promise.resolve().then(function () { return WebGPURenderer$1; });
      RendererClass = WebGPURenderer;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer } = await Promise.resolve().then(function () { return WebGLRenderer$1; });
      RendererClass = WebGLRenderer;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      const { CanvasRenderer } = await Promise.resolve().then(function () { return CanvasRenderer$1; });
      RendererClass = CanvasRenderer;
      finalOptions = { ...options, ...options.canvasOptions };
      break;
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  delete finalOptions.canvasOptions;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

const VERSION = "8.16.0";

class ApplicationInitHook {
  static init() {
    globalThis.__PIXI_APP_INIT__?.(this, VERSION);
  }
  static destroy() {
  }
}
/** @ignore */
ApplicationInitHook.extension = ExtensionType.Application;
class RendererInitHook {
  constructor(renderer) {
    this._renderer = renderer;
  }
  init() {
    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
RendererInitHook.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};

class ResizePlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    Object.defineProperty(
      this,
      "resizeTo",
      {
        configurable: true,
        set(dom) {
          globalThis.removeEventListener("resize", this.queueResize);
          this._resizeTo = dom;
          if (dom) {
            globalThis.addEventListener("resize", this.queueResize);
            this.resize();
          }
        },
        get() {
          return this._resizeTo;
        }
      }
    );
    this.queueResize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      this._resizeId = requestAnimationFrame(() => this.resize());
    };
    this._cancelResize = () => {
      if (this._resizeId) {
        cancelAnimationFrame(this._resizeId);
        this._resizeId = null;
      }
    };
    this.resize = () => {
      if (!this._resizeTo) {
        return;
      }
      this._cancelResize();
      let width;
      let height;
      if (this._resizeTo === globalThis.window) {
        width = globalThis.innerWidth;
        height = globalThis.innerHeight;
      } else {
        const { clientWidth, clientHeight } = this._resizeTo;
        width = clientWidth;
        height = clientHeight;
      }
      this.renderer.resize(width, height);
      this.render();
    };
    this._resizeId = null;
    this._resizeTo = null;
    this.resizeTo = options.resizeTo || null;
  }
  /**
   * Clean up the ticker, scoped to application
   * @private
   */
  static destroy() {
    globalThis.removeEventListener("resize", this.queueResize);
    this._cancelResize();
    this._cancelResize = null;
    this.queueResize = null;
    this.resizeTo = null;
    this.resize = null;
  }
}
/** @ignore */
ResizePlugin.extension = ExtensionType.Application;

class TickerPlugin {
  /**
   * Initialize the plugin with scope of application instance
   * @private
   * @param {object} [options] - See application options
   */
  static init(options) {
    options = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, options);
    Object.defineProperty(
      this,
      "ticker",
      {
        configurable: true,
        set(ticker) {
          if (this._ticker) {
            this._ticker.remove(this.render, this);
          }
          this._ticker = ticker;
          if (ticker) {
            ticker.add(this.render, this, UPDATE_PRIORITY.LOW);
          }
        },
        get() {
          return this._ticker;
        }
      }
    );
    this.stop = () => {
      this._ticker.stop();
    };
    this.start = () => {
      this._ticker.start();
    };
    this._ticker = null;
    this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
    if (options.autoStart) {
      this.start();
    }
  }
  /**
   * Clean up the ticker, scoped to application.
   * @private
   */
  static destroy() {
    if (this._ticker) {
      const oldTicker = this._ticker;
      this.ticker = null;
      oldTicker.destroy();
    }
  }
}
/** @ignore */
TickerPlugin.extension = ExtensionType.Application;

extensions.add(ResizePlugin);
extensions.add(TickerPlugin);

const _Application = class _Application {
  constructor(...args) {
    /**
     * The root display container for your application.
     * All visual elements should be added to this container or its children.
     * @example
     * ```js
     * // Create a sprite and add it to the stage
     * const sprite = Sprite.from('image.png');
     * app.stage.addChild(sprite);
     *
     * // Create a container for grouping objects
     * const container = new Container();
     * app.stage.addChild(container);
     * ```
     */
    this.stage = new Container();
    if (args[0] !== void 0) {
      deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */
  async init(options) {
    options = { ...options };
    this.stage || (this.stage = new Container());
    this.renderer = await autoDetectRenderer(options);
    _Application._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */
  get view() {
    deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
/**
 * Collection of installed plugins.
 * @internal
 */
_Application._plugins = [];
let Application = _Application;
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ApplicationInitHook);

var parseSvgPath;
var hasRequiredParseSvgPath;

function requireParseSvgPath () {
	if (hasRequiredParseSvgPath) return parseSvgPath;
	hasRequiredParseSvgPath = 1;
	parseSvgPath = parse;

	/**
	 * expected argument lengths
	 * @type {Object}
	 */

	var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0};

	/**
	 * segment pattern
	 * @type {RegExp}
	 */

	var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

	/**
	 * parse an svg path data string. Generates an Array
	 * of commands where each command is an Array of the
	 * form `[command, arg1, arg2, ...]`
	 *
	 * @param {String} path
	 * @return {Array}
	 */

	function parse(path) {
		var data = [];
		path.replace(segment, function(_, command, args){
			var type = command.toLowerCase();
			args = parseValues(args);

			// overloaded moveTo
			if (type == 'm' && args.length > 2) {
				data.push([command].concat(args.splice(0, 2)));
				type = 'l';
				command = command == 'm' ? 'l' : 'L';
			}

			while (true) {
				if (args.length == length[type]) {
					args.unshift(command);
					return data.push(args)
				}
				if (args.length < length[type]) throw new Error('malformed path data')
				data.push([command].concat(args.splice(0, length[type])));
			}
		});
		return data
	}

	var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

	function parseValues(args) {
		var numbers = args.match(number);
		return numbers ? numbers.map(Number) : []
	}
	return parseSvgPath;
}

var parseSvgPathExports = requireParseSvgPath();
var parse = /*@__PURE__*/getDefaultExportFromCjs(parseSvgPathExports);

function parseSVGPath(svgPath, path) {
  const commands = parse(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i = 0; i < commands.length; i++) {
    const command = commands[i];
    const type = command[0];
    const data = command;
    switch (type) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path.bezierCurveTo(
          data[1],
          data[2],
          // First control point
          data[3],
          data[4],
          // Second control point
          lastX,
          lastY
          // End point
        );
        break;
      case "c":
        path.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          // First control point
          lastX + data[3],
          lastY + data[4],
          // Second control point
          lastX + data[5],
          lastY + data[6]
          // End point
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path.bezierCurveToShort(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "s":
        path.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path.quadraticCurveTo(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "q":
        path.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "Z":
      // Close Path
      case "z":
        path.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn$2(`Unknown SVG path command: ${type}`);
    }
    if (type !== "Z" && type !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path;
}

class Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x = 0, y = 0, radius = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks.
     * @example
     * ```ts
     * // Check shape type
     * const shape = new Circle(0, 0, 50);
     * console.log(shape.type); // 'circle'
     *
     * // Use in type guards
     * if (shape.type === 'circle') {
     *     console.log(shape.radius);
     * }
     * ```
     * @remarks
     * - Used for shape type checking
     * - More efficient than instanceof
     * - Read-only property
     * @readonly
     * @default 'circle'
     * @see {@link SHAPE_PRIMITIVE} For all shape types
     * @see {@link ShapePrimitive} For shape interface
     */
    this.type = "circle";
    this.x = x;
    this.y = y;
    this.radius = radius;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(x, y) {
    if (this.radius <= 0) return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x;
    let dy = this.y - y;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(x, y, width, alignment = 0.5) {
    if (this.radius === 0) return false;
    const dx = this.x - x;
    const dy = this.y - y;
    const radius = this.radius;
    const outerWidth = (1 - alignment) * width;
    const distance = Math.sqrt(dx * dx + dy * dy);
    return distance <= radius + outerWidth && distance > radius - (width - outerWidth);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(out) {
    out || (out = new Rectangle());
    out.x = this.x - this.radius;
    out.y = this.y - this.radius;
    out.width = this.radius * 2;
    out.height = this.radius * 2;
    return out;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(circle) {
    this.x = circle.x;
    this.y = circle.y;
    this.radius = circle.radius;
    return this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(circle) {
    circle.copyFrom(this);
    return circle;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}

class Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @example
     * ```ts
     * // Check shape type
     * const shape = new Ellipse(0, 0, 50, 25);
     * console.log(shape.type); // 'ellipse'
     *
     * // Use in type guards
     * if (shape.type === 'ellipse') {
     *     console.log(shape.halfWidth, shape.halfHeight);
     * }
     * ```
     * @readonly
     * @default 'ellipse'
     * @see {@link SHAPE_PRIMITIVE} For all shape types
     */
    this.type = "ellipse";
    this.x = x;
    this.y = y;
    this.halfWidth = halfWidth;
    this.halfHeight = halfHeight;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (xÂ²/aÂ² + yÂ²/bÂ² â‰¤ 1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(x, y) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0) {
      return false;
    }
    let normx = (x - this.x) / this.halfWidth;
    let normy = (y - this.y) / this.halfHeight;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const { halfWidth, halfHeight } = this;
    if (halfWidth <= 0 || halfHeight <= 0) {
      return false;
    }
    const strokeOuterWidth = strokeWidth * (1 - alignment);
    const strokeInnerWidth = strokeWidth - strokeOuterWidth;
    const innerHorizontal = halfWidth - strokeInnerWidth;
    const innerVertical = halfHeight - strokeInnerWidth;
    const outerHorizontal = halfWidth + strokeOuterWidth;
    const outerVertical = halfHeight + strokeOuterWidth;
    const normalizedX = x - this.x;
    const normalizedY = y - this.y;
    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
    return innerEllipse > 1 && outerEllipse <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(out) {
    out || (out = new Rectangle());
    out.x = this.x - this.halfWidth;
    out.y = this.y - this.halfHeight;
    out.width = this.halfWidth * 2;
    out.height = this.halfHeight * 2;
    return out;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(ellipse) {
    this.x = ellipse.x;
    this.y = ellipse.y;
    this.halfWidth = ellipse.halfWidth;
    this.halfHeight = ellipse.halfHeight;
    return this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(ellipse) {
    ellipse.copyFrom(this);
    return ellipse;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}

function squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) {
  const a = x - x1;
  const b = y - y1;
  const c = x2 - x1;
  const d = y2 - y1;
  const dot = a * c + b * d;
  const lenSq = c * c + d * d;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * c;
    yy = y1 + param * d;
  }
  const dx = x - xx;
  const dy = y - yy;
  return dx * dx + dy * dy;
}

let tempRect$3;
let tempRect2;
class Polygon {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @example
     * ```ts
     * // Check shape type
     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);
     * console.log(shape.type); // 'polygon'
     *
     * // Use in type guards
     * if (shape.type === 'polygon') {
     *     // TypeScript knows this is a Polygon
     *     console.log(shape.points.length);
     * }
     * ```
     * @readonly
     * @default 'polygon'
     * @see {@link SHAPE_PRIMITIVE} For all shape types
     */
    this.type = "polygon";
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p = [];
      for (let i = 0, il = flat.length; i < il; i++) {
        p.push(flat[i].x, flat[i].y);
      }
      flat = p;
    }
    this.points = flat;
    this.closePath = true;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let area = 0;
    const points = this.points;
    const length = points.length;
    for (let i = 0; i < length; i += 2) {
      const x1 = points[i];
      const y1 = points[i + 1];
      const x2 = points[(i + 2) % length];
      const y2 = points[(i + 3) % length];
      area += (x2 - x1) * (y2 + y1);
    }
    return area < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(polygon) {
    const thisBounds = this.getBounds(tempRect$3);
    const otherBounds = polygon.getBounds(tempRect2);
    if (!thisBounds.containsRect(otherBounds)) {
      return false;
    }
    const points = polygon.points;
    for (let i = 0; i < points.length; i += 2) {
      const x = points[i];
      const y = points[i + 1];
      if (!this.contains(x, y)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closePath = this.closePath;
    return polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(x, y) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i = 0, j = length - 1; i < length; j = i++) {
      const xi = this.points[i * 2];
      const yi = this.points[i * 2 + 1];
      const xj = this.points[j * 2];
      const yj = this.points[j * 2 + 1];
      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(x, y, strokeWidth, alignment = 0.5) {
    const strokeWidthSquared = strokeWidth * strokeWidth;
    const rightWidthSquared = strokeWidthSquared * (1 - alignment);
    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
    const { points } = this;
    const iterationLength = points.length - (this.closePath ? 0 : 2);
    for (let i = 0; i < iterationLength; i += 2) {
      const x1 = points[i];
      const y1 = points[i + 1];
      const x2 = points[(i + 2) % points.length];
      const y2 = points[(i + 3) % points.length];
      const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);
      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));
      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(out) {
    out || (out = new Rectangle());
    const points = this.points;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i];
      const y = points[i + 1];
      minX = x < minX ? x : minX;
      maxX = x > maxX ? x : maxX;
      minY = y < minY ? y : minY;
      maxY = y > maxY ? y : maxY;
    }
    out.x = minX;
    out.width = maxX - minX;
    out.y = minY;
    out.height = maxY - minY;
    return out;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(polygon) {
    this.points = polygon.points.slice();
    this.closePath = polygon.closePath;
    return this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(polygon) {
    polygon.copyFrom(this);
    return polygon;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
}

const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
  const dx = pX - cornerX;
  const dy = pY - cornerY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;
};
class RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
    /**
     * The type of the object, mainly used to avoid `instanceof` checks
     * @example
     * ```ts
     * // Check shape type
     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);
     * console.log(shape.type); // 'roundedRectangle'
     *
     * // Use in type guards
     * if (shape.type === 'roundedRectangle') {
     *     console.log(shape.radius);
     * }
     * ```
     * @readonly
     * @default 'roundedRectangle'
     * @see {@link SHAPE_PRIMITIVE} For all shape types
     */
    this.type = "roundedRectangle";
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.radius = radius;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(out) {
    out || (out = new Rectangle());
    out.x = this.x;
    out.y = this.y;
    out.width = this.width;
    out.height = this.height;
    return out;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(x, y) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x >= this.x && x <= this.x + this.width) {
      if (y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return true;
        }
        let dx = x - (this.x + radius);
        let dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
    const { x, y, width, height, radius } = this;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const innerX = x + radius;
    const innerY = y + radius;
    const innerWidth = width - radius * 2;
    const innerHeight = height - radius * 2;
    const rightBound = x + width;
    const bottomBound = y + height;
    if ((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
      return true;
    }
    if ((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
      return true;
    }
    return (
      // Top-left
      pX < innerX && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      )
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}

const cachedGroups = {};
function getTextureBatchBindGroup(textures, size, maxTextures) {
  let uid = 2166136261;
  for (let i = 0; i < size; i++) {
    uid ^= textures[i].uid;
    uid = Math.imul(uid, 16777619);
    uid >>>= 0;
  }
  return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);
}
function generateTextureBatchBindGroup(textures, size, key, maxTextures) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i = 0; i < maxTextures; i++) {
    const texture = i < size ? textures[i] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}

class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
    this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    if (!this._float64Array) {
      this._float64Array = new Float64Array(this.rawBinaryData);
    }
    return this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    if (!this._bigUint64Array) {
      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
    }
    return this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type) {
    return this[`${type}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null;
    this.uint32View = null;
    this.float32View = null;
    this.uint16View = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._int32View = null;
    this._float64Array = null;
    this._bigUint64Array = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(type) {
    switch (type) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type} isn't a valid view type`);
    }
  }
}

function fastCopy(sourceBuffer, destinationBuffer, sourceOffset, byteLength) {
  sourceOffset ?? (sourceOffset = 0);
  byteLength ?? (byteLength = Math.min(sourceBuffer.byteLength - sourceOffset, destinationBuffer.byteLength));
  if (!(sourceOffset & 7) && !(byteLength & 7)) {
    const len = byteLength / 8;
    new Float64Array(destinationBuffer, 0, len).set(new Float64Array(sourceBuffer, sourceOffset, len));
  } else if (!(sourceOffset & 3) && !(byteLength & 3)) {
    const len = byteLength / 4;
    new Float32Array(destinationBuffer, 0, len).set(new Float32Array(sourceBuffer, sourceOffset, len));
  } else {
    new Uint8Array(destinationBuffer).set(new Uint8Array(sourceBuffer, sourceOffset, byteLength));
  }
}

const BLEND_TO_NPM = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
  return STENCIL_MODES2;
})(STENCIL_MODES || {});

function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}

const fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i = 0; i < maxIfs; ++i) {
    if (i > 0) {
      src += "\nelse ";
    }
    if (i < maxIfs - 1) {
      src += `if(test == ${i}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}

let maxTexturesPerBatchCache = null;
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
    maxTexturesPerBatchCache,
    gl
  );
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}

class BatchTextureArray {
  constructor() {
    /** Respective locations for textures. */
    this.ids = /* @__PURE__ */ Object.create(null);
    this.textures = [];
    this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let i = 0; i < this.count; i++) {
      const t = this.textures[i];
      this.textures[i] = null;
      this.ids[t.uid] = null;
    }
    this.count = 0;
  }
}

class Batch {
  constructor() {
    this.renderPipeId = "batch";
    this.action = "startBatch";
    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones
    // public elementStart = 0;
    // public elementSize = 0;
    // for drawing..
    this.start = 0;
    this.size = 0;
    this.textures = new BatchTextureArray();
    this.blendMode = "normal";
    this.topology = "triangle-strip";
    this.canBundle = true;
  }
  destroy() {
    this.textures = null;
    this.gpuBindGroup = null;
    this.bindGroup = null;
    this.batcher = null;
    this.elements = null;
  }
}
const batchPool = [];
let batchPoolIndex = 0;
GlobalResourceRegistry.register({
  clear: () => {
    if (batchPool.length > 0) {
      for (const item of batchPool) {
        if (item) item.destroy();
      }
    }
    batchPool.length = 0;
    batchPoolIndex = 0;
  }
});
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batch.elements = null;
  batchPool[batchPoolIndex++] = batch;
}
let BATCH_TICK = 0;
const _Batcher = class _Batcher {
  constructor(options) {
    /** unique id for this batcher */
    this.uid = uid$1("batcher");
    /** Indicates whether the batch data has been modified and needs updating. */
    this.dirty = true;
    /** The current index of the batch being processed. */
    this.batchIndex = 0;
    /** An array of all batches created during the current rendering process. */
    this.batches = [];
    this._elements = [];
    options = { ..._Batcher.defaultOptions, ...options };
    if (!options.maxTextures) {
      deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
      options.maxTextures = getMaxTexturesPerBatch();
    }
    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
    this.indexBuffer = new Uint16Array(indicesInitialSize);
    this.maxTextures = maxTextures;
  }
  begin() {
    this.elementSize = 0;
    this.elementStart = 0;
    this.indexSize = 0;
    this.attributeSize = 0;
    for (let i = 0; i < this.batchIndex; i++) {
      returnBatchToPool(this.batches[i]);
    }
    this.batchIndex = 0;
    this._batchIndexStart = 0;
    this._batchIndexSize = 0;
    this.dirty = true;
  }
  add(batchableObject) {
    this._elements[this.elementSize++] = batchableObject;
    batchableObject._indexStart = this.indexSize;
    batchableObject._attributeStart = this.attributeSize;
    batchableObject._batcher = this;
    this.indexSize += batchableObject.indexSize;
    this.attributeSize += batchableObject.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(batchableObject, texture) {
    const textureId = batchableObject._batch.textures.ids[texture._source.uid];
    if (!textureId && textureId !== 0) return false;
    batchableObject._textureId = textureId;
    batchableObject.texture = texture;
    return true;
  }
  updateElement(batchableObject) {
    this.dirty = true;
    const attributeBuffer = this.attributeBuffer;
    if (batchableObject.packAsQuad) {
      this.packQuadAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    } else {
      this.packAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    }
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(instructionSet) {
    const elements = this._elements;
    if (!elements[this.elementStart]) return;
    let batch = getBatchFromPool();
    let textureBatch = batch.textures;
    textureBatch.clear();
    const firstElement = elements[this.elementStart];
    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
    let topology = firstElement.topology;
    if (this.attributeSize * 4 > this.attributeBuffer.size) {
      this._resizeAttributeBuffer(this.attributeSize * 4);
    }
    if (this.indexSize > this.indexBuffer.length) {
      this._resizeIndexBuffer(this.indexSize);
    }
    const f32 = this.attributeBuffer.float32View;
    const u32 = this.attributeBuffer.uint32View;
    const indexBuffer = this.indexBuffer;
    let size = this._batchIndexSize;
    let start = this._batchIndexStart;
    let action = "startBatch";
    let batchElements = [];
    const maxTextures = this.maxTextures;
    for (let i = this.elementStart; i < this.elementSize; ++i) {
      const element = elements[i];
      elements[i] = null;
      const texture = element.texture;
      const source = texture._source;
      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);
      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
      if (source._batchTick === BATCH_TICK && !breakRequired) {
        element._textureId = source._textureBindLocation;
        size += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packQuadIndex(
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        } else {
          this.packAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packIndex(
            element,
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        }
        element._batch = batch;
        batchElements.push(element);
        continue;
      }
      source._batchTick = BATCH_TICK;
      if (textureBatch.count >= maxTextures || breakRequired) {
        this._finishBatch(
          batch,
          start,
          size - start,
          textureBatch,
          blendMode,
          topology,
          instructionSet,
          action,
          batchElements
        );
        action = "renderBatch";
        start = size;
        blendMode = adjustedBlendMode;
        topology = element.topology;
        batch = getBatchFromPool();
        textureBatch = batch.textures;
        textureBatch.clear();
        batchElements = [];
        ++BATCH_TICK;
      }
      element._textureId = source._textureBindLocation = textureBatch.count;
      textureBatch.ids[source.uid] = textureBatch.count;
      textureBatch.textures[textureBatch.count++] = source;
      element._batch = batch;
      batchElements.push(element);
      size += element.indexSize;
      if (element.packAsQuad) {
        this.packQuadAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packQuadIndex(
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      } else {
        this.packAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packIndex(
          element,
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      }
    }
    if (textureBatch.count > 0) {
      this._finishBatch(
        batch,
        start,
        size - start,
        textureBatch,
        blendMode,
        topology,
        instructionSet,
        action,
        batchElements
      );
      start = size;
      ++BATCH_TICK;
    }
    this.elementStart = this.elementSize;
    this._batchIndexStart = start;
    this._batchIndexSize = size;
  }
  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action, elements) {
    batch.gpuBindGroup = null;
    batch.bindGroup = null;
    batch.action = action;
    batch.batcher = this;
    batch.textures = textureBatch;
    batch.blendMode = blendMode;
    batch.topology = topology;
    batch.start = indexStart;
    batch.size = indexSize;
    batch.elements = elements;
    ++BATCH_TICK;
    this.batches[this.batchIndex++] = batch;
    instructionSet.add(batch);
  }
  finish(instructionSet) {
    this.break(instructionSet);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(size) {
    if (size * 4 <= this.attributeBuffer.size) return;
    this._resizeAttributeBuffer(size * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(size) {
    if (size <= this.indexBuffer.length) return;
    this._resizeIndexBuffer(size);
  }
  _resizeAttributeBuffer(size) {
    const newSize = Math.max(size, this.attributeBuffer.size * 2);
    const newArrayBuffer = new ViewableBuffer(newSize);
    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
    this.attributeBuffer = newArrayBuffer;
  }
  _resizeIndexBuffer(size) {
    const indexBuffer = this.indexBuffer;
    let newSize = Math.max(size, indexBuffer.length * 1.5);
    newSize += newSize % 2;
    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
      for (let i = 0; i < indexBuffer.length; i++) {
        newIndexBuffer[i] = indexBuffer[i];
      }
    } else {
      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
    }
    this.indexBuffer = newIndexBuffer;
  }
  packQuadIndex(indexBuffer, index, indicesOffset) {
    indexBuffer[index] = indicesOffset + 0;
    indexBuffer[index + 1] = indicesOffset + 1;
    indexBuffer[index + 2] = indicesOffset + 2;
    indexBuffer[index + 3] = indicesOffset + 0;
    indexBuffer[index + 4] = indicesOffset + 2;
    indexBuffer[index + 5] = indicesOffset + 3;
  }
  packIndex(element, indexBuffer, index, indicesOffset) {
    const indices = element.indices;
    const size = element.indexSize;
    const indexOffset = element.indexOffset;
    const attributeOffset = element.attributeOffset;
    for (let i = 0; i < size; i++) {
      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;
    }
  }
  /**
   * Destroys the batch and its resources.
   * @param options - destruction options
   * @param options.shader - whether to destroy the associated shader
   */
  destroy(options = {}) {
    if (this.batches === null) return;
    for (let i = 0; i < this.batchIndex; i++) {
      returnBatchToPool(this.batches[i]);
    }
    this.batches = null;
    this.geometry.destroy(true);
    this.geometry = null;
    if (options.shader) {
      this.shader?.destroy();
      this.shader = null;
    }
    for (let i = 0; i < this._elements.length; i++) {
      if (this._elements[i]) this._elements[i]._batch = null;
    }
    this._elements = null;
    this.indexBuffer = null;
    this.attributeBuffer.destroy();
    this.attributeBuffer = null;
  }
};
_Batcher.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let Batcher = _Batcher;

var BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
  return BufferUsage2;
})(BufferUsage || {});

class Buffer extends EventEmitter {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(options) {
    let { data, size } = options;
    const { usage, label, shrinkToFit } = options;
    super();
    /**
     * emits when the underlying buffer has changed shape (i.e. resized)
     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
     * @event change
     */
    /**
     * emits when the underlying buffer data has been updated. letting the renderer know
     * that it needs to update the buffer on the GPU
     * @event update
     */
    /**
     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU
     * @event destroy
     */
    /** @internal */
    this._gpuData = /* @__PURE__ */ Object.create(null);
    /** @internal */
    this._gcLastUsed = -1;
    /** If set to true, the buffer will be garbage collected automatically when it is not used. */
    this.autoGarbageCollect = true;
    /** a unique id for this uniform group used through the renderer */
    this.uid = uid$1("buffer");
    /**
     * a resource type, used to identify how to handle it when its in a bind group / shader resource
     * @internal
     */
    this._resourceType = "buffer";
    /**
     * the resource id used internally by the renderer to build bind group keys
     * @internal
     */
    this._resourceId = uid$1("resource");
    /**
     * used internally to know if a uniform group was used in the last render pass
     * @internal
     */
    this._touched = 0;
    /** @internal */
    this._updateID = 1;
    this._dataInt32 = null;
    /**
     * should the GPU buffer be shrunk when the data becomes smaller?
     * changing this will cause the buffer to be destroyed and a new one created on the GPU
     * this can be expensive, especially if the buffer is already big enough!
     * setting this to false will prevent the buffer from being shrunk. This will yield better performance
     * if you are constantly setting data that is changing size often.
     * @default true
     */
    this.shrinkToFit = true;
    /**
     * Has the buffer been destroyed?
     * @readonly
     */
    this.destroyed = false;
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this._data = data;
    size ?? (size = data?.byteLength);
    const mappedAtCreation = !!data;
    this.descriptor = {
      size,
      usage,
      mappedAtCreation,
      label
    };
    this.shrinkToFit = shrinkToFit ?? true;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(value) {
    this.setDataWithSize(value, value.length, true);
  }
  get dataInt32() {
    if (!this._dataInt32) {
      this._dataInt32 = new Int32Array(this.data.buffer);
    }
    return this._dataInt32;
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & BufferUsage.STATIC);
  }
  set static(value) {
    if (value) {
      this.descriptor.usage |= BufferUsage.STATIC;
    } else {
      this.descriptor.usage &= ~BufferUsage.STATIC;
    }
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(value, size, syncGPU) {
    this._updateID++;
    this._updateSize = size * value.BYTES_PER_ELEMENT;
    if (this._data === value) {
      if (syncGPU) this.emit("update", this);
      return;
    }
    const oldData = this._data;
    this._data = value;
    this._dataInt32 = null;
    if (!oldData || oldData.length !== value.length) {
      if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength) {
        if (syncGPU) this.emit("update", this);
      } else {
        this.descriptor.size = value.byteLength;
        this._resourceId = uid$1("resource");
        this.emit("change", this);
      }
      return;
    }
    if (syncGPU) this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(sizeInBytes) {
    this._updateSize = sizeInBytes ?? this._updateSize;
    this._updateID++;
    this.emit("update", this);
  }
  /** Unloads the buffer from the GPU */
  unload() {
    this.emit("unload", this);
    for (const key in this._gpuData) {
      this._gpuData[key]?.destroy();
    }
    this._gpuData = /* @__PURE__ */ Object.create(null);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = true;
    this.unload();
    this.emit("destroy", this);
    this.emit("change", this);
    this._data = null;
    this.descriptor = null;
    this.removeAllListeners();
  }
}

function ensureIsBuffer(buffer, index) {
  if (!(buffer instanceof Buffer)) {
    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer({
      data: buffer,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}

function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i = offset; i < data.length; i += stride) {
    const x = data[i];
    const y = data[i + 1];
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
    if (x < minX) minX = x;
    if (y < minY) minY = y;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}

function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
class Geometry extends EventEmitter {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(options = {}) {
    super();
    /** @internal */
    this._gpuData = /* @__PURE__ */ Object.create(null);
    /** If set to true, the resource will be garbage collected automatically when it is not used. */
    this.autoGarbageCollect = true;
    /** @internal */
    this._gcLastUsed = -1;
    /** The unique id of the geometry. */
    this.uid = uid$1("geometry");
    /**
     * the layout key will be generated by WebGPU all geometries that have the same structure
     * will have the same layout key. This is used to cache the pipeline layout
     * @internal
     */
    this._layoutKey = 0;
    /** the instance count of the geometry to draw */
    this.instanceCount = 1;
    this._bounds = new Bounds();
    this._boundsDirty = true;
    const { attributes, indexBuffer, topology } = options;
    this.buffers = [];
    this.attributes = {};
    if (attributes) {
      for (const i in attributes) {
        this.addAttribute(i, attributes[i]);
      }
    }
    this.instanceCount = options.instanceCount ?? 1;
    if (indexBuffer) {
      this.addIndex(indexBuffer);
    }
    this.topology = topology || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = true;
    this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id) {
    return this.attributes[id];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id) {
    return this.getAttribute(id).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const i in this.attributes) {
      const attribute = this.attributes[i];
      const buffer = attribute.buffer;
      return buffer.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(name, attributeOption) {
    const attribute = ensureIsAttribute(attributeOption);
    const bufferIndex = this.buffers.indexOf(attribute.buffer);
    if (bufferIndex === -1) {
      this.buffers.push(attribute.buffer);
      attribute.buffer.on("update", this.onBufferUpdate, this);
      attribute.buffer.on("change", this.onBufferUpdate, this);
    }
    this.attributes[name] = attribute;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(indexBuffer) {
    this.indexBuffer = ensureIsBuffer(indexBuffer, true);
    this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    if (!this._boundsDirty) return this._bounds;
    this._boundsDirty = false;
    return getGeometryBounds(this, "aPosition", this._bounds);
  }
  /** Unloads the geometry from the GPU. */
  unload() {
    this.emit("unload", this);
    for (const key in this._gpuData) {
      this._gpuData[key]?.destroy();
    }
    this._gpuData = /* @__PURE__ */ Object.create(null);
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(destroyBuffers = false) {
    this.emit("destroy", this);
    this.removeAllListeners();
    if (destroyBuffers) {
      this.buffers.forEach((buffer) => buffer.destroy());
    }
    this.unload();
    this.indexBuffer?.destroy();
    this.attributes = null;
    this.buffers = null;
    this.indexBuffer = null;
    this._bounds = null;
  }
}

const placeHolderBufferData = new Float32Array(1);
const placeHolderIndexData = new Uint32Array(1);
class BatchGeometry extends Geometry {
  constructor() {
    const vertexSize = 6;
    const attributeBuffer = new Buffer({
      data: placeHolderBufferData,
      label: "attribute-batch-buffer",
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
      shrinkToFit: false
    });
    const indexBuffer = new Buffer({
      data: placeHolderIndexData,
      label: "index-batch-buffer",
      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: false
    });
    const stride = vertexSize * 4;
    super({
      attributes: {
        aPosition: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 0
        },
        aUV: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 2 * 4
        },
        aColor: {
          buffer: attributeBuffer,
          format: "unorm8x4",
          stride,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: attributeBuffer,
          format: "uint16x2",
          stride,
          offset: 5 * 4
        }
      },
      indexBuffer
    });
  }
}

function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i in srcParts) {
      const id = i.toLocaleLowerCase();
      const part = parts[id];
      if (part) {
        let sanitisedPart = srcParts[i];
        if (i === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn$2(`${i} placement hook does not exist in shader`);
      }
    }
  }
}

const findHooksRx = /\{\{(.*?)\}\}/g;
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}

function extractInputs(fragmentSource, out) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractInputs(fragment.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}

function extractOutputs(fragmentSource, out) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractOutputs(fragment.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}

function injectBits(templateSrc, fragmentParts) {
  let out = templateSrc;
  for (const i in fragmentParts) {
    const parts = fragmentParts[i];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out = out.replace(`{{${i}}}`, `//-----${i} START-----//
${parts.join("\n")}
//----${i} FINISH----//`);
    } else {
      out = out.replace(`{{${i}}}`, "");
    }
  }
  return out;
}

const cacheMap = /* @__PURE__ */ Object.create(null);
const bitCacheMap = /* @__PURE__ */ new Map();
let CACHE_UID = 0;
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId]) return cacheMap[cacheId];
  const { vertex, fragment } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex, fragment, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId]) return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a, b) => a - b).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex, fragment, bits) {
  const vertexParts = compileHooks(vertex);
  const fragmentParts = compileHooks(fragment);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex, vertexParts),
    fragment: injectBits(fragment, fragmentParts)
  };
}

const vertexGPUTemplate = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
);
const fragmentGPUTemplate = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
);
const vertexGlTemplate = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
);
const fragmentGlTemplate = (
  /* glsl */
  `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
);

const globalUniformsBit = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
};
const globalUniformsBitGl = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};

function compileHighShaderGpuProgram({ bits, name }) {
  const source = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return GpuProgram.from({
    name,
    vertex: {
      source: source.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}

const colorBit = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};
const colorBitGl = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};

const textureBatchBitGpuCache = {};
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i = 0; i < maxTextures; i++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i = 0; i < maxTextures; i++) {
      if (i === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
const textureBatchBitGlCache = {};
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i = 0; i < maxTextures; i++) {
    if (i > 0) {
      src.push("else");
    }
    if (i < maxTextures - 1) {
      src.push(`if(vTextureId < ${i}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}

const roundPixelsBit = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};
const roundPixelsBitGl = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};

const batchSamplersUniformGroupHash = {};
function getBatchSamplersUniformGroup(maxTextures) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
  if (batchSamplersUniformGroup) return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures);
  for (let i = 0; i < maxTextures; i++) {
    sampleValues[i] = i;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}

class DefaultShader extends Shader {
  constructor(maxTextures) {
    const glProgram = compileHighShaderGlProgram({
      name: "batch",
      bits: [
        colorBitGl,
        generateTextureBatchBitGl(maxTextures),
        roundPixelsBitGl
      ]
    });
    const gpuProgram = compileHighShaderGpuProgram({
      name: "batch",
      bits: [
        colorBit,
        generateTextureBatchBit(maxTextures),
        roundPixelsBit
      ]
    });
    super({
      glProgram,
      gpuProgram,
      resources: {
        batchSamplers: getBatchSamplersUniformGroup(maxTextures)
      }
    });
    this.maxTextures = maxTextures;
  }
}

let defaultShader = null;
const _DefaultBatcher = class _DefaultBatcher extends Batcher {
  constructor(options) {
    super(options);
    this.geometry = new BatchGeometry();
    this.name = _DefaultBatcher.extension.name;
    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */
    this.vertexSize = 6;
    defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));
    this.shader = defaultShader;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(element, float32View, uint32View, index, textureId) {
    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
    const wt = element.transform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const { positions, uvs } = element;
    const argb = element.color;
    const offset = element.attributeOffset;
    const end = offset + element.attributeSize;
    for (let i = offset; i < end; i++) {
      const i2 = i * 2;
      const x = positions[i2];
      const y = positions[i2 + 1];
      float32View[index++] = a * x + c * y + tx;
      float32View[index++] = d * y + b * x + ty;
      float32View[index++] = uvs[i2];
      float32View[index++] = uvs[i2 + 1];
      uint32View[index++] = argb;
      uint32View[index++] = textureIdAndRound;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(element, float32View, uint32View, index, textureId) {
    const texture = element.texture;
    const wt = element.transform;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const bounds = element.bounds;
    const w0 = bounds.maxX;
    const w1 = bounds.minX;
    const h0 = bounds.maxY;
    const h1 = bounds.minY;
    const uvs = texture.uvs;
    const argb = element.color;
    const textureIdAndRound = textureId << 16 | element.roundPixels & 65535;
    float32View[index + 0] = a * w1 + c * h1 + tx;
    float32View[index + 1] = d * h1 + b * w1 + ty;
    float32View[index + 2] = uvs.x0;
    float32View[index + 3] = uvs.y0;
    uint32View[index + 4] = argb;
    uint32View[index + 5] = textureIdAndRound;
    float32View[index + 6] = a * w0 + c * h1 + tx;
    float32View[index + 7] = d * h1 + b * w0 + ty;
    float32View[index + 8] = uvs.x1;
    float32View[index + 9] = uvs.y1;
    uint32View[index + 10] = argb;
    uint32View[index + 11] = textureIdAndRound;
    float32View[index + 12] = a * w0 + c * h0 + tx;
    float32View[index + 13] = d * h0 + b * w0 + ty;
    float32View[index + 14] = uvs.x2;
    float32View[index + 15] = uvs.y2;
    uint32View[index + 16] = argb;
    uint32View[index + 17] = textureIdAndRound;
    float32View[index + 18] = a * w1 + c * h0 + tx;
    float32View[index + 19] = d * h0 + b * w1 + ty;
    float32View[index + 20] = uvs.x3;
    float32View[index + 21] = uvs.y3;
    uint32View[index + 22] = argb;
    uint32View[index + 23] = textureIdAndRound;
  }
  /**
   * Updates the maximum number of textures that can be used in the shader.
   * @param maxTextures - The maximum number of textures that can be used in the shader.
   * @internal
   */
  _updateMaxTextures(maxTextures) {
    if (this.shader.maxTextures === maxTextures) return;
    defaultShader = new DefaultShader(maxTextures);
    this.shader = defaultShader;
  }
  destroy() {
    this.shader = null;
    super.destroy();
  }
};
/** @ignore */
_DefaultBatcher.extension = {
  type: [
    ExtensionType.Batcher
  ],
  name: "default"
};
let DefaultBatcher = _DefaultBatcher;

class GCManagedHash {
  constructor(options) {
    // Exposed directly for GC system access
    this.items = /* @__PURE__ */ Object.create(null);
    const { renderer, type, onUnload, priority, name } = options;
    this._renderer = renderer;
    renderer.gc.addResourceHash(this, "items", type, priority ?? 0);
    this._onUnload = onUnload;
    this.name = name;
  }
  /**
   * Add an item to the hash. No-op if already added.
   * @param item
   * @returns true if the item was added, false if it was already in the hash
   */
  add(item) {
    if (this.items[item.uid]) return false;
    this.items[item.uid] = item;
    item.once("unload", this.remove, this);
    item._gcLastUsed = this._renderer.gc.now;
    return true;
  }
  remove(item, ...args) {
    if (!this.items[item.uid]) return;
    const gpuData = item._gpuData[this._renderer.uid];
    if (!gpuData) return;
    this._onUnload?.(item, ...args);
    gpuData.destroy();
    item._gpuData[this._renderer.uid] = null;
    this.items[item.uid] = null;
  }
  removeAll(...args) {
    Object.values(this.items).forEach((item) => item && this.remove(item, ...args));
  }
  destroy(...args) {
    this.removeAll(...args);
    this.items = /* @__PURE__ */ Object.create(null);
    this._renderer = null;
    this._onUnload = null;
  }
}

function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a = matrix.a;
  const b = matrix.b;
  const c = matrix.c;
  const d = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size) {
    const x = vertices[verticesOffset];
    const y = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a * x + c * y + tx;
    uvs[uvsOffset + 1] = b * x + d * y + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}

function transformVertices(vertices, m, offset, stride, size) {
  const a = m.a;
  const b = m.b;
  const c = m.c;
  const d = m.d;
  const tx = m.tx;
  const ty = m.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size || (size = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i = 0; i < size; i++) {
    const x = vertices[index];
    const y = vertices[index + 1];
    vertices[index] = a * x + c * y + tx;
    vertices[index + 1] = b * x + d * y + ty;
    index += stride;
  }
}

const identityMatrix = new Matrix();
class BatchableGraphics {
  constructor() {
    this.packAsQuad = false;
    this.batcherName = "default";
    this.topology = "triangle-list";
    this.applyTransform = true;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    if (this.renderable && this.applyTransform) {
      return this.renderable.groupBlendMode;
    }
    return "normal";
  }
  get color() {
    const rgb = this.baseColor;
    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
    const renderable = this.renderable;
    if (renderable) {
      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
    }
    return bgr + (this.alpha * 255 << 24);
  }
  get transform() {
    return this.renderable?.groupTransform || identityMatrix;
  }
  copyTo(gpuBuffer) {
    gpuBuffer.indexOffset = this.indexOffset;
    gpuBuffer.indexSize = this.indexSize;
    gpuBuffer.attributeOffset = this.attributeOffset;
    gpuBuffer.attributeSize = this.attributeSize;
    gpuBuffer.baseColor = this.baseColor;
    gpuBuffer.alpha = this.alpha;
    gpuBuffer.texture = this.texture;
    gpuBuffer.geometryData = this.geometryData;
    gpuBuffer.topology = this.topology;
  }
  reset() {
    this.applyTransform = true;
    this.renderable = null;
    this.topology = "triangle-list";
  }
  destroy() {
    this.renderable = null;
    this.texture = null;
    this.geometryData = null;
    this._batcher = null;
    this._batch = null;
  }
}

const buildCircle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "circle"
  },
  build(shape, points) {
    let x;
    let y;
    let dx;
    let dy;
    let rx;
    let ry;
    if (shape.type === "circle") {
      const circle = shape;
      rx = ry = circle.radius;
      if (rx <= 0) {
        return false;
      }
      x = circle.x;
      y = circle.y;
      dx = dy = 0;
    } else if (shape.type === "ellipse") {
      const ellipse = shape;
      rx = ellipse.halfWidth;
      ry = ellipse.halfHeight;
      if (rx <= 0 || ry <= 0) {
        return false;
      }
      x = ellipse.x;
      y = ellipse.y;
      dx = dy = 0;
    } else {
      const roundedRect = shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x = roundedRect.x + halfWidth;
      y = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (dx < 0 || dy < 0) {
      return false;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (m === 0) {
      return false;
    }
    if (n === 0) {
      points[0] = points[6] = x + dx;
      points[1] = points[3] = y + dy;
      points[2] = points[4] = x - dx;
      points[5] = points[7] = y - dy;
      return true;
    }
    let j1 = 0;
    let j2 = n * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m;
    let x0 = dx + rx;
    let y0 = dy;
    let x1 = x + x0;
    let x2 = x - x0;
    let y1 = y + y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j2] = y1;
    points[--j2] = x2;
    if (dy) {
      const y22 = y - y0;
      points[j3++] = x2;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x1;
    }
    for (let i = 1; i < n; i++) {
      const a = Math.PI / 2 * (i / n);
      const x02 = dx + Math.cos(a) * rx;
      const y02 = dy + Math.sin(a) * ry;
      const x12 = x + x02;
      const x22 = x - x02;
      const y12 = y + y02;
      const y22 = y - y02;
      points[j1++] = x12;
      points[j1++] = y12;
      points[--j2] = y12;
      points[--j2] = x22;
      points[j3++] = x22;
      points[j3++] = y22;
      points[--j4] = y22;
      points[--j4] = x12;
    }
    x0 = dx;
    y0 = dy + ry;
    x1 = x + x0;
    x2 = x - x0;
    y1 = y + y0;
    const y2 = y - y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j4] = y2;
    points[--j4] = x1;
    if (dx) {
      points[j1++] = x2;
      points[j1++] = y1;
      points[--j4] = y2;
      points[--j4] = x2;
    }
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    if (points.length === 0) {
      return;
    }
    let centerX = 0;
    let centerY = 0;
    for (let i = 0; i < points.length; i += 2) {
      centerX += points[i];
      centerY += points[i + 1];
    }
    centerX /= points.length / 2;
    centerY /= points.length / 2;
    let count = verticesOffset;
    vertices[count * verticesStride] = centerX;
    vertices[count * verticesStride + 1] = centerY;
    const centerIndex = count++;
    for (let i = 0; i < points.length; i += 2) {
      vertices[count * verticesStride] = points[i];
      vertices[count * verticesStride + 1] = points[i + 1];
      if (i > 0) {
        indices[indicesOffset++] = count;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count - 1;
      }
      count++;
    }
    indices[indicesOffset++] = centerIndex + 1;
    indices[indicesOffset++] = centerIndex;
    indices[indicesOffset++] = count - 1;
  }
};
const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };

const closePointEps = 1e-4;
const curveEps = 1e-4;

function getOrientationOfPoints(points) {
  const m = points.length;
  if (m < 6) {
    return 1;
  }
  let area = 0;
  for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {
    const x2 = points[i];
    const y2 = points[i + 1];
    area += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}

function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x - nx * innerWeight;
  const iy = y - ny * innerWeight;
  const ox = x + nx * outerWeight;
  const oy = y + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i = 1; i < length - 1; ++i) {
    x0 = points[(i - 1) * 2];
    y0 = points[(i - 1) * 2 + 1];
    x1 = points[i * 2];
    y1 = points[i * 2 + 1];
    x2 = points[(i + 1) * 2];
    y2 = points[(i + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i = indexStart; i < indexCount + indexStart - 2; ++i) {
    x0 = verts[i * 2];
    y0 = verts[i * 2 + 1];
    x1 = verts[(i + 1) * 2];
    y1 = verts[(i + 1) * 2 + 1];
    x2 = verts[(i + 2) * 2];
    y2 = verts[(i + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i, i + 1, i + 2);
  }
}

function buildPixelLine(points, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i = 0; i < length; i++) {
    verts.push(points[i * 2]);
    verts.push(points[i * 2 + 1]);
  }
  for (let i = 0; i < length - 1; i++) {
    indices.push(indexStart + i, indexStart + i + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}

function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = earcut(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i = 0; i < triangles.length; i += 3) {
    indices[indicesOffset++] = triangles[i] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i = 0; i < points.length; i += 2) {
    vertices[index] = points[i];
    vertices[index + 1] = points[i + 1];
    index += verticesStride;
  }
}

const emptyArray = [];
const buildPolygon = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "polygon"
  },
  build(shape, points) {
    for (let i = 0; i < shape.points.length; i++) {
      points[i] = shape.points[i];
    }
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
  }
};

const buildRectangle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "rectangle"
  },
  build(shape, points) {
    const rectData = shape;
    const x = rectData.x;
    const y = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    if (!(width > 0 && height > 0)) {
      return false;
    }
    points[0] = x;
    points[1] = y;
    points[2] = x + width;
    points[3] = y;
    points[4] = x + width;
    points[5] = y + height;
    points[6] = x;
    points[7] = y + height;
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count] = points[0];
    vertices[verticesOffset + count + 1] = points[1];
    count += verticesStride;
    vertices[verticesOffset + count] = points[2];
    vertices[verticesOffset + count + 1] = points[3];
    count += verticesStride;
    vertices[verticesOffset + count] = points[6];
    vertices[verticesOffset + count + 1] = points[7];
    count += verticesStride;
    vertices[verticesOffset + count] = points[4];
    vertices[verticesOffset + count + 1] = points[5];
    count += verticesStride;
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 3;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};

const buildTriangle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "triangle"
  },
  build(shape, points) {
    points[0] = shape.x;
    points[1] = shape.y;
    points[2] = shape.x2;
    points[3] = shape.y2;
    points[4] = shape.x3;
    points[5] = shape.y3;
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count] = points[0];
    vertices[verticesOffset + count + 1] = points[1];
    count += verticesStride;
    vertices[verticesOffset + count] = points[2];
    vertices[verticesOffset + count + 1] = points[3];
    count += verticesStride;
    vertices[verticesOffset + count] = points[4];
    vertices[verticesOffset + count + 1] = points[5];
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};

const emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
const _FillGradient = class _FillGradient {
  constructor(...args) {
    /**
     * Unique identifier for this gradient instance
     * @internal
     */
    this.uid = uid$1("fillGradient");
    /**
     * Internal tick counter to track changes in the gradient.
     * This is used to invalidate the gradient when the texture changes.
     * @internal
     */
    this._tick = 0;
    /** Type of gradient - currently only supports 'linear' */
    this.type = "linear";
    /** Array of color stops defining the gradient */
    this.colorStops = [];
    let options = ensureGradientOptions(args);
    const defaults = options.type === "radial" ? _FillGradient.defaultRadialOptions : _FillGradient.defaultLinearOptions;
    options = { ...defaults, ...definedProps(options) };
    this._textureSize = options.textureSize;
    this._wrapMode = options.wrapMode;
    if (options.type === "radial") {
      this.center = options.center;
      this.outerCenter = options.outerCenter ?? this.center;
      this.innerRadius = options.innerRadius;
      this.outerRadius = options.outerRadius;
      this.scale = options.scale;
      this.rotation = options.rotation;
    } else {
      this.start = options.start;
      this.end = options.end;
    }
    this.textureSpace = options.textureSpace;
    this.type = options.type;
    options.colorStops.forEach((stop) => {
      this.addColorStop(stop.offset, stop.color);
    });
  }
  /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */
  addColorStop(offset, color) {
    this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
    return this;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildLinearGradient() {
    if (this.texture) return;
    let { x: x0, y: y0 } = this.start;
    let { x: x1, y: y1 } = this.end;
    let dx = x1 - x0;
    let dy = y1 - y0;
    const flip = dx < 0 || dy < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (dx < 0) {
        const temp = x0;
        x0 = x1;
        x1 = temp;
        dx *= -1;
      }
      if (dy < 0) {
        const temp = y0;
        y0 = y1;
        y1 = temp;
        dy *= -1;
      }
    }
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context } = getCanvas(defaultSize, 1);
    const gradient = !flip ? context.createLinearGradient(0, 0, this._textureSize, 0) : context.createLinearGradient(this._textureSize, 0, 0, 0);
    addColorStops(gradient, colorStops);
    context.fillStyle = gradient;
    context.fillRect(0, 0, defaultSize, 1);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const m = new Matrix();
    m.scale(dist / defaultSize, 1);
    m.rotate(angle);
    m.translate(x0, y0);
    if (this.textureSpace === "local") {
      m.scale(defaultSize, defaultSize);
    }
    this.transform = m;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildGradient() {
    if (!this.texture) this._tick++;
    if (this.type === "linear") {
      this.buildLinearGradient();
    } else {
      this.buildRadialGradient();
    }
  }
  /**
   * Builds the internal texture and transform for the radial gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildRadialGradient() {
    if (this.texture) return;
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context } = getCanvas(defaultSize, defaultSize);
    const { x: x0, y: y0 } = this.center;
    const { x: x1, y: y1 } = this.outerCenter;
    const r0 = this.innerRadius;
    const r1 = this.outerRadius;
    const ox = x1 - r1;
    const oy = y1 - r1;
    const scale = defaultSize / (r1 * 2);
    const cx = (x0 - ox) * scale;
    const cy = (y0 - oy) * scale;
    const gradient = context.createRadialGradient(
      cx,
      cy,
      r0 * scale,
      (x1 - ox) * scale,
      (y1 - oy) * scale,
      r1 * scale
    );
    addColorStops(gradient, colorStops);
    context.fillStyle = colorStops[colorStops.length - 1].color;
    context.fillRect(0, 0, defaultSize, defaultSize);
    context.fillStyle = gradient;
    context.translate(cx, cy);
    context.rotate(this.rotation);
    context.scale(1, this.scale);
    context.translate(-cx, -cy);
    context.fillRect(0, 0, defaultSize, defaultSize);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const m = new Matrix();
    m.scale(1 / scale, 1 / scale);
    m.translate(ox, oy);
    if (this.textureSpace === "local") {
      m.scale(defaultSize, defaultSize);
    }
    this.transform = m;
  }
  /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture?.destroy(true);
    this.texture = null;
    this.transform = null;
    this.colorStops = [];
    this.start = null;
    this.end = null;
    this.center = null;
    this.outerCenter = null;
  }
  /**
   * Returns a unique key for this gradient instance.
   * This key is used for caching and texture management.
   * @returns {string} Unique key for the gradient
   */
  get styleKey() {
    return `fill-gradient-${this.uid}-${this._tick}`;
  }
};
/** Default options for creating a gradient fill */
_FillGradient.defaultLinearOptions = {
  start: { x: 0, y: 0 },
  end: { x: 0, y: 1 },
  colorStops: [],
  textureSpace: "local",
  type: "linear",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
/** Default options for creating a radial gradient fill */
_FillGradient.defaultRadialOptions = {
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0,
  outerRadius: 0.5,
  colorStops: [],
  scale: 1,
  textureSpace: "local",
  type: "radial",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
let FillGradient = _FillGradient;
function addColorStops(gradient, colorStops) {
  for (let i = 0; i < colorStops.length; i++) {
    const stop = colorStops[i];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = DOMAdapter.get().createCanvas(width, height);
  const context = canvas.getContext("2d");
  return { canvas, context };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    deprecation("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}

const tempTextureMatrix$2 = new Matrix();
const tempRect$2 = new Rectangle();
function generateTextureMatrix(out, style, shape, matrix) {
  const textureMatrix = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect$2);
    if (style.width) {
      bounds.pad(style.width);
    }
    const { x: tx, y: ty } = bounds;
    const sx = 1 / bounds.width;
    const sy = 1 / bounds.height;
    const mTx = -tx * sx;
    const mTy = -ty * sy;
    const a1 = textureMatrix.a;
    const b1 = textureMatrix.b;
    const c1 = textureMatrix.c;
    const d1 = textureMatrix.d;
    textureMatrix.a *= sx;
    textureMatrix.b *= sx;
    textureMatrix.c *= sy;
    textureMatrix.d *= sy;
    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
  }
  const sourceStyle = style.texture.source.style;
  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
    sourceStyle.addressMode = "repeat";
    sourceStyle.update();
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix$2.copyFrom(matrix).invert());
  }
  return textureMatrix;
}

const shapeBuilders = {};
extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
const tempRect$1 = new Rectangle();
const tempTextureMatrix$1 = new Matrix();
function buildContextBatches(context, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i = 0; i < context.instructions.length; i++) {
    const instruction = context.instructions[i];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect$1;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  if (!build.build(rect, points)) {
    return;
  }
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const texture = data.image;
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const points = [];
    const build = shapeBuilders[shape.type];
    if (!build.build(shape, points)) {
      return;
    }
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    let topology = "triangle-list";
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        buildLine(points, lineStyle, false, close, vertices, indices);
      } else {
        buildPixelLine(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = generateTextureMatrix(tempTextureMatrix$1, style, shape, matrix);
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k = 0; k < holePrimitives.length; k++) {
    const holePrimitive = holePrimitives[k].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    if (holeBuilder.build(holePrimitive, holePoints)) {
      holeArrays.push(holePoints);
    }
  }
  return holeArrays;
}

class GpuGraphicsContext {
  constructor() {
    this.batches = [];
    this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
  reset() {
    if (this.batches) {
      this.batches.forEach((batch) => {
        BigPool.return(batch);
      });
    }
    if (this.graphicsData) {
      BigPool.return(this.graphicsData);
    }
    this.isBatchable = false;
    this.context = null;
    this.batches.length = 0;
    this.geometryData.indices.length = 0;
    this.geometryData.vertices.length = 0;
    this.geometryData.uvs.length = 0;
    this.graphicsData = null;
  }
  destroy() {
    this.reset();
    this.batches = null;
    this.geometryData = null;
  }
}
class GraphicsContextRenderData {
  constructor() {
    this.instructions = new InstructionSet();
  }
  init(options) {
    const maxTextures = options.maxTextures;
    this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new DefaultBatcher({ maxTextures });
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
    return this.batcher.geometry;
  }
  destroy() {
    this.batcher.destroy();
    this.instructions.destroy();
    this.batcher = null;
    this.instructions = null;
  }
}
const _GraphicsContextSystem = class _GraphicsContextSystem {
  constructor(renderer) {
    this._renderer = renderer;
    this._managedContexts = new GCManagedHash({ renderer, type: "resource", name: "graphicsContext" });
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(options) {
    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;
  }
  /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */
  getContextRenderData(context) {
    return context._gpuData[this._renderer.uid].graphicsData || this._initContextRenderData(context);
  }
  /**
   * Updates the GPU context for a given GraphicsContext.
   * If the context is dirty, it will rebuild the batches and geometry data.
   * @param context - The GraphicsContext to update.
   * @returns The updated GpuGraphicsContext.
   * @internal
   */
  updateGpuContext(context) {
    const hasContext = !!context._gpuData[this._renderer.uid];
    const gpuContext = context._gpuData[this._renderer.uid] || this._initContext(context);
    if (context.dirty || !hasContext) {
      if (hasContext) {
        gpuContext.reset();
      }
      buildContextBatches(context, gpuContext);
      const batchMode = context.batchMode;
      if (context.customShader || batchMode === "no-batch") {
        gpuContext.isBatchable = false;
      } else if (batchMode === "auto") {
        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
      } else {
        gpuContext.isBatchable = true;
      }
      context.dirty = false;
    }
    return gpuContext;
  }
  /**
   * Returns the GpuGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the GpuGraphicsContext for.
   * @returns The GpuGraphicsContext for the given GraphicsContext.
   * @internal
   */
  getGpuContext(context) {
    return context._gpuData[this._renderer.uid] || this._initContext(context);
  }
  _initContextRenderData(context) {
    const graphicsData = BigPool.get(GraphicsContextRenderData, {
      maxTextures: this._renderer.limits.maxBatchableTextures
    });
    const gpuContext = context._gpuData[this._renderer.uid];
    const { batches, geometryData } = gpuContext;
    gpuContext.graphicsData = graphicsData;
    const vertexSize = geometryData.vertices.length;
    const indexSize = geometryData.indices.length;
    for (let i = 0; i < batches.length; i++) {
      batches[i].applyTransform = false;
    }
    const batcher = graphicsData.batcher;
    batcher.ensureAttributeBuffer(vertexSize);
    batcher.ensureIndexBuffer(indexSize);
    batcher.begin();
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      batcher.add(batch);
    }
    batcher.finish(graphicsData.instructions);
    const geometry = batcher.geometry;
    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
    const drawBatches = batcher.batches;
    for (let i = 0; i < drawBatches.length; i++) {
      const batch = drawBatches[i];
      batch.bindGroup = getTextureBatchBindGroup(
        batch.textures.textures,
        batch.textures.count,
        this._renderer.limits.maxBatchableTextures
      );
    }
    return graphicsData;
  }
  _initContext(context) {
    const gpuContext = new GpuGraphicsContext();
    gpuContext.context = context;
    context._gpuData[this._renderer.uid] = gpuContext;
    this._managedContexts.add(context);
    return gpuContext;
  }
  destroy() {
    this._managedContexts.destroy();
    this._renderer = null;
  }
};
/** @ignore */
_GraphicsContextSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "graphicsContext"
};
/** The default options for the GraphicsContextSystem. */
_GraphicsContextSystem.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let GraphicsContextSystem = _GraphicsContextSystem;

const RECURSION_LIMIT$2 = 8;
const FLT_EPSILON$1 = 11920929e-14;
const PATH_DISTANCE_EPSILON$1 = 1;
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON$1 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive$1(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT$2) {
    return;
  }
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    if (d2 > FLT_EPSILON$1 && d3 > FLT_EPSILON$1) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else if (d2 > FLT_EPSILON$1) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else if (d3 > FLT_EPSILON$1) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive$1(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive$1(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);
}

const RECURSION_LIMIT$1 = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
  if (level > RECURSION_LIMIT$1) {
    return;
  }
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d > FLT_EPSILON) {
    if (d * d <= distanceTolerance * (dx * dx + dy * dy)) {
      {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
}

function buildArc(points, x, y, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f = dist / steps;
  let t = start;
  f *= clockwise ? -1 : 1;
  for (let i = 0; i < steps + 1; i++) {
    const cs = Math.cos(t);
    const sn = Math.sin(t);
    const nx = x + cs * radius;
    const ny = y + sn * radius;
    points.push(nx, ny);
    t += f;
  }
}

function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}

const TAU = Math.PI * 2;
const out = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
};
const mapToEllipse = ({ x, y }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
  x *= rx;
  y *= ry;
  const xp = cosPhi * x - sinPhi * y;
  const yp = sinPhi * x + cosPhi * y;
  out2.x = xp + centerX;
  out2.y = yp + centerY;
  return out2;
};
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a,
      y: y1 + x1 * a
    },
    {
      x: x2 + y2 * a,
      y: y2 - x2 * a
    },
    {
      x: x2,
      y: y2
    }
  ];
}
const vectorAngle = (ux, uy, vx, vy) => {
  const sign = ux * vy - uy * vx < 0 ? -1 : 1;
  let dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
const getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
  const rxSq = Math.pow(rx, 2);
  const rySq = Math.pow(ry, 2);
  const pxpSq = Math.pow(pxp, 2);
  const pypSq = Math.pow(pyp, 2);
  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxSq * pypSq + rySq * pxpSq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  const centerXp = radicant * rx / ry * pyp;
  const centerYp = radicant * -ry / rx * pxp;
  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
  const vx1 = (pxp - centerXp) / rx;
  const vy1 = (pyp - centerYp) / ry;
  const vx2 = (-pxp - centerXp) / rx;
  const vy2 = (-pyp - centerYp) / ry;
  const ang1 = vectorAngle(1, 0, vx1, vy1);
  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  out2.centerX = centerX;
  out2.centerY = centerY;
  out2.ang1 = ang1;
  out2.ang2 = ang2;
};
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i = 0; i < segments; i++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x,
      y
    );
    lastX = x;
    lastY = y;
    ang1 += ang2;
  }
}

function roundedShapeArc(g, points, radius) {
  const vecFrom = (p, pp) => {
    const x = pp.x - p.x;
    const y = pp.y - p.y;
    const len = Math.sqrt(x * x + y * y);
    const nx = x / len;
    const ny = y / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i, p) => {
    if (i === 0) {
      g.moveTo(p.x, p.y);
    } else {
      g.lineTo(p.x, p.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i === 0) {
      g.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g, points, radius, smoothness) {
  const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t) => ({
    x: p1.x + (p2.x - p1.x) * t,
    y: p1.y + (p2.y - p1.y) * t
  });
  const numPoints = points.length;
  for (let i = 0; i < numPoints; i++) {
    const thisPoint = points[(i + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i === 0) {
        g.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i];
    const nextPoint = points[(i + 2) % numPoints];
    const lastEdgeLength = distance(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i === 0) {
      g.moveTo(start.x, start.y);
    } else {
      g.lineTo(start.x, start.y);
    }
    g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}

const tempRectangle = new Rectangle();
class ShapePath {
  constructor(graphicsPath2D) {
    /** The list of shape primitives that make up the path. */
    this.shapePrimitives = [];
    this._currentPoly = null;
    this._bounds = new Bounds();
    this._graphicsPath2D = graphicsPath2D;
    this.signed = graphicsPath2D.checkForHoles;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x, y) {
    this.startPoly(x, y);
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x, y) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x || fromY !== y) {
      points.push(x, y);
    }
    return this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    this._ensurePoly(false);
    const points = this._currentPoly.points;
    buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);
    return this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    buildArcTo(points, x1, y1, x2, y2, radius);
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    const points = this._currentPoly.points;
    buildArcToSvg(
      points,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      x,
      y,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveBezier(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      cp2x,
      cp2y,
      x,
      y,
      smoothness
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveQuadratic(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      x,
      y,
      smoothing
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.endPoly(true);
    return this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(path, transform) {
    this.endPoly();
    if (transform && !transform.isIdentity()) {
      path = path.clone(true);
      path.transform(transform);
    }
    const shapePrimitives = this.shapePrimitives;
    const start = shapePrimitives.length;
    for (let i = 0; i < path.instructions.length; i++) {
      const instruction = path.instructions[i];
      this[instruction.action](...instruction.data);
    }
    if (path.checkForHoles && shapePrimitives.length - start > 1) {
      let mainShape = null;
      for (let i = start; i < shapePrimitives.length; i++) {
        const shapePrimitive = shapePrimitives[i];
        if (shapePrimitive.shape.type === "polygon") {
          const polygon = shapePrimitive.shape;
          const mainPolygon = mainShape?.shape;
          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
            mainShape.holes || (mainShape.holes = []);
            mainShape.holes.push(shapePrimitive);
            shapePrimitives.copyWithin(i, i + 1);
            shapePrimitives.length--;
            i--;
          } else {
            mainShape = shapePrimitive;
          }
        }
      }
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(closePath = false) {
    this.endPoly(closePath);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h, transform) {
    this.drawShape(new Rectangle(x, y, w, h), transform);
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius, transform) {
    this.drawShape(new Circle(x, y, radius), transform);
    return this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(points, close, transform) {
    const polygon = new Polygon(points);
    polygon.closePath = close;
    this.drawShape(polygon, transform);
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x, y, radius, sides, rotation = 0, transform) {
    sides = Math.max(sides | 0, 3);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const polygon = [];
    for (let i = 0; i < sides; i++) {
      const angle = startAngle - i * delta;
      polygon.push(
        x + radius * Math.cos(angle),
        y + radius * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {
    sides = Math.max(sides | 0, 3);
    if (corner <= 0) {
      return this.regularPoly(x, y, radius, sides, rotation);
    }
    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
    corner = Math.min(corner, sideLength);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const internalAngle = (sides - 2) * Math.PI / sides / 2;
    for (let i = 0; i < sides; i++) {
      const angle = i * delta + startAngle;
      const x0 = x + radius * Math.cos(angle);
      const y0 = y + radius * Math.sin(angle);
      const a1 = angle + Math.PI + internalAngle;
      const a2 = angle - Math.PI - internalAngle;
      const x1 = x0 + corner * Math.cos(a1);
      const y1 = y0 + corner * Math.sin(a1);
      const x3 = x0 + corner * Math.cos(a2);
      const y3 = y0 + corner * Math.sin(a2);
      if (i === 0) {
        this.moveTo(x1, y1);
      } else {
        this.lineTo(x1, y1);
      }
      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic = false, smoothness) {
    if (points.length < 3) {
      return this;
    }
    if (useQuadratic) {
      roundedShapeQuadraticCurve(this, points, radius, smoothness);
    } else {
      roundedShapeArc(this, points, radius);
    }
    return this.closePath();
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x, y, width, height, fillet) {
    if (fillet === 0) {
      return this.rect(x, y, width, height);
    }
    const maxFillet = Math.min(width, height) / 2;
    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
    const right = x + width;
    const bottom = y + height;
    const dir = inset < 0 ? -inset : 0;
    const size = Math.abs(inset);
    return this.moveTo(x, y + size).arcTo(x + dir, y + dir, x + size, y, size).lineTo(right - size, y).arcTo(right - dir, y + dir, right, y + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x + width - size, bottom, size).lineTo(x + size, bottom).arcTo(x + dir, bottom - dir, x, bottom - size, size).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x, y, width, height, chamfer, transform) {
    if (chamfer <= 0) {
      return this.rect(x, y, width, height);
    }
    const inset = Math.min(chamfer, Math.min(width, height) / 2);
    const right = x + width;
    const bottom = y + height;
    const points = [
      x + inset,
      y,
      right - inset,
      y,
      right,
      y + inset,
      right,
      bottom - inset,
      right - inset,
      bottom,
      x + inset,
      bottom,
      x,
      bottom - inset,
      x,
      y + inset
    ];
    for (let i = points.length - 1; i >= 2; i -= 2) {
      if (points[i] === points[i - 2] && points[i - 1] === points[i - 3]) {
        points.splice(i - 1, 2);
      }
    }
    return this.poly(points, true, transform);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x, y, radiusX, radiusY, transform) {
    this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x, y, w, h, radius, transform) {
    this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);
    return this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(shape, matrix) {
    this.endPoly();
    this.shapePrimitives.push({ shape, transform: matrix });
    return this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(x, y) {
    let currentPoly = this._currentPoly;
    if (currentPoly) {
      this.endPoly();
    }
    currentPoly = new Polygon();
    currentPoly.points.push(x, y);
    this._currentPoly = currentPoly;
    return this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(closePath = false) {
    const shape = this._currentPoly;
    if (shape && shape.points.length > 2) {
      shape.closePath = closePath;
      this.shapePrimitives.push({ shape });
    }
    this._currentPoly = null;
    return this;
  }
  _ensurePoly(start = true) {
    if (this._currentPoly) return;
    this._currentPoly = new Polygon();
    if (start) {
      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (lastShape) {
        let lx = lastShape.shape.x;
        let ly = lastShape.shape.y;
        if (lastShape.transform && !lastShape.transform.isIdentity()) {
          const t = lastShape.transform;
          const tempX = lx;
          lx = t.a * lx + t.c * ly + t.tx;
          ly = t.b * tempX + t.d * ly + t.ty;
        }
        this._currentPoly.points.push(lx, ly);
      } else {
        this._currentPoly.points.push(0, 0);
      }
    }
  }
  /** Builds the path. */
  buildPath() {
    const path = this._graphicsPath2D;
    this.shapePrimitives.length = 0;
    this._currentPoly = null;
    for (let i = 0; i < path.instructions.length; i++) {
      const instruction = path.instructions[i];
      this[instruction.action](...instruction.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const bounds = this._bounds;
    bounds.clear();
    const shapePrimitives = this.shapePrimitives;
    for (let i = 0; i < shapePrimitives.length; i++) {
      const shapePrimitive = shapePrimitives[i];
      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
      if (shapePrimitive.transform) {
        bounds.addRect(boundsRect, shapePrimitive.transform);
      } else {
        bounds.addRect(boundsRect);
      }
    }
    return bounds;
  }
}

class GraphicsPath {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */
  constructor(instructions, signed = false) {
    this.instructions = [];
    /** unique id for this graphics path */
    this.uid = uid$1("graphicsPath");
    this._dirty = true;
    this.checkForHoles = signed;
    if (typeof instructions === "string") {
      parseSVGPath(instructions, this);
    } else {
      this.instructions = instructions?.slice() ?? [];
    }
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    if (!this._shapePath) {
      this._shapePath = new ShapePath(this);
    }
    if (this._dirty) {
      this._dirty = false;
      this._shapePath.buildPath();
    }
    return this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(path, transform) {
    path = path.clone();
    this.instructions.push({ action: "addPath", data: [path, transform] });
    this._dirty = true;
    return this;
  }
  arc(...args) {
    this.instructions.push({ action: "arc", data: args });
    this._dirty = true;
    return this;
  }
  arcTo(...args) {
    this.instructions.push({ action: "arcTo", data: args });
    this._dirty = true;
    return this;
  }
  arcToSvg(...args) {
    this.instructions.push({ action: "arcToSvg", data: args });
    this._dirty = true;
    return this;
  }
  bezierCurveTo(...args) {
    this.instructions.push({ action: "bezierCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cp1x = 0;
    let cp1y = 0;
    if (!last || last.action !== "bezierCurveTo") {
      cp1x = lastPoint.x;
      cp1y = lastPoint.y;
    } else {
      cp1x = last.data[2];
      cp1y = last.data[3];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cp1x = currentX + (currentX - cp1x);
      cp1y = currentY + (currentY - cp1y);
    }
    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.instructions.push({ action: "closePath", data: [] });
    this._dirty = true;
    return this;
  }
  ellipse(...args) {
    this.instructions.push({ action: "ellipse", data: args });
    this._dirty = true;
    return this;
  }
  lineTo(...args) {
    this.instructions.push({ action: "lineTo", data: args });
    this._dirty = true;
    return this;
  }
  moveTo(...args) {
    this.instructions.push({ action: "moveTo", data: args });
    return this;
  }
  quadraticCurveTo(...args) {
    this.instructions.push({ action: "quadraticCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(x, y, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cpx1 = 0;
    let cpy1 = 0;
    if (!last || last.action !== "quadraticCurveTo") {
      cpx1 = lastPoint.x;
      cpy1 = lastPoint.y;
    } else {
      cpx1 = last.data[0];
      cpy1 = last.data[1];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cpx1 = currentX + (currentX - cpx1);
      cpy1 = currentY + (currentY - cpy1);
    }
    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x, y, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h, transform) {
    this.instructions.push({ action: "rect", data: [x, y, w, h, transform] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius, transform) {
    this.instructions.push({ action: "circle", data: [x, y, radius, transform] });
    this._dirty = true;
    return this;
  }
  roundRect(...args) {
    this.instructions.push({ action: "roundRect", data: args });
    this._dirty = true;
    return this;
  }
  poly(...args) {
    this.instructions.push({ action: "poly", data: args });
    this._dirty = true;
    return this;
  }
  regularPoly(...args) {
    this.instructions.push({ action: "regularPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundPoly(...args) {
    this.instructions.push({ action: "roundPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundShape(...args) {
    this.instructions.push({ action: "roundShape", data: args });
    this._dirty = true;
    return this;
  }
  filletRect(...args) {
    this.instructions.push({ action: "filletRect", data: args });
    this._dirty = true;
    return this;
  }
  chamferRect(...args) {
    this.instructions.push({ action: "chamferRect", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(x, y, points, radius, innerRadius, rotation, transform) {
    innerRadius || (innerRadius = radius / 2);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const len = points * 2;
    const delta = Math.PI * 2 / len;
    const polygon = [];
    for (let i = 0; i < len; i++) {
      const r = i % 2 ? innerRadius : radius;
      const angle = i * delta + startAngle;
      polygon.push(
        x + r * Math.cos(angle),
        y + r * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(deep = false) {
    const newGraphicsPath2D = new GraphicsPath();
    newGraphicsPath2D.checkForHoles = this.checkForHoles;
    if (!deep) {
      newGraphicsPath2D.instructions = this.instructions.slice();
    } else {
      for (let i = 0; i < this.instructions.length; i++) {
        const instruction = this.instructions[i];
        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
      }
    }
    return newGraphicsPath2D;
  }
  clear() {
    this.instructions.length = 0;
    this._dirty = true;
    return this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(matrix) {
    if (matrix.isIdentity()) return this;
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let x = 0;
    let y = 0;
    let cpx1 = 0;
    let cpy1 = 0;
    let cpx2 = 0;
    let cpy2 = 0;
    let rx = 0;
    let ry = 0;
    for (let i = 0; i < this.instructions.length; i++) {
      const instruction = this.instructions[i];
      const data = instruction.data;
      switch (instruction.action) {
        case "moveTo":
        case "lineTo":
          x = data[0];
          y = data[1];
          data[0] = a * x + c * y + tx;
          data[1] = b * x + d * y + ty;
          break;
        case "bezierCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          cpx2 = data[2];
          cpy2 = data[3];
          x = data[4];
          y = data[5];
          data[0] = a * cpx1 + c * cpy1 + tx;
          data[1] = b * cpx1 + d * cpy1 + ty;
          data[2] = a * cpx2 + c * cpy2 + tx;
          data[3] = b * cpx2 + d * cpy2 + ty;
          data[4] = a * x + c * y + tx;
          data[5] = b * x + d * y + ty;
          break;
        case "quadraticCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          x = data[2];
          y = data[3];
          data[0] = a * cpx1 + c * cpy1 + tx;
          data[1] = b * cpx1 + d * cpy1 + ty;
          data[2] = a * x + c * y + tx;
          data[3] = b * x + d * y + ty;
          break;
        case "arcToSvg":
          x = data[5];
          y = data[6];
          rx = data[0];
          ry = data[1];
          data[0] = a * rx + c * ry;
          data[1] = b * rx + d * ry;
          data[5] = a * x + c * y + tx;
          data[6] = b * x + d * y + ty;
          break;
        case "circle":
          data[4] = adjustTransform(data[3], matrix);
          break;
        case "rect":
          data[4] = adjustTransform(data[4], matrix);
          break;
        case "ellipse":
          data[8] = adjustTransform(data[8], matrix);
          break;
        case "roundRect":
          data[5] = adjustTransform(data[5], matrix);
          break;
        case "addPath":
          data[0].transform(matrix);
          break;
        case "poly":
          data[2] = adjustTransform(data[2], matrix);
          break;
        default:
          warn$2("unknown transform action", instruction.action);
          break;
      }
    }
    this._dirty = true;
    return this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(out) {
    let index = this.instructions.length - 1;
    let lastInstruction = this.instructions[index];
    if (!lastInstruction) {
      out.x = 0;
      out.y = 0;
      return out;
    }
    while (lastInstruction.action === "closePath") {
      index--;
      if (index < 0) {
        out.x = 0;
        out.y = 0;
        return out;
      }
      lastInstruction = this.instructions[index];
    }
    switch (lastInstruction.action) {
      case "moveTo":
      case "lineTo":
        out.x = lastInstruction.data[0];
        out.y = lastInstruction.data[1];
        break;
      case "quadraticCurveTo":
        out.x = lastInstruction.data[2];
        out.y = lastInstruction.data[3];
        break;
      case "bezierCurveTo":
        out.x = lastInstruction.data[4];
        out.y = lastInstruction.data[5];
        break;
      case "arc":
      case "arcToSvg":
        out.x = lastInstruction.data[5];
        out.y = lastInstruction.data[6];
        break;
      case "addPath":
        lastInstruction.data[0].getLastPoint(out);
        break;
    }
    return out;
  }
}
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}

function parseSVGFloatAttribute(svg, id, defaultValue) {
  const value = svg.getAttribute(id);
  return value ? Number(value) : defaultValue;
}

function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i = 0; i < definitions.length; i++) {
    const definition = definitions[i];
    for (let j = 0; j < definition.children.length; j++) {
      const child = definition.children[j];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient();
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = parseSVGFloatAttribute(child, "x1", 0);
  const y0 = parseSVGFloatAttribute(child, "y1", 0);
  const x1 = parseSVGFloatAttribute(child, "x2", 1);
  const y1 = parseSVGFloatAttribute(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new FillGradient(
    x0,
    y0,
    x1,
    y1,
    gradientUnit === "objectBoundingBox" ? "local" : "global"
  );
  for (let k = 0; k < child.children.length; k++) {
    const stop = child.children[k];
    const offset = parseSVGFloatAttribute(stop, "offset", 0);
    const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  warn$2("[SVG Parser] Radial gradients are not yet supported");
  return new FillGradient(0, 0, 1, 0);
}

function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}

const styleAttributes = {
  // Fill properties
  fill: { type: "paint", default: 0 },
  // Fill color/gradient
  "fill-opacity": { type: "number", default: 1 },
  // Fill transparency
  // Stroke properties
  stroke: { type: "paint", default: 0 },
  // Stroke color/gradient
  "stroke-width": { type: "number", default: 1 },
  // Width of stroke
  "stroke-opacity": { type: "number", default: 1 },
  // Stroke transparency
  "stroke-linecap": { type: "string", default: "butt" },
  // End cap style: butt, round, square
  "stroke-linejoin": { type: "string", default: "miter" },
  // Join style: miter, round, bevel
  "stroke-miterlimit": { type: "number", default: 10 },
  // Limit on miter join sharpness
  "stroke-dasharray": { type: "string", default: "none" },
  // Dash pattern
  "stroke-dashoffset": { type: "number", default: 0 },
  // Offset for dash pattern
  // Global properties
  opacity: { type: "number", default: 1 }
  // Overall opacity
};
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key in styleAttributes) {
    const attribute = svg.getAttribute(key);
    if (attribute) {
      parseAttribute(session, result, key, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i = 0; i < styleParts.length; i++) {
      const stylePart = styleParts[i].trim();
      const [key, value] = stylePart.split(":");
      if (styleAttributes[key]) {
        parseAttribute(session, result, key, value.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id, value) {
  switch (id) {
    case "stroke":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.strokeStyle.fill = session.defs[id2];
        } else {
          result.strokeStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value);
      break;
    case "fill":
      if (value !== "none") {
        if (value.startsWith("url(")) {
          const id2 = extractSvgUrlId(value);
          result.fillStyle.fill = session.defs[id2];
        } else {
          result.fillStyle.color = Color.shared.setValue(value).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value);
      result.strokeStyle.alpha = Number(value);
      break;
  }
}

function checkForNestedPattern(subpathsWithArea) {
  if (subpathsWithArea.length <= 2) {
    return true;
  }
  const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);
  const [largestArea, secondArea] = areas;
  const smallestArea = areas[areas.length - 1];
  const largestToSecondRatio = largestArea / secondArea;
  const secondToSmallestRatio = secondArea / smallestArea;
  if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
    return false;
  }
  return true;
}

function extractSubpaths(pathData) {
  const parts = pathData.split(/(?=[Mm])/);
  const subpaths = parts.filter((part) => part.trim().length > 0);
  return subpaths;
}
function calculatePathArea(pathData) {
  const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!coords || coords.length < 4) return 0;
  const numbers = coords.map(Number);
  const xs = [];
  const ys = [];
  for (let i = 0; i < numbers.length; i += 2) {
    if (i + 1 < numbers.length) {
      xs.push(numbers[i]);
      ys.push(numbers[i + 1]);
    }
  }
  if (xs.length === 0 || ys.length === 0) return 0;
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const area = (maxX - minX) * (maxY - minY);
  return area;
}
function appendSVGPath(pathData, graphicsPath) {
  const tempPath = new GraphicsPath(pathData, false);
  for (const instruction of tempPath.instructions) {
    graphicsPath.instructions.push(instruction);
  }
}

function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new GraphicsPath()
  };
  parseSVGDefinitions(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child.nodeName.toLowerCase() === "defs") continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x;
  let y;
  let x1;
  let y1;
  let x2;
  let y2;
  let cx;
  let cy;
  let r;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path": {
      d = svg.getAttribute("d");
      const fillRule = svg.getAttribute("fill-rule");
      const subpaths = extractSubpaths(d);
      const hasExplicitEvenodd = fillRule === "evenodd";
      const hasMultipleSubpaths = subpaths.length > 1;
      const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
      if (shouldProcessHoles) {
        const subpathsWithArea = subpaths.map((subpath) => ({
          path: subpath,
          area: calculatePathArea(subpath)
        }));
        subpathsWithArea.sort((a, b) => b.area - a.area);
        const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
        if (useMultipleHolesApproach) {
          for (let i = 0; i < subpathsWithArea.length; i++) {
            const subpath = subpathsWithArea[i];
            const isMainShape = i === 0;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isMainShape) {
              if (fillStyle) session.context.fill(fillStyle);
              if (strokeStyle) session.context.stroke(strokeStyle);
            } else {
              session.context.cut();
            }
          }
        } else {
          for (let i = 0; i < subpathsWithArea.length; i++) {
            const subpath = subpathsWithArea[i];
            const isHole = i % 2 === 1;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isHole) {
              session.context.cut();
            } else {
              if (fillStyle) session.context.fill(fillStyle);
              if (strokeStyle) session.context.stroke(strokeStyle);
            }
          }
        }
      } else {
        const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
        graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);
        session.context.path(graphicsPath);
        if (fillStyle) session.context.fill(fillStyle);
        if (strokeStyle) session.context.stroke(strokeStyle);
      }
      break;
    }
    case "circle":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      r = parseSVGFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r, r);
      if (fillStyle) session.context.fill(fillStyle);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    case "rect":
      x = parseSVGFloatAttribute(svg, "x", 0);
      y = parseSVGFloatAttribute(svg, "y", 0);
      width = parseSVGFloatAttribute(svg, "width", 0);
      height = parseSVGFloatAttribute(svg, "height", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x, y, width, height, rx || ry);
      } else {
        session.context.rect(x, y, width, height);
      }
      if (fillStyle) session.context.fill(fillStyle);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle) session.context.fill(fillStyle);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = parseSVGFloatAttribute(svg, "x1", 0);
      y1 = parseSVGFloatAttribute(svg, "y1", 0);
      x2 = parseSVGFloatAttribute(svg, "x2", 0);
      y2 = parseSVGFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x2, y2);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/-?\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, true);
      if (fillStyle) session.context.fill(fillStyle);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/-?\d+/g).map((n) => parseInt(n, 10));
      session.context.poly(points, false);
      if (strokeStyle) session.context.stroke(strokeStyle);
      break;
    // Group elements - just process children
    case "g":
    case "svg":
      break;
    default: {
      warn$2(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i = 0; i < children.length; i++) {
    renderChildren(children[i], session, fillStyle, strokeStyle);
  }
}

const repetitionMap = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class FillPattern {
  constructor(texture, repetition) {
    /**
     * unique id for this fill pattern
     * @internal
     */
    this.uid = uid$1("fillPattern");
    /**
     * Internal tick counter to track changes in the pattern.
     * This is used to invalidate the pattern when the texture or transform changes.
     * @internal
     */
    this._tick = 0;
    /** The transform matrix applied to the pattern */
    this.transform = new Matrix();
    this.texture = texture;
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    if (repetition) {
      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
    }
  }
  /**
   * Sets the transform for the pattern
   * @param transform - The transform matrix to apply to the pattern.
   * If not provided, the pattern will use the default transform.
   */
  setTransform(transform) {
    const texture = this.texture;
    this.transform.copyFrom(transform);
    this.transform.invert();
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    this._tick++;
  }
  /** Internal texture used to render the gradient */
  get texture() {
    return this._texture;
  }
  set texture(value) {
    if (this._texture === value) return;
    this._texture = value;
    this._tick++;
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `fill-pattern-${this.uid}-${this._tick}`;
  }
  /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture.destroy(true);
    this.texture = null;
  }
}

function isColorLike(value) {
  return Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof FillPattern;
}
function isFillGradient(value) {
  return value instanceof FillGradient;
}
function isTexture(value) {
  return value instanceof Texture;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value, defaultStyle) {
  fill.texture = value;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  fill.textureSpace = value.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  const color = Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === void 0 || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isTexture(value)) {
    return handleTexture(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}

const tmpPoint = new Point();
const tempMatrix$3 = new Matrix();
const _GraphicsContext = class _GraphicsContext extends EventEmitter {
  constructor() {
    super(...arguments);
    /** @internal */
    this._gpuData = /* @__PURE__ */ Object.create(null);
    /** If set to true, the resource will be garbage collected automatically when it is not used. */
    this.autoGarbageCollect = true;
    /** @internal */
    this._gcLastUsed = -1;
    /**
     * unique id for this graphics context
     * @internal
     */
    this.uid = uid$1("graphicsContext");
    /**
     * Indicates whether content is updated and have to be re-rendered.
     * @internal
     */
    this.dirty = true;
    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */
    this.batchMode = "auto";
    /** @internal */
    this.instructions = [];
    /** Whether the graphics context has been destroyed. */
    this.destroyed = false;
    this._activePath = new GraphicsPath();
    this._transform = new Matrix();
    this._fillStyle = { ..._GraphicsContext.defaultFillStyle };
    this._strokeStyle = { ..._GraphicsContext.defaultStrokeStyle };
    this._stateStack = [];
    this._tick = 0;
    this._bounds = new Bounds();
    this._boundsDirty = true;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const clone = new _GraphicsContext();
    clone.batchMode = this.batchMode;
    clone.instructions = this.instructions.slice();
    clone._activePath = this._activePath.clone();
    clone._transform = this._transform.clone();
    clone._fillStyle = { ...this._fillStyle };
    clone._strokeStyle = { ...this._strokeStyle };
    clone._stateStack = this._stateStack.slice();
    clone._bounds = this._bounds.clone();
    clone._boundsDirty = true;
    return clone;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(value) {
    this._fillStyle = toFillStyle(value, _GraphicsContext.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(value) {
    this._strokeStyle = toStrokeStyle(value, _GraphicsContext.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(style) {
    this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);
    return this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(style) {
    this._strokeStyle = toFillStyle(style, _GraphicsContext.defaultStrokeStyle);
    return this;
  }
  texture(texture, tint, dx, dy, dw, dh) {
    this.instructions.push({
      action: "texture",
      data: {
        image: texture,
        dx: dx || 0,
        dy: dy || 0,
        dw: dw || texture.frame.width,
        dh: dh || texture.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: tint || tint === 0 ? Color.shared.setValue(tint).toNumber() : 16777215
      }
    });
    this.onUpdate();
    return this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    this._activePath = new GraphicsPath();
    return this;
  }
  fill(style, alpha) {
    let path;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && lastInstruction?.action === "stroke") {
      path = lastInstruction.data.path;
    } else {
      path = this._activePath.clone();
    }
    if (!path) return this;
    if (style != null) {
      if (alpha !== void 0 && typeof style === "number") {
        deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
        style = { color: style, alpha };
      }
      this._fillStyle = toFillStyle(style, _GraphicsContext.defaultFillStyle);
    }
    this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  _initNextPathLocation() {
    const { x, y } = this._activePath.getLastPoint(Point.shared);
    this._activePath.clear();
    this._activePath.moveTo(x, y);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(style) {
    let path;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && lastInstruction?.action === "fill") {
      path = lastInstruction.data.path;
    } else {
      path = this._activePath.clone();
    }
    if (!path) return this;
    if (style != null) {
      this._strokeStyle = toStrokeStyle(style, _GraphicsContext.defaultStrokeStyle);
    }
    this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let i = 0; i < 2; i++) {
      const lastInstruction = this.instructions[this.instructions.length - 1 - i];
      const holePath = this._activePath.clone();
      if (lastInstruction) {
        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
          if (lastInstruction.data.hole) {
            lastInstruction.data.hole.addPath(holePath);
          } else {
            lastInstruction.data.hole = holePath;
            break;
          }
        }
      }
    }
    this._initNextPathLocation();
    return this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    this._tick++;
    const t = this._transform;
    this._activePath.arc(
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      radius,
      startAngle,
      endAngle,
      counterclockwise
    );
    return this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._tick++;
    const t = this._transform;
    this._activePath.arcTo(
      t.a * x1 + t.c * y1 + t.tx,
      t.b * x1 + t.d * y1 + t.ty,
      t.a * x2 + t.c * y2 + t.tx,
      t.b * x2 + t.d * y2 + t.ty,
      radius
    );
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
    this._tick++;
    const t = this._transform;
    this._activePath.arcToSvg(
      rx,
      ry,
      xAxisRotation,
      // should we rotate this with transform??
      largeArcFlag,
      sweepFlag,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
    this._tick++;
    const t = this._transform;
    this._activePath.bezierCurveTo(
      t.a * cp1x + t.c * cp1y + t.tx,
      t.b * cp1x + t.d * cp1y + t.ty,
      t.a * cp2x + t.c * cp2y + t.tx,
      t.b * cp2x + t.d * cp2y + t.ty,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      smoothness
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this._tick++;
    this._activePath?.closePath();
    return this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x, y, radiusX, radiusY) {
    this._tick++;
    this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x, y, radius) {
    this._tick++;
    this._activePath.circle(x, y, radius, this._transform.clone());
    return this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(path) {
    this._tick++;
    this._activePath.addPath(path, this._transform.clone());
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x, y) {
    this._tick++;
    const t = this._transform;
    this._activePath.lineTo(
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty
    );
    return this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x, y) {
    this._tick++;
    const t = this._transform;
    const instructions = this._activePath.instructions;
    const transformedX = t.a * x + t.c * y + t.tx;
    const transformedY = t.b * x + t.d * y + t.ty;
    if (instructions.length === 1 && instructions[0].action === "moveTo") {
      instructions[0].data[0] = transformedX;
      instructions[0].data[1] = transformedY;
      return this;
    }
    this._activePath.moveTo(
      transformedX,
      transformedY
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cpx, cpy, x, y, smoothness) {
    this._tick++;
    const t = this._transform;
    this._activePath.quadraticCurveTo(
      t.a * cpx + t.c * cpy + t.tx,
      t.b * cpx + t.d * cpy + t.ty,
      t.a * x + t.c * y + t.tx,
      t.b * x + t.d * y + t.ty,
      smoothness
    );
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x, y, w, h) {
    this._tick++;
    this._activePath.rect(x, y, w, h, this._transform.clone());
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x, y, w, h, radius) {
    this._tick++;
    this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());
    return this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(points, close) {
    this._tick++;
    this._activePath.poly(points, close, this._transform.clone());
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x, y, radius, sides, rotation = 0, transform) {
    this._tick++;
    this._activePath.regularPoly(x, y, radius, sides, rotation, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x, y, radius, sides, corner, rotation) {
    this._tick++;
    this._activePath.roundPoly(x, y, radius, sides, corner, rotation);
    return this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic, smoothness) {
    this._tick++;
    this._activePath.roundShape(points, radius, useQuadratic, smoothness);
    return this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x, y, width, height, fillet) {
    this._tick++;
    this._activePath.filletRect(x, y, width, height, fillet);
    return this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x, y, width, height, chamfer, transform) {
    this._tick++;
    this._activePath.chamferRect(x, y, width, height, chamfer, transform);
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(x, y, points, radius, innerRadius = 0, rotation = 0) {
    this._tick++;
    this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());
    return this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(svg) {
    this._tick++;
    SVGParser(svg, this);
    return this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const state = this._stateStack.pop();
    if (state) {
      this._transform = state.transform;
      this._fillStyle = state.fillStyle;
      this._strokeStyle = state.strokeStyle;
    }
    return this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    });
    return this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    this._transform.identity();
    return this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(angle) {
    this._transform.rotate(angle);
    return this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(x, y = x) {
    this._transform.scale(x, y);
    return this;
  }
  setTransform(a, b, c, d, dx, dy) {
    if (a instanceof Matrix) {
      this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);
      return this;
    }
    this._transform.set(a, b, c, d, dx, dy);
    return this;
  }
  transform(a, b, c, d, dx, dy) {
    if (a instanceof Matrix) {
      this._transform.append(a);
      return this;
    }
    tempMatrix$3.set(a, b, c, d, dx, dy);
    this._transform.append(tempMatrix$3);
    return this;
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(x, y = x) {
    this._transform.translate(x, y);
    return this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    this._activePath.clear();
    this.instructions.length = 0;
    this.resetTransform();
    this.onUpdate();
    return this;
  }
  onUpdate() {
    this._boundsDirty = true;
    if (this.dirty) return;
    this.emit("update", this, 16);
    this.dirty = true;
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty) return this._bounds;
    this._boundsDirty = false;
    const bounds = this._bounds;
    bounds.clear();
    for (let i = 0; i < this.instructions.length; i++) {
      const instruction = this.instructions[i];
      const action = instruction.action;
      if (action === "fill") {
        const data = instruction.data;
        bounds.addBounds(data.path.bounds);
      } else if (action === "texture") {
        const data = instruction.data;
        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
      }
      if (action === "stroke") {
        const data = instruction.data;
        const alignment = data.style.alignment;
        const outerPadding = data.style.width * (1 - alignment);
        const _bounds = data.path.bounds;
        bounds.addFrame(
          _bounds.minX - outerPadding,
          _bounds.minY - outerPadding,
          _bounds.maxX + outerPadding,
          _bounds.maxY + outerPadding
        );
      }
    }
    return bounds;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    if (!this.bounds.containsPoint(point.x, point.y)) return false;
    const instructions = this.instructions;
    let hasHit = false;
    for (let k = 0; k < instructions.length; k++) {
      const instruction = instructions[k];
      const data = instruction.data;
      const path = data.path;
      if (!instruction.action || !path) continue;
      const style = data.style;
      const shapes = path.shapePath.shapePrimitives;
      for (let i = 0; i < shapes.length; i++) {
        const shape = shapes[i].shape;
        if (!style || !shape) continue;
        const transform = shapes[i].transform;
        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
        if (instruction.action === "fill") {
          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
        } else {
          const strokeStyle = style;
          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
        }
        const holes = data.hole;
        if (holes) {
          const holeShapes = holes.shapePath?.shapePrimitives;
          if (holeShapes) {
            for (let j = 0; j < holeShapes.length; j++) {
              if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y)) {
                hasHit = false;
              }
            }
          }
        }
        if (hasHit) {
          return true;
        }
      }
    }
    return hasHit;
  }
  /** Unloads the GPU data from the graphics context. */
  unload() {
    this.emit("unload", this);
    for (const key in this._gpuData) {
      this._gpuData[key]?.destroy();
    }
    this._gpuData = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * context.destroy();
   * context.destroy(true);
   * context.destroy({ texture: true, textureSource: true });
   */
  destroy(options = false) {
    if (this.destroyed) return;
    this.destroyed = true;
    this._stateStack.length = 0;
    this._transform = null;
    this.unload();
    this.emit("destroy", this);
    this.removeAllListeners();
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      if (this._fillStyle.texture) {
        this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
      }
      if (this._strokeStyle.texture) {
        this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
      }
    }
    this._fillStyle = null;
    this._strokeStyle = null;
    this.instructions = null;
    this._activePath = null;
    this._bounds = null;
    this._stateStack = null;
    this.customShader = null;
    this._transform = null;
  }
};
/** The default fill style to use when none is provided. */
_GraphicsContext.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local"
};
/** The default stroke style to use when none is provided. */
_GraphicsContext.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local",
  /** If the stroke is a pixel line. */
  pixelLine: false
};
let GraphicsContext = _GraphicsContext;

class EventsTickerClass {
  constructor() {
    /** The frequency that fake events will be fired. */
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  /**
   * Initializes the event ticker.
   * @param events - The event system.
   */
  init(events) {
    this.removeTickerListener();
    this.events = events;
    this.interactionFrequency = 10;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
  /** Whether to pause the update checks or not. */
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(paused) {
    this._pauseUpdate = paused;
  }
  /** Adds the ticker listener. */
  addTickerListener() {
    if (this._tickerAdded || !this.domElement) {
      return;
    }
    Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
    this._tickerAdded = true;
  }
  /** Removes the ticker listener. */
  removeTickerListener() {
    if (!this._tickerAdded) {
      return;
    }
    Ticker.system.remove(this._tickerUpdate, this);
    this._tickerAdded = false;
  }
  /** Sets flag to not fire extra events when the user has already moved there mouse */
  pointerMoved() {
    this._didMove = true;
  }
  /** Updates the state of interactive objects. */
  _update() {
    if (!this.domElement || this._pauseUpdate) {
      return;
    }
    if (this._didMove) {
      this._didMove = false;
      return;
    }
    const rootPointerEvent = this.events["_rootPointerEvent"];
    if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
      return;
    }
    globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY,
      pointerType: rootPointerEvent.pointerType,
      pointerId: rootPointerEvent.pointerId
    }) : new MouseEvent("mousemove", {
      clientX: rootPointerEvent.clientX,
      clientY: rootPointerEvent.clientY
    }));
  }
  /**
   * Updates the state of interactive objects if at least {@link interactionFrequency}
   * milliseconds have passed since the last invocation.
   *
   * Invoked by a throttled ticker update from {@link Ticker.system}.
   * @param ticker - The throttled ticker.
   */
  _tickerUpdate(ticker) {
    this._deltaTime += ticker.deltaTime;
    if (this._deltaTime < this.interactionFrequency) {
      return;
    }
    this._deltaTime = 0;
    this._update();
  }
  /** Destroys the event ticker. */
  destroy() {
    this.removeTickerListener();
    this.events = null;
    this.domElement = null;
    this._deltaTime = 0;
    this._didMove = false;
    this._tickerAdded = false;
    this._pauseUpdate = true;
  }
}
const EventsTicker = new EventsTickerClass();

class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments);
    /** The coordinates of the mouse event relative to the canvas. */
    this.client = new Point();
    /** The movement in this pointer relative to the last `mousemove` event. */
    this.movement = new Point();
    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */
    this.offset = new Point();
    /** The pointer coordinates in world space. */
    this.global = new Point();
    /**
     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly
     * different semantics than native PointerEvent screenX/screenY.
     */
    this.screen = new Point();
  }
  /** @readonly */
  get clientX() {
    return this.client.x;
  }
  /** @readonly */
  get clientY() {
    return this.client.y;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
   * @readonly
   */
  get x() {
    return this.clientX;
  }
  /**
   * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
   * @readonly
   */
  get y() {
    return this.clientY;
  }
  /** @readonly */
  get movementX() {
    return this.movement.x;
  }
  /** @readonly */
  get movementY() {
    return this.movement.y;
  }
  /** @readonly */
  get offsetX() {
    return this.offset.x;
  }
  /** @readonly */
  get offsetY() {
    return this.offset.y;
  }
  /** @readonly */
  get globalX() {
    return this.global.x;
  }
  /** @readonly */
  get globalY() {
    return this.global.y;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.x`.
   * @readonly
   */
  get screenX() {
    return this.screen.x;
  }
  /**
   * The pointer coordinates in the renderer's screen. Alias for `screen.y`.
   * @readonly
   */
  get screenY() {
    return this.screen.y;
  }
  /**
   * Converts global coordinates into container-local coordinates.
   *
   * This method transforms coordinates from world space to a container's local space,
   * useful for precise positioning and hit testing.
   * @param container - The Container to get local coordinates for
   * @param point - Optional Point object to store the result. If not provided, a new Point will be created
   * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used
   * @returns The local coordinates as a Point object
   * @example
   * ```ts
   * // Basic usage - get local coordinates relative to a container
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Get position relative to the sprite
   *     const localPos = event.getLocalPosition(sprite);
   *     console.log('Local position:', localPos.x, localPos.y);
   * });
   * // Using custom global coordinates
   * const customGlobal = new Point(100, 100);
   * sprite.on('pointermove', (event: FederatedMouseEvent) => {
   *     // Transform custom coordinates
   *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);
   *     console.log('Custom local position:', localPos.x, localPos.y);
   * });
   * ```
   * @see {@link Container.worldTransform} For the transformation matrix
   * @see {@link Point} For the point class used to store coordinates
   */
  getLocalPosition(container, point, globalPos) {
    return container.worldTransform.applyInverse(globalPos || this.global, point);
  }
  /**
   * Whether the modifier key was pressed when this event natively occurred.
   * @param key - The modifier key.
   */
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  /**
   * Not supported.
   * @param _typeArg
   * @param _canBubbleArg
   * @param _cancelableArg
   * @param _viewArg
   * @param _detailArg
   * @param _screenXArg
   * @param _screenYArg
   * @param _clientXArg
   * @param _clientYArg
   * @param _ctrlKeyArg
   * @param _altKeyArg
   * @param _shiftKeyArg
   * @param _metaKeyArg
   * @param _buttonArg
   * @param _relatedTargetArg
   * @deprecated since 7.0.0
   * @ignore
   */
  // eslint-disable-next-line max-params
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}

class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     */
    this.width = 0;
    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     */
    this.height = 0;
    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     */
    this.isPrimary = false;
  }
  /**
   * Only included for completeness for now
   * @ignore
   */
  getCoalescedEvents() {
    if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
      return [this];
    }
    return [];
  }
  /**
   * Only included for completeness for now
   * @ignore
   */
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}

class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments);
    /**
     * Units specified in pixels.
     * @ignore
     */
    this.DOM_DELTA_PIXEL = 0;
    /**
     * Units specified in lines.
     * @ignore
     */
    this.DOM_DELTA_LINE = 1;
    /**
     * Units specified in pages.
     * @ignore
     */
    this.DOM_DELTA_PAGE = 2;
  }
}
/**
 * Units specified in pixels.
 * @ignore
 */
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
/**
 * Units specified in lines.
 * @ignore
 */
FederatedWheelEvent.DOM_DELTA_LINE = 1;
/**
 * Units specified in pages.
 * @ignore
 */
FederatedWheelEvent.DOM_DELTA_PAGE = 2;

const PROPAGATION_LIMIT = 2048;
const tempHitLocation = new Point();
const tempLocalMapping = new Point();
class EventBoundary {
  /**
   * @param rootTarget - The holder of the event boundary.
   */
  constructor(rootTarget) {
    /**
     * Emits events after they were dispatched into the scene graph.
     *
     * This can be used for global events listening, regardless of the scene graph being used. It should
     * not be used by interactive libraries for normal use.
     *
     * Special events that do not bubble all the way to the root target are not emitted from here,
     * e.g. pointerenter, pointerleave, click.
     */
    this.dispatch = new EventEmitter();
    /**
     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.
     *
     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of
     * the Pointer Event API's approach.
     */
    this.moveOnAll = false;
    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */
    this.enableGlobalMoveEvents = true;
    /**
     * State object for mapping methods.
     * @see EventBoundary#trackingData
     */
    this.mappingState = {
      trackingData: {}
    };
    /**
     * The event pool maps event constructors to an free pool of instances of those specific events.
     * @see EventBoundary#allocateEvent
     * @see EventBoundary#freeEvent
     */
    this.eventPool = /* @__PURE__ */ new Map();
    /** Every interactive element gathered from the scene. Only used in `pointermove` */
    this._allInteractiveElements = [];
    /** Every element that passed the hit test. Only used in `pointermove` */
    this._hitElements = [];
    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */
    this._isPointerMoveEvent = false;
    this.rootTarget = rootTarget;
    this.hitPruneFn = this.hitPruneFn.bind(this);
    this.hitTestFn = this.hitTestFn.bind(this);
    this.mapPointerDown = this.mapPointerDown.bind(this);
    this.mapPointerMove = this.mapPointerMove.bind(this);
    this.mapPointerOut = this.mapPointerOut.bind(this);
    this.mapPointerOver = this.mapPointerOver.bind(this);
    this.mapPointerUp = this.mapPointerUp.bind(this);
    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
    this.mapWheel = this.mapWheel.bind(this);
    this.mappingTable = {};
    this.addEventMapping("pointerdown", this.mapPointerDown);
    this.addEventMapping("pointermove", this.mapPointerMove);
    this.addEventMapping("pointerout", this.mapPointerOut);
    this.addEventMapping("pointerleave", this.mapPointerOut);
    this.addEventMapping("pointerover", this.mapPointerOver);
    this.addEventMapping("pointerup", this.mapPointerUp);
    this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
    this.addEventMapping("wheel", this.mapWheel);
  }
  /**
   * Adds an event mapping for the event `type` handled by `fn`.
   *
   * Event mappings can be used to implement additional or custom events. They take an event
   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
   *
   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
   * instead.
   * @param type - The type of upstream event to map.
   * @param fn - The mapping method. The context of this function must be bound manually, if desired.
   */
  addEventMapping(type, fn) {
    if (!this.mappingTable[type]) {
      this.mappingTable[type] = [];
    }
    this.mappingTable[type].push({
      fn,
      priority: 0
    });
    this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  /**
   * Dispatches the given event
   * @param e - The event to dispatch.
   * @param type - The type of event to dispatch. Defaults to `e.type`.
   */
  dispatchEvent(e, type) {
    e.propagationStopped = false;
    e.propagationImmediatelyStopped = false;
    this.propagate(e, type);
    this.dispatch.emit(type || e.type, e);
  }
  /**
   * Maps the given upstream event through the event boundary and propagates it downstream.
   * @param e - The event to map.
   */
  mapEvent(e) {
    if (!this.rootTarget) {
      return;
    }
    const mappers = this.mappingTable[e.type];
    if (mappers) {
      for (let i = 0, j = mappers.length; i < j; i++) {
        mappers[i].fn(e);
      }
    } else {
      warn$2(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
  }
  /**
   * Finds the Container that is the target of a event at the given coordinates.
   *
   * The passed (x,y) coordinates are in the world space above this event boundary.
   * @param x - The x coordinate of the event.
   * @param y - The y coordinate of the event.
   */
  hitTest(x, y) {
    EventsTicker.pauseUpdate = true;
    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
    const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
    const invertedPath = this[fn](
      this.rootTarget,
      this.rootTarget.eventMode,
      tempHitLocation.set(x, y),
      this.hitTestFn,
      this.hitPruneFn
    );
    return invertedPath && invertedPath[0];
  }
  /**
   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
   * target `e.target`.
   * @param e - The event to propagate.
   * @param type - The type of event to propagate. Defaults to `e.type`.
   */
  propagate(e, type) {
    if (!e.target) {
      return;
    }
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
    e.eventPhase = e.AT_TARGET;
    e.currentTarget = e.target;
    this.notifyTarget(e, type);
    if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    e.eventPhase = e.BUBBLING_PHASE;
    for (let i = composedPath.length - 2; i >= 0; i--) {
      e.currentTarget = composedPath[i];
      this.notifyTarget(e, type);
      if (e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  }
  /**
   * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.
   *
   * This is used in the `globalpointermove` event.
   * @param e - The emitted event.
   * @param type - The listeners to notify.
   * @param targets - The targets to notify.
   */
  all(e, type, targets = this._allInteractiveElements) {
    if (targets.length === 0) return;
    e.eventPhase = e.BUBBLING_PHASE;
    const events = Array.isArray(type) ? type : [type];
    for (let i = targets.length - 1; i >= 0; i--) {
      events.forEach((event) => {
        e.currentTarget = targets[i];
        this.notifyTarget(e, event);
      });
    }
  }
  /**
   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
   * `target`. The last element in the path is `target`.
   * @param target - The target to find the propagation path to.
   */
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {
      if (!target.parent) {
        throw new Error("Cannot find propagation path to disconnected target");
      }
      propagationPath.push(target.parent);
      target = target.parent;
    }
    propagationPath.reverse();
    return propagationPath;
  }
  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
    let shouldReturn = false;
    if (this._interactivePrune(currentTarget)) return null;
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestMoveRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          location,
          testFn,
          pruneFn,
          ignore || pruneFn(currentTarget, location)
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) {
            if (isInteractive) this._allInteractiveElements.push(currentTarget);
            nestedHit.push(currentTarget);
          }
          if (this._hitElements.length === 0) this._hitElements = nestedHit;
          shouldReturn = true;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);
    if (ignore || this._hitElements.length > 0) return null;
    if (shouldReturn) return this._hitElements;
    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  /**
   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
   * @param currentTarget - The Container that is to be hit tested.
   * @param eventMode - The event mode for the `currentTarget` or one of its parents.
   * @param location - The location that is being tested for overlap.
   * @param testFn - Callback that determines whether the target passes hit testing. This callback
   *  can assume that `pruneFn` failed to prune the container.
   * @param pruneFn - Callback that determiness whether the target and all of its children
   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
   *  of the scene graph.
   * @returns An array holding the hit testing target and all its ancestors in order. The first element
   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
   */
  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
      return null;
    }
    if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
      EventsTicker.pauseUpdate = false;
    }
    if (currentTarget.interactiveChildren && currentTarget.children) {
      const children = currentTarget.children;
      const relativeLocation = location;
      for (let i = children.length - 1; i >= 0; i--) {
        const child = children[i];
        const nestedHit = this.hitTestRecursive(
          child,
          this._isInteractive(eventMode) ? eventMode : child.eventMode,
          relativeLocation,
          testFn,
          pruneFn
        );
        if (nestedHit) {
          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
            continue;
          }
          const isInteractive = currentTarget.isInteractive();
          if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);
          return nestedHit;
        }
      }
    }
    const isInteractiveMode = this._isInteractive(eventMode);
    const isInteractiveTarget = currentTarget.isInteractive();
    if (isInteractiveMode && testFn(currentTarget, location)) {
      return isInteractiveTarget ? [currentTarget] : [];
    }
    return null;
  }
  _isInteractive(int) {
    return int === "static" || int === "dynamic";
  }
  _interactivePrune(container) {
    if (!container || !container.visible || !container.renderable || !container.measurable) {
      return true;
    }
    if (container.eventMode === "none") {
      return true;
    }
    if (container.eventMode === "passive" && !container.interactiveChildren) {
      return true;
    }
    return false;
  }
  /**
   * Checks whether the container or any of its children cannot pass the hit test at all.
   *
   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
   * and {@link Container._maskEffect} for pruning.
   * @param container - The container to prune.
   * @param location - The location to test for overlap.
   */
  hitPruneFn(container, location) {
    if (container.hitArea) {
      container.worldTransform.applyInverse(location, tempLocalMapping);
      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
        return true;
      }
    }
    if (container.effects && container.effects.length) {
      for (let i = 0; i < container.effects.length; i++) {
        const effect = container.effects[i];
        if (effect.containsPoint) {
          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
          if (!effectContainsPoint) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Checks whether the container passes hit testing for the given location.
   * @param container - The container to test.
   * @param location - The location to test for overlap.
   * @returns - Whether `container` passes hit testing for `location`.
   */
  hitTestFn(container, location) {
    if (container.hitArea) {
      return true;
    }
    if (container?.containsPoint) {
      container.worldTransform.applyInverse(location, tempLocalMapping);
      return container.containsPoint(tempLocalMapping);
    }
    return false;
  }
  /**
   * Notify all the listeners to the event's `currentTarget`.
   *
   * If the `currentTarget` contains the property `on<type>`, then it is called here,
   * simulating the behavior from version 6.x and prior.
   * @param e - The event passed to the target.
   * @param type - The type of event to notify. Defaults to `e.type`.
   */
  notifyTarget(e, type) {
    if (!e.currentTarget.isInteractive()) {
      return;
    }
    type ?? (type = e.type);
    const handlerKey = `on${type}`;
    e.currentTarget[handlerKey]?.(e);
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this._notifyListeners(e, key);
    if (e.eventPhase === e.AT_TARGET) {
      this._notifyListeners(e, type);
    }
  }
  /**
   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
   *
   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
   * @param from - The upstream `pointerdown` event.
   */
  mapPointerDown(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerdown");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchstart");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
    }
    const trackingData = this.trackingData(from.pointerId);
    trackingData.pressTargetsByButton[from.button] = e.composedPath();
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
   *
   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
   * @param from - The upstream `pointermove` event.
   */
  mapPointerMove(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    this._isPointerMoveEvent = true;
    const e = this.createPointerEvent(from);
    this._isPointerMoveEvent = false;
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    const trackingData = this.trackingData(from.pointerId);
    const outTarget = this.findMountedTarget(trackingData.overTargets);
    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {
      const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
      const outEvent = this.createPointerEvent(from, outType, outTarget);
      this.dispatchEvent(outEvent, "pointerout");
      if (isMouse) this.dispatchEvent(outEvent, "mouseout");
      if (!e.composedPath().includes(outTarget)) {
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
        leaveEvent.eventPhase = leaveEvent.AT_TARGET;
        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
          leaveEvent.currentTarget = leaveEvent.target;
          this.notifyTarget(leaveEvent);
          if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
          leaveEvent.target = leaveEvent.target.parent;
        }
        this.freeEvent(leaveEvent);
      }
      this.freeEvent(outEvent);
    }
    if (outTarget !== e.target) {
      const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
      const overEvent = this.clonePointerEvent(e, overType);
      this.dispatchEvent(overEvent, "pointerover");
      if (isMouse) this.dispatchEvent(overEvent, "mouseover");
      let overTargetAncestor = outTarget?.parent;
      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
        if (overTargetAncestor === e.target) break;
        overTargetAncestor = overTargetAncestor.parent;
      }
      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
      if (didPointerEnter) {
        const enterEvent = this.clonePointerEvent(e, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        this.freeEvent(enterEvent);
      }
      this.freeEvent(overEvent);
    }
    const allMethods = [];
    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
    this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e, "pointermove");
    allowGlobalPointerEvents && allMethods.push("globalpointermove");
    if (e.pointerType === "touch") {
      this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove");
      allowGlobalPointerEvents && allMethods.push("globaltouchmove");
    }
    if (isMouse) {
      this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove");
      allowGlobalPointerEvents && allMethods.push("globalmousemove");
      this.cursor = e.target?.cursor;
    }
    if (allMethods.length > 0) {
      this.all(e, allMethods);
    }
    this._allInteractiveElements.length = 0;
    this._hitElements.length = 0;
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
   *
   * The tracking data for the specific pointer gets a new `overTarget`.
   * @param from - The upstream `pointerover` event.
   */
  mapPointerOver(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const e = this.createPointerEvent(from);
    const isMouse = e.pointerType === "mouse" || e.pointerType === "pen";
    this.dispatchEvent(e, "pointerover");
    if (isMouse) this.dispatchEvent(e, "mouseover");
    if (e.pointerType === "mouse") this.cursor = e.target?.cursor;
    const enterEvent = this.clonePointerEvent(e, "pointerenter");
    enterEvent.eventPhase = enterEvent.AT_TARGET;
    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
      enterEvent.currentTarget = enterEvent.target;
      this.notifyTarget(enterEvent);
      if (isMouse) this.notifyTarget(enterEvent, "mouseenter");
      enterEvent.target = enterEvent.target.parent;
    }
    trackingData.overTargets = e.composedPath();
    this.freeEvent(e);
    this.freeEvent(enterEvent);
  }
  /**
   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
   *
   * The tracking data for the specific pointer is cleared of a `overTarget`.
   * @param from - The upstream `pointerout` event.
   */
  mapPointerOut(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    if (trackingData.overTargets) {
      const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
      const outTarget = this.findMountedTarget(trackingData.overTargets);
      const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
      this.dispatchEvent(outEvent);
      if (isMouse) this.dispatchEvent(outEvent, "mouseout");
      const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
      leaveEvent.eventPhase = leaveEvent.AT_TARGET;
      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
        leaveEvent.currentTarget = leaveEvent.target;
        this.notifyTarget(leaveEvent);
        if (isMouse) this.notifyTarget(leaveEvent, "mouseleave");
        leaveEvent.target = leaveEvent.target.parent;
      }
      trackingData.overTargets = null;
      this.freeEvent(outEvent);
      this.freeEvent(leaveEvent);
    }
    this.cursor = null;
  }
  /**
   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
   * and `click`/`rightclick`/`pointertap` events, in that order.
   *
   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
   * specific pointer types.
   * @param from - The upstream `pointerup` event.
   */
  mapPointerUp(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const now = performance.now();
    const e = this.createPointerEvent(from);
    this.dispatchEvent(e, "pointerup");
    if (e.pointerType === "touch") {
      this.dispatchEvent(e, "touchend");
    } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
      const isRightButton = e.button === 2;
      this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    let clickTarget = pressTarget;
    if (pressTarget && !e.composedPath().includes(pressTarget)) {
      let currentTarget = pressTarget;
      while (currentTarget && !e.composedPath().includes(currentTarget)) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          const isRightButton = e.button === 2;
          this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
      clickTarget = currentTarget;
    }
    if (clickTarget) {
      const clickEvent = this.clonePointerEvent(e, "click");
      clickEvent.target = clickTarget;
      clickEvent.path = null;
      if (!trackingData.clicksByButton[from.button]) {
        trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        };
      }
      const clickHistory = trackingData.clicksByButton[from.button];
      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {
        ++clickHistory.clickCount;
      } else {
        clickHistory.clickCount = 1;
      }
      clickHistory.target = clickEvent.target;
      clickHistory.timeStamp = now;
      clickEvent.detail = clickHistory.clickCount;
      if (clickEvent.pointerType === "mouse") {
        const isRightButton = clickEvent.button === 2;
        this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
      } else if (clickEvent.pointerType === "touch") {
        this.dispatchEvent(clickEvent, "tap");
      }
      this.dispatchEvent(clickEvent, "pointertap");
      this.freeEvent(clickEvent);
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
   * `pointerdown` target to `rootTarget`.
   *
   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
   *
   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
   * @param from - The upstream `pointerupoutside` event.
   */
  mapPointerUpOutside(from) {
    if (!(from instanceof FederatedPointerEvent)) {
      warn$2("EventBoundary cannot map a non-pointer event as a pointer event");
      return;
    }
    const trackingData = this.trackingData(from.pointerId);
    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
    const e = this.createPointerEvent(from);
    if (pressTarget) {
      let currentTarget = pressTarget;
      while (currentTarget) {
        e.currentTarget = currentTarget;
        this.notifyTarget(e, "pointerupoutside");
        if (e.pointerType === "touch") {
          this.notifyTarget(e, "touchendoutside");
        } else if (e.pointerType === "mouse" || e.pointerType === "pen") {
          this.notifyTarget(e, e.button === 2 ? "rightupoutside" : "mouseupoutside");
        }
        currentTarget = currentTarget.parent;
      }
      delete trackingData.pressTargetsByButton[from.button];
    }
    this.freeEvent(e);
  }
  /**
   * Maps the upstream `wheel` event to a downstream `wheel` event.
   * @param from - The upstream `wheel` event.
   */
  mapWheel(from) {
    if (!(from instanceof FederatedWheelEvent)) {
      warn$2("EventBoundary cannot map a non-wheel event as a wheel event");
      return;
    }
    const wheelEvent = this.createWheelEvent(from);
    this.dispatchEvent(wheelEvent);
    this.freeEvent(wheelEvent);
  }
  /**
   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
   *
   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
   * or `pointerover` target was unmounted from the scene graph.
   * @param propagationPath - The propagation path was valid in the past.
   * @returns - The most specific event-target still mounted at the same location in the scene graph.
   */
  findMountedTarget(propagationPath) {
    if (!propagationPath) {
      return null;
    }
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length; i++) {
      if (propagationPath[i].parent === currentTarget) {
        currentTarget = propagationPath[i];
      } else {
        break;
      }
    }
    return currentTarget;
  }
  /**
   * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The `originalEvent` for the returned event.
   * @param [type=from.type] - The type of the returned event.
   * @param target - The target of the returned event.
   */
  createPointerEvent(from, type, target) {
    const event = this.allocateEvent(FederatedPointerEvent);
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
    if (typeof type === "string") {
      event.type = type;
    }
    return event;
  }
  /**
   * Creates a wheel event whose `originalEvent` is `from`.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The upstream wheel event.
   */
  createWheelEvent(from) {
    const event = this.allocateEvent(FederatedWheelEvent);
    this.copyWheelData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from;
    event.target = this.hitTest(event.global.x, event.global.y);
    return event;
  }
  /**
   * Clones the event `from`, with an optional `type` override.
   *
   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
   * @param from - The event to clone.
   * @param [type=from.type] - The type of the returned event.
   */
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent;
    event.originalEvent = from.originalEvent;
    this.copyPointerData(from, event);
    this.copyMouseData(from, event);
    this.copyData(from, event);
    event.target = from.target;
    event.path = from.composedPath().slice();
    event.type = type ?? event.type;
    return event;
  }
  /**
   * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + deltaMode
   * + deltaX
   * + deltaY
   * + deltaZ
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode;
    to.deltaX = from.deltaX;
    to.deltaY = from.deltaY;
    to.deltaZ = from.deltaZ;
  }
  /**
   * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + pointerId
   * + width
   * + height
   * + isPrimary
   * + pointerType
   * + pressure
   * + tangentialPressure
   * + tiltX
   * + tiltY
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyPointerData(from, to) {
    if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;
    to.pointerId = from.pointerId;
    to.width = from.width;
    to.height = from.height;
    to.isPrimary = from.isPrimary;
    to.pointerType = from.pointerType;
    to.pressure = from.pressure;
    to.tangentialPressure = from.tangentialPressure;
    to.tiltX = from.tiltX;
    to.tiltY = from.tiltY;
    to.twist = from.twist;
  }
  /**
   * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.
   *
   * The following properties are copied:
   * + altKey
   * + button
   * + buttons
   * + clientX
   * + clientY
   * + metaKey
   * + movementX
   * + movementY
   * + pageX
   * + pageY
   * + x
   * + y
   * + screen
   * + shiftKey
   * + global
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyMouseData(from, to) {
    if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;
    to.altKey = from.altKey;
    to.button = from.button;
    to.buttons = from.buttons;
    to.client.copyFrom(from.client);
    to.ctrlKey = from.ctrlKey;
    to.metaKey = from.metaKey;
    to.movement.copyFrom(from.movement);
    to.screen.copyFrom(from.screen);
    to.shiftKey = from.shiftKey;
    to.global.copyFrom(from.global);
  }
  /**
   * Copies base {@link FederatedEvent} data from `from` into `to`.
   *
   * The following properties are copied:
   * + isTrusted
   * + srcElement
   * + timeStamp
   * + type
   * @param from - The event to copy data from.
   * @param to - The event to copy data into.
   */
  copyData(from, to) {
    to.isTrusted = from.isTrusted;
    to.srcElement = from.srcElement;
    to.timeStamp = performance.now();
    to.type = from.type;
    to.detail = from.detail;
    to.view = from.view;
    to.which = from.which;
    to.layer.copyFrom(from.layer);
    to.page.copyFrom(from.page);
  }
  /**
   * @param id - The pointer ID.
   * @returns The tracking data stored for the given pointer. If no data exists, a blank
   *  state will be created.
   */
  trackingData(id) {
    if (!this.mappingState.trackingData[id]) {
      this.mappingState.trackingData[id] = {
        pressTargetsByButton: {},
        clicksByButton: {},
        overTarget: null
      };
    }
    return this.mappingState.trackingData[id];
  }
  /**
   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
   *
   * This allocation is constructor-agnostic, as long as it only takes one argument - this event
   * boundary.
   * @param constructor - The event's constructor.
   * @returns An event of the given type.
   */
  allocateEvent(constructor) {
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    const event = this.eventPool.get(constructor).pop() || new constructor(this);
    event.eventPhase = event.NONE;
    event.currentTarget = null;
    event.defaultPrevented = false;
    event.path = null;
    event.target = null;
    return event;
  }
  /**
   * Frees the event and puts it back into the event pool.
   *
   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
   *
   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
   * not be freed. This is because of the possibility that the same event is freed twice, which can cause
   * it to be allocated twice & result in overwriting.
   * @param event - The event to be freed.
   * @throws Error if the event is managed by another event boundary.
   */
  freeEvent(event) {
    if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
    const constructor = event.constructor;
    if (!this.eventPool.has(constructor)) {
      this.eventPool.set(constructor, []);
    }
    this.eventPool.get(constructor).push(event);
  }
  /**
   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
   * is set on the event.
   * @param e - The event to call each listener with.
   * @param type - The event key.
   */
  _notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (!listeners) return;
    if ("fn" in listeners) {
      if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, void 0, true);
      listeners.fn.call(listeners.context, e);
    } else {
      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
        if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);
        listeners[i].fn.call(listeners[i].context, e);
      }
    }
  }
}

const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
const _EventSystem = class _EventSystem {
  /**
   * @param {Renderer} renderer
   */
  constructor(renderer) {
    /**
     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.
     * This is used to determine the appropriate event handling strategy.
     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification
     * @readonly
     * @default 'ontouchstart' in globalThis
     */
    this.supportsTouchEvents = "ontouchstart" in globalThis;
    /**
     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.
     * Used to optimize event handling and provide more consistent cross-device interaction.
     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification
     * @readonly
     * @default !!globalThis.PointerEvent
     */
    this.supportsPointerEvents = !!globalThis.PointerEvent;
    /**
     * The DOM element to which the root event listeners are bound. This is automatically set to
     * the renderer's {@link Renderer#view view}.
     */
    this.domElement = null;
    /** The resolution used to convert between the DOM client space into world space. */
    this.resolution = 1;
    this.renderer = renderer;
    this.rootBoundary = new EventBoundary(null);
    EventsTicker.init(this);
    this.autoPreventDefault = true;
    this._eventsAdded = false;
    this._rootPointerEvent = new FederatedPointerEvent(null);
    this._rootWheelEvent = new FederatedWheelEvent(null);
    this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    this.features = new Proxy({ ..._EventSystem.defaultEventFeatures }, {
      set: (target, key, value) => {
        if (key === "globalMove") {
          this.rootBoundary.enableGlobalMoveEvents = value;
        }
        target[key] = value;
        return true;
      }
    });
    this._onPointerDown = this._onPointerDown.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerUp = this._onPointerUp.bind(this);
    this._onPointerOverOut = this._onPointerOverOut.bind(this);
    this.onWheel = this.onWheel.bind(this);
  }
  /**
   * The default interaction mode for all display objects.
   * @see Container.eventMode
   * @type {EventMode}
   * @readonly
   * @since 7.2.0
   */
  static get defaultEventMode() {
    return this._defaultEventMode;
  }
  /**
   * Runner init called, view is available at this point.
   * @ignore
   */
  init(options) {
    const { canvas, resolution } = this.renderer;
    this.setTargetElement(canvas);
    this.resolution = resolution;
    _EventSystem._defaultEventMode = options.eventMode ?? "passive";
    Object.assign(this.features, options.eventFeatures ?? {});
    this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
  }
  /**
   * Handle changing resolution.
   * @ignore
   */
  resolutionChange(resolution) {
    this.resolution = resolution;
  }
  /** Destroys all event listeners and detaches the renderer. */
  destroy() {
    EventsTicker.destroy();
    this.setTargetElement(null);
    this.renderer = null;
    this._currentCursor = null;
  }
  /**
   * Sets the current cursor mode, handling any callbacks or CSS style changes.
   * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.
   * @param mode - Cursor mode to set. Can be:
   * - A CSS cursor string (e.g., 'pointer', 'grab')
   * - A key from the cursorStyles dictionary
   * - null/undefined to reset to default
   * @example
   * ```ts
   * // Using predefined cursor styles
   * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor
   * app.renderer.events.setCursor('grab');       // Set grab cursor
   * app.renderer.events.setCursor(null);         // Reset to default
   *
   * // Using custom cursor styles
   * app.renderer.events.cursorStyles.custom = 'url("cursor.png"), auto';
   * app.renderer.events.setCursor('custom');     // Apply custom cursor
   *
   * // Using callback-based cursor
   * app.renderer.events.cursorStyles.dynamic = (mode) => {
   *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';
   * };
   * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback
   * ```
   * @remarks
   * - Has no effect on OffscreenCanvas except for callback-based cursors
   * - Caches current cursor to avoid unnecessary DOM updates
   * - Supports CSS cursor values, style objects, and callback functions
   * @see {@link EventSystem.cursorStyles} For defining custom cursor styles
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference
   */
  setCursor(mode) {
    mode || (mode = "default");
    let applyStyles = true;
    if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
      applyStyles = false;
    }
    if (this._currentCursor === mode) {
      return;
    }
    this._currentCursor = mode;
    const style = this.cursorStyles[mode];
    if (style) {
      switch (typeof style) {
        case "string":
          if (applyStyles) {
            this.domElement.style.cursor = style;
          }
          break;
        case "function":
          style(mode);
          break;
        case "object":
          if (applyStyles) {
            Object.assign(this.domElement.style, style);
          }
          break;
      }
    } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
      this.domElement.style.cursor = mode;
    }
  }
  /**
   * The global pointer event instance containing the most recent pointer state.
   * This is useful for accessing pointer information without listening to events.
   * @example
   * ```ts
   * // Access current pointer position at any time
   * const eventSystem = app.renderer.events;
   * const pointer = eventSystem.pointer;
   *
   * // Get global coordinates
   * console.log('Position:', pointer.global.x, pointer.global.y);
   *
   * // Check button state
   * console.log('Buttons pressed:', pointer.buttons);
   *
   * // Get pointer type and pressure
   * console.log('Type:', pointer.pointerType);
   * console.log('Pressure:', pointer.pressure);
   * ```
   * @readonly
   * @since 7.2.0
   * @see {@link FederatedPointerEvent} For all available pointer properties
   */
  get pointer() {
    return this._rootPointerEvent;
  }
  /**
   * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerDown(nativeEvent) {
    if (!this.features.click) return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const events = this._normalizeToPointerData(nativeEvent);
    if (this.autoPreventDefault && events[0].isNormalized) {
      const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
      if (cancelable) {
        nativeEvent.preventDefault();
      }
    }
    for (let i = 0, j = events.length; i < j; i++) {
      const nativeEvent2 = events[i];
      const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
      this.rootBoundary.mapEvent(federatedEvent);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch events.
   */
  _onPointerMove(nativeEvent) {
    if (!this.features.move) return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    EventsTicker.pointerMoved();
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerUp(nativeEvent) {
    if (!this.features.click) return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    let target = nativeEvent.target;
    if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
      target = nativeEvent.composedPath()[0];
    }
    const outside = target !== this.domElement ? "outside" : "";
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      event.type += outside;
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
   * @param nativeEvent - The native mouse/pointer/touch event.
   */
  _onPointerOverOut(nativeEvent) {
    if (!this.features.click) return;
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    const normalizedEvents = this._normalizeToPointerData(nativeEvent);
    for (let i = 0, j = normalizedEvents.length; i < j; i++) {
      const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);
      this.rootBoundary.mapEvent(event);
    }
    this.setCursor(this.rootBoundary.cursor);
  }
  /**
   * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
   * @param nativeEvent - The native wheel event.
   */
  onWheel(nativeEvent) {
    if (!this.features.wheel) return;
    const wheelEvent = this.normalizeWheelEvent(nativeEvent);
    this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
    this.rootBoundary.mapEvent(wheelEvent);
  }
  /**
   * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
   * This method manages the DOM event bindings for the event system, allowing you to
   * change or remove the target element that receives input events.
   * > [!IMPORTANT] This will default to the canvas element of the renderer, so you
   * > should not need to call this unless you are using a custom element.
   * @param element - The new DOM element to bind events to, or null to remove all event bindings
   * @example
   * ```ts
   * // Set a new canvas element as the target
   * const canvas = document.createElement('canvas');
   * app.renderer.events.setTargetElement(canvas);
   *
   * // Remove all event bindings
   * app.renderer.events.setTargetElement(null);
   *
   * // Switch to a different canvas
   * const newCanvas = document.querySelector('#game-canvas');
   * app.renderer.events.setTargetElement(newCanvas);
   * ```
   * @remarks
   * - Automatically removes event listeners from previous element
   * - Required for the event system to function
   * - Safe to call multiple times
   * @see {@link EventSystem#domElement} The current DOM element
   * @see {@link EventsTicker} For the ticker system that tracks pointer movement
   */
  setTargetElement(element) {
    this._removeEvents();
    this.domElement = element;
    EventsTicker.domElement = element;
    this._addEvents();
  }
  /** Register event listeners on {@link Renderer#domElement this.domElement}. */
  _addEvents() {
    if (this._eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.addTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "none";
        style.msTouchAction = "none";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "none";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
      this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.addEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
      this.domElement.addEventListener("mousedown", this._onPointerDown, true);
      this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.addEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.addEventListener("touchstart", this._onPointerDown, true);
        this.domElement.addEventListener("touchend", this._onPointerUp, true);
        this.domElement.addEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.addEventListener("wheel", this.onWheel, {
      passive: true,
      capture: true
    });
    this._eventsAdded = true;
  }
  /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
  _removeEvents() {
    if (!this._eventsAdded || !this.domElement) {
      return;
    }
    EventsTicker.removeTickerListener();
    const style = this.domElement.style;
    if (style) {
      if (globalThis.navigator.msPointerEnabled) {
        style.msContentZooming = "";
        style.msTouchAction = "";
      } else if (this.supportsPointerEvents) {
        style.touchAction = "";
      }
    }
    if (this.supportsPointerEvents) {
      globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
      this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
      this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
      this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
      globalThis.removeEventListener("pointerup", this._onPointerUp, true);
    } else {
      globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
      this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
      this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
      this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
      globalThis.removeEventListener("mouseup", this._onPointerUp, true);
      if (this.supportsTouchEvents) {
        this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
        this.domElement.removeEventListener("touchend", this._onPointerUp, true);
        this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
      }
    }
    this.domElement.removeEventListener("wheel", this.onWheel, true);
    this.domElement = null;
    this._eventsAdded = false;
  }
  /**
   * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.
   * This takes into account the current scale, position, and resolution of the DOM element.
   * @param point - The point to store the mapped coordinates in
   * @param x - The x coordinate in DOM/client space
   * @param y - The y coordinate in DOM/client space
   * @example
   * ```ts
   * // Map mouse coordinates to PixiJS space
   * const point = new Point();
   * app.renderer.events.mapPositionToPoint(
   *     point,
   *     event.clientX,
   *     event.clientY
   * );
   * console.log('Mapped position:', point.x, point.y);
   *
   * // Using with pointer events
   * sprite.on('pointermove', (event) => {
   *     // event.global already contains mapped coordinates
   *     console.log('Global:', event.global.x, event.global.y);
   *
   *     // Map to local coordinates
   *     const local = event.getLocalPosition(sprite);
   *     console.log('Local:', local.x, local.y);
   * });
   * ```
   * @remarks
   * - Accounts for element scaling and positioning
   * - Adjusts for device pixel ratio/resolution
   */
  mapPositionToPoint(point, x, y) {
    const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
      width: this.domElement.width,
      height: this.domElement.height,
      left: 0,
      top: 0
    };
    const resolutionMultiplier = 1 / this.resolution;
    point.x = (x - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
    point.y = (y - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
  }
  /**
   * Ensures that the original event object contains all data that a regular pointer event would have
   * @param event - The original event data from a touch or mouse event
   * @returns An array containing a single normalized pointer event, in the case of a pointer
   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
   */
  _normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event instanceof TouchEvent) {
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        if (typeof touch.button === "undefined") touch.button = 0;
        if (typeof touch.buttons === "undefined") touch.buttons = 1;
        if (typeof touch.isPrimary === "undefined") {
          touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
        }
        if (typeof touch.width === "undefined") touch.width = touch.radiusX || 1;
        if (typeof touch.height === "undefined") touch.height = touch.radiusY || 1;
        if (typeof touch.tiltX === "undefined") touch.tiltX = 0;
        if (typeof touch.tiltY === "undefined") touch.tiltY = 0;
        if (typeof touch.pointerType === "undefined") touch.pointerType = "touch";
        if (typeof touch.pointerId === "undefined") touch.pointerId = touch.identifier || 0;
        if (typeof touch.pressure === "undefined") touch.pressure = touch.force || 0.5;
        if (typeof touch.twist === "undefined") touch.twist = 0;
        if (typeof touch.tangentialPressure === "undefined") touch.tangentialPressure = 0;
        if (typeof touch.layerX === "undefined") touch.layerX = touch.offsetX = touch.clientX;
        if (typeof touch.layerY === "undefined") touch.layerY = touch.offsetY = touch.clientY;
        touch.isNormalized = true;
        touch.type = event.type;
        normalizedEvents.push(touch);
      }
    } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
      const tempEvent = event;
      if (typeof tempEvent.isPrimary === "undefined") tempEvent.isPrimary = true;
      if (typeof tempEvent.width === "undefined") tempEvent.width = 1;
      if (typeof tempEvent.height === "undefined") tempEvent.height = 1;
      if (typeof tempEvent.tiltX === "undefined") tempEvent.tiltX = 0;
      if (typeof tempEvent.tiltY === "undefined") tempEvent.tiltY = 0;
      if (typeof tempEvent.pointerType === "undefined") tempEvent.pointerType = "mouse";
      if (typeof tempEvent.pointerId === "undefined") tempEvent.pointerId = MOUSE_POINTER_ID;
      if (typeof tempEvent.pressure === "undefined") tempEvent.pressure = 0.5;
      if (typeof tempEvent.twist === "undefined") tempEvent.twist = 0;
      if (typeof tempEvent.tangentialPressure === "undefined") tempEvent.tangentialPressure = 0;
      tempEvent.isNormalized = true;
      normalizedEvents.push(tempEvent);
    } else {
      normalizedEvents.push(event);
    }
    return normalizedEvents;
  }
  /**
   * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
   *
   * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
   * multiple native wheel events.
   * @param nativeEvent - The native wheel event that occurred on the canvas.
   * @returns A federated wheel event.
   */
  normalizeWheelEvent(nativeEvent) {
    const event = this._rootWheelEvent;
    this._transferMouseData(event, nativeEvent);
    event.deltaX = nativeEvent.deltaX;
    event.deltaY = nativeEvent.deltaY;
    event.deltaZ = nativeEvent.deltaZ;
    event.deltaMode = nativeEvent.deltaMode;
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.nativeEvent = nativeEvent;
    event.type = nativeEvent.type;
    return event;
  }
  /**
   * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
   * @param event
   * @param nativeEvent
   */
  _bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null;
    event.nativeEvent = nativeEvent;
    event.pointerId = nativeEvent.pointerId;
    event.width = nativeEvent.width;
    event.height = nativeEvent.height;
    event.isPrimary = nativeEvent.isPrimary;
    event.pointerType = nativeEvent.pointerType;
    event.pressure = nativeEvent.pressure;
    event.tangentialPressure = nativeEvent.tangentialPressure;
    event.tiltX = nativeEvent.tiltX;
    event.tiltY = nativeEvent.tiltY;
    event.twist = nativeEvent.twist;
    this._transferMouseData(event, nativeEvent);
    this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
    event.global.copyFrom(event.screen);
    event.offset.copyFrom(event.screen);
    event.isTrusted = nativeEvent.isTrusted;
    if (event.type === "pointerleave") {
      event.type = "pointerout";
    }
    if (event.type.startsWith("mouse")) {
      event.type = event.type.replace("mouse", "pointer");
    }
    if (event.type.startsWith("touch")) {
      event.type = TOUCH_TO_POINTER[event.type] || event.type;
    }
    return event;
  }
  /**
   * Transfers base & mouse event data from the `nativeEvent` to the federated event.
   * @param event
   * @param nativeEvent
   */
  _transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted;
    event.srcElement = nativeEvent.srcElement;
    event.timeStamp = performance.now();
    event.type = nativeEvent.type;
    event.altKey = nativeEvent.altKey;
    event.button = nativeEvent.button;
    event.buttons = nativeEvent.buttons;
    event.client.x = nativeEvent.clientX;
    event.client.y = nativeEvent.clientY;
    event.ctrlKey = nativeEvent.ctrlKey;
    event.metaKey = nativeEvent.metaKey;
    event.movement.x = nativeEvent.movementX;
    event.movement.y = nativeEvent.movementY;
    event.page.x = nativeEvent.pageX;
    event.page.y = nativeEvent.pageY;
    event.relatedTarget = null;
    event.shiftKey = nativeEvent.shiftKey;
  }
};
/** @ignore */
_EventSystem.extension = {
  name: "events",
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.CanvasSystem,
    ExtensionType.WebGPUSystem
  ],
  priority: -1
};
/**
 * The event features that are enabled by the EventSystem
 * @since 7.2.0
 * @example
 * ```ts
 * import { EventSystem, EventSystemFeatures } from 'pixi.js';
 * // Access the default event features
 * EventSystem.defaultEventFeatures = {
 *     // Enable pointer movement events
 *     move: true,
 *     // Enable global pointer move events
 *     globalMove: true,
 *     // Enable click events
 *     click: true,
 *     // Enable wheel events
 *     wheel: true,
 * };
 * ```
 */
_EventSystem.defaultEventFeatures = {
  /** Enables pointer events associated with pointer movement. */
  move: true,
  /** Enables global pointer move events. */
  globalMove: true,
  /** Enables pointer events associated with clicking. */
  click: true,
  /** Enables wheel events. */
  wheel: true
};
let EventSystem = _EventSystem;

const FederatedContainer = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  get interactive() {
    return this.eventMode === "dynamic" || this.eventMode === "static";
  },
  set interactive(value) {
    this.eventMode = value ? "static" : "passive";
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? EventSystem.defaultEventMode;
  },
  set eventMode(value) {
    this._internalEventMode = value;
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: true,
  hitArea: null,
  addEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const signal = typeof options === "object" ? options.signal : void 0;
    const once = typeof options === "object" ? options.once === true : false;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
    const emitter = this;
    if (signal) {
      signal.addEventListener("abort", () => {
        emitter.off(type, listenerFn, context);
      });
    }
    if (once) {
      emitter.once(type, listenerFn, context);
    } else {
      emitter.on(type, listenerFn, context);
    }
  },
  removeEventListener(type, listener, options) {
    const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
    const context = typeof listener === "function" ? void 0 : listener;
    type = capture ? `${type}capture` : type;
    listener = typeof listener === "function" ? listener : listener.handleEvent;
    this.off(type, listener, context);
  },
  dispatchEvent(e) {
    if (!(e instanceof FederatedEvent)) {
      throw new Error("Container cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = false;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }
};

var vertex$2 = "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";

var fragment$2 = "in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n";

var source$1 = "struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";

class PassthroughFilter extends Filter {
  constructor() {
    const gpuProgram = GpuProgram.from({
      vertex: { source: source$1, entryPoint: "mainVertex" },
      fragment: { source: source$1, entryPoint: "mainFragment" },
      name: "passthrough-filter"
    });
    const glProgram = GlProgram.from({
      vertex: vertex$2,
      fragment: fragment$2,
      name: "passthrough-filter"
    });
    super({
      gpuProgram,
      glProgram
    });
  }
}

class FilterPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  push(filterEffect, container, instructionSet) {
    const renderPipes = this._renderer.renderPipes;
    renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      canBundle: false,
      action: "pushFilter",
      container,
      filterEffect
    });
  }
  pop(_filterEffect, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  execute(instruction) {
    if (instruction.action === "pushFilter") {
      this._renderer.filter.push(instruction);
    } else if (instruction.action === "popFilter") {
      this._renderer.filter.pop();
    }
  }
  destroy() {
    this._renderer = null;
  }
}
FilterPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "filter"
};

function pointInTriangle(px, py, x1, y1, x2, y2, x3, y3) {
  const v2x = x3 - x1;
  const v2y = y3 - y1;
  const v1x = x2 - x1;
  const v1y = y2 - y1;
  const v0x = px - x1;
  const v0y = py - y1;
  const dot00 = v2x * v2x + v2y * v2y;
  const dot01 = v2x * v1x + v2y * v1y;
  const dot02 = v2x * v0x + v2y * v0y;
  const dot11 = v1x * v1x + v1y * v1y;
  const dot12 = v1x * v0x + v1y * v0y;
  const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
  return u >= 0 && v >= 0 && u + v < 1;
}

const tempProjectionMatrix = new Matrix();
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const actualMatrix = bounds.matrix;
  for (let i = 0; i < renderables.length; i++) {
    const renderable = renderables[i];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
    if (renderGroup?.isCachedAsTexture) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform).append(renderable.worldTransform);
    } else if (renderGroup?._parentCacheAsTextureRenderGroup) {
      bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(renderable.groupTransform);
    } else {
      bounds.matrix = renderable.worldTransform;
    }
    bounds.addBounds(renderable.bounds);
  }
  bounds.matrix = actualMatrix;
  return bounds;
}

const quadGeometry = new Geometry({
  attributes: {
    aPosition: {
      buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      format: "float32x2",
      stride: 2 * 4,
      offset: 0
    }
  },
  indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
});
class FilterData {
  constructor() {
    /**
     * Indicates whether the filter should be skipped.
     * @type {boolean}
     */
    this.skip = false;
    /**
     * The texture to which the filter is applied.
     * @type {Texture}
     */
    this.inputTexture = null;
    /**
     * The back texture used for blending, if required.
     * @type {Texture | null}
     */
    this.backTexture = null;
    /**
     * The list of filters to be applied.
     * @type {Filter[]}
     */
    this.filters = null;
    /**
     * The bounds of the filter area.
     * @type {Bounds}
     */
    this.bounds = new Bounds();
    /**
     * The container to which the filter is applied.
     * @type {Container}
     */
    this.container = null;
    /**
     * Indicates whether blending is required for the filter.
     * @type {boolean}
     */
    this.blendRequired = false;
    /**
     * The render surface where the output of the filter is rendered.
     * @type {RenderSurface}
     */
    this.outputRenderSurface = null;
    /**
     * The global frame of the filter area.
     * @type {{ x: number, y: number, width: number, height: number }}
     */
    this.globalFrame = { x: 0, y: 0, width: 0, height: 0 };
    /** The first enabled filter index in the current filter list. */
    this.firstEnabledIndex = -1;
    /** The last enabled filter index in the current filter list. */
    this.lastEnabledIndex = -1;
  }
}
class FilterSystem {
  constructor(renderer) {
    this._filterStackIndex = 0;
    this._filterStack = [];
    this._filterGlobalUniforms = new UniformGroup({
      uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
      uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
      uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
    });
    this._globalFilterBindGroup = new BindGroup({});
    this.renderer = renderer;
  }
  /**
   * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
   * @readonly
   */
  get activeBackTexture() {
    return this._activeFilterData?.backTexture;
  }
  /**
   * Pushes a filter instruction onto the filter stack.
   * @param instruction - The instruction containing the filter effect and container.
   * @internal
   */
  push(instruction) {
    const renderer = this.renderer;
    const filters = instruction.filterEffect.filters;
    const filterData = this._pushFilterData();
    filterData.skip = false;
    filterData.filters = filters;
    filterData.container = instruction.container;
    filterData.outputRenderSurface = renderer.renderTarget.renderSurface;
    const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
    const rootResolution = colorTextureSource.resolution;
    const rootAntialias = colorTextureSource.antialias;
    if (filters.every((filter) => !filter.enabled)) {
      filterData.skip = true;
      return;
    }
    const bounds = filterData.bounds;
    this._calculateFilterArea(instruction, bounds);
    this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);
    if (filterData.skip) {
      return;
    }
    const previousFilterData = this._getPreviousFilterData();
    const globalResolution = this._findFilterResolution(rootResolution);
    let offsetX = 0;
    let offsetY = 0;
    if (previousFilterData) {
      offsetX = previousFilterData.bounds.minX;
      offsetY = previousFilterData.bounds.minY;
    }
    this._calculateGlobalFrame(
      filterData,
      offsetX,
      offsetY,
      globalResolution,
      colorTextureSource.width,
      colorTextureSource.height
    );
    this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);
  }
  /**
   * Applies filters to a texture.
   *
   * This method takes a texture and a list of filters, applies the filters to the texture,
   * and returns the resulting texture.
   * @param {object} params - The parameters for applying filters.
   * @param {Texture} params.texture - The texture to apply filters to.
   * @param {Filter[]} params.filters - The filters to apply.
   * @returns {Texture} The resulting texture after all filters have been applied.
   * @example
   *
   * ```ts
   * // Create a texture and a list of filters
   * const texture = new Texture(...);
   * const filters = [new BlurFilter(), new ColorMatrixFilter()];
   *
   * // Apply the filters to the texture
   * const resultTexture = filterSystem.applyToTexture({ texture, filters });
   *
   * // Use the resulting texture
   * sprite.texture = resultTexture;
   * ```
   *
   * Key Points:
   * 1. padding is not currently supported here - so clipping may occur with filters that use padding.
   * 2. If all filters are disabled or skipped, the original texture is returned.
   */
  generateFilteredTexture({ texture, filters }) {
    const filterData = this._pushFilterData();
    this._activeFilterData = filterData;
    filterData.skip = false;
    filterData.filters = filters;
    const colorTextureSource = texture.source;
    const rootResolution = colorTextureSource.resolution;
    const rootAntialias = colorTextureSource.antialias;
    if (filters.every((filter) => !filter.enabled)) {
      filterData.skip = true;
      return texture;
    }
    const bounds = filterData.bounds;
    bounds.addRect(texture.frame);
    this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);
    if (filterData.skip) {
      return texture;
    }
    const globalResolution = rootResolution;
    const offsetX = 0;
    const offsetY = 0;
    this._calculateGlobalFrame(
      filterData,
      offsetX,
      offsetY,
      globalResolution,
      colorTextureSource.width,
      colorTextureSource.height
    );
    filterData.outputRenderSurface = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      filterData.resolution,
      filterData.antialias
    );
    filterData.backTexture = Texture.EMPTY;
    filterData.inputTexture = texture;
    const renderer = this.renderer;
    renderer.renderTarget.finishRenderPass();
    this._applyFiltersToTexture(filterData, true);
    const outputTexture = filterData.outputRenderSurface;
    outputTexture.source.alphaMode = "premultiplied-alpha";
    return outputTexture;
  }
  /** @internal */
  pop() {
    const renderer = this.renderer;
    const filterData = this._popFilterData();
    if (filterData.skip) {
      return;
    }
    renderer.globalUniforms.pop();
    renderer.renderTarget.finishRenderPass();
    this._activeFilterData = filterData;
    this._applyFiltersToTexture(filterData, false);
    if (filterData.blendRequired) {
      TexturePool.returnTexture(filterData.backTexture);
    }
    TexturePool.returnTexture(filterData.inputTexture);
  }
  /**
   * Copies the last render surface to a texture.
   * @param lastRenderSurface - The last render surface to copy from.
   * @param bounds - The bounds of the area to copy.
   * @param previousBounds - The previous bounds to use for offsetting the copy.
   */
  getBackTexture(lastRenderSurface, bounds, previousBounds) {
    const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
    const backTexture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      backgroundResolution,
      false
    );
    let x = bounds.minX;
    let y = bounds.minY;
    if (previousBounds) {
      x -= previousBounds.minX;
      y -= previousBounds.minY;
    }
    x = Math.floor(x * backgroundResolution);
    y = Math.floor(y * backgroundResolution);
    const width = Math.ceil(bounds.width * backgroundResolution);
    const height = Math.ceil(bounds.height * backgroundResolution);
    this.renderer.renderTarget.copyToTexture(
      lastRenderSurface,
      backTexture,
      { x, y },
      { width, height },
      { x: 0, y: 0 }
    );
    return backTexture;
  }
  /**
   * Applies a filter to a texture.
   * @param filter - The filter to apply.
   * @param input - The input texture.
   * @param output - The output render surface.
   * @param clear - Whether to clear the output surface before applying the filter.
   */
  applyFilter(filter, input, output, clear) {
    const renderer = this.renderer;
    const filterData = this._activeFilterData;
    const outputRenderSurface = filterData.outputRenderSurface;
    const isFinalTarget = outputRenderSurface === output;
    const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
    const resolution = this._findFilterResolution(rootResolution);
    let offsetX = 0;
    let offsetY = 0;
    if (isFinalTarget) {
      const offset = this._findPreviousFilterOffset();
      offsetX = offset.x;
      offsetY = offset.y;
    }
    this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);
    const filterToApply = filter.enabled ? filter : this._getPassthroughFilter();
    this._setupBindGroupsAndRender(filterToApply, input, renderer);
  }
  /**
   * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
   *
   * Use `outputMatrix * vTextureCoord` in the shader.
   * @param outputMatrix - The matrix to output to.
   * @param {Sprite} sprite - The sprite to map to.
   * @returns The mapped matrix.
   */
  calculateSpriteMatrix(outputMatrix, sprite) {
    const data = this._activeFilterData;
    const mappedMatrix = outputMatrix.set(
      data.inputTexture._source.width,
      0,
      0,
      data.inputTexture._source.height,
      data.bounds.minX,
      data.bounds.minY
    );
    const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
    const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
    if (renderGroup && renderGroup.cacheToLocalTransform) {
      worldTransform.prepend(renderGroup.cacheToLocalTransform);
    }
    worldTransform.invert();
    mappedMatrix.prepend(worldTransform);
    mappedMatrix.scale(
      1 / sprite.texture.orig.width,
      1 / sprite.texture.orig.height
    );
    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
    return mappedMatrix;
  }
  destroy() {
    this._passthroughFilter?.destroy(true);
    this._passthroughFilter = null;
  }
  _getPassthroughFilter() {
    this._passthroughFilter ?? (this._passthroughFilter = new PassthroughFilter());
    return this._passthroughFilter;
  }
  /**
   * Sets up the bind groups and renders the filter.
   * @param filter - The filter to apply
   * @param input - The input texture
   * @param renderer - The renderer instance
   */
  _setupBindGroupsAndRender(filter, input, renderer) {
    if (renderer.renderPipes.uniformBatch) {
      const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
      this._globalFilterBindGroup.setResource(batchUniforms, 0);
    } else {
      this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
    }
    this._globalFilterBindGroup.setResource(input.source, 1);
    this._globalFilterBindGroup.setResource(input.source.style, 2);
    filter.groups[0] = this._globalFilterBindGroup;
    renderer.encoder.draw({
      geometry: quadGeometry,
      shader: filter,
      state: filter._state,
      topology: "triangle-list"
    });
    if (renderer.type === RendererType.WEBGL) {
      renderer.renderTarget.finishRenderPass();
    }
  }
  /**
   * Sets up the filter textures including input texture and back texture if needed.
   * @param filterData - The filter data to update
   * @param bounds - The bounds for the texture
   * @param renderer - The renderer instance
   * @param previousFilterData - The previous filter data for back texture calculation
   */
  _setupFilterTextures(filterData, bounds, renderer, previousFilterData) {
    filterData.backTexture = Texture.EMPTY;
    filterData.inputTexture = TexturePool.getOptimalTexture(
      bounds.width,
      bounds.height,
      filterData.resolution,
      filterData.antialias
    );
    if (filterData.blendRequired) {
      renderer.renderTarget.finishRenderPass();
      const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);
      filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);
    }
    renderer.renderTarget.bind(filterData.inputTexture, true);
    renderer.globalUniforms.push({
      offset: bounds
    });
  }
  /**
   * Calculates and sets the global frame for the filter.
   * @param filterData - The filter data to update
   * @param offsetX - The X offset
   * @param offsetY - The Y offset
   * @param globalResolution - The global resolution
   * @param sourceWidth - The source texture width
   * @param sourceHeight - The source texture height
   */
  _calculateGlobalFrame(filterData, offsetX, offsetY, globalResolution, sourceWidth, sourceHeight) {
    const globalFrame = filterData.globalFrame;
    globalFrame.x = offsetX * globalResolution;
    globalFrame.y = offsetY * globalResolution;
    globalFrame.width = sourceWidth * globalResolution;
    globalFrame.height = sourceHeight * globalResolution;
  }
  /**
   * Updates the filter uniforms with the current filter state.
   * @param input - The input texture
   * @param output - The output render surface
   * @param filterData - The current filter data
   * @param offsetX - The X offset for positioning
   * @param offsetY - The Y offset for positioning
   * @param resolution - The current resolution
   * @param isFinalTarget - Whether this is the final render target
   * @param clear - Whether to clear the output surface
   */
  _updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear) {
    const uniforms = this._filterGlobalUniforms.uniforms;
    const outputFrame = uniforms.uOutputFrame;
    const inputSize = uniforms.uInputSize;
    const inputPixel = uniforms.uInputPixel;
    const inputClamp = uniforms.uInputClamp;
    const globalFrame = uniforms.uGlobalFrame;
    const outputTexture = uniforms.uOutputTexture;
    if (isFinalTarget) {
      outputFrame[0] = filterData.bounds.minX - offsetX;
      outputFrame[1] = filterData.bounds.minY - offsetY;
    } else {
      outputFrame[0] = 0;
      outputFrame[1] = 0;
    }
    outputFrame[2] = input.frame.width;
    outputFrame[3] = input.frame.height;
    inputSize[0] = input.source.width;
    inputSize[1] = input.source.height;
    inputSize[2] = 1 / inputSize[0];
    inputSize[3] = 1 / inputSize[1];
    inputPixel[0] = input.source.pixelWidth;
    inputPixel[1] = input.source.pixelHeight;
    inputPixel[2] = 1 / inputPixel[0];
    inputPixel[3] = 1 / inputPixel[1];
    inputClamp[0] = 0.5 * inputPixel[2];
    inputClamp[1] = 0.5 * inputPixel[3];
    inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
    inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
    const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
    globalFrame[0] = offsetX * resolution;
    globalFrame[1] = offsetY * resolution;
    globalFrame[2] = rootTexture.source.width * resolution;
    globalFrame[3] = rootTexture.source.height * resolution;
    if (output instanceof Texture) output.source.resource = null;
    const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
    this.renderer.renderTarget.bind(output, !!clear);
    if (output instanceof Texture) {
      outputTexture[0] = output.frame.width;
      outputTexture[1] = output.frame.height;
    } else {
      outputTexture[0] = renderTarget.width;
      outputTexture[1] = renderTarget.height;
    }
    outputTexture[2] = renderTarget.isRoot ? -1 : 1;
    this._filterGlobalUniforms.update();
  }
  /**
   * Finds the correct resolution by looking back through the filter stack.
   * @param rootResolution - The fallback root resolution to use
   * @returns The resolution from the previous filter or root resolution
   */
  _findFilterResolution(rootResolution) {
    let currentIndex = this._filterStackIndex - 1;
    while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
      --currentIndex;
    }
    return currentIndex > 0 && this._filterStack[currentIndex].inputTexture ? this._filterStack[currentIndex].inputTexture.source._resolution : rootResolution;
  }
  /**
   * Finds the offset from the previous non-skipped filter in the stack.
   * @returns The offset coordinates from the previous filter
   */
  _findPreviousFilterOffset() {
    let offsetX = 0;
    let offsetY = 0;
    let lastIndex = this._filterStackIndex;
    while (lastIndex > 0) {
      lastIndex--;
      const prevFilterData = this._filterStack[lastIndex];
      if (!prevFilterData.skip) {
        offsetX = prevFilterData.bounds.minX;
        offsetY = prevFilterData.bounds.minY;
        break;
      }
    }
    return { x: offsetX, y: offsetY };
  }
  /**
   * Calculates the filter area bounds based on the instruction type.
   * @param instruction - The filter instruction
   * @param bounds - The bounds object to populate
   */
  _calculateFilterArea(instruction, bounds) {
    if (instruction.renderables) {
      getGlobalRenderableBounds(instruction.renderables, bounds);
    } else if (instruction.filterEffect.filterArea) {
      bounds.clear();
      bounds.addRect(instruction.filterEffect.filterArea);
      bounds.applyMatrix(instruction.container.worldTransform);
    } else {
      instruction.container.getFastGlobalBounds(true, bounds);
    }
    if (instruction.container) {
      const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;
      const filterFrameTransform = renderGroup.cacheToLocalTransform;
      if (filterFrameTransform) {
        bounds.applyMatrix(filterFrameTransform);
      }
    }
  }
  _applyFiltersToTexture(filterData, clear) {
    const inputTexture = filterData.inputTexture;
    const bounds = filterData.bounds;
    const filters = filterData.filters;
    const firstEnabled = filterData.firstEnabledIndex;
    const lastEnabled = filterData.lastEnabledIndex;
    this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
    this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);
    if (firstEnabled === lastEnabled) {
      filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);
    } else {
      let flip = filterData.inputTexture;
      const tempTexture = TexturePool.getOptimalTexture(
        bounds.width,
        bounds.height,
        flip.source._resolution,
        false
      );
      let flop = tempTexture;
      for (let i = firstEnabled; i < lastEnabled; i++) {
        const filter = filters[i];
        if (!filter.enabled) continue;
        filter.apply(this, flip, flop, true);
        const t = flip;
        flip = flop;
        flop = t;
      }
      filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);
      TexturePool.returnTexture(tempTexture);
    }
  }
  _calculateFilterBounds(filterData, viewPort, rootAntialias, rootResolution, paddingMultiplier) {
    const renderer = this.renderer;
    const bounds = filterData.bounds;
    const filters = filterData.filters;
    let resolution = Infinity;
    let padding = 0;
    let antialias = true;
    let blendRequired = false;
    let enabled = false;
    let clipToViewport = true;
    let firstEnabledIndex = -1;
    let lastEnabledIndex = -1;
    for (let i = 0; i < filters.length; i++) {
      const filter = filters[i];
      if (!filter.enabled) continue;
      if (firstEnabledIndex === -1) firstEnabledIndex = i;
      lastEnabledIndex = i;
      resolution = Math.min(resolution, filter.resolution === "inherit" ? rootResolution : filter.resolution);
      padding += filter.padding;
      if (filter.antialias === "off") {
        antialias = false;
      } else if (filter.antialias === "inherit") {
        antialias && (antialias = rootAntialias);
      }
      if (!filter.clipToViewport) {
        clipToViewport = false;
      }
      const isCompatible = !!(filter.compatibleRenderers & renderer.type);
      if (!isCompatible) {
        enabled = false;
        break;
      }
      if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
        warn$2("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
        enabled = false;
        break;
      }
      enabled = true;
      blendRequired || (blendRequired = filter.blendRequired);
    }
    if (!enabled) {
      filterData.skip = true;
      return;
    }
    if (clipToViewport) {
      bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);
    }
    bounds.scale(resolution).ceil().scale(1 / resolution).pad((padding | 0) * paddingMultiplier);
    if (!bounds.isPositive) {
      filterData.skip = true;
      return;
    }
    filterData.antialias = antialias;
    filterData.resolution = resolution;
    filterData.blendRequired = blendRequired;
    filterData.firstEnabledIndex = firstEnabledIndex;
    filterData.lastEnabledIndex = lastEnabledIndex;
  }
  _popFilterData() {
    this._filterStackIndex--;
    return this._filterStack[this._filterStackIndex];
  }
  _getPreviousFilterData() {
    let previousFilterData;
    let index = this._filterStackIndex - 1;
    while (index > 0) {
      index--;
      previousFilterData = this._filterStack[index];
      if (!previousFilterData.skip) {
        break;
      }
    }
    return previousFilterData;
  }
  _pushFilterData() {
    let filterData = this._filterStack[this._filterStackIndex];
    if (!filterData) {
      filterData = this._filterStack[this._filterStackIndex] = new FilterData();
    }
    this._filterStackIndex++;
    return filterData;
  }
}
/** @ignore */
FilterSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "filter"
};

var fragment$1 = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\nuniform float uInverse;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha;\n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    float a = alphaMul * masky.r * npmAlpha * clip;\n\n    if (uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    finalColor = original * a;\n}\n";

var vertex$1 = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";

var source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n    var uAlpha = filterUniforms.uAlpha;\n\n    var clip = step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse == 1.0) {\n        a = 1.0 - a;\n    }\n\n    return source * a;\n}\n";

class MaskFilter extends Filter {
  constructor(options) {
    const { sprite, ...rest } = options;
    const textureMatrix = new TextureMatrix(sprite.texture);
    const filterUniforms = new UniformGroup({
      uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
      uAlpha: { value: 1, type: "f32" },
      uInverse: { value: options.inverse ? 1 : 0, type: "f32" }
    });
    const gpuProgram = GpuProgram.from({
      vertex: {
        source,
        entryPoint: "mainVertex"
      },
      fragment: {
        source,
        entryPoint: "mainFragment"
      }
    });
    const glProgram = GlProgram.from({
      vertex: vertex$1,
      fragment: fragment$1,
      name: "mask-filter"
    });
    super({
      ...rest,
      gpuProgram,
      glProgram,
      clipToViewport: false,
      resources: {
        filterUniforms,
        uMaskTexture: sprite.texture.source
      }
    });
    this.sprite = sprite;
    this._textureMatrix = textureMatrix;
  }
  set inverse(value) {
    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
  }
  get inverse() {
    return this.resources.filterUniforms.uniforms.uInverse === 1;
  }
  apply(filterManager, input, output, clearMode) {
    this._textureMatrix.texture = this.sprite.texture;
    filterManager.calculateSpriteMatrix(
      this.resources.filterUniforms.uniforms.uFilterMatrix,
      this.sprite
    ).prepend(this._textureMatrix.mapCoord);
    this.resources.uMaskTexture = this.sprite.texture.source;
    filterManager.applyFilter(this, input, output, clearMode);
  }
}

class CanvasGraphicsContext {
  constructor() {
    /**
     * Whether this context can be batched.
     * @advanced
     */
    this.isBatchable = false;
  }
  /**
   * Reset cached canvas data.
   * @advanced
   */
  reset() {
    this.isBatchable = false;
    this.context = null;
    if (this.graphicsData) {
      this.graphicsData.destroy();
      this.graphicsData = null;
    }
  }
  /**
   * Destroy the cached data.
   * @advanced
   */
  destroy() {
    this.reset();
  }
}
class CanvasGraphicsContextRenderData {
  constructor() {
    /**
     * Instructions for canvas rendering.
     * @advanced
     */
    this.instructions = new InstructionSet();
  }
  /**
   * Initialize render data.
   * @advanced
   */
  init() {
    this.instructions.reset();
  }
  /**
   * Destroy render data.
   * @advanced
   */
  destroy() {
    this.instructions.destroy();
    this.instructions = null;
  }
}
const _CanvasGraphicsContextSystem = class _CanvasGraphicsContextSystem {
  constructor(renderer) {
    this._renderer = renderer;
    this._managedContexts = new GCManagedHash({ renderer, type: "resource", name: "graphicsContext" });
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(options) {
    _CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _CanvasGraphicsContextSystem.defaultOptions.bezierSmoothness;
  }
  /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */
  getContextRenderData(context) {
    const gpuContext = this.getGpuContext(context);
    return gpuContext.graphicsData || this._initContextRenderData(context);
  }
  /**
   * Updates the GPU context for a given GraphicsContext.
   * @param context - The GraphicsContext to update.
   * @returns The updated CanvasGraphicsContext.
   * @internal
   */
  updateGpuContext(context) {
    const gpuData = context._gpuData;
    const hasContext = !!gpuData[this._renderer.uid];
    const gpuContext = gpuData[this._renderer.uid] || this._initContext(context);
    if (context.dirty || !hasContext) {
      if (hasContext) {
        gpuContext.reset();
      }
      gpuContext.isBatchable = false;
      context.dirty = false;
    }
    return gpuContext;
  }
  /**
   * Returns the CanvasGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the CanvasGraphicsContext for.
   * @returns The CanvasGraphicsContext for the given GraphicsContext.
   * @internal
   */
  getGpuContext(context) {
    const gpuData = context._gpuData;
    return gpuData[this._renderer.uid] || this._initContext(context);
  }
  _initContextRenderData(context) {
    const renderData = new CanvasGraphicsContextRenderData();
    const gpuContext = this.getGpuContext(context);
    gpuContext.graphicsData = renderData;
    renderData.init();
    return renderData;
  }
  _initContext(context) {
    const gpuContext = new CanvasGraphicsContext();
    gpuContext.context = context;
    context._gpuData[this._renderer.uid] = gpuContext;
    this._managedContexts.add(context);
    return gpuContext;
  }
  destroy() {
    this._managedContexts.destroy();
    this._renderer = null;
  }
};
/** @ignore */
_CanvasGraphicsContextSystem.extension = {
  type: [
    ExtensionType.CanvasSystem
  ],
  name: "graphicsContext"
};
/** The default options for the GraphicsContextSystem. */
_CanvasGraphicsContextSystem.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let CanvasGraphicsContextSystem = _CanvasGraphicsContextSystem;

class CanvasGraphicsPipe {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this.renderer = renderer;
    this._adaptor = adaptor;
    this.renderer.runners.contextChange.add(this);
    this._managedGraphics = new GCManagedHash({ renderer, type: "renderable", priority: -1, name: "graphics" });
  }
  contextChange() {
    this._adaptor.contextChange(this.renderer);
  }
  validateRenderable(_graphics) {
    return false;
  }
  addRenderable(graphics, instructionSet) {
    this._managedGraphics.add(graphics);
    this.renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(graphics);
  }
  updateRenderable(_graphics) {
  }
  execute(graphics) {
    if (!graphics.isRenderable) return;
    this._adaptor.execute(this, graphics);
  }
  destroy() {
    this._managedGraphics.destroy();
    this.renderer = null;
    this._adaptor.destroy();
    this._adaptor = null;
  }
}
/** @ignore */
CanvasGraphicsPipe.extension = {
  type: [
    ExtensionType.CanvasPipes
  ],
  name: "graphics"
};

function color32BitToUniform(abgr, out, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out[offset++] = (abgr & 255) / 255 * alpha;
  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out[offset++] = alpha;
}

class GraphicsGpuData {
  constructor() {
    this.batches = [];
    this.batched = false;
  }
  destroy() {
    this.batches.forEach((batch) => {
      BigPool.return(batch);
    });
    this.batches.length = 0;
  }
}
class GraphicsPipe {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this.renderer = renderer;
    this._adaptor = adaptor;
    this.renderer.runners.contextChange.add(this);
    this._managedGraphics = new GCManagedHash({ renderer, type: "renderable", priority: -1, name: "graphics" });
  }
  contextChange() {
    this._adaptor.contextChange(this.renderer);
  }
  validateRenderable(graphics) {
    const context = graphics.context;
    const wasBatched = !!graphics._gpuData;
    const contextSystem = this.renderer.graphicsContext;
    const gpuContext = contextSystem.updateGpuContext(context);
    if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
      return true;
    }
    return false;
  }
  addRenderable(graphics, instructionSet) {
    const contextSystem = this.renderer.graphicsContext;
    const gpuContext = contextSystem.updateGpuContext(graphics.context);
    if (graphics.didViewUpdate) {
      this._rebuild(graphics);
    }
    if (gpuContext.isBatchable) {
      this._addToBatcher(graphics, instructionSet);
    } else {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(graphics);
    }
  }
  updateRenderable(graphics) {
    const gpuData = this._getGpuDataForRenderable(graphics);
    const batches = gpuData.batches;
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      batch._batcher.updateElement(batch);
    }
  }
  execute(graphics) {
    if (!graphics.isRenderable) return;
    const renderer = this.renderer;
    const context = graphics.context;
    const contextSystem = renderer.graphicsContext;
    if (!contextSystem.getGpuContext(context).batches.length) {
      return;
    }
    const shader = context.customShader || this._adaptor.shader;
    this.state.blendMode = graphics.groupBlendMode;
    const localUniforms = shader.resources.localUniforms.uniforms;
    localUniforms.uTransformMatrix = graphics.groupTransform;
    localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
    color32BitToUniform(
      graphics.groupColorAlpha,
      localUniforms.uColor,
      0
    );
    this._adaptor.execute(this, graphics);
  }
  _rebuild(graphics) {
    const gpuData = this._getGpuDataForRenderable(graphics);
    const contextSystem = this.renderer.graphicsContext;
    const gpuContext = contextSystem.updateGpuContext(graphics.context);
    gpuData.destroy();
    if (gpuContext.isBatchable) {
      this._updateBatchesForRenderable(graphics, gpuData);
    }
  }
  _addToBatcher(graphics, instructionSet) {
    const batchPipe = this.renderer.renderPipes.batch;
    const batches = this._getGpuDataForRenderable(graphics).batches;
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      batchPipe.addToBatch(batch, instructionSet);
    }
  }
  _getGpuDataForRenderable(graphics) {
    return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);
  }
  _initGpuDataForRenderable(graphics) {
    const gpuData = new GraphicsGpuData();
    graphics._gpuData[this.renderer.uid] = gpuData;
    this._managedGraphics.add(graphics);
    return gpuData;
  }
  _updateBatchesForRenderable(graphics, gpuData) {
    const context = graphics.context;
    const contextSystem = this.renderer.graphicsContext;
    const gpuContext = contextSystem.getGpuContext(context);
    const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
    gpuData.batches = gpuContext.batches.map((batch) => {
      const batchClone = BigPool.get(BatchableGraphics);
      batch.copyTo(batchClone);
      batchClone.renderable = graphics;
      batchClone.roundPixels = roundPixels;
      return batchClone;
    });
  }
  destroy() {
    this._managedGraphics.destroy();
    this.renderer = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.state = null;
  }
}
/** @ignore */
GraphicsPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes
  ],
  name: "graphics"
};

extensions.add(CanvasGraphicsPipe);
extensions.add(GraphicsPipe);
extensions.add(CanvasGraphicsContextSystem);
extensions.add(GraphicsContextSystem);

class Graphics extends ViewContainer {
  /**
   * Creates a new Graphics object.
   * @param options - Options for the Graphics.
   */
  constructor(options) {
    if (options instanceof GraphicsContext) {
      options = { context: options };
    }
    const { context, roundPixels, ...rest } = options || {};
    super({
      label: "Graphics",
      ...rest
    });
    /** @internal */
    this.renderPipeId = "graphics";
    if (!context) {
      this.context = this._ownedContext = new GraphicsContext();
      this.context.autoGarbageCollect = this.autoGarbageCollect;
    } else {
      this.context = context;
    }
    this.didViewUpdate = true;
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
  }
  set context(context) {
    if (context === this._context) return;
    if (this._context) {
      this._context.off("update", this.onViewUpdate, this);
      this._context.off("unload", this.unload, this);
    }
    this._context = context;
    this._context.on("update", this.onViewUpdate, this);
    this._context.on("unload", this.unload, this);
    this.onViewUpdate();
  }
  /**
   * The underlying graphics context used for drawing operations.
   * Controls how shapes and paths are rendered.
   * @example
   * ```ts
   * // Create a shared context
   * const sharedContext = new GraphicsContext();
   *
   * // Create graphics objects sharing the same context
   * const graphics1 = new Graphics();
   * const graphics2 = new Graphics();
   *
   * // Assign shared context
   * graphics1.context = sharedContext;
   * graphics2.context = sharedContext;
   *
   * // Both graphics will show the same shapes
   * sharedContext
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   * ```
   * @see {@link GraphicsContext} For drawing operations
   * @see {@link GraphicsOptions} For context configuration
   */
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphics object.
   * Returns the boundaries after all graphical operations but before any transforms.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Get bounds information
   * const bounds = graphics.bounds;
   * console.log(bounds.width);  // 100
   * console.log(bounds.height); // 100
   * ```
   * @readonly
   * @see {@link Bounds} For bounds operations
   * @see {@link Container#getBounds} For transformed bounds
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */
  updateBounds() {
  }
  /**
   * Checks if the object contains the given point.
   * Returns true if the point lies within the Graphics object's rendered area.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Check point intersection
   * if (graphics.containsPoint({ x: 50, y: 50 })) {
   *     console.log('Point is inside rectangle!');
   * }
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is inside the Graphics object
   * @see {@link Graphics#bounds} For bounding box checks
   * @see {@link PointData} For point data structure
   */
  containsPoint(point) {
    return this._context.containsPoint(point);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @example
   * ```ts
   * // Destroy the graphics and its context
   * graphics.destroy();
   * graphics.destroy(true);
   * graphics.destroy({ context: true, texture: true, textureSource: true });
   * ```
   */
  destroy(options) {
    if (this._ownedContext && !options) {
      this._ownedContext.destroy(options);
    } else if (options === true || options?.context === true) {
      this._context.destroy(options);
    }
    this._ownedContext = null;
    this._context = null;
    super.destroy(options);
  }
  /**
   * @param now - The current time in milliseconds.
   * @internal
   */
  _onTouch(now) {
    this._gcLastUsed = now;
    this._context._gcLastUsed = now;
  }
  _callContextMethod(method, args) {
    this.context[method](...args);
    return this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context.
   * The fill style can be a color, gradient, pattern, or a complex style object.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics
   *     .setFillStyle({ color: 0xff0000 }) // Red fill
   *     .rect(0, 0, 100, 100)
   *     .fill();
   *
   * // Gradient fill
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setFillStyle(gradient)
   *     .circle(100, 100, 50)
   *     .fill();
   *
   * // Pattern fill
   * const pattern = new FillPattern(texture);
   * graphics
   *     .setFillStyle({
   *         fill: pattern,
   *         alpha: 0.5
   *     })
   *     .rect(0, 0, 200, 200)
   *     .fill();
   * ```
   * @param {FillInput} args - The fill style to apply
   * @returns The Graphics instance for chaining
   * @see {@link FillStyle} For fill style options
   * @see {@link FillGradient} For gradient fills
   * @see {@link FillPattern} For pattern fills
   */
  setFillStyle(...args) {
    return this._callContextMethod("setFillStyle", args);
  }
  /**
   * Sets the current stroke style of the graphics context.
   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color stroke
   * graphics
   *     .setStrokeStyle({
   *         width: 2,
   *         color: 0x000000
   *     })
   *     .rect(0, 0, 100, 100)
   *     .stroke();
   *
   * // Complex stroke style
   * graphics
   *     .setStrokeStyle({
   *         width: 4,
   *         color: 0xff0000,
   *         alpha: 0.5,
   *         join: 'round',
   *         cap: 'round',
   *         alignment: 0.5
   *     })
   *     .circle(100, 100, 50)
   *     .stroke();
   *
   * // Gradient stroke
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setStrokeStyle({
   *         width: 10,
   *         fill: gradient
   *     })
   *     .poly([0,0, 100,50, 0,100])
   *     .stroke();
   * ```
   * @param {StrokeInput} args - The stroke style to apply
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link FillPattern} For pattern strokes
   */
  setStrokeStyle(...args) {
    return this._callContextMethod("setStrokeStyle", args);
  }
  fill(...args) {
    return this._callContextMethod("fill", args);
  }
  /**
   * Strokes the current path with the current stroke style or specified style.
   * Outlines the shape using the stroke settings.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Stroke with direct color
   * graphics
   *     .circle(50, 50, 25)
   *     .stroke({
   *         width: 2,
   *         color: 0xff0000
   *     }); // 2px red stroke
   *
   * // Fill with texture
   * graphics
   *    .rect(0, 0, 100, 100)
   *    .stroke(myTexture); // Fill with texture
   *
   * // Stroke with gradient
   * const gradient = new FillGradient({
   *     end: { x: 1, y: 0 },
   *     colorStops: [
   *         { offset: 0, color: 0xff0000 },
   *         { offset: 0.5, color: 0x00ff00 },
   *         { offset: 1, color: 0x0000ff },
   *     ],
   * });
   *
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .stroke({
   *         width: 4,
   *         fill: gradient,
   *         alignment: 0.5,
   *         join: 'round'
   *     });
   * ```
   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
   * - A stroke style object with width, color, etc.
   * - A gradient
   * - A pattern
   * If omitted, uses current stroke style.
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link setStrokeStyle} For setting default stroke style
   */
  stroke(...args) {
    return this._callContextMethod("stroke", args);
  }
  texture(...args) {
    return this._callContextMethod("texture", args);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @example
   * ```ts
   * const graphics = new Graphics();
   * graphics
   *     .circle(150, 150, 50)
   *     .fill({ color: 0x00ff00 })
   *     .beginPath() // Starts a new path
   *     .circle(250, 150, 50)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for chaining
   * @see {@link Graphics#moveTo} For starting a new subpath
   * @see {@link Graphics#closePath} For closing the current path
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path.
   *
   * If a hole is not completely in a shape, it will fail to cut correctly.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw outer circle
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *     .circle(100, 100, 25) // Inner circle
   *     .cut() // Cuts out the inner circle from the outer circle
   * ```
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...args) {
    return this._callContextMethod("arc", args);
  }
  arcTo(...args) {
    return this._callContextMethod("arcTo", args);
  }
  arcToSvg(...args) {
    return this._callContextMethod("arcToSvg", args);
  }
  bezierCurveTo(...args) {
    return this._callContextMethod("bezierCurveTo", args);
  }
  /**
   * Closes the current path by drawing a straight line back to the start point.
   *
   * This is useful for completing shapes and ensuring they are properly closed for fills.
   * @example
   * ```ts
   * // Create a triangle with closed path
   * const graphics = new Graphics();
   * graphics
   *     .moveTo(50, 50)
   *     .lineTo(100, 100)
   *     .lineTo(0, 100)
   *     .closePath()
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path
   * @see {@link Graphics#fill} For filling closed paths
   * @see {@link Graphics#stroke} For stroking paths
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...args) {
    return this._callContextMethod("ellipse", args);
  }
  circle(...args) {
    return this._callContextMethod("circle", args);
  }
  path(...args) {
    return this._callContextMethod("path", args);
  }
  lineTo(...args) {
    return this._callContextMethod("lineTo", args);
  }
  moveTo(...args) {
    return this._callContextMethod("moveTo", args);
  }
  quadraticCurveTo(...args) {
    return this._callContextMethod("quadraticCurveTo", args);
  }
  rect(...args) {
    return this._callContextMethod("rect", args);
  }
  roundRect(...args) {
    return this._callContextMethod("roundRect", args);
  }
  poly(...args) {
    return this._callContextMethod("poly", args);
  }
  regularPoly(...args) {
    return this._callContextMethod("regularPoly", args);
  }
  roundPoly(...args) {
    return this._callContextMethod("roundPoly", args);
  }
  roundShape(...args) {
    return this._callContextMethod("roundShape", args);
  }
  filletRect(...args) {
    return this._callContextMethod("filletRect", args);
  }
  chamferRect(...args) {
    return this._callContextMethod("chamferRect", args);
  }
  star(...args) {
    return this._callContextMethod("star", args);
  }
  svg(...args) {
    return this._callContextMethod("svg", args);
  }
  restore(...args) {
    return this._callContextMethod("restore", args);
  }
  /**
   * Saves the current graphics state onto a stack. The state includes:
   * - Current transformation matrix
   * - Current fill style
   * - Current stroke style
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Save state before complex operations
   * graphics.save();
   *
   * // Create transformed and styled shape
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4)
   *     .setFillStyle({
   *         color: 0xff0000,
   *         alpha: 0.5
   *     })
   *     .rect(-25, -25, 50, 50)
   *     .fill();
   *
   * // Restore to original state
   * graphics.restore();
   *
   * // Continue drawing with previous state
   * graphics
   *     .circle(50, 50, 25)
   *     .fill();
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#restore} For restoring the saved state
   * @see {@link Graphics#setTransform} For setting transformations
   */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * This matrix represents all accumulated transformations including translate, scale, and rotate.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply some transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4);
   *
   * // Get the current transform matrix
   * const matrix = graphics.getTransform();
   * console.log(matrix.tx, matrix.ty); // 100, 100
   *
   * // Use the matrix for other operations
   * graphics
   *     .setTransform(matrix)
   *     .circle(0, 0, 50)
   *     .fill({ color: 0xff0000 });
   * ```
   * @returns The current transformation matrix.
   * @see {@link Graphics#setTransform} For setting the transform matrix
   * @see {@link Matrix} For matrix operations
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .scaleTransform(2, 2)
   *     .circle(0, 0, 25)
   *     .fill({ color: 0xff0000 });
   * // Reset transform to default state
   * graphics
   *     .resetTransform()
   *     .circle(50, 50, 25) // Will draw at actual coordinates
   *     .fill({ color: 0x00ff00 });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#getTransform} For getting the current transform
   * @see {@link Graphics#setTransform} For setting a specific transform
   * @see {@link Graphics#save} For saving the current transform state
   * @see {@link Graphics#restore} For restoring a previous transform state
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...args) {
    return this._callContextMethod("rotate", args);
  }
  scaleTransform(...args) {
    return this._callContextMethod("scale", args);
  }
  setTransform(...args) {
    return this._callContextMethod("setTransform", args);
  }
  transform(...args) {
    return this._callContextMethod("transform", args);
  }
  translateTransform(...args) {
    return this._callContextMethod("translate", args);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it.
   * This includes clearing the current path, fill style, stroke style, and transformations.
   *
   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
   * > Instead, they are intended to be used for static or semi-static graphics that
   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw some shapes
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 })
   *     .rect(200, 100, 100, 50)
   *     .fill({ color: 0x00ff00 });
   *
   * // Clear all graphics
   * graphics.clear();
   *
   * // Start fresh with new shapes
   * graphics
   *     .circle(150, 150, 30)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path without clearing styles
   * @see {@link Graphics#save} For saving the current state
   * @see {@link Graphics#restore} For restoring a previous state
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * Gets or sets the current fill style for the graphics context. The fill style determines
   * how shapes are filled when using the fill() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics.fillStyle = {
   *     color: 0xff0000,  // Red
   *     alpha: 1
   * };
   *
   * // Using gradients
   * const gradient = new FillGradient({
   *     end: { x: 0, y: 1 }, // Vertical gradient
   *     stops: [
   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
   *     ]
   * });
   *
   * graphics.fillStyle = {
   *     fill: gradient,
   *     alpha: 0.8
   * };
   *
   * // Using patterns
   * graphics.fillStyle = {
   *     texture: myTexture,
   *     alpha: 1,
   *     matrix: new Matrix()
   *         .scale(0.5, 0.5)
   *         .rotate(Math.PI / 4)
   * };
   * ```
   * @type {ConvertedFillStyle}
   * @see {@link FillStyle} For all available fill style options
   * @see {@link FillGradient} For creating gradient fills
   * @see {@link Graphics#fill} For applying the fill to paths
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(value) {
    this._context.fillStyle = value;
  }
  /**
   * Gets or sets the current stroke style for the graphics context. The stroke style determines
   * how paths are outlined when using the stroke() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic stroke style
   * graphics.strokeStyle = {
   *     width: 2,
   *     color: 0xff0000,
   *     alpha: 1
   * };
   *
   * // Using with gradients
   * const gradient = new FillGradient({
   *   end: { x: 0, y: 1 },
   *   stops: [
   *       { offset: 0, color: 0xff0000, alpha: 1 },
   *       { offset: 1, color: 0x0000ff, alpha: 1 }
   *   ]
   * });
   *
   * graphics.strokeStyle = {
   *     width: 4,
   *     fill: gradient,
   *     alignment: 0.5,
   *     join: 'round',
   *     cap: 'round'
   * };
   *
   * // Complex stroke settings
   * graphics.strokeStyle = {
   *     width: 6,
   *     color: 0x00ff00,
   *     alpha: 0.5,
   *     join: 'miter',
   *     miterLimit: 10,
   * };
   * ```
   * @see {@link StrokeStyle} For all available stroke style options
   * @see {@link Graphics#stroke} For applying the stroke to paths
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(value) {
    this._context.strokeStyle = value;
  }
  /**
   * Creates a new Graphics object that copies the current graphics content.
   * The clone can either share the same context (shallow clone) or have its own independent
   * context (deep clone).
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Create original graphics content
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *
   * // Create a shallow clone (shared context)
   * const shallowClone = graphics.clone();
   *
   * // Changes to original affect the clone
   * graphics
   *     .circle(200, 100, 30)
   *     .fill({ color: 0x00ff00 });
   *
   * // Create a deep clone (independent context)
   * const deepClone = graphics.clone(true);
   *
   * // Modify deep clone independently
   * deepClone
   *     .translateTransform(100, 100)
   *     .circle(0, 0, 40)
   *     .fill({ color: 0x0000ff });
   * ```
   * @param deep - Whether to create a deep clone of the graphics object.
   *              If false (default), the context will be shared between objects.
   *              If true, creates an independent copy of the context.
   * @returns A new Graphics instance with either shared or copied context
   * @see {@link Graphics#context} For accessing the underlying graphics context
   * @see {@link GraphicsContext} For understanding the shared context behavior
   */
  clone(deep = false) {
    if (deep) {
      return new Graphics(this._context.clone());
    }
    this._ownedContext = null;
    const clone = new Graphics(this._context);
    return clone;
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(width, color, alpha) {
    deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const strokeStyle = {};
    width && (strokeStyle.width = width);
    color && (strokeStyle.color = color);
    alpha && (strokeStyle.alpha = alpha);
    this.context.strokeStyle = strokeStyle;
    return this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(color, alpha) {
    deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const fillStyle = {};
    if (color !== void 0) fillStyle.color = color;
    if (alpha !== void 0) fillStyle.alpha = alpha;
    this.context.fillStyle = fillStyle;
    return this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.context.fill();
    const strokeStyle = this.context.strokeStyle;
    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
      this.context.stroke();
    }
    return this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...args) {
    deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
    return this._callContextMethod("circle", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...args) {
    deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
    return this._callContextMethod("ellipse", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...args) {
    deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
    return this._callContextMethod("poly", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...args) {
    deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
    return this._callContextMethod("rect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...args) {
    deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
    return this._callContextMethod("roundRect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...args) {
    deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
    return this._callContextMethod("star", args);
  }
}

const _MeshGeometry = class _MeshGeometry extends Geometry {
  constructor(...args) {
    let options = args[0] ?? {};
    if (options instanceof Float32Array) {
      deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
      options = {
        positions: options,
        uvs: args[1],
        indices: args[2]
      };
    }
    options = { ..._MeshGeometry.defaultOptions, ...options };
    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    let uvs = options.uvs;
    if (!uvs) {
      if (options.positions) {
        uvs = new Float32Array(positions.length);
      } else {
        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      }
    }
    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
    const shrinkToFit = options.shrinkBuffersToFit;
    const positionBuffer = new Buffer({
      data: positions,
      label: "attribute-mesh-positions",
      shrinkToFit,
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
    });
    const uvBuffer = new Buffer({
      data: uvs,
      label: "attribute-mesh-uvs",
      shrinkToFit,
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
    });
    const indexBuffer = new Buffer({
      data: indices,
      label: "index-mesh-buffer",
      shrinkToFit,
      usage: BufferUsage.INDEX | BufferUsage.COPY_DST
    });
    super({
      attributes: {
        aPosition: {
          buffer: positionBuffer,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        },
        aUV: {
          buffer: uvBuffer,
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer,
      topology: options.topology
    });
    this.batchMode = "auto";
  }
  /** The positions of the mesh. */
  get positions() {
    return this.attributes.aPosition.buffer.data;
  }
  /**
   * Set the positions of the mesh.
   * When setting the positions, its important that the uvs array is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The positions of the mesh.
   */
  set positions(value) {
    this.attributes.aPosition.buffer.data = value;
  }
  /** The UVs of the mesh. */
  get uvs() {
    return this.attributes.aUV.buffer.data;
  }
  /**
   * Set the UVs of the mesh.
   * Its important that the uvs array you set is at least as long as the positions array.
   * otherwise the geometry will not be valid.
   * @param {Float32Array} value - The UVs of the mesh.
   */
  set uvs(value) {
    this.attributes.aUV.buffer.data = value;
  }
  /** The indices of the mesh. */
  get indices() {
    return this.indexBuffer.data;
  }
  set indices(value) {
    this.indexBuffer.data = value;
  }
};
_MeshGeometry.defaultOptions = {
  topology: "triangle-list",
  shrinkBuffersToFit: false
};
let MeshGeometry = _MeshGeometry;

class BatchableMesh {
  constructor() {
    this.batcherName = "default";
    this.packAsQuad = false;
    this.indexOffset = 0;
    this.attributeOffset = 0;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
    this._textureMatrixUpdateId = -1;
    this._uvUpdateId = -1;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get topology() {
    return this._topology || this.geometry.topology;
  }
  set topology(value) {
    this._topology = value;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.geometry = null;
    this._uvUpdateId = -1;
    this._textureMatrixUpdateId = -1;
  }
  /**
   * Sets the texture for the batchable mesh.
   * As it does so, it resets the texture matrix update ID.
   * this is to ensure that the texture matrix is recalculated when the uvs are referenced
   * @param value - The texture to set.
   */
  setTexture(value) {
    if (this.texture === value) return;
    this.texture = value;
    this._textureMatrixUpdateId = -1;
  }
  get uvs() {
    const geometry = this.geometry;
    const uvBuffer = geometry.getBuffer("aUV");
    const uvs = uvBuffer.data;
    let transformedUvs = uvs;
    const textureMatrix = this.texture.textureMatrix;
    if (!textureMatrix.isSimple) {
      transformedUvs = this._transformedUvs;
      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
        if (!transformedUvs || transformedUvs.length < uvs.length) {
          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
        }
        this._textureMatrixUpdateId = textureMatrix._updateID;
        this._uvUpdateId = uvBuffer._updateID;
        textureMatrix.multiplyUvs(uvs, transformedUvs);
      }
    }
    return transformedUvs;
  }
  get positions() {
    return this.geometry.positions;
  }
  get indices() {
    return this.geometry.indices;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  get groupTransform() {
    return this.renderable.groupTransform;
  }
  get attributeSize() {
    return this.geometry.positions.length / 2;
  }
  get indexSize() {
    return this.geometry.indices.length;
  }
}

class MeshGpuData {
  destroy() {
  }
}
class MeshPipe {
  constructor(renderer, adaptor) {
    this.localUniforms = new UniformGroup({
      uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this.localUniformsBindGroup = new BindGroup({
      0: this.localUniforms
    });
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init();
  }
  validateRenderable(mesh) {
    const meshData = this._getMeshData(mesh);
    const wasBatched = meshData.batched;
    const isBatched = mesh.batched;
    meshData.batched = isBatched;
    if (wasBatched !== isBatched) {
      return true;
    } else if (isBatched) {
      const geometry = mesh._geometry;
      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
        meshData.indexSize = geometry.indices.length;
        meshData.vertexSize = geometry.positions.length;
        return true;
      }
      const batchableMesh = this._getBatchableMesh(mesh);
      if (batchableMesh.texture.uid !== mesh._texture.uid) {
        batchableMesh._textureMatrixUpdateId = -1;
      }
      return !batchableMesh._batcher.checkAndUpdateTexture(
        batchableMesh,
        mesh._texture
      );
    }
    return false;
  }
  addRenderable(mesh, instructionSet) {
    const batcher = this.renderer.renderPipes.batch;
    const meshData = this._getMeshData(mesh);
    if (mesh.didViewUpdate) {
      meshData.indexSize = mesh._geometry.indices?.length;
      meshData.vertexSize = mesh._geometry.positions?.length;
    }
    if (meshData.batched) {
      const gpuBatchableMesh = this._getBatchableMesh(mesh);
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      batcher.addToBatch(gpuBatchableMesh, instructionSet);
    } else {
      batcher.break(instructionSet);
      instructionSet.add(mesh);
    }
  }
  updateRenderable(mesh) {
    if (mesh.batched) {
      const gpuBatchableMesh = this._getBatchableMesh(mesh);
      gpuBatchableMesh.setTexture(mesh._texture);
      gpuBatchableMesh.geometry = mesh._geometry;
      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
    }
  }
  execute(mesh) {
    if (!mesh.isRenderable) return;
    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
    const localUniforms = this.localUniforms;
    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
    localUniforms.update();
    color32BitToUniform(
      mesh.groupColorAlpha,
      localUniforms.uniforms.uColor,
      0
    );
    this._adaptor.execute(this, mesh);
  }
  _getMeshData(mesh) {
    var _a, _b;
    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
    return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);
  }
  _initMeshData(mesh) {
    mesh._gpuData[this.renderer.uid].meshData = {
      batched: mesh.batched,
      indexSize: 0,
      vertexSize: 0
    };
    return mesh._gpuData[this.renderer.uid].meshData;
  }
  _getBatchableMesh(mesh) {
    var _a, _b;
    (_a = mesh._gpuData)[_b = this.renderer.uid] || (_a[_b] = new MeshGpuData());
    return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);
  }
  _initBatchableMesh(mesh) {
    const gpuMesh = new BatchableMesh();
    gpuMesh.renderable = mesh;
    gpuMesh.setTexture(mesh._texture);
    gpuMesh.transform = mesh.groupTransform;
    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
    mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;
    return gpuMesh;
  }
  destroy() {
    this.localUniforms = null;
    this.localUniformsBindGroup = null;
    this._adaptor.destroy();
    this._adaptor = null;
    this.renderer = null;
  }
}
/** @ignore */
MeshPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes
  ],
  name: "mesh"
};

extensions.add(MeshPipe);

class Mesh extends ViewContainer {
  constructor(...args) {
    let options = args[0];
    if (options instanceof Geometry) {
      deprecation(v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead");
      options = {
        geometry: options,
        shader: args[1]
      };
      if (args[3]) {
        deprecation(v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead");
        options.geometry.topology = args[3];
      }
    }
    const { geometry, shader, texture, roundPixels, state, ...rest } = options;
    super({
      label: "Mesh",
      ...rest
    });
    /** @internal */
    this.renderPipeId = "mesh";
    /** @internal */
    this._shader = null;
    this.allowChildren = false;
    this.shader = shader ?? null;
    this.texture = texture ?? shader?.texture ?? Texture.WHITE;
    this.state = state ?? State.for2d();
    this._geometry = geometry;
    this._geometry.on("update", this.onViewUpdate, this);
    this.roundPixels = roundPixels ?? false;
  }
  /** Alias for {@link Mesh#shader}. */
  get material() {
    deprecation(v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
    return this._shader;
  }
  /**
   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
   * Can be shared between multiple Mesh objects.
   */
  set shader(value) {
    if (this._shader === value) return;
    this._shader = value;
    this.onViewUpdate();
  }
  get shader() {
    return this._shader;
  }
  /**
   * Includes vertex positions, face indices, colors, UVs, and
   * custom attributes within buffers, reducing the cost of passing all
   * this data to the GPU. Can be shared between multiple Mesh objects.
   */
  set geometry(value) {
    if (this._geometry === value) return;
    this._geometry?.off("update", this.onViewUpdate, this);
    value.on("update", this.onViewUpdate, this);
    this._geometry = value;
    this.onViewUpdate();
  }
  get geometry() {
    return this._geometry;
  }
  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
  set texture(value) {
    value || (value = Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value) return;
    if (currentTexture && currentTexture.dynamic) currentTexture.off("update", this.onViewUpdate, this);
    if (value.dynamic) value.on("update", this.onViewUpdate, this);
    if (this.shader) {
      this.shader.texture = value;
    }
    this._texture = value;
    this.onViewUpdate();
  }
  get texture() {
    return this._texture;
  }
  get batched() {
    if (this._shader) return false;
    if ((this.state.data & 12) !== 0) return false;
    if (this._geometry instanceof MeshGeometry) {
      if (this._geometry.batchMode === "auto") {
        return this._geometry.positions.length / 2 <= 100;
      }
      return this._geometry.batchMode === "batch";
    }
    return false;
  }
  /**
   * The local bounds of the mesh.
   * @type {Bounds}
   */
  get bounds() {
    return this._geometry.bounds;
  }
  /**
   * Update local bounds of the mesh.
   * @private
   */
  updateBounds() {
    this._bounds = this._geometry.bounds;
  }
  /**
   * Checks if the object contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const { x, y } = point;
    if (!this.bounds.containsPoint(x, y)) return false;
    const vertices = this.geometry.getBuffer("aPosition").data;
    const step = this.geometry.topology === "triangle-strip" ? 3 : 1;
    if (this.geometry.getIndex()) {
      const indices = this.geometry.getIndex().data;
      const len = indices.length;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = indices[i] * 2;
        const ind1 = indices[i + 1] * 2;
        const ind2 = indices[i + 2] * 2;
        if (pointInTriangle(
          x,
          y,
          vertices[ind0],
          vertices[ind0 + 1],
          vertices[ind1],
          vertices[ind1 + 1],
          vertices[ind2],
          vertices[ind2 + 1]
        )) {
          return true;
        }
      }
    } else {
      const len = vertices.length / 2;
      for (let i = 0; i + 2 < len; i += step) {
        const ind0 = i * 2;
        const ind1 = (i + 1) * 2;
        const ind2 = (i + 2) * 2;
        if (pointInTriangle(
          x,
          y,
          vertices[ind0],
          vertices[ind0 + 1],
          vertices[ind1],
          vertices[ind1 + 1],
          vertices[ind2],
          vertices[ind2 + 1]
        )) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * mesh.destroy();
   * mesh.destroy(true);
   * mesh.destroy({ texture: true, textureSource: true });
   */
  destroy(options) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options?.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._geometry?.off("update", this.onViewUpdate, this);
    this._texture = null;
    this._geometry = null;
    this._shader = null;
  }
}

let canUseNewCanvasBlendModesValue;
function createColoredCanvas(color) {
  const canvas = DOMAdapter.get().createCanvas(6, 1);
  const context = canvas.getContext("2d");
  context.fillStyle = color;
  context.fillRect(0, 0, 6, 1);
  return canvas;
}
function canUseNewCanvasBlendModes() {
  if (canUseNewCanvasBlendModesValue !== void 0) {
    return canUseNewCanvasBlendModesValue;
  }
  try {
    const magenta = createColoredCanvas("#ff00ff");
    const yellow = createColoredCanvas("#ffff00");
    const canvas = DOMAdapter.get().createCanvas(6, 1);
    const context = canvas.getContext("2d");
    context.globalCompositeOperation = "multiply";
    context.drawImage(magenta, 0, 0);
    context.drawImage(yellow, 2, 0);
    const imageData = context.getImageData(2, 0, 1, 1);
    if (!imageData) {
      canUseNewCanvasBlendModesValue = false;
    } else {
      const data = imageData.data;
      canUseNewCanvasBlendModesValue = data[0] === 255 && data[1] === 0 && data[2] === 0;
    }
  } catch (_error) {
    canUseNewCanvasBlendModesValue = false;
  }
  return canUseNewCanvasBlendModesValue;
}

const canvasUtils = {
  canvas: null,
  convertTintToImage: false,
  cacheStepsPerColorChannel: 8,
  canUseMultiply: canUseNewCanvasBlendModes(),
  tintMethod: null,
  _canvasSourceCache: /* @__PURE__ */ new WeakMap(),
  _unpremultipliedCache: /* @__PURE__ */ new WeakMap(),
  getCanvasSource: (texture) => {
    const source = texture.source;
    const resource = source?.resource;
    if (!resource) {
      return null;
    }
    const isPMA = source.alphaMode === "premultiplied-alpha";
    const resourceWidth = source.resourceWidth ?? source.pixelWidth;
    const resourceHeight = source.resourceHeight ?? source.pixelHeight;
    const needsResize = resourceWidth !== source.pixelWidth || resourceHeight !== source.pixelHeight;
    if (isPMA) {
      if (resource instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && resource instanceof OffscreenCanvas) {
        if (!needsResize) {
          return resource;
        }
      }
      const cached = canvasUtils._unpremultipliedCache.get(source);
      if (cached?.resourceId === source._resourceId) {
        return cached.canvas;
      }
    }
    if (resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int8Array || resource instanceof Uint16Array || resource instanceof Int16Array || resource instanceof Uint32Array || resource instanceof Int32Array || resource instanceof Float32Array || resource instanceof ArrayBuffer) {
      const cached = canvasUtils._canvasSourceCache.get(source);
      if (cached?.resourceId === source._resourceId) {
        return cached.canvas;
      }
      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);
      const context = canvas.getContext("2d");
      const imageData = context.createImageData(source.pixelWidth, source.pixelHeight);
      const data = imageData.data;
      const bytes = resource instanceof ArrayBuffer ? new Uint8Array(resource) : new Uint8Array(resource.buffer, resource.byteOffset, resource.byteLength);
      if (source.format === "bgra8unorm") {
        for (let i = 0; i < data.length && i + 3 < bytes.length; i += 4) {
          data[i] = bytes[i + 2];
          data[i + 1] = bytes[i + 1];
          data[i + 2] = bytes[i];
          data[i + 3] = bytes[i + 3];
        }
      } else {
        data.set(bytes.subarray(0, data.length));
      }
      context.putImageData(imageData, 0, 0);
      canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });
      return canvas;
    }
    if (isPMA) {
      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);
      const context = canvas.getContext("2d", { willReadFrequently: true });
      canvas.width = source.pixelWidth;
      canvas.height = source.pixelHeight;
      context.drawImage(resource, 0, 0);
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const a = data[i + 3];
        if (a > 0) {
          const alphaInv = 255 / a;
          data[i] = Math.min(255, data[i] * alphaInv + 0.5);
          data[i + 1] = Math.min(255, data[i + 1] * alphaInv + 0.5);
          data[i + 2] = Math.min(255, data[i + 2] * alphaInv + 0.5);
        }
      }
      context.putImageData(imageData, 0, 0);
      canvasUtils._unpremultipliedCache.set(source, { canvas, resourceId: source._resourceId });
      return canvas;
    }
    if (needsResize) {
      const cached = canvasUtils._canvasSourceCache.get(source);
      if (cached?.resourceId === source._resourceId) {
        return cached.canvas;
      }
      const canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);
      const context = canvas.getContext("2d");
      canvas.width = source.pixelWidth;
      canvas.height = source.pixelHeight;
      context.drawImage(resource, 0, 0);
      canvasUtils._canvasSourceCache.set(source, { canvas, resourceId: source._resourceId });
      return canvas;
    }
    return resource;
  },
  getTintedCanvas: (sprite, color) => {
    const texture = sprite.texture;
    const stringColor = Color.shared.setValue(color).toHex();
    const cache = texture.tintCache || (texture.tintCache = {});
    const cachedCanvas = cache[stringColor];
    const resourceId = texture.source._resourceId;
    if (cachedCanvas?.tintId === resourceId) {
      return cachedCanvas;
    }
    const canvas = cachedCanvas && "getContext" in cachedCanvas ? cachedCanvas : DOMAdapter.get().createCanvas();
    canvasUtils.tintMethod(texture, color, canvas);
    canvas.tintId = resourceId;
    {
      cache[stringColor] = canvas;
    }
    return cache[stringColor];
  },
  getTintedPattern: (texture, color) => {
    const stringColor = Color.shared.setValue(color).toHex();
    const cache = texture.patternCache || (texture.patternCache = {});
    const resourceId = texture.source._resourceId;
    let pattern = cache[stringColor];
    if (pattern?.tintId === resourceId) {
      return pattern;
    }
    if (!canvasUtils.canvas) {
      canvasUtils.canvas = DOMAdapter.get().createCanvas();
    }
    canvasUtils.tintMethod(texture, color, canvasUtils.canvas);
    const context = canvasUtils.canvas.getContext("2d");
    pattern = context.createPattern(canvasUtils.canvas, "repeat");
    pattern.tintId = resourceId;
    cache[stringColor] = pattern;
    return pattern;
  },
  /**
   * Applies a transform to a CanvasPattern.
   * @param pattern - The pattern to apply the transform to.
   * @param matrix - The matrix to apply.
   * @param matrix.a
   * @param matrix.b
   * @param matrix.c
   * @param matrix.d
   * @param matrix.tx
   * @param matrix.ty
   * @param invert
   */
  applyPatternTransform: (pattern, matrix, invert = true) => {
    if (!matrix) return;
    const patternAny = pattern;
    if (!patternAny.setTransform) return;
    const DOMMatrixCtor = globalThis.DOMMatrix;
    if (!DOMMatrixCtor) return;
    const domMatrix = new DOMMatrixCtor([matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty]);
    patternAny.setTransform(invert ? domMatrix.inverse() : domMatrix);
  },
  tintWithMultiply: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture.frame.clone();
    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
    const rotate = texture.rotate;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    const isVertical = groupD8.isVertical(rotate);
    const outWidth = isVertical ? crop.height : crop.width;
    const outHeight = isVertical ? crop.width : crop.height;
    canvas.width = Math.ceil(outWidth);
    canvas.height = Math.ceil(outHeight);
    context.save();
    context.fillStyle = Color.shared.setValue(color).toHex();
    context.fillRect(0, 0, outWidth, outHeight);
    context.globalCompositeOperation = "multiply";
    const source = canvasUtils.getCanvasSource(texture);
    if (!source) {
      context.restore();
      return;
    }
    if (rotate) {
      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);
    }
    context.drawImage(
      source,
      crop.x,
      crop.y,
      crop.width,
      crop.height,
      0,
      0,
      crop.width,
      crop.height
    );
    context.globalCompositeOperation = "destination-atop";
    context.drawImage(
      source,
      crop.x,
      crop.y,
      crop.width,
      crop.height,
      0,
      0,
      crop.width,
      crop.height
    );
    context.restore();
  },
  tintWithOverlay: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture.frame.clone();
    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
    const rotate = texture.rotate;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    const isVertical = groupD8.isVertical(rotate);
    const outWidth = isVertical ? crop.height : crop.width;
    const outHeight = isVertical ? crop.width : crop.height;
    canvas.width = Math.ceil(outWidth);
    canvas.height = Math.ceil(outHeight);
    context.save();
    context.globalCompositeOperation = "copy";
    context.fillStyle = Color.shared.setValue(color).toHex();
    context.fillRect(0, 0, outWidth, outHeight);
    context.globalCompositeOperation = "destination-atop";
    const source = canvasUtils.getCanvasSource(texture);
    if (!source) {
      context.restore();
      return;
    }
    if (rotate) {
      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);
    }
    context.drawImage(
      source,
      crop.x,
      crop.y,
      crop.width,
      crop.height,
      0,
      0,
      crop.width,
      crop.height
    );
    context.restore();
  },
  tintWithPerPixel: (texture, color, canvas) => {
    const context = canvas.getContext("2d");
    const crop = texture.frame.clone();
    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
    const rotate = texture.rotate;
    crop.x *= resolution;
    crop.y *= resolution;
    crop.width *= resolution;
    crop.height *= resolution;
    const isVertical = groupD8.isVertical(rotate);
    const outWidth = isVertical ? crop.height : crop.width;
    const outHeight = isVertical ? crop.width : crop.height;
    canvas.width = Math.ceil(outWidth);
    canvas.height = Math.ceil(outHeight);
    context.save();
    context.globalCompositeOperation = "copy";
    const source = canvasUtils.getCanvasSource(texture);
    if (!source) {
      context.restore();
      return;
    }
    if (rotate) {
      canvasUtils._applyInverseRotation(context, rotate, crop.width, crop.height);
    }
    context.drawImage(
      source,
      crop.x,
      crop.y,
      crop.width,
      crop.height,
      0,
      0,
      crop.width,
      crop.height
    );
    context.restore();
    const r = color >> 16 & 255;
    const g = color >> 8 & 255;
    const b = color & 255;
    const imageData = context.getImageData(0, 0, outWidth, outHeight);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      data[i] = data[i] * r / 255;
      data[i + 1] = data[i + 1] * g / 255;
      data[i + 2] = data[i + 2] * b / 255;
    }
    context.putImageData(imageData, 0, 0);
  },
  /**
   * Applies inverse rotation transform to context for texture packer rotation compensation.
   * Supports all 16 groupD8 symmetries (rotations and reflections).
   * @param context - Canvas 2D context
   * @param rotate - The groupD8 rotation value
   * @param srcWidth - Source crop width (before rotation)
   * @param srcHeight - Source crop height (before rotation)
   */
  _applyInverseRotation: (context, rotate, srcWidth, srcHeight) => {
    const inv = groupD8.inv(rotate);
    const a = groupD8.uX(inv);
    const b = groupD8.uY(inv);
    const c = groupD8.vX(inv);
    const d = groupD8.vY(inv);
    const tx = -Math.min(0, a * srcWidth, c * srcHeight, a * srcWidth + c * srcHeight);
    const ty = -Math.min(0, b * srcWidth, d * srcHeight, b * srcWidth + d * srcHeight);
    context.transform(a, b, c, d, tx, ty);
  }
};
canvasUtils.tintMethod = canvasUtils.canUseMultiply ? canvasUtils.tintWithMultiply : canvasUtils.tintWithPerPixel;

const localUniformBit = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* wgsl */
      `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
    ),
    end: (
      /* wgsl */
      `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
    )
  }
};
const localUniformBitGroup2 = {
  ...localUniformBit,
  vertex: {
    ...localUniformBit.vertex,
    // replace the group!
    header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
  }
};
const localUniformBitGl = {
  name: "local-uniform-bit",
  vertex: {
    header: (
      /* glsl */
      `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
    ),
    end: (
      /* glsl */
      `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
    )
  }
};

class CanvasPoolClass {
  constructor(canvasOptions) {
    this._canvasPool = /* @__PURE__ */ Object.create(null);
    this.canvasOptions = canvasOptions || {};
    this.enableFullScreen = false;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(pixelWidth, pixelHeight) {
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = pixelWidth;
    canvas.height = pixelHeight;
    const context = canvas.getContext("2d");
    return { canvas, context };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
    minWidth = Math.ceil(minWidth * resolution - 1e-6);
    minHeight = Math.ceil(minHeight * resolution - 1e-6);
    minWidth = nextPow2(minWidth);
    minHeight = nextPow2(minHeight);
    const key = (minWidth << 17) + (minHeight << 1);
    if (!this._canvasPool[key]) {
      this._canvasPool[key] = [];
    }
    let canvasAndContext = this._canvasPool[key].pop();
    if (!canvasAndContext) {
      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
    }
    return canvasAndContext;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(canvasAndContext) {
    const canvas = canvasAndContext.canvas;
    const { width, height } = canvas;
    const key = (width << 17) + (height << 1);
    canvasAndContext.context.resetTransform();
    canvasAndContext.context.clearRect(0, 0, width, height);
    this._canvasPool[key].push(canvasAndContext);
  }
  clear() {
    this._canvasPool = {};
  }
}
const CanvasPool = new CanvasPoolClass();
GlobalResourceRegistry.register(CanvasPool);

class BatchableSprite {
  constructor() {
    this.batcherName = "default";
    this.topology = "triangle-list";
    // batch specific..
    this.attributeSize = 4;
    this.indexSize = 6;
    this.packAsQuad = true;
    this.roundPixels = 0;
    this._attributeStart = 0;
    // location in the buffer
    this._batcher = null;
    this._batch = null;
  }
  get blendMode() {
    return this.renderable.groupBlendMode;
  }
  get color() {
    return this.renderable.groupColorAlpha;
  }
  reset() {
    this.renderable = null;
    this.texture = null;
    this._batcher = null;
    this._batch = null;
    this.bounds = null;
  }
  destroy() {
    this.reset();
  }
}

function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}

const _CanvasBatchAdaptor = class _CanvasBatchAdaptor {
  static _getPatternRepeat(addressModeU, addressModeV) {
    const repeatU = addressModeU && addressModeU !== "clamp-to-edge";
    const repeatV = addressModeV && addressModeV !== "clamp-to-edge";
    if (repeatU && repeatV) return "repeat";
    if (repeatU) return "repeat-x";
    if (repeatV) return "repeat-y";
    return "no-repeat";
  }
  start(batchPipe, geometry, shader) {
  }
  execute(batchPipe, batch) {
    const elements = batch.elements;
    if (!elements || !elements.length) return;
    const renderer = batchPipe.renderer;
    const contextSystem = renderer.canvasContext;
    const context = contextSystem.activeContext;
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      if (!element.packAsQuad) continue;
      const quad = element;
      const texture = quad.texture;
      const source = texture ? canvasUtils.getCanvasSource(texture) : null;
      if (!source) continue;
      const textureStyle = texture.source.style;
      const smoothProperty = contextSystem.smoothProperty;
      const shouldSmooth = textureStyle.scaleMode !== "nearest";
      if (context[smoothProperty] !== shouldSmooth) {
        context[smoothProperty] = shouldSmooth;
      }
      contextSystem.setBlendMode(batch.blendMode);
      const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 4294967295;
      const argb = quad.color;
      const globalAlpha = (globalColor >>> 24 & 255) / 255;
      const quadAlpha = (argb >>> 24 & 255) / 255;
      const filterAlpha = renderer.filter?.alphaMultiplier ?? 1;
      const alpha = globalAlpha * quadAlpha * filterAlpha;
      if (alpha <= 0) continue;
      context.globalAlpha = alpha;
      const globalTint = globalColor & 16777215;
      const quadTint = argb & 16777215;
      const tint = bgr2rgb(multiplyHexColors(quadTint, globalTint));
      const frame = texture.frame;
      const repeatU = textureStyle.addressModeU ?? textureStyle.addressMode;
      const repeatV = textureStyle.addressModeV ?? textureStyle.addressMode;
      const repeat = _CanvasBatchAdaptor._getPatternRepeat(repeatU, repeatV);
      const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
      const isFromCachedRenderGroup = quad.renderable?.renderGroup?.isCachedAsTexture;
      const sx = frame.x * resolution;
      const sy = frame.y * resolution;
      const sw = frame.width * resolution;
      const sh = frame.height * resolution;
      const bounds = quad.bounds;
      const isRootTarget = renderer.renderTarget.renderTarget.isRoot;
      const dx = bounds.minX;
      const dy = bounds.minY;
      const dw = bounds.maxX - bounds.minX;
      const dh = bounds.maxY - bounds.minY;
      const rotate = texture.rotate;
      const uvs = texture.uvs;
      const uvMin = Math.min(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);
      const uvMax = Math.max(uvs.x0, uvs.x1, uvs.x2, uvs.x3, uvs.y0, uvs.y1, uvs.y2, uvs.y3);
      const needsRepeat = repeat !== "no-repeat" && (uvMin < 0 || uvMax > 1);
      const willUseProcessedCanvas = !needsRepeat && (tint !== 16777215 || rotate);
      const applyRotateTransform = rotate && !willUseProcessedCanvas;
      if (applyRotateTransform) {
        _CanvasBatchAdaptor._tempPatternMatrix.copyFrom(quad.transform);
        groupD8.matrixAppendRotationInv(
          _CanvasBatchAdaptor._tempPatternMatrix,
          rotate,
          dx,
          dy,
          dw,
          dh
        );
        contextSystem.setContextTransform(
          _CanvasBatchAdaptor._tempPatternMatrix,
          quad.roundPixels === 1,
          void 0,
          isFromCachedRenderGroup && isRootTarget
        );
      } else {
        contextSystem.setContextTransform(
          quad.transform,
          quad.roundPixels === 1,
          void 0,
          isFromCachedRenderGroup && isRootTarget
        );
      }
      const drawX = applyRotateTransform ? 0 : dx;
      const drawY = applyRotateTransform ? 0 : dy;
      const drawW = dw;
      const drawH = dh;
      if (needsRepeat) {
        let patternSource = source;
        const canTint = tint !== 16777215 && !rotate;
        const fitsFrame = frame.width <= texture.source.width && frame.height <= texture.source.height;
        if (canTint && fitsFrame) {
          patternSource = canvasUtils.getTintedCanvas({ texture }, tint);
        }
        const pattern = context.createPattern(patternSource, repeat);
        if (!pattern) continue;
        const denomX = drawW;
        const denomY = drawH;
        if (denomX === 0 || denomY === 0) continue;
        const invDx = 1 / denomX;
        const invDy = 1 / denomY;
        const a = (uvs.x1 - uvs.x0) * invDx;
        const b = (uvs.y1 - uvs.y0) * invDx;
        const c = (uvs.x3 - uvs.x0) * invDy;
        const d = (uvs.y3 - uvs.y0) * invDy;
        const tx = uvs.x0 - a * drawX - c * drawY;
        const ty = uvs.y0 - b * drawX - d * drawY;
        const pixelWidth = texture.source.pixelWidth;
        const pixelHeight = texture.source.pixelHeight;
        _CanvasBatchAdaptor._tempPatternMatrix.set(
          a * pixelWidth,
          b * pixelHeight,
          c * pixelWidth,
          d * pixelHeight,
          tx * pixelWidth,
          ty * pixelHeight
        );
        canvasUtils.applyPatternTransform(pattern, _CanvasBatchAdaptor._tempPatternMatrix);
        context.fillStyle = pattern;
        context.fillRect(drawX, drawY, drawW, drawH);
      } else {
        const needsProcessing = tint !== 16777215 || rotate;
        const processedSource = needsProcessing ? canvasUtils.getTintedCanvas({ texture }, tint) : source;
        const isProcessed = processedSource !== source;
        context.drawImage(
          processedSource,
          isProcessed ? 0 : sx,
          isProcessed ? 0 : sy,
          isProcessed ? processedSource.width : sw,
          isProcessed ? processedSource.height : sh,
          drawX,
          drawY,
          drawW,
          drawH
        );
      }
    }
  }
};
_CanvasBatchAdaptor._tempPatternMatrix = new Matrix();
/** @ignore */
_CanvasBatchAdaptor.extension = {
  type: [
    ExtensionType.CanvasPipesAdaptor
  ],
  name: "batch"
};
let CanvasBatchAdaptor = _CanvasBatchAdaptor;

class GlBatchAdaptor {
  constructor() {
    this._tempState = State.for2d();
    /**
     * We only want to sync the a batched shaders uniforms once on first use
     * this is a hash of shader uids to a boolean value.  When the shader is first bound
     * we set the value to true.  When the shader is bound again we check the value and
     * if it is true we know that the uniforms have already been synced and we skip it.
     */
    this._didUploadHash = {};
  }
  init(batcherPipe) {
    batcherPipe.renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._didUploadHash = {};
  }
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const didUpload = this._didUploadHash[shader.uid];
    renderer.shader.bind(shader, didUpload);
    if (!didUpload) {
      this._didUploadHash[shader.uid] = true;
    }
    renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
    renderer.geometry.bind(geometry, shader.glProgram);
  }
  execute(batchPipe, batch) {
    const renderer = batchPipe.renderer;
    this._tempState.blendMode = batch.blendMode;
    renderer.state.set(this._tempState);
    const textures = batch.textures.textures;
    for (let i = 0; i < batch.textures.count; i++) {
      renderer.texture.bind(textures[i], i);
    }
    renderer.geometry.draw(batch.topology, batch.size, batch.start);
  }
}
/** @ignore */
GlBatchAdaptor.extension = {
  type: [
    ExtensionType.WebGLPipesAdaptor
  ],
  name: "batch"
};

const tempState = State.for2d();
class GpuBatchAdaptor {
  start(batchPipe, geometry, shader) {
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    const program = shader.gpuProgram;
    this._shader = shader;
    this._geometry = geometry;
    encoder.setGeometry(geometry, program);
    tempState.blendMode = "normal";
    renderer.pipeline.getPipeline(
      geometry,
      program,
      tempState
    );
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.resetBindGroup(1);
    encoder.setBindGroup(0, globalUniformsBindGroup, program);
  }
  execute(batchPipe, batch) {
    const program = this._shader.gpuProgram;
    const renderer = batchPipe.renderer;
    const encoder = renderer.encoder;
    if (!batch.bindGroup) {
      const textureBatch = batch.textures;
      batch.bindGroup = getTextureBatchBindGroup(
        textureBatch.textures,
        textureBatch.count,
        renderer.limits.maxBatchableTextures
      );
    }
    tempState.blendMode = batch.blendMode;
    const gpuBindGroup = renderer.bindGroup.getBindGroup(
      batch.bindGroup,
      program,
      1
    );
    const pipeline = renderer.pipeline.getPipeline(
      this._geometry,
      program,
      tempState,
      batch.topology
    );
    batch.bindGroup._touch(renderer.gc.now, renderer.tick);
    encoder.setPipeline(pipeline);
    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
  }
}
/** @ignore */
GpuBatchAdaptor.extension = {
  type: [
    ExtensionType.WebGPUPipesAdaptor
  ],
  name: "batch"
};

const _BatcherPipe = class _BatcherPipe {
  constructor(renderer, adaptor) {
    this.state = State.for2d();
    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);
    /** A record of all active batchers, keyed by their names */
    this._activeBatches = /* @__PURE__ */ Object.create(null);
    this.renderer = renderer;
    this._adaptor = adaptor;
    this._adaptor.init?.(this);
  }
  static getBatcher(name) {
    return new this._availableBatchers[name]();
  }
  buildStart(instructionSet) {
    let batchers = this._batchersByInstructionSet[instructionSet.uid];
    if (!batchers) {
      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);
      batchers.default || (batchers.default = new DefaultBatcher({
        maxTextures: this.renderer.limits.maxBatchableTextures
      }));
    }
    this._activeBatches = batchers;
    this._activeBatch = this._activeBatches.default;
    for (const i in this._activeBatches) {
      this._activeBatches[i].begin();
    }
  }
  addToBatch(batchableObject, instructionSet) {
    if (this._activeBatch.name !== batchableObject.batcherName) {
      this._activeBatch.break(instructionSet);
      let batch = this._activeBatches[batchableObject.batcherName];
      if (!batch) {
        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);
        batch.begin();
      }
      this._activeBatch = batch;
    }
    this._activeBatch.add(batchableObject);
  }
  break(instructionSet) {
    this._activeBatch.break(instructionSet);
  }
  buildEnd(instructionSet) {
    this._activeBatch.break(instructionSet);
    const batches = this._activeBatches;
    for (const i in batches) {
      const batch = batches[i];
      const geometry = batch.geometry;
      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);
      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);
    }
  }
  upload(instructionSet) {
    const batchers = this._batchersByInstructionSet[instructionSet.uid];
    for (const i in batchers) {
      const batcher = batchers[i];
      const geometry = batcher.geometry;
      if (batcher.dirty) {
        batcher.dirty = false;
        geometry.buffers[0].update(batcher.attributeSize * 4);
      }
    }
  }
  execute(batch) {
    if (batch.action === "startBatch") {
      const batcher = batch.batcher;
      const geometry = batcher.geometry;
      const shader = batcher.shader;
      this._adaptor.start(this, geometry, shader);
    }
    this._adaptor.execute(this, batch);
  }
  destroy() {
    this.state = null;
    this.renderer = null;
    this._adaptor = null;
    for (const i in this._activeBatches) {
      this._activeBatches[i].destroy();
    }
    this._activeBatches = null;
  }
};
/** @ignore */
_BatcherPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "batch"
};
_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);
let BatcherPipe = _BatcherPipe;
extensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);
extensions.add(DefaultBatcher);

const textureBit = {
  name: "texture-bit",
  vertex: {
    header: (
      /* wgsl */
      `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
    ),
    main: (
      /* wgsl */
      `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* wgsl */
      `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `
    ),
    main: (
      /* wgsl */
      `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
    )
  }
};
const textureBitGl = {
  name: "texture-bit",
  vertex: {
    header: (
      /* glsl */
      `
            uniform mat3 uTextureMatrix;
        `
    ),
    main: (
      /* glsl */
      `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
    )
  },
  fragment: {
    header: (
      /* glsl */
      `
        uniform sampler2D uTexture;


        `
    ),
    main: (
      /* glsl */
      `
            outColor = texture(uTexture, vUV);
        `
    )
  }
};

const tempBounds$1 = new Bounds();
class AlphaMaskEffect extends FilterEffect {
  constructor() {
    super();
    this.filters = [new MaskFilter({
      sprite: new Sprite(Texture.EMPTY),
      inverse: false,
      resolution: "inherit",
      antialias: "inherit"
    })];
  }
  get sprite() {
    return this.filters[0].sprite;
  }
  set sprite(value) {
    this.filters[0].sprite = value;
  }
  get inverse() {
    return this.filters[0].inverse;
  }
  set inverse(value) {
    this.filters[0].inverse = value;
  }
}
class AlphaMaskPipe {
  constructor(renderer) {
    this._activeMaskStage = [];
    this._renderer = renderer;
  }
  push(mask, maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskBegin",
      mask,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false,
      maskedContainer
    });
    mask.inverse = maskedContainer._maskOptions.inverse;
    if (mask.renderMaskToTexture) {
      const maskContainer = mask.mask;
      maskContainer.includeInBuild = true;
      maskContainer.collectRenderables(
        instructionSet,
        renderer,
        null
      );
      maskContainer.includeInBuild = false;
    }
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "pushMaskEnd",
      mask,
      maskedContainer,
      inverse: maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  pop(mask, _maskedContainer, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "alphaMask",
      action: "popMaskEnd",
      mask,
      inverse: _maskedContainer._maskOptions.inverse,
      canBundle: false
    });
  }
  execute(instruction) {
    const renderer = this._renderer;
    const renderMask = instruction.mask.renderMaskToTexture;
    if (instruction.action === "pushMaskBegin") {
      const filterEffect = BigPool.get(AlphaMaskEffect);
      filterEffect.inverse = instruction.inverse;
      if (renderMask) {
        instruction.mask.mask.measurable = true;
        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds$1);
        instruction.mask.mask.measurable = false;
        bounds.ceil();
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        const filterTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          colorTextureSource._resolution,
          colorTextureSource.antialias
        );
        renderer.renderTarget.push(filterTexture, true);
        renderer.globalUniforms.push({
          offset: bounds,
          worldColor: 4294967295
        });
        const sprite = filterEffect.sprite;
        sprite.texture = filterTexture;
        sprite.worldTransform.tx = bounds.minX;
        sprite.worldTransform.ty = bounds.minY;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer,
          filterTexture
        });
      } else {
        filterEffect.sprite = instruction.mask.mask;
        this._activeMaskStage.push({
          filterEffect,
          maskedContainer: instruction.maskedContainer
        });
      }
    } else if (instruction.action === "pushMaskEnd") {
      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
      if (renderMask) {
        if (renderer.type === RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
        renderer.renderTarget.pop();
        renderer.globalUniforms.pop();
      }
      renderer.filter.push({
        renderPipeId: "filter",
        action: "pushFilter",
        container: maskData.maskedContainer,
        filterEffect: maskData.filterEffect,
        canBundle: false
      });
    } else if (instruction.action === "popMaskEnd") {
      renderer.filter.pop();
      const maskData = this._activeMaskStage.pop();
      if (renderMask) {
        TexturePool.returnTexture(maskData.filterTexture);
      }
      BigPool.return(maskData.filterEffect);
    }
  }
  destroy() {
    this._renderer = null;
    this._activeMaskStage = null;
  }
}
/** @ignore */
AlphaMaskPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "alphaMask"
};

class CanvasColorMaskPipe {
  constructor(renderer) {
    this._colorStack = [];
    this._colorStackIndex = 0;
    this._currentColor = 0;
    this._renderer = renderer;
  }
  buildStart() {
    this._colorStack[0] = 15;
    this._colorStackIndex = 1;
    this._currentColor = 15;
  }
  push(mask, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
    const currentColor = this._colorStack[this._colorStackIndex];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
    this._colorStackIndex++;
  }
  pop(_mask, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    this._colorStackIndex--;
    const currentColor = colorStack[this._colorStackIndex - 1];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
  }
  execute(_instruction) {
  }
  destroy() {
    this._renderer = null;
    this._colorStack = null;
  }
}
/** @ignore */
CanvasColorMaskPipe.extension = {
  type: [
    ExtensionType.CanvasPipes
  ],
  name: "colorMask"
};

class ColorMaskPipe {
  constructor(renderer) {
    this._colorStack = [];
    this._colorStackIndex = 0;
    this._currentColor = 0;
    this._renderer = renderer;
  }
  buildStart() {
    this._colorStack[0] = 15;
    this._colorStackIndex = 1;
    this._currentColor = 15;
  }
  push(mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
    const currentColor = this._colorStack[this._colorStackIndex];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
    this._colorStackIndex++;
  }
  pop(_mask, _container, instructionSet) {
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    const colorStack = this._colorStack;
    this._colorStackIndex--;
    const currentColor = colorStack[this._colorStackIndex - 1];
    if (currentColor !== this._currentColor) {
      this._currentColor = currentColor;
      instructionSet.add({
        renderPipeId: "colorMask",
        colorMask: currentColor,
        canBundle: false
      });
    }
  }
  execute(instruction) {
    const renderer = this._renderer;
    renderer.colorMask.setMask(instruction.colorMask);
  }
  destroy() {
    this._renderer = null;
    this._colorStack = null;
  }
}
/** @ignore */
ColorMaskPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes
  ],
  name: "colorMask"
};

function buildRoundedRectPath$1(context, x, y, width, height, radius) {
  radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
}
function buildShapePath$1(context, shape) {
  switch (shape.type) {
    case "rectangle": {
      const rect = shape;
      context.rect(rect.x, rect.y, rect.width, rect.height);
      break;
    }
    case "roundedRectangle": {
      const rect = shape;
      buildRoundedRectPath$1(context, rect.x, rect.y, rect.width, rect.height, rect.radius);
      break;
    }
    case "circle": {
      const circle = shape;
      context.moveTo(circle.x + circle.radius, circle.y);
      context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
      break;
    }
    case "ellipse": {
      const ellipse = shape;
      if (context.ellipse) {
        context.moveTo(ellipse.x + ellipse.halfWidth, ellipse.y);
        context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);
      } else {
        context.save();
        context.translate(ellipse.x, ellipse.y);
        context.scale(ellipse.halfWidth, ellipse.halfHeight);
        context.moveTo(1, 0);
        context.arc(0, 0, 1, 0, Math.PI * 2);
        context.restore();
      }
      break;
    }
    case "triangle": {
      const tri = shape;
      context.moveTo(tri.x, tri.y);
      context.lineTo(tri.x2, tri.y2);
      context.lineTo(tri.x3, tri.y3);
      context.closePath();
      break;
    }
    case "polygon":
    default: {
      const poly = shape;
      const points = poly.points;
      if (!points?.length) break;
      context.moveTo(points[0], points[1]);
      for (let i = 2; i < points.length; i += 2) {
        context.lineTo(points[i], points[i + 1]);
      }
      if (poly.closePath) {
        context.closePath();
      }
      break;
    }
  }
}
function addHolePaths$1(context, holes) {
  if (!holes?.length) return false;
  for (let i = 0; i < holes.length; i++) {
    const hole = holes[i];
    if (!hole?.shape) continue;
    const transform = hole.transform;
    const hasTransform = transform && !transform.isIdentity();
    if (hasTransform) {
      context.save();
      context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    }
    buildShapePath$1(context, hole.shape);
    if (hasTransform) {
      context.restore();
    }
  }
  return true;
}
class CanvasStencilMaskPipe {
  constructor(renderer) {
    this._warnedMaskTypes = /* @__PURE__ */ new Set();
    this._canvasMaskStack = [];
    this._renderer = renderer;
  }
  push(mask, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
  }
  pop(_mask, _container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      mask: _mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
  }
  execute(instruction) {
    if (instruction.action !== "pushMaskBegin" && instruction.action !== "popMaskEnd") {
      return;
    }
    const canvasRenderer = this._renderer;
    const contextSystem = canvasRenderer.canvasContext;
    const context = contextSystem?.activeContext;
    if (!context) return;
    if (instruction.action === "popMaskEnd") {
      const didClip = this._canvasMaskStack.pop();
      if (didClip) {
        context.restore();
      }
      return;
    }
    if (instruction.inverse) {
      this._warnOnce(
        "inverse",
        "CanvasRenderer: inverse masks are not supported on Canvas2D; ignoring inverse flag."
      );
    }
    const maskContainer = instruction.mask.mask;
    if (!(maskContainer instanceof Graphics)) {
      this._warnOnce(
        "nonGraphics",
        "CanvasRenderer: only Graphics masks are supported in Canvas2D; skipping mask."
      );
      this._canvasMaskStack.push(false);
      return;
    }
    const graphics = maskContainer;
    const instructions = graphics.context?.instructions;
    if (!instructions?.length) {
      this._canvasMaskStack.push(false);
      return;
    }
    context.save();
    contextSystem.setContextTransform(
      graphics.groupTransform,
      (canvasRenderer._roundPixels | graphics._roundPixels) === 1
    );
    context.beginPath();
    let drewPath = false;
    let hasHoles = false;
    for (let i = 0; i < instructions.length; i++) {
      const instructionData = instructions[i];
      const action = instructionData.action;
      if (action !== "fill" && action !== "stroke") continue;
      const data = instructionData.data;
      const shapePath = data?.path?.shapePath;
      if (!shapePath?.shapePrimitives?.length) continue;
      const shapePrimitives = shapePath.shapePrimitives;
      for (let j = 0; j < shapePrimitives.length; j++) {
        const primitive = shapePrimitives[j];
        if (!primitive?.shape) continue;
        const transform = primitive.transform;
        const hasTransform = transform && !transform.isIdentity();
        if (hasTransform) {
          context.save();
          context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
        }
        buildShapePath$1(context, primitive.shape);
        hasHoles = addHolePaths$1(context, primitive.holes) || hasHoles;
        drewPath = true;
        if (hasTransform) {
          context.restore();
        }
      }
    }
    if (!drewPath) {
      context.restore();
      this._canvasMaskStack.push(false);
      return;
    }
    if (hasHoles) {
      context.clip("evenodd");
    } else {
      context.clip();
    }
    this._canvasMaskStack.push(true);
  }
  destroy() {
    this._renderer = null;
    this._warnedMaskTypes = null;
    this._canvasMaskStack = null;
  }
  _warnOnce(key, message) {
    if (this._warnedMaskTypes.has(key)) return;
    this._warnedMaskTypes.add(key);
    warn$2(message);
  }
}
CanvasStencilMaskPipe.extension = {
  type: [
    ExtensionType.CanvasPipes
  ],
  name: "stencilMask"
};

class StencilMaskPipe {
  constructor(renderer) {
    // used when building and also when executing..
    this._maskStackHash = {};
    this._maskHash = /* @__PURE__ */ new WeakMap();
    this._renderer = renderer;
  }
  push(mask, _container, instructionSet) {
    var _a;
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskBegin",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskContainer = effect.mask;
    maskContainer.includeInBuild = true;
    if (!this._maskHash.has(effect)) {
      this._maskHash.set(effect, {
        instructionsStart: 0,
        instructionsLength: 0
      });
    }
    const maskData = this._maskHash.get(effect);
    maskData.instructionsStart = instructionSet.instructionSize;
    maskContainer.collectRenderables(
      instructionSet,
      renderer,
      null
    );
    maskContainer.includeInBuild = false;
    renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "pushMaskEnd",
      mask,
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
    maskData.instructionsLength = instructionsLength;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
  }
  pop(mask, _container, instructionSet) {
    const effect = mask;
    const renderer = this._renderer;
    renderer.renderPipes.batch.break(instructionSet);
    renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskBegin",
      inverse: _container._maskOptions.inverse,
      canBundle: false
    });
    const maskData = this._maskHash.get(mask);
    for (let i = 0; i < maskData.instructionsLength; i++) {
      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
    }
    instructionSet.add({
      renderPipeId: "stencilMask",
      action: "popMaskEnd",
      canBundle: false
    });
  }
  execute(instruction) {
    var _a;
    const renderer = this._renderer;
    const gpuRenderer = renderer;
    const renderTargetUid = renderer.renderTarget.renderTarget.uid;
    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
    if (instruction.action === "pushMaskBegin") {
      gpuRenderer.renderTarget.ensureDepthStencil();
      gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
      maskStackIndex++;
      gpuRenderer.colorMask.setMask(0);
    } else if (instruction.action === "pushMaskEnd") {
      if (instruction.inverse) {
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      gpuRenderer.colorMask.setMask(15);
    } else if (instruction.action === "popMaskBegin") {
      gpuRenderer.colorMask.setMask(0);
      if (maskStackIndex !== 0) {
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
      } else {
        gpuRenderer.renderTarget.clear(null, CLEAR.STENCIL);
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
      }
      maskStackIndex--;
    } else if (instruction.action === "popMaskEnd") {
      if (instruction.inverse) {
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);
      } else {
        gpuRenderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
      }
      gpuRenderer.colorMask.setMask(15);
    }
    this._maskStackHash[renderTargetUid] = maskStackIndex;
  }
  destroy() {
    this._renderer = null;
    this._maskStackHash = null;
    this._maskHash = null;
  }
}
StencilMaskPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes
  ],
  name: "stencilMask"
};

const FALLBACK_BLEND = "source-over";
function mapCanvasBlendModesToPixi() {
  const supportsAdvanced = canUseNewCanvasBlendModes();
  const map = /* @__PURE__ */ Object.create(null);
  map.inherit = FALLBACK_BLEND;
  map.none = FALLBACK_BLEND;
  map.normal = "source-over";
  map.add = "lighter";
  map.multiply = supportsAdvanced ? "multiply" : FALLBACK_BLEND;
  map.screen = supportsAdvanced ? "screen" : FALLBACK_BLEND;
  map.overlay = supportsAdvanced ? "overlay" : FALLBACK_BLEND;
  map.darken = supportsAdvanced ? "darken" : FALLBACK_BLEND;
  map.lighten = supportsAdvanced ? "lighten" : FALLBACK_BLEND;
  map["color-dodge"] = supportsAdvanced ? "color-dodge" : FALLBACK_BLEND;
  map["color-burn"] = supportsAdvanced ? "color-burn" : FALLBACK_BLEND;
  map["hard-light"] = supportsAdvanced ? "hard-light" : FALLBACK_BLEND;
  map["soft-light"] = supportsAdvanced ? "soft-light" : FALLBACK_BLEND;
  map.difference = supportsAdvanced ? "difference" : FALLBACK_BLEND;
  map.exclusion = supportsAdvanced ? "exclusion" : FALLBACK_BLEND;
  map.saturation = supportsAdvanced ? "saturation" : FALLBACK_BLEND;
  map.color = supportsAdvanced ? "color" : FALLBACK_BLEND;
  map.luminosity = supportsAdvanced ? "luminosity" : FALLBACK_BLEND;
  map["linear-burn"] = supportsAdvanced ? "color-burn" : FALLBACK_BLEND;
  map["linear-dodge"] = supportsAdvanced ? "color-dodge" : FALLBACK_BLEND;
  map["linear-light"] = supportsAdvanced ? "hard-light" : FALLBACK_BLEND;
  map["pin-light"] = supportsAdvanced ? "hard-light" : FALLBACK_BLEND;
  map["vivid-light"] = supportsAdvanced ? "hard-light" : FALLBACK_BLEND;
  map["hard-mix"] = FALLBACK_BLEND;
  map.negation = supportsAdvanced ? "difference" : FALLBACK_BLEND;
  map["normal-npm"] = map.normal;
  map["add-npm"] = map.add;
  map["screen-npm"] = map.screen;
  map.erase = "destination-out";
  map.subtract = FALLBACK_BLEND;
  map.divide = FALLBACK_BLEND;
  map.min = FALLBACK_BLEND;
  map.max = FALLBACK_BLEND;
  return map;
}

const tempMatrix$2 = new Matrix();
class CanvasContextSystem {
  /**
   * @param renderer - The owning CanvasRenderer.
   */
  constructor(renderer) {
    /** Resolution of the active context. */
    this.activeResolution = 1;
    /** The image smoothing property to toggle for this browser. */
    this.smoothProperty = "imageSmoothingEnabled";
    /** Map of Pixi blend modes to canvas composite operations. */
    this.blendModes = mapCanvasBlendModesToPixi();
    /** Current canvas blend mode. */
    this._activeBlendMode = "normal";
    /** Optional projection transform for render targets. */
    this._projTransform = null;
    /** True when external blend mode control is in use. */
    this._outerBlend = false;
    /** Tracks unsupported blend mode warnings to avoid spam. */
    this._warnedBlendModes = /* @__PURE__ */ new Set();
    this._renderer = renderer;
  }
  resolutionChange(resolution) {
    this.activeResolution = resolution;
  }
  /** Initializes the root context and smoothing flag selection. */
  init() {
    const alpha = this._renderer.background.alpha < 1;
    this.rootContext = this._renderer.canvas.getContext(
      "2d",
      { alpha }
    );
    this.activeContext = this.rootContext;
    this.activeResolution = this._renderer.resolution;
    if (!this.rootContext.imageSmoothingEnabled) {
      const rc = this.rootContext;
      if (rc.webkitImageSmoothingEnabled) {
        this.smoothProperty = "webkitImageSmoothingEnabled";
      } else if (rc.mozImageSmoothingEnabled) {
        this.smoothProperty = "mozImageSmoothingEnabled";
      } else if (rc.oImageSmoothingEnabled) {
        this.smoothProperty = "oImageSmoothingEnabled";
      } else if (rc.msImageSmoothingEnabled) {
        this.smoothProperty = "msImageSmoothingEnabled";
      }
    }
  }
  /**
   * Sets the current transform on the active context.
   * @param transform - Transform to apply.
   * @param roundPixels - Whether to round translation to integers.
   * @param localResolution - Optional local resolution multiplier.
   * @param skipGlobalTransform - If true, skip applying the global world transform matrix.
   */
  setContextTransform(transform, roundPixels, localResolution, skipGlobalTransform) {
    const globalTransform = skipGlobalTransform ? Matrix.IDENTITY : this._renderer.globalUniforms.globalUniformData?.worldTransformMatrix || Matrix.IDENTITY;
    let mat = tempMatrix$2;
    mat.copyFrom(globalTransform);
    mat.append(transform);
    const proj = this._projTransform;
    const contextResolution = this.activeResolution;
    localResolution = localResolution || contextResolution;
    if (proj) {
      const finalMat = Matrix.shared;
      finalMat.copyFrom(mat);
      finalMat.prepend(proj);
      mat = finalMat;
    }
    if (roundPixels) {
      this.activeContext.setTransform(
        mat.a * localResolution,
        mat.b * localResolution,
        mat.c * localResolution,
        mat.d * localResolution,
        mat.tx * contextResolution | 0,
        mat.ty * contextResolution | 0
      );
    } else {
      this.activeContext.setTransform(
        mat.a * localResolution,
        mat.b * localResolution,
        mat.c * localResolution,
        mat.d * localResolution,
        mat.tx * contextResolution,
        mat.ty * contextResolution
      );
    }
  }
  /**
   * Clears the current render target, optionally filling with a color.
   * @param clearColor - Color to fill after clearing.
   * @param alpha - Alpha override for the clear color.
   */
  clear(clearColor, alpha) {
    const context = this.activeContext;
    const renderer = this._renderer;
    context.clearRect(0, 0, renderer.width, renderer.height);
    if (clearColor) {
      const color = Color.shared.setValue(clearColor);
      context.globalAlpha = alpha ?? color.alpha;
      context.fillStyle = color.toHex();
      context.fillRect(0, 0, renderer.width, renderer.height);
      context.globalAlpha = 1;
    }
  }
  /**
   * Sets the active blend mode.
   * @param blendMode - Pixi blend mode.
   */
  setBlendMode(blendMode) {
    if (this._activeBlendMode === blendMode) return;
    this._activeBlendMode = blendMode;
    this._outerBlend = false;
    const mappedBlend = this.blendModes[blendMode];
    if (!mappedBlend) {
      if (!this._warnedBlendModes.has(blendMode)) {
        console.warn(
          `CanvasRenderer: blend mode "${blendMode}" is not supported in Canvas2D; falling back to "source-over".`
        );
        this._warnedBlendModes.add(blendMode);
      }
      this.activeContext.globalCompositeOperation = "source-over";
      return;
    }
    this.activeContext.globalCompositeOperation = mappedBlend;
  }
  /** Releases context references. */
  destroy() {
    this.rootContext = null;
    this.activeContext = null;
    this._warnedBlendModes.clear();
  }
}
/** @ignore */
CanvasContextSystem.extension = {
  type: [
    ExtensionType.CanvasSystem
  ],
  name: "canvasContext"
};

class CanvasLimitsSystem {
  constructor() {
    this.maxTextures = 16;
    this.maxBatchableTextures = 16;
    this.maxUniformBindings = 0;
  }
  init() {
  }
}
/** @ignore */
CanvasLimitsSystem.extension = {
  type: [
    ExtensionType.CanvasSystem
  ],
  name: "limits"
};

class CustomRenderPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  updateRenderable() {
  }
  destroyRenderable() {
  }
  validateRenderable() {
    return false;
  }
  addRenderable(container, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add(container);
  }
  execute(container) {
    if (!container.isRenderable) return;
    container.render(this._renderer);
  }
  destroy() {
    this._renderer = null;
  }
}
CustomRenderPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "customRender"
};

function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i = 0; i < instructionSet.instructionSize; i++) {
    const instruction = instructions[i];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}

class RenderGroupPipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderGroup(renderGroup, instructionSet) {
    if (renderGroup.isCachedAsTexture) {
      this._addRenderableCacheAsTexture(renderGroup, instructionSet);
    } else {
      this._addRenderableDirect(renderGroup, instructionSet);
    }
  }
  execute(renderGroup) {
    if (!renderGroup.isRenderable) return;
    if (renderGroup.isCachedAsTexture) {
      this._executeCacheAsTexture(renderGroup);
    } else {
      this._executeDirect(renderGroup);
    }
  }
  destroy() {
    this._renderer = null;
  }
  _addRenderableDirect(renderGroup, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    if (renderGroup._batchableRenderGroup) {
      BigPool.return(renderGroup._batchableRenderGroup);
      renderGroup._batchableRenderGroup = null;
    }
    instructionSet.add(renderGroup);
  }
  _addRenderableCacheAsTexture(renderGroup, instructionSet) {
    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));
    batchableRenderGroup.renderable = renderGroup.root;
    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
    batchableRenderGroup.texture = renderGroup.texture;
    batchableRenderGroup.bounds = renderGroup._textureBounds;
    instructionSet.add(renderGroup);
    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);
    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);
  }
  _executeCacheAsTexture(renderGroup) {
    if (renderGroup.textureNeedsUpdate) {
      renderGroup.textureNeedsUpdate = false;
      const worldTransformMatrix = new Matrix().translate(
        -renderGroup._textureBounds.x,
        -renderGroup._textureBounds.y
      );
      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);
      this._renderer.globalUniforms.push({
        worldTransformMatrix,
        worldColor: 4294967295,
        offset: { x: 0, y: 0 }
      });
      executeInstructions(renderGroup, this._renderer.renderPipes);
      this._renderer.renderTarget.finishRenderPass();
      this._renderer.renderTarget.pop();
      this._renderer.globalUniforms.pop();
    }
    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
  }
  _executeDirect(renderGroup) {
    this._renderer.globalUniforms.push({
      worldTransformMatrix: renderGroup.inverseParentTextureTransform,
      worldColor: renderGroup.worldColorAlpha
    });
    executeInstructions(renderGroup, this._renderer.renderPipes);
    this._renderer.globalUniforms.pop();
  }
}
RenderGroupPipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "renderGroup"
};

const emptyCanvasStyle = "#808080";
const tempMatrix$1 = new Matrix();
const tempTextureMatrix = new Matrix();
const tempGradientMatrix = new Matrix();
const tempPatternMatrix = new Matrix();
function fillTriangles(context, vertices, indices) {
  context.beginPath();
  for (let i = 0; i < indices.length; i += 3) {
    const i0 = indices[i] * 2;
    const i1 = indices[i + 1] * 2;
    const i2 = indices[i + 2] * 2;
    context.moveTo(vertices[i0], vertices[i0 + 1]);
    context.lineTo(vertices[i1], vertices[i1 + 1]);
    context.lineTo(vertices[i2], vertices[i2 + 1]);
    context.closePath();
  }
  context.fill();
}
function colorToHex(color) {
  const clamped = color & 16777215;
  return `#${clamped.toString(16).padStart(6, "0")}`;
}
function buildRoundedRectPath(context, x, y, width, height, radius) {
  radius = Math.max(0, Math.min(radius, Math.min(width, height) / 2));
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
}
function buildShapePath(context, shape) {
  switch (shape.type) {
    case "rectangle": {
      const rect = shape;
      context.rect(rect.x, rect.y, rect.width, rect.height);
      break;
    }
    case "roundedRectangle": {
      const rect = shape;
      buildRoundedRectPath(context, rect.x, rect.y, rect.width, rect.height, rect.radius);
      break;
    }
    case "circle": {
      const circle = shape;
      context.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
      break;
    }
    case "ellipse": {
      const ellipse = shape;
      if (context.ellipse) {
        context.ellipse(ellipse.x, ellipse.y, ellipse.halfWidth, ellipse.halfHeight, 0, 0, Math.PI * 2);
      } else {
        context.save();
        context.translate(ellipse.x, ellipse.y);
        context.scale(ellipse.halfWidth, ellipse.halfHeight);
        context.arc(0, 0, 1, 0, Math.PI * 2);
        context.restore();
      }
      break;
    }
    case "triangle": {
      const tri = shape;
      context.moveTo(tri.x, tri.y);
      context.lineTo(tri.x2, tri.y2);
      context.lineTo(tri.x3, tri.y3);
      context.closePath();
      break;
    }
    case "polygon":
    default: {
      const poly = shape;
      const points = poly.points;
      if (!points?.length) break;
      context.moveTo(points[0], points[1]);
      for (let i = 2; i < points.length; i += 2) {
        context.lineTo(points[i], points[i + 1]);
      }
      if (poly.closePath) {
        context.closePath();
      }
      break;
    }
  }
}
function addHolePaths(context, holes) {
  if (!holes?.length) return false;
  for (let i = 0; i < holes.length; i++) {
    const hole = holes[i];
    if (!hole?.shape) continue;
    const transform = hole.transform;
    const hasTransform = transform && !transform.isIdentity();
    if (hasTransform) {
      context.save();
      context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
    }
    buildShapePath(context, hole.shape);
    if (hasTransform) {
      context.restore();
    }
  }
  return true;
}
function getCanvasStyle(style, tint, textureMatrix, currentTransform) {
  const fill = style.fill;
  if (fill instanceof FillGradient) {
    fill.buildGradient();
    const gradientTexture = fill.texture;
    if (gradientTexture) {
      const pattern = canvasUtils.getTintedPattern(gradientTexture, tint);
      const patternMatrix = textureMatrix ? tempPatternMatrix.copyFrom(textureMatrix).scale(gradientTexture.source.pixelWidth, gradientTexture.source.pixelHeight) : tempPatternMatrix.copyFrom(fill.transform);
      if (currentTransform && !style.textureSpace) {
        patternMatrix.append(currentTransform);
      }
      canvasUtils.applyPatternTransform(pattern, patternMatrix);
      return pattern;
    }
  }
  if (fill instanceof FillPattern) {
    const pattern = canvasUtils.getTintedPattern(fill.texture, tint);
    canvasUtils.applyPatternTransform(pattern, fill.transform);
    return pattern;
  }
  const texture = style.texture;
  if (texture && texture !== Texture.WHITE) {
    if (!texture.source.resource) {
      return emptyCanvasStyle;
    }
    const pattern = canvasUtils.getTintedPattern(texture, tint);
    const patternMatrix = textureMatrix ? tempPatternMatrix.copyFrom(textureMatrix).scale(texture.source.pixelWidth, texture.source.pixelHeight) : style.matrix;
    canvasUtils.applyPatternTransform(pattern, patternMatrix);
    return pattern;
  }
  return colorToHex(tint);
}
class CanvasGraphicsAdaptor {
  constructor() {
    this.shader = null;
  }
  contextChange(renderer) {
  }
  execute(graphicsPipe, renderable) {
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.canvasContext;
    const context = contextSystem.activeContext;
    const baseTransform = renderable.groupTransform;
    const globalColor = renderer.globalUniforms.globalUniformData?.worldColor ?? 4294967295;
    const groupColorAlpha = renderable.groupColorAlpha;
    const globalAlpha = (globalColor >>> 24 & 255) / 255;
    const groupAlphaValue = (groupColorAlpha >>> 24 & 255) / 255;
    const filterAlpha = renderer.filter?.alphaMultiplier ?? 1;
    const groupAlpha = globalAlpha * groupAlphaValue * filterAlpha;
    if (groupAlpha <= 0) return;
    const globalTint = globalColor & 16777215;
    const groupTintBGR = groupColorAlpha & 16777215;
    const groupTint = bgr2rgb(multiplyHexColors(groupTintBGR, globalTint));
    const roundPixels = renderer._roundPixels | renderable._roundPixels;
    context.save();
    contextSystem.setContextTransform(baseTransform, roundPixels === 1);
    contextSystem.setBlendMode(renderable.groupBlendMode);
    const instructions = renderable.context.instructions;
    for (let i = 0; i < instructions.length; i++) {
      const instruction = instructions[i];
      if (instruction.action === "texture") {
        const data2 = instruction.data;
        const texture = data2.image;
        const source = texture ? canvasUtils.getCanvasSource(texture) : null;
        if (!source) continue;
        const alpha2 = data2.alpha * groupAlpha;
        if (alpha2 <= 0) continue;
        const tint2 = multiplyHexColors(data2.style, groupTint);
        context.globalAlpha = alpha2;
        let drawSource = source;
        if (tint2 !== 16777215) {
          drawSource = canvasUtils.getTintedCanvas({ texture }, tint2);
        }
        const frame = texture.frame;
        const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
        let sx = frame.x * resolution;
        let sy = frame.y * resolution;
        const sw = frame.width * resolution;
        const sh = frame.height * resolution;
        if (drawSource !== source) {
          sx = 0;
          sy = 0;
        }
        const transform = data2.transform;
        const hasTransform = transform && !transform.isIdentity();
        const rotate = texture.rotate;
        if (hasTransform || rotate) {
          tempMatrix$1.copyFrom(baseTransform);
          if (hasTransform) {
            tempMatrix$1.append(transform);
          }
          if (rotate) {
            groupD8.matrixAppendRotationInv(tempMatrix$1, rotate, data2.dx, data2.dy, data2.dw, data2.dh);
          }
          contextSystem.setContextTransform(tempMatrix$1, roundPixels === 1);
        } else {
          contextSystem.setContextTransform(baseTransform, roundPixels === 1);
        }
        context.drawImage(
          drawSource,
          sx,
          sy,
          drawSource === source ? sw : drawSource.width,
          drawSource === source ? sh : drawSource.height,
          rotate ? 0 : data2.dx,
          rotate ? 0 : data2.dy,
          data2.dw,
          data2.dh
        );
        if (hasTransform || rotate) {
          contextSystem.setContextTransform(baseTransform, roundPixels === 1);
        }
        continue;
      }
      const data = instruction.data;
      const shapePath = data?.path?.shapePath;
      if (!shapePath?.shapePrimitives?.length) continue;
      const style = data.style;
      const tint = multiplyHexColors(style.color, groupTint);
      const alpha = style.alpha * groupAlpha;
      if (alpha <= 0) continue;
      const isStroke = instruction.action === "stroke";
      context.globalAlpha = alpha;
      if (isStroke) {
        const strokeStyle = style;
        context.lineWidth = strokeStyle.width;
        context.lineCap = strokeStyle.cap;
        context.lineJoin = strokeStyle.join;
        context.miterLimit = strokeStyle.miterLimit;
      }
      const shapePrimitives = shapePath.shapePrimitives;
      if (!isStroke && data.hole?.shapePath?.shapePrimitives?.length) {
        const lastShape = shapePrimitives[shapePrimitives.length - 1];
        lastShape.holes = data.hole.shapePath.shapePrimitives;
      }
      for (let j = 0; j < shapePrimitives.length; j++) {
        const primitive = shapePrimitives[j];
        if (!primitive?.shape) continue;
        const transform = primitive.transform;
        const hasTransform = transform && !transform.isIdentity();
        const hasTexture = style.texture && style.texture !== Texture.WHITE;
        const textureTransform = style.textureSpace === "global" ? transform : null;
        const textureMatrix = hasTexture ? generateTextureMatrix(tempTextureMatrix, style, primitive.shape, textureTransform) : null;
        const currentTransform = hasTransform ? tempGradientMatrix.copyFrom(baseTransform).append(transform) : baseTransform;
        const canvasStyle = getCanvasStyle(
          style,
          tint,
          textureMatrix,
          currentTransform
        );
        if (hasTransform) {
          context.save();
          context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);
        }
        if (isStroke) {
          const strokeStyle = style;
          const useStrokeGeometry = strokeStyle.alignment !== 0.5 && !strokeStyle.pixelLine;
          if (useStrokeGeometry) {
            const points = [];
            const vertices = [];
            const indices = [];
            const shapeBuilder = shapeBuilders[primitive.shape.type];
            if (shapeBuilder?.build(primitive.shape, points)) {
              const close = primitive.shape.closePath ?? true;
              buildLine(points, strokeStyle, false, close, vertices, indices);
              context.fillStyle = canvasStyle;
              fillTriangles(context, vertices, indices);
            } else {
              context.strokeStyle = canvasStyle;
              context.beginPath();
              buildShapePath(context, primitive.shape);
              context.stroke();
            }
          } else {
            context.strokeStyle = canvasStyle;
            context.beginPath();
            buildShapePath(context, primitive.shape);
            context.stroke();
          }
        } else {
          context.fillStyle = canvasStyle;
          context.beginPath();
          buildShapePath(context, primitive.shape);
          const hasHoles = addHolePaths(context, primitive.holes);
          if (hasHoles) {
            context.fill("evenodd");
          } else {
            context.fill();
          }
        }
        if (hasTransform) {
          context.restore();
        }
      }
    }
    context.restore();
  }
  destroy() {
    this.shader = null;
  }
}
/** @ignore */
CanvasGraphicsAdaptor.extension = {
  type: [
    ExtensionType.CanvasPipesAdaptor
  ],
  name: "graphics"
};

class SpritePipe {
  constructor(renderer) {
    this._renderer = renderer;
  }
  addRenderable(sprite, instructionSet) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
  }
  updateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);
    gpuSprite._batcher.updateElement(gpuSprite);
  }
  validateRenderable(sprite) {
    const gpuSprite = this._getGpuSprite(sprite);
    return !gpuSprite._batcher.checkAndUpdateTexture(
      gpuSprite,
      sprite._texture
    );
  }
  _updateBatchableSprite(sprite, batchableSprite) {
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.texture = sprite._texture;
  }
  _getGpuSprite(sprite) {
    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);
  }
  _initGPUSprite(sprite) {
    const batchableSprite = new BatchableSprite();
    batchableSprite.renderable = sprite;
    batchableSprite.transform = sprite.groupTransform;
    batchableSprite.texture = sprite._texture;
    batchableSprite.bounds = sprite.visualBounds;
    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
    sprite._gpuData[this._renderer.uid] = batchableSprite;
    return batchableSprite;
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
SpritePipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "sprite"
};

const BLEND_MODE_FILTERS = {};
extensions.handle(ExtensionType.BlendMode, (value) => {
  if (!value.name) {
    throw new Error("BlendMode extension must have a name property");
  }
  BLEND_MODE_FILTERS[value.name] = value.ref;
}, (value) => {
  delete BLEND_MODE_FILTERS[value.name];
});
class BlendModePipe {
  constructor(renderer) {
    this._blendModeStack = [];
    this._isAdvanced = false;
    this._filterHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    this._renderer.runners.prerender.add(this);
  }
  prerender() {
    this._activeBlendMode = "normal";
    this._isAdvanced = false;
  }
  /**
   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.
   * @param renderable - The renderable or {@link RenderGroup} associated with the change.
   * @param blendMode - The blend mode to activate.
   * @param instructionSet - The instruction set being built.
   */
  pushBlendMode(renderable, blendMode, instructionSet) {
    this._blendModeStack.push(blendMode);
    this.setBlendMode(renderable, blendMode, instructionSet);
  }
  /**
   * Pop the last blend mode from the stack and apply the new top-of-stack mode.
   * @param instructionSet - The instruction set being built.
   */
  popBlendMode(instructionSet) {
    this._blendModeStack.pop();
    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
    this.setBlendMode(null, blendMode, instructionSet);
  }
  /**
   * Ensure a blend mode switch is added to the instruction set when the mode changes.
   * If an advanced blend mode is active, subsequent renderables will be collected so they can be
   * rendered within a single filter pass.
   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.
   * @param blendMode - The target blend mode.
   * @param instructionSet - The instruction set being built.
   */
  setBlendMode(renderable, blendMode, instructionSet) {
    const isRenderGroup = renderable instanceof RenderGroup;
    if (this._activeBlendMode === blendMode) {
      if (this._isAdvanced && renderable && !isRenderGroup) {
        this._renderableList?.push(renderable);
      }
      return;
    }
    if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);
    this._activeBlendMode = blendMode;
    if (!renderable) return;
    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
    if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);
  }
  _beginAdvancedBlendMode(renderable, instructionSet) {
    this._renderer.renderPipes.batch.break(instructionSet);
    const blendMode = this._activeBlendMode;
    if (!BLEND_MODE_FILTERS[blendMode]) {
      warn$2(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
      return;
    }
    const filterEffect = this._ensureFilterEffect(blendMode);
    const isRenderGroup = renderable instanceof RenderGroup;
    const instruction = {
      renderPipeId: "filter",
      action: "pushFilter",
      filterEffect,
      renderables: isRenderGroup ? null : [renderable],
      container: isRenderGroup ? renderable.root : null,
      canBundle: false
    };
    this._renderableList = instruction.renderables;
    instructionSet.add(instruction);
  }
  _ensureFilterEffect(blendMode) {
    let filterEffect = this._filterHash[blendMode];
    if (!filterEffect) {
      filterEffect = this._filterHash[blendMode] = new FilterEffect();
      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
    }
    return filterEffect;
  }
  _endAdvancedBlendMode(instructionSet) {
    this._isAdvanced = false;
    this._renderableList = null;
    this._renderer.renderPipes.batch.break(instructionSet);
    instructionSet.add({
      renderPipeId: "filter",
      action: "popFilter",
      canBundle: false
    });
  }
  /**
   * called when the instruction build process is starting this will reset internally to the default blend mode
   * @internal
   */
  buildStart() {
    this._isAdvanced = false;
  }
  /**
   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
   * active, we add the final render instructions added to the instruction set
   * @param instructionSet - The instruction set we are adding to
   * @internal
   */
  buildEnd(instructionSet) {
    if (!this._isAdvanced) return;
    this._endAdvancedBlendMode(instructionSet);
  }
  /** @internal */
  destroy() {
    this._renderer = null;
    this._renderableList = null;
    for (const i in this._filterHash) {
      this._filterHash[i].destroy();
    }
    this._filterHash = null;
  }
}
/** @ignore */
BlendModePipe.extension = {
  type: [
    ExtensionType.WebGLPipes,
    ExtensionType.WebGPUPipes,
    ExtensionType.CanvasPipes
  ],
  name: "blendMode"
};

function clearList(list, index) {
  index || (index = 0);
  for (let j = index; j < list.length; j++) {
    if (list[j]) {
      list[j] = null;
    } else {
      break;
    }
  }
}

const tempContainer = new Container();
const UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j in childrenToUpdate) {
    const renderGroupDepth = Number(j);
    const childrenAtDepth = childrenToUpdate[j];
    const list = childrenAtDepth.list;
    const index = childrenAtDepth.index;
    for (let i = 0; i < index; i++) {
      const child = list[i];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    clearList(list, index);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(
      root.relativeGroupTransform,
      renderGroupParent.worldTransform
    );
    renderGroup.worldColor = multiplyColors(
      root.groupColor,
      renderGroupParent.worldColor
    );
    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root.localTransform);
    renderGroup.worldColor = root.localColor;
    worldAlpha = root.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick) return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent = container.parent;
  if (parent && !parent.renderGroup) {
    updateFlags |= container._updateFlags;
    container.relativeGroupTransform.appendFrom(
      localTransform,
      parent.relativeGroupTransform
    );
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children = container.children;
    const length = children.length;
    for (let i = 0; i < length; i++) {
      updateTransformAndChildren(children[i], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    const renderable = container;
    if (renderable.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(renderable);
    }
  }
}
function updateColorBlendVisibility(container, parent, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.groupColor = multiplyColors(
      container.localColor,
      parent.groupColor
    );
    let groupAlpha = container.localAlpha * parent.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;
  }
  container._updateFlags = 0;
}

function validateRenderables(renderGroup, renderPipes) {
  const { list } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {
    const container = list[i];
    const renderable = container;
    const pipe = renderPipes[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}

const tempMatrix = new Matrix();
class RenderGroupSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  render({ container, transform }) {
    const parent = container.parent;
    const renderGroupParent = container.renderGroup.renderGroupParent;
    container.parent = null;
    container.renderGroup.renderGroupParent = null;
    const renderer = this._renderer;
    const originalLocalTransform = tempMatrix;
    if (transform) {
      originalLocalTransform.copyFrom(container.renderGroup.localTransform);
      container.renderGroup.localTransform.copyFrom(transform);
    }
    const renderPipes = renderer.renderPipes;
    this._updateCachedRenderGroups(container.renderGroup, null);
    this._updateRenderGroups(container.renderGroup);
    renderer.globalUniforms.start({
      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
      worldColor: container.renderGroup.worldColorAlpha
    });
    executeInstructions(container.renderGroup, renderPipes);
    if (renderPipes.uniformBatch) {
      renderPipes.uniformBatch.renderEnd();
    }
    if (transform) {
      container.renderGroup.localTransform.copyFrom(originalLocalTransform);
    }
    container.parent = parent;
    container.renderGroup.renderGroupParent = renderGroupParent;
  }
  destroy() {
    this._renderer = null;
  }
  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
    if (renderGroup.isCachedAsTexture) {
      if (!renderGroup.textureNeedsUpdate) return;
      closestCacheAsTexture = renderGroup;
    }
    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {
      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);
    }
    renderGroup.invalidateMatrices();
    if (renderGroup.isCachedAsTexture) {
      if (renderGroup.textureNeedsUpdate) {
        const bounds = renderGroup.root.getLocalBounds();
        const renderer = this._renderer;
        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;
        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;
        const scaleMode = renderGroup.textureOptions.scaleMode ?? "linear";
        const lastTexture = renderGroup.texture;
        bounds.ceil();
        if (renderGroup.texture) {
          TexturePool.returnTexture(renderGroup.texture, true);
        }
        const texture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        texture._source.style = new TextureStyle({ scaleMode });
        renderGroup.texture = texture;
        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());
        renderGroup._textureBounds.copyFrom(bounds);
        if (lastTexture !== renderGroup.texture) {
          if (renderGroup.renderGroupParent) {
            renderGroup.renderGroupParent.structureDidChange = true;
          }
        }
      }
    } else if (renderGroup.texture) {
      TexturePool.returnTexture(renderGroup.texture, true);
      renderGroup.texture = null;
    }
  }
  _updateRenderGroups(renderGroup) {
    const renderer = this._renderer;
    const renderPipes = renderer.renderPipes;
    renderGroup.runOnRender(renderer);
    renderGroup.instructionSet.renderPipes = renderPipes;
    if (!renderGroup.structureDidChange) {
      validateRenderables(renderGroup, renderPipes);
    } else {
      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
    }
    updateRenderGroupTransforms(renderGroup);
    if (renderGroup.structureDidChange) {
      renderGroup.structureDidChange = false;
      this._buildInstructions(renderGroup, renderer);
    } else {
      this._updateRenderables(renderGroup);
    }
    renderGroup.childrenRenderablesToUpdate.index = 0;
    renderer.renderPipes.batch.upload(renderGroup.instructionSet);
    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;
    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {
      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);
    }
  }
  _updateRenderables(renderGroup) {
    const { list, index } = renderGroup.childrenRenderablesToUpdate;
    for (let i = 0; i < index; i++) {
      const container = list[i];
      if (container.didViewUpdate) {
        renderGroup.updateRenderable(container);
      }
    }
    clearList(list, index);
  }
  _buildInstructions(renderGroup, rendererOrPipes) {
    const root = renderGroup.root;
    const instructionSet = renderGroup.instructionSet;
    instructionSet.reset();
    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
    const renderPipes = renderer.renderPipes;
    renderPipes.batch.buildStart(instructionSet);
    renderPipes.blendMode.buildStart();
    renderPipes.colorMask.buildStart();
    if (root.sortableChildren) {
      root.sortChildren();
    }
    root.collectRenderablesWithEffects(instructionSet, renderer, null);
    renderPipes.batch.buildEnd(instructionSet);
    renderPipes.blendMode.buildEnd(instructionSet);
  }
}
/** @ignore */
RenderGroupSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "renderGroup"
};

const _BackgroundSystem = class _BackgroundSystem {
  constructor() {
    this.clearBeforeRender = true;
    this._backgroundColor = new Color(0);
    this.color = this._backgroundColor;
    this.alpha = 1;
  }
  /**
   * initiates the background system
   * @param options - the options for the background colors
   */
  init(options) {
    options = { ..._BackgroundSystem.defaultOptions, ...options };
    this.clearBeforeRender = options.clearBeforeRender;
    this.color = options.background || options.backgroundColor || this._backgroundColor;
    this.alpha = options.backgroundAlpha;
    this._backgroundColor.setAlpha(options.backgroundAlpha);
  }
  /** The background color to fill if not transparent */
  get color() {
    return this._backgroundColor;
  }
  set color(value) {
    const incoming = Color.shared.setValue(value);
    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {
      warn$2(
        "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."
      );
    }
    this._backgroundColor.setValue(value);
  }
  /** The background color alpha. Setting this to 0 will make the canvas transparent. */
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(value) {
    this._backgroundColor.setAlpha(value);
  }
  /** The background color as an [R, G, B, A] array. */
  get colorRgba() {
    return this._backgroundColor.toArray();
  }
  /**
   * destroys the background system
   * @internal
   */
  destroy() {
  }
};
/** @ignore */
_BackgroundSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "background",
  priority: 0
};
/** default options used by the system */
_BackgroundSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.backgroundAlpha}
   * @default 1
   */
  backgroundAlpha: 1,
  /**
   * {@link WebGLOptions.backgroundColor}
   * @default 0x000000
   */
  backgroundColor: 0,
  /**
   * {@link WebGLOptions.clearBeforeRender}
   * @default true
   */
  clearBeforeRender: true
};
let BackgroundSystem = _BackgroundSystem;

const imageTypes = {
  png: "image/png",
  jpg: "image/jpeg",
  webp: "image/webp"
};
const _ExtractSystem = class _ExtractSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._renderer = renderer;
  }
  _normalizeOptions(options, defaults = {}) {
    if (options instanceof Container || options instanceof Texture) {
      return {
        target: options,
        ...defaults
      };
    }
    return {
      ...defaults,
      ...options
    };
  }
  /**
   * Creates an IImage from a display object or texture.
   * @param options - Options for creating the image, or the target to extract
   * @returns Promise that resolves with the generated IImage
   * @example
   * ```ts
   * // Basic usage with a sprite
   * const sprite = new Sprite(texture);
   * const image = await renderer.extract.image(sprite);
   * document.body.appendChild(image);
   *
   * // Advanced usage with options
   * const image = await renderer.extract.image({
   *     target: container,
   *     format: 'webp',
   *     quality: 0.8,
   *     frame: new Rectangle(0, 0, 100, 100),
   *     resolution: 2,
   *     clearColor: '#ff0000',
   *     antialias: true
   * });
   *
   * // Extract directly from a texture
   * const texture = Texture.from('myTexture.png');
   * const image = await renderer.extract.image(texture);
   * ```
   * @see {@link ExtractImageOptions} For detailed options
   * @see {@link ExtractSystem.base64} For base64 string output
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ImageLike} For the image interface
   * @category rendering
   */
  async image(options) {
    const image = DOMAdapter.get().createImage();
    image.src = await this.base64(options);
    return image;
  }
  /**
   * Converts the target into a base64 encoded string.
   *
   * This method works by first creating
   * a canvas using `Extract.canvas` and then converting it to a base64 string.
   * @param options - The options for creating the base64 string, or the target to extract
   * @returns Promise that resolves with the base64 encoded string
   * @example
   * ```ts
   * // Basic usage with a sprite
   * const sprite = new Sprite(texture);
   * const base64 = await renderer.extract.base64(sprite);
   * console.log(base64); // data:image/png;base64,...
   *
   * // Advanced usage with options
   * const base64 = await renderer.extract.base64({
   *     target: container,
   *     format: 'webp',
   *     quality: 0.8,
   *     frame: new Rectangle(0, 0, 100, 100),
   *     resolution: 2
   * });
   * ```
   * @throws Will throw an error if the platform doesn't support any of:
   * - ICanvas.toDataURL
   * - ICanvas.toBlob
   * - ICanvas.convertToBlob
   * @see {@link ExtractImageOptions} For detailed options
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ExtractSystem.image} For HTMLImage output
   * @category rendering
   */
  async base64(options) {
    options = this._normalizeOptions(
      options,
      _ExtractSystem.defaultImageOptions
    );
    const { format, quality } = options;
    const canvas = this.canvas(options);
    if (canvas.toBlob !== void 0) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("ICanvas.toBlob failed!"));
            return;
          }
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        }, imageTypes[format], quality);
      });
    }
    if (canvas.toDataURL !== void 0) {
      return canvas.toDataURL(imageTypes[format], quality);
    }
    if (canvas.convertToBlob !== void 0) {
      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }
    throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
  }
  /**
   * Creates a Canvas element, renders the target to it and returns it.
   * This method is useful for creating static images or when you need direct canvas access.
   * @param options - The options for creating the canvas, or the target to extract
   * @returns A Canvas element with the texture rendered on
   * @example
   * ```ts
   * // Basic canvas extraction from a sprite
   * const sprite = new Sprite(texture);
   * const canvas = renderer.extract.canvas(sprite);
   * document.body.appendChild(canvas);
   *
   * // Extract with custom region
   * const canvas = renderer.extract.canvas({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const canvas = renderer.extract.canvas({
   *     target: sprite,
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Extract directly from a texture
   * const texture = Texture.from('myTexture.png');
   * const canvas = renderer.extract.canvas(texture);
   *
   * // Extract with anti-aliasing
   * const canvas = renderer.extract.canvas({
   *     target: graphics,
   *     antialias: true
   * });
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link ExtractSystem.image} For HTMLImage output
   * @see {@link ExtractSystem.pixels} For raw pixel data
   * @category rendering
   */
  canvas(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    if (target instanceof Texture) {
      return renderer.texture.generateCanvas(target);
    }
    const texture = renderer.textureGenerator.generateTexture(options);
    const canvas = renderer.texture.generateCanvas(texture);
    texture.destroy(true);
    return canvas;
  }
  /**
   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,
   * with integer values between 0 and 255 (inclusive).
   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA
   * @param options - The options for extracting the image, or the target to extract
   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format
   * @example
   * ```ts
   * // Basic pixel extraction
   * const sprite = new Sprite(texture);
   * const pixels = renderer.extract.pixels(sprite);
   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values
   *
   * // Extract with custom region
   * const pixels = renderer.extract.pixels({
   *     target: sprite,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const pixels = renderer.extract.pixels({
   *     target: sprite,
   *     resolution: 2
   * });
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link ExtractSystem.canvas} For canvas output
   * @see {@link ExtractSystem.image} For image output
   * @category rendering
   */
  pixels(options) {
    options = this._normalizeOptions(options);
    const target = options.target;
    const renderer = this._renderer;
    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
    const pixelInfo = renderer.texture.getPixels(texture);
    if (target instanceof Container) {
      texture.destroy(true);
    }
    return pixelInfo;
  }
  /**
   * Creates a texture from a display object or existing texture.
   *
   * This is useful for creating
   * reusable textures from rendered content or making copies of existing textures.
   * > [!NOTE] The returned texture should be destroyed when no longer needed
   * @param options - The options for creating the texture, or the target to extract
   * @returns A new texture containing the extracted content
   * @example
   * ```ts
   * // Basic texture extraction from a sprite
   * const sprite = new Sprite(texture);
   * const extractedTexture = renderer.extract.texture(sprite);
   *
   * // Extract with custom region
   * const regionTexture = renderer.extract.texture({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Extract with high resolution
   * const hiResTexture = renderer.extract.texture({
   *     target: sprite,
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Create a new sprite from extracted texture
   * const newSprite = new Sprite(
   *     renderer.extract.texture({
   *         target: graphics,
   *         antialias: true
   *     })
   * );
   *
   * // Clean up when done
   * extractedTexture.destroy(true);
   * ```
   * @see {@link ExtractOptions} For detailed options
   * @see {@link Texture} For texture management
   * @see {@link GenerateTextureSystem} For texture generation
   * @category rendering
   */
  texture(options) {
    options = this._normalizeOptions(options);
    if (options.target instanceof Texture) return options.target;
    return this._renderer.textureGenerator.generateTexture(options);
  }
  /**
   * Extracts and downloads content from the renderer as an image file.
   * This is a convenient way to save screenshots or export rendered content.
   * > [!NOTE] The download will use PNG format regardless of the filename extension
   * @param options - The options for downloading and extracting the image, or the target to extract
   * @example
   * ```ts
   * // Basic download with default filename
   * const sprite = new Sprite(texture);
   * renderer.extract.download(sprite); // Downloads as 'image.png'
   *
   * // Download with custom filename
   * renderer.extract.download({
   *     target: sprite,
   *     filename: 'screenshot.png'
   * });
   *
   * // Download with custom region
   * renderer.extract.download({
   *     target: container,
   *     filename: 'region.png',
   *     frame: new Rectangle(0, 0, 100, 100)
   * });
   *
   * // Download with high resolution and background
   * renderer.extract.download({
   *     target: stage,
   *     filename: 'hd-screenshot.png',
   *     resolution: 2,
   *     clearColor: '#ff0000'
   * });
   *
   * // Download with anti-aliasing
   * renderer.extract.download({
   *     target: graphics,
   *     filename: 'smooth.png',
   *     antialias: true
   * });
   * ```
   * @see {@link ExtractDownloadOptions} For detailed options
   * @see {@link ExtractSystem.image} For creating images without download
   * @see {@link ExtractSystem.canvas} For canvas output
   * @category rendering
   */
  download(options) {
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const link = document.createElement("a");
    link.download = options.filename ?? "image.png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  /**
   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
   * The image will be displayed in the browser's console using CSS background images.
   * @param options - The options for logging the image, or the target to log
   * @param options.width - The width of the logged image preview in the console (in pixels)
   * @example
   * ```ts
   * // Basic usage
   * const sprite = new Sprite(texture);
   * renderer.extract.log(sprite);
   * ```
   * @see {@link ExtractSystem.canvas} For getting raw canvas output
   * @see {@link ExtractSystem.pixels} For raw pixel data
   * @category rendering
   * @advanced
   */
  log(options) {
    const width = options.width ?? 200;
    options = this._normalizeOptions(options);
    const canvas = this.canvas(options);
    const base64 = canvas.toDataURL();
    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
    const style = [
      "font-size: 1px;",
      `padding: ${width}px ${300}px;`,
      `background: url(${base64}) no-repeat;`,
      "background-size: contain;"
    ].join(" ");
    console.log("%c ", style);
  }
  destroy() {
    this._renderer = null;
  }
};
/** @ignore */
_ExtractSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "extract"
};
/**
 * Default options for image extraction.
 * @example
 * ```ts
 * // Customize default options
 * ExtractSystem.defaultImageOptions.format = 'webp';
 * ExtractSystem.defaultImageOptions.quality = 0.8;
 *
 * // Use defaults
 * const image = await renderer.extract.image(sprite);
 * ```
 */
_ExtractSystem.defaultImageOptions = {
  format: "png",
  quality: 1
};
let ExtractSystem = _ExtractSystem;

class RenderTexture extends Texture {
  /**
   * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.
   * @param options - Options for the RenderTexture, including width, height, and dynamic.
   * @returns A new RenderTexture instance.
   * @example
   * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });
   * rt.resize(500, 500);
   */
  static create(options) {
    const { dynamic, ...rest } = options;
    return new RenderTexture({
      source: new TextureSource(rest),
      dynamic: dynamic ?? false
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(width, height, resolution) {
    this.source.resize(width, height, resolution);
    return this;
  }
}

const tempRect = new Rectangle();
const tempBounds = new Bounds();
const noColor = [0, 0, 0, 0];
class GenerateTextureSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  /**
   * Creates a texture from a display object that can be used for creating sprites and other textures.
   * This is particularly useful for optimizing performance when a complex container needs to be reused.
   * @param options - Generate texture options or a container to convert to texture
   * @returns A new RenderTexture containing the rendered display object
   * @example
   * ```ts
   * // Basic usage with a container
   * const container = new Container();
   * container.addChild(
   *     new Graphics()
   *         .circle(0, 0, 50)
   *         .fill('red')
   * );
   *
   * const texture = renderer.textureGenerator.generateTexture(container);
   *
   * // Advanced usage with options
   * const texture = renderer.textureGenerator.generateTexture({
   *     target: container,
   *     frame: new Rectangle(0, 0, 100, 100), // Specific region
   *     resolution: 2,                        // High DPI
   *     clearColor: '#ff0000',               // Red background
   *     antialias: true                      // Smooth edges
   * });
   *
   * // Create a sprite from the generated texture
   * const sprite = new Sprite(texture);
   *
   * // Clean up when done
   * texture.destroy(true);
   * ```
   * @see {@link GenerateTextureOptions} For detailed texture generation options
   * @see {@link RenderTexture} For the type of texture created
   * @category rendering
   */
  generateTexture(options) {
    if (options instanceof Container) {
      options = {
        target: options,
        frame: void 0,
        textureSourceOptions: {},
        resolution: void 0
      };
    }
    const resolution = options.resolution || this._renderer.resolution;
    const antialias = options.antialias || this._renderer.view.antialias;
    const container = options.target;
    let clearColor = options.clearColor;
    if (clearColor) {
      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
    } else {
      clearColor = noColor;
    }
    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;
    region.width = Math.max(region.width, 1 / resolution) | 0;
    region.height = Math.max(region.height, 1 / resolution) | 0;
    const target = RenderTexture.create({
      ...options.textureSourceOptions,
      width: region.width,
      height: region.height,
      resolution,
      antialias
    });
    const transform = Matrix.shared.translate(-region.x, -region.y);
    this._renderer.render({
      container,
      transform,
      target,
      clearColor
    });
    target.source.updateMipmaps();
    return target;
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
GenerateTextureSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "textureGenerator"
};

function cleanHash(hash) {
  let clean = false;
  for (const i in hash) {
    if (hash[i] == void 0) {
      clean = true;
      break;
    }
  }
  if (!clean) return hash;
  const cleanHash2 = /* @__PURE__ */ Object.create(null);
  for (const i in hash) {
    const value = hash[i];
    if (value) {
      cleanHash2[i] = value;
    }
  }
  return cleanHash2;
}
function cleanArray(arr) {
  let offset = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == void 0) {
      offset++;
    } else {
      arr[i - offset] = arr[i];
    }
  }
  arr.length -= offset;
  return arr;
}

const _GCSystem = class _GCSystem {
  /**
   * Creates a new GCSystem instance.
   * @param renderer - The renderer this garbage collection system works for
   */
  constructor(renderer) {
    /** Array of resources being tracked for garbage collection */
    this._managedResources = [];
    this._managedResourceHashes = [];
    this._managedCollections = [];
    this._ready = false;
    this._renderer = renderer;
  }
  /**
   * Initializes the garbage collection system with the provided options.
   * @param options - Configuration options
   */
  init(options) {
    options = { ..._GCSystem.defaultOptions, ...options };
    this.maxUnusedTime = options.gcMaxUnusedTime;
    this._frequency = options.gcFrequency;
    this.enabled = options.gcActive;
    this.now = performance.now();
  }
  /**
   * Gets whether the garbage collection system is currently enabled.
   * @returns True if GC is enabled, false otherwise
   */
  get enabled() {
    return !!this._handler;
  }
  /**
   * Enables or disables the garbage collection system.
   * When enabled, schedules periodic cleanup of resources.
   * When disabled, cancels all scheduled cleanups.
   */
  set enabled(value) {
    if (this.enabled === value) return;
    if (value) {
      this._handler = this._renderer.scheduler.repeat(
        () => {
          this._ready = true;
        },
        this._frequency,
        false
      );
      this._collectionsHandler = this._renderer.scheduler.repeat(
        () => {
          for (const hash of this._managedCollections) {
            const { context, collection, type } = hash;
            if (type === "hash") {
              context[collection] = cleanHash(context[collection]);
            } else {
              context[collection] = cleanArray(context[collection]);
            }
          }
        },
        this._frequency
      );
    } else {
      this._renderer.scheduler.cancel(this._handler);
      this._renderer.scheduler.cancel(this._collectionsHandler);
      this._handler = 0;
      this._collectionsHandler = 0;
    }
  }
  /**
   * Called before rendering. Updates the current timestamp.
   * @param options - The render options
   * @param options.container - The container to render
   */
  prerender({ container }) {
    this.now = performance.now();
    container.renderGroup.gcTick = this._renderer.tick++;
    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
  }
  /** Performs garbage collection after rendering. */
  postrender() {
    if (!this._ready || !this.enabled) return;
    this.run();
    this._ready = false;
  }
  /**
   * Updates the GC tick counter for a render group and its children.
   * @param renderGroup - The render group to update
   * @param gcTick - The new tick value
   */
  _updateInstructionGCTick(renderGroup, gcTick) {
    renderGroup.instructionSet.gcTick = gcTick;
    renderGroup.gcTick = gcTick;
    for (const child of renderGroup.renderGroupChildren) {
      this._updateInstructionGCTick(child, gcTick);
    }
  }
  /**
   * Registers a collection for garbage collection tracking.
   * @param context - The object containing the collection
   * @param collection - The property name on context that holds the collection
   * @param type - The type of collection to track ('hash' or 'array')
   */
  addCollection(context, collection, type) {
    this._managedCollections.push({
      context,
      collection,
      type
    });
  }
  /**
   * Registers a resource for garbage collection tracking.
   * @param resource - The resource to track
   * @param type - The type of resource to track
   */
  addResource(resource, type) {
    if (resource._gcLastUsed !== -1) {
      resource._gcLastUsed = this.now;
      resource._onTouch?.(this.now);
      return;
    }
    const index = this._managedResources.length;
    resource._gcData = {
      index,
      type
    };
    resource._gcLastUsed = this.now;
    resource._onTouch?.(this.now);
    resource.once("unload", this.removeResource, this);
    this._managedResources.push(resource);
  }
  /**
   * Removes a resource from garbage collection tracking.
   * Call this when manually destroying a resource.
   * @param resource - The resource to stop tracking
   */
  removeResource(resource) {
    const gcData = resource._gcData;
    if (!gcData) return;
    const index = gcData.index;
    const last = this._managedResources.length - 1;
    if (index !== last) {
      const lastResource = this._managedResources[last];
      this._managedResources[index] = lastResource;
      lastResource._gcData.index = index;
    }
    this._managedResources.length--;
    resource._gcData = null;
    resource._gcLastUsed = -1;
  }
  /**
   * Registers a hash-based resource collection for garbage collection tracking.
   * Resources in the hash will be automatically tracked and cleaned up when unused.
   * @param context - The object containing the hash property
   * @param hash - The property name on context that holds the resource hash
   * @param type - The type of resources in the hash ('resource' or 'renderable')
   * @param priority - Processing priority (lower values are processed first)
   */
  addResourceHash(context, hash, type, priority = 0) {
    this._managedResourceHashes.push({
      context,
      hash,
      type,
      priority
    });
    this._managedResourceHashes.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Performs garbage collection by cleaning up unused resources.
   * Removes resources that haven't been used for longer than maxUnusedTime.
   */
  run() {
    const now = performance.now();
    const managedResourceHashes = this._managedResourceHashes;
    for (const hashEntry of managedResourceHashes) {
      this.runOnHash(hashEntry, now);
    }
    let writeIndex = 0;
    for (let i = 0; i < this._managedResources.length; i++) {
      const resource = this._managedResources[i];
      writeIndex = this.runOnResource(resource, now, writeIndex);
    }
    this._managedResources.length = writeIndex;
  }
  updateRenderableGCTick(renderable, now) {
    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
    const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;
    if ((renderGroup?.gcTick ?? 0) === currentTick) {
      renderable._gcLastUsed = now;
      renderable._onTouch?.(now);
    }
  }
  runOnResource(resource, now, writeIndex) {
    const gcData = resource._gcData;
    if (gcData.type === "renderable") {
      this.updateRenderableGCTick(resource, now);
    }
    const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;
    if (isRecentlyUsed || !resource.autoGarbageCollect) {
      this._managedResources[writeIndex] = resource;
      gcData.index = writeIndex;
      writeIndex++;
    } else {
      resource.unload();
      resource._gcData = null;
      resource._gcLastUsed = -1;
      resource.off("unload", this.removeResource, this);
    }
    return writeIndex;
  }
  /**
   * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.
   * @param hashValue - The original hash to clone from
   * @param stopKey - The key to stop at (exclusive)
   * @returns A new hash object with copied entries
   */
  _createHashClone(hashValue, stopKey) {
    const hashClone = /* @__PURE__ */ Object.create(null);
    for (const k in hashValue) {
      if (k === stopKey) break;
      if (hashValue[k] !== null) hashClone[k] = hashValue[k];
    }
    return hashClone;
  }
  runOnHash(hashEntry, now) {
    const { context, hash, type } = hashEntry;
    const hashValue = context[hash];
    let hashClone = null;
    let nullCount = 0;
    for (const key in hashValue) {
      const resource = hashValue[key];
      if (resource === null) {
        nullCount++;
        if (nullCount === 1e4 && !hashClone) {
          hashClone = this._createHashClone(hashValue, key);
        }
        continue;
      }
      if (resource._gcLastUsed === -1) {
        resource._gcLastUsed = now;
        resource._onTouch?.(now);
        if (hashClone) hashClone[key] = resource;
        continue;
      }
      if (type === "renderable") {
        this.updateRenderableGCTick(resource, now);
      }
      const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;
      if (!isRecentlyUsed && resource.autoGarbageCollect) {
        if (!hashClone) {
          if (nullCount + 1 !== 1e4) {
            hashValue[key] = null;
            nullCount++;
          } else {
            hashClone = this._createHashClone(hashValue, key);
          }
        }
        if (type === "renderable") {
          const res = resource;
          const renderGroup = res.renderGroup ?? res.parentRenderGroup;
          if (renderGroup) renderGroup.structureDidChange = true;
        }
        resource.unload();
        resource._gcData = null;
        resource._gcLastUsed = -1;
      } else if (hashClone) {
        hashClone[key] = resource;
      }
    }
    if (hashClone) {
      context[hash] = hashClone;
    }
  }
  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
  destroy() {
    this.enabled = false;
    this._managedResources.forEach((resource) => {
      resource.off("unload", this.removeResource, this);
    });
    this._managedResources.length = 0;
    this._managedResourceHashes.length = 0;
    this._managedCollections.length = 0;
    this._renderer = null;
  }
};
/** @ignore */
_GCSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "gc",
  priority: 0
};
/** Default options for the GCSystem */
_GCSystem.defaultOptions = {
  /** Enable/disable the garbage collector */
  gcActive: true,
  /** Time in ms before an unused resource is collected (default 1 minute) */
  gcMaxUnusedTime: 6e4,
  /** How often to run garbage collection in ms (default 30 seconds) */
  gcFrequency: 3e4
};
let GCSystem = _GCSystem;

class GlobalUniformSystem {
  constructor(renderer) {
    this._stackIndex = 0;
    this._globalUniformDataStack = [];
    this._uniformsPool = [];
    this._activeUniforms = [];
    this._bindGroupPool = [];
    this._activeBindGroups = [];
    this._renderer = renderer;
  }
  reset() {
    this._stackIndex = 0;
    for (let i = 0; i < this._activeUniforms.length; i++) {
      this._uniformsPool.push(this._activeUniforms[i]);
    }
    for (let i = 0; i < this._activeBindGroups.length; i++) {
      this._bindGroupPool.push(this._activeBindGroups[i]);
    }
    this._activeUniforms.length = 0;
    this._activeBindGroups.length = 0;
  }
  start(options) {
    this.reset();
    this.push(options);
  }
  bind({
    size,
    projectionMatrix,
    worldTransformMatrix,
    worldColor,
    offset
  }) {
    const renderTarget = this._renderer.renderTarget.renderTarget;
    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
      worldTransformMatrix: new Matrix(),
      worldColor: 4294967295,
      offset: new Point()
    };
    const globalUniformData = {
      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
      resolution: size || renderTarget.size,
      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
      worldColor: worldColor || currentGlobalUniformData.worldColor,
      offset: offset || currentGlobalUniformData.offset,
      bindGroup: null
    };
    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
    this._activeUniforms.push(uniformGroup);
    const uniforms = uniformGroup.uniforms;
    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
    uniforms.uResolution = globalUniformData.resolution;
    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
    color32BitToUniform(
      globalUniformData.worldColor,
      uniforms.uWorldColorAlpha,
      0
    );
    uniformGroup.update();
    let bindGroup;
    if (this._renderer.renderPipes.uniformBatch) {
      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
    } else {
      bindGroup = this._bindGroupPool.pop() || new BindGroup();
      this._activeBindGroups.push(bindGroup);
      bindGroup.setResource(uniformGroup, 0);
    }
    globalUniformData.bindGroup = bindGroup;
    this._currentGlobalUniformData = globalUniformData;
  }
  push(options) {
    this.bind(options);
    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
  }
  pop() {
    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
    if (this._renderer.type === RendererType.WEBGL) {
      this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
  }
  get bindGroup() {
    return this._currentGlobalUniformData.bindGroup;
  }
  get globalUniformData() {
    return this._currentGlobalUniformData;
  }
  get uniformGroup() {
    return this._currentGlobalUniformData.bindGroup.resources[0];
  }
  _createUniforms() {
    const globalUniforms = new UniformGroup({
      uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
      uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
      uResolution: { value: [0, 0], type: "vec2<f32>" }
    }, {
      isStatic: true
    });
    return globalUniforms;
  }
  destroy() {
    this._renderer = null;
    this._globalUniformDataStack.length = 0;
    this._uniformsPool.length = 0;
    this._activeUniforms.length = 0;
    this._bindGroupPool.length = 0;
    this._activeBindGroups.length = 0;
    this._currentGlobalUniformData = null;
  }
}
/** @ignore */
GlobalUniformSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "globalUniforms"
};

let uid = 1;
class SchedulerSystem {
  constructor() {
    this._tasks = [];
    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */
    this._offset = 0;
  }
  /** Initializes the scheduler system and starts the ticker. */
  init() {
    Ticker.system.add(this._update, this);
  }
  /**
   * Schedules a repeating task.
   * @param func - The function to execute.
   * @param duration - The interval duration in milliseconds.
   * @param useOffset - this will spread out tasks so that they do not all run at the same time
   * @returns The unique identifier for the scheduled task.
   */
  repeat(func, duration, useOffset = true) {
    const id = uid++;
    let offset = 0;
    if (useOffset) {
      this._offset += 1e3;
      offset = this._offset;
    }
    this._tasks.push({
      func,
      duration,
      start: performance.now(),
      offset,
      last: performance.now(),
      repeat: true,
      id
    });
    return id;
  }
  /**
   * Cancels a scheduled task.
   * @param id - The unique identifier of the task to cancel.
   */
  cancel(id) {
    for (let i = 0; i < this._tasks.length; i++) {
      if (this._tasks[i].id === id) {
        this._tasks.splice(i, 1);
        return;
      }
    }
  }
  /**
   * Updates and executes the scheduled tasks.
   * @private
   */
  _update() {
    const now = performance.now();
    for (let i = 0; i < this._tasks.length; i++) {
      const task = this._tasks[i];
      if (now - task.offset - task.last >= task.duration) {
        const elapsed = now - task.start;
        task.func(elapsed);
        task.last = now;
      }
    }
  }
  /**
   * Destroys the scheduler system and removes all tasks.
   * @internal
   */
  destroy() {
    Ticker.system.remove(this._update, this);
    this._tasks.length = 0;
  }
}
/** @ignore */
SchedulerSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "scheduler",
  priority: 0
};

let saidHello = false;
function sayHello(type) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);
  }
  saidHello = true;
}

class HelloSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  /**
   * It all starts here! This initiates every system, passing in the options for any system by name.
   * @param options - the config for the renderer and all its systems
   */
  init(options) {
    if (options.hello) {
      let name = this._renderer.name;
      if (this._renderer.type === RendererType.WEBGL) {
        name += ` ${this._renderer.context.webGLVersion}`;
      }
      sayHello(name);
    }
  }
}
/** @ignore */
HelloSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "hello",
  priority: -2
};
/** The default options for the system. */
HelloSystem.defaultOptions = {
  /** {@link WebGLOptions.hello} */
  hello: false
};

const _RenderableGCSystem = class _RenderableGCSystem {
  /**
   * Creates a new RenderableGCSystem instance.
   * @param renderer - The renderer this garbage collection system works for
   */
  constructor(renderer) {
    this._renderer = renderer;
  }
  /**
   * Initializes the garbage collection system with the provided options.
   * @param options - Configuration options for the renderer
   */
  init(options) {
    options = { ..._RenderableGCSystem.defaultOptions, ...options };
    this.maxUnusedTime = options.renderableGCMaxUnusedTime;
  }
  /**
   * Gets whether the garbage collection system is currently enabled.
   * @returns True if GC is enabled, false otherwise
   */
  get enabled() {
    deprecation("8.15.0", "RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.");
    return this._renderer.gc.enabled;
  }
  /**
   * Enables or disables the garbage collection system.
   * When enabled, schedules periodic cleanup of resources.
   * When disabled, cancels all scheduled cleanups.
   */
  set enabled(value) {
    deprecation("8.15.0", "RenderableGCSystem.enabled is deprecated, please use the GCSystem.enabled instead.");
    this._renderer.gc.enabled = value;
  }
  /**
   * Adds a hash table to be managed by the garbage collector.
   * @param context - The object containing the hash table
   * @param hash - The property name of the hash table
   */
  addManagedHash(context, hash) {
    deprecation("8.15.0", "RenderableGCSystem.addManagedHash is deprecated, please use the GCSystem.addCollection instead.");
    this._renderer.gc.addCollection(context, hash, "hash");
  }
  /**
   * Adds an array to be managed by the garbage collector.
   * @param context - The object containing the array
   * @param hash - The property name of the array
   */
  addManagedArray(context, hash) {
    deprecation("8.15.0", "RenderableGCSystem.addManagedArray is deprecated, please use the GCSystem.addCollection instead.");
    this._renderer.gc.addCollection(context, hash, "array");
  }
  /**
   * Starts tracking a renderable for garbage collection.
   * @param _renderable - The renderable to track
   * @deprecated since 8.15.0
   */
  addRenderable(_renderable) {
    deprecation("8.15.0", "RenderableGCSystem.addRenderable is deprecated, please use the GCSystem instead.");
    this._renderer.gc.addResource(_renderable, "renderable");
  }
  /**
   * Performs garbage collection by cleaning up unused renderables.
   * Removes renderables that haven't been used for longer than maxUnusedTime.
   */
  run() {
    deprecation("8.15.0", "RenderableGCSystem.run is deprecated, please use the GCSystem instead.");
    this._renderer.gc.run();
  }
  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */
  destroy() {
    this._renderer = null;
  }
};
/**
 * Extension metadata for registering this system with the renderer.
 * @ignore
 */
_RenderableGCSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "renderableGC",
  priority: 0
};
/**
 * Default configuration options for the garbage collection system.
 * These can be overridden when initializing the renderer.
 * @deprecated since 8.15.0
 */
_RenderableGCSystem.defaultOptions = {
  /** Enable/disable the garbage collector */
  renderableGCActive: true,
  /** Time in ms before an unused resource is collected (default 1 minute) */
  renderableGCMaxUnusedTime: 6e4,
  /** How often to run garbage collection in ms (default 30 seconds) */
  renderableGCFrequency: 3e4
};
let RenderableGCSystem = _RenderableGCSystem;

const _TextureGCSystem = class _TextureGCSystem {
  /**
   * Frame count since started.
   * @readonly
   * @deprecated since 8.15.0
   */
  get count() {
    return this._renderer.tick;
  }
  /**
   * Frame count since last garbage collection.
   * @readonly
   * @deprecated since 8.15.0
   */
  get checkCount() {
    return this._checkCount;
  }
  set checkCount(value) {
    deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
    this._checkCount = value;
  }
  /**
   * Maximum idle frames before a texture is destroyed by garbage collection.
   * @see TextureGCSystem.defaultMaxIdle
   * @deprecated since 8.15.0
   */
  get maxIdle() {
    return this._renderer.gc.maxUnusedTime / 1e3 * 60;
  }
  set maxIdle(value) {
    deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
    this._renderer.gc.maxUnusedTime = value / 60 * 1e3;
  }
  /**
   * Frames between two garbage collections.
   * @see TextureGCSystem.defaultCheckCountMax
   * @deprecated since 8.15.0
   */
  // eslint-disable-next-line dot-notation
  get checkCountMax() {
    return Math.floor(this._renderer.gc["_frequency"] / 1e3);
  }
  set checkCountMax(_value) {
    deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
  }
  /**
   * Current garbage collection mode.
   * @see TextureGCSystem.defaultMode
   * @deprecated since 8.15.0
   */
  get active() {
    return this._renderer.gc.enabled;
  }
  set active(value) {
    deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
    this._renderer.gc.enabled = value;
  }
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._renderer = renderer;
    this._checkCount = 0;
  }
  init(options) {
    if (options.textureGCActive !== _TextureGCSystem.defaultOptions.textureGCActive) {
      this.active = options.textureGCActive;
    }
    if (options.textureGCMaxIdle !== _TextureGCSystem.defaultOptions.textureGCMaxIdle) {
      this.maxIdle = options.textureGCMaxIdle;
    }
    if (options.textureGCCheckCountMax !== _TextureGCSystem.defaultOptions.textureGCCheckCountMax) {
      this.checkCountMax = options.textureGCCheckCountMax;
    }
  }
  /**
   * Checks to see when the last time a texture was used.
   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
   * @deprecated since 8.15.0
   */
  run() {
    deprecation("8.15.0", "TextureGCSystem.run is deprecated, please use the GCSystem instead.");
    this._renderer.gc.run();
  }
  destroy() {
    this._renderer = null;
  }
};
/** @ignore */
_TextureGCSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "textureGC"
};
/**
 * Default options for the TextureGCSystem
 * @deprecated since 8.15.0
 */
_TextureGCSystem.defaultOptions = {
  /**
   * If set to true, this will enable the garbage collector on the GPU.
   * @default true
   */
  textureGCActive: true,
  /**
   * @deprecated since 8.3.0
   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}
   */
  textureGCAMaxIdle: null,
  /**
   * The maximum idle frames before a texture is destroyed by garbage collection.
   * @default 60 * 60
   */
  textureGCMaxIdle: 60 * 60,
  /**
   * Frames between two garbage collections.
   * @default 600
   */
  textureGCCheckCountMax: 600
};
let TextureGCSystem = _TextureGCSystem;

const _RenderTarget = class _RenderTarget {
  /**
   * @param [descriptor] - Options for creating a render target.
   */
  constructor(descriptor = {}) {
    /** unique id for this render target */
    this.uid = uid$1("renderTarget");
    /**
     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could
     * write to multiple if required! (eg deferred lighting)
     */
    this.colorTextures = [];
    this.dirtyId = 0;
    this.isRoot = false;
    this._size = new Float32Array(2);
    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */
    this._managedColorTextures = false;
    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };
    this.stencil = descriptor.stencil;
    this.depth = descriptor.depth;
    this.isRoot = descriptor.isRoot;
    if (typeof descriptor.colorTextures === "number") {
      this._managedColorTextures = true;
      for (let i = 0; i < descriptor.colorTextures; i++) {
        this.colorTextures.push(
          new TextureSource({
            width: descriptor.width,
            height: descriptor.height,
            resolution: descriptor.resolution,
            antialias: descriptor.antialias
          })
        );
      }
    } else {
      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
      const colorSource = this.colorTexture.source;
      this.resize(colorSource.width, colorSource.height, colorSource._resolution);
    }
    this.colorTexture.source.on("resize", this.onSourceResize, this);
    if (descriptor.depthStencilTexture || this.stencil) {
      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
        this.depthStencilTexture = descriptor.depthStencilTexture.source;
      } else {
        this.ensureDepthStencilTexture();
      }
    }
  }
  get size() {
    const _size = this._size;
    _size[0] = this.pixelWidth;
    _size[1] = this.pixelHeight;
    return _size;
  }
  get width() {
    return this.colorTexture.source.width;
  }
  get height() {
    return this.colorTexture.source.height;
  }
  get pixelWidth() {
    return this.colorTexture.source.pixelWidth;
  }
  get pixelHeight() {
    return this.colorTexture.source.pixelHeight;
  }
  get resolution() {
    return this.colorTexture.source._resolution;
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  onSourceResize(source) {
    this.resize(source.width, source.height, source._resolution, true);
  }
  /**
   * This will ensure a depthStencil texture is created for this render target.
   * Most likely called by the mask system to make sure we have stencil buffer added.
   * @internal
   */
  ensureDepthStencilTexture() {
    if (!this.depthStencilTexture) {
      this.depthStencilTexture = new TextureSource({
        width: this.width,
        height: this.height,
        resolution: this.resolution,
        format: "depth24plus-stencil8",
        autoGenerateMipmaps: false,
        antialias: false,
        mipLevelCount: 1
        // sampleCount: handled by the render target system..
      });
    }
  }
  resize(width, height, resolution = this.resolution, skipColorTexture = false) {
    this.dirtyId++;
    this.colorTextures.forEach((colorTexture, i) => {
      if (skipColorTexture && i === 0) return;
      colorTexture.source.resize(width, height, resolution);
    });
    if (this.depthStencilTexture) {
      this.depthStencilTexture.source.resize(width, height, resolution);
    }
  }
  destroy() {
    this.colorTexture.source.off("resize", this.onSourceResize, this);
    if (this._managedColorTextures) {
      this.colorTextures.forEach((texture) => {
        texture.destroy();
      });
    }
    if (this.depthStencilTexture) {
      this.depthStencilTexture.destroy();
      delete this.depthStencilTexture;
    }
  }
};
/** The default options for a render target */
_RenderTarget.defaultOptions = {
  /** the width of the RenderTarget */
  width: 0,
  /** the height of the RenderTarget */
  height: 0,
  /** the resolution of the RenderTarget */
  resolution: 1,
  /** an array of textures, or a number indicating how many color textures there should be */
  colorTextures: 1,
  /** should this render target have a stencil buffer? */
  stencil: false,
  /** should this render target have a depth buffer? */
  depth: false,
  /** should this render target be antialiased? */
  antialias: false,
  // save on perf by default!
  /** is this a root element, true if this is gl context owners render target */
  isRoot: false
};
let RenderTarget = _RenderTarget;

const canvasCache = /* @__PURE__ */ new Map();
GlobalResourceRegistry.register(canvasCache);
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}

const _ViewSystem = class _ViewSystem {
  /**
   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.
   * @type {boolean}
   */
  get autoDensity() {
    return this.texture.source.autoDensity;
  }
  set autoDensity(value) {
    this.texture.source.autoDensity = value;
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.texture.source._resolution;
  }
  set resolution(value) {
    this.texture.source.resize(
      this.texture.source.width,
      this.texture.source.height,
      value
    );
  }
  /**
   * initiates the view system
   * @param options - the options for the view
   */
  init(options) {
    options = {
      ..._ViewSystem.defaultOptions,
      ...options
    };
    if (options.view) {
      deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
      options.canvas = options.view;
    }
    this.screen = new Rectangle(0, 0, options.width, options.height);
    this.canvas = options.canvas || DOMAdapter.get().createCanvas();
    this.antialias = !!options.antialias;
    this.texture = getCanvasTexture(this.canvas, options);
    this.renderTarget = new RenderTarget({
      colorTextures: [this.texture],
      depth: !!options.depth,
      isRoot: true
    });
    this.texture.source.transparent = options.backgroundAlpha < 1;
    this.resolution = options.resolution;
  }
  /**
   * Resizes the screen and canvas to the specified dimensions.
   * @param desiredScreenWidth - The new width of the screen.
   * @param desiredScreenHeight - The new height of the screen.
   * @param resolution
   */
  resize(desiredScreenWidth, desiredScreenHeight, resolution) {
    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
    this.screen.width = this.texture.frame.width;
    this.screen.height = this.texture.frame.height;
  }
  /**
   * Destroys this System and optionally removes the canvas from the dom.
   * @param {options | false} options - The options for destroying the view, or "false".
   * @example
   * viewSystem.destroy();
   * viewSystem.destroy(true);
   * viewSystem.destroy({ removeView: true });
   */
  destroy(options = false) {
    const removeView = typeof options === "boolean" ? options : !!options?.removeView;
    if (removeView && this.canvas.parentNode) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
    this.texture.destroy();
  }
};
/** @ignore */
_ViewSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "view",
  priority: 0
};
/** The default options for the view system. */
_ViewSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.width}
   * @default 800
   */
  width: 800,
  /**
   * {@link WebGLOptions.height}
   * @default 600
   */
  height: 600,
  /**
   * {@link WebGLOptions.autoDensity}
   * @default false
   */
  autoDensity: false,
  /**
   * {@link WebGLOptions.antialias}
   * @default false
   */
  antialias: false
};
let ViewSystem = _ViewSystem;

const SharedSystems = [
  BackgroundSystem,
  GlobalUniformSystem,
  HelloSystem,
  ViewSystem,
  RenderGroupSystem,
  GCSystem,
  TextureGCSystem,
  GenerateTextureSystem,
  ExtractSystem,
  RendererInitHook,
  RenderableGCSystem,
  SchedulerSystem
];
const SharedRenderPipes = [
  BlendModePipe,
  BatcherPipe,
  SpritePipe,
  RenderGroupPipe,
  AlphaMaskPipe,
  StencilMaskPipe,
  ColorMaskPipe,
  CustomRenderPipe
];

function calculateProjection(pm, x, y, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x * pm.a;
  pm.ty = -sign - y * pm.d;
  return pm;
}

function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}

class RenderTargetSystem {
  constructor(renderer) {
    /** This is the root viewport for the render pass */
    this.rootViewPort = new Rectangle();
    /** the current viewport that the gpu is using */
    this.viewport = new Rectangle();
    /** the current mip level being rendered to (for texture subresources) */
    this.mipLevel = 0;
    /** the current array layer being rendered to (for array-backed targets) */
    this.layer = 0;
    /**
     * a runner that lets systems know if the active render target has changed.
     * Eg the Stencil System needs to know so it can manage the stencil buffer
     */
    this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
    /** the projection matrix that is used by the shaders based on the active render target and the viewport */
    this.projectionMatrix = new Matrix();
    /** the default clear color for render targets */
    this.defaultClearColor = [0, 0, 0, 0];
    /**
     * a hash that stores the render target for a given render surface. When you pass in a texture source,
     * a render target is created for it. This map stores and makes it easy to retrieve the render target
     */
    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
    /** A hash that stores a gpu render target for a given render target. */
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
    /**
     * A stack that stores the render target and frame that is currently being rendered to.
     * When push is called, the current render target is stored in this stack.
     * When pop is called, the previous render target is restored.
     */
    this._renderTargetStack = [];
    this._renderer = renderer;
    renderer.gc.addCollection(this, "_gpuRenderTargetHash", "hash");
  }
  /** called when dev wants to finish a render pass */
  finishRenderPass() {
    this.adaptor.finishRenderPass(this.renderTarget);
  }
  /**
   * called when the renderer starts to render a scene.
   * @param options
   * @param options.target - the render target to render to
   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param options.clearColor - the color to clear to
   * @param options.frame - the frame to render to
   * @param options.mipLevel - the mip level to render to
   * @param options.layer - The layer of the render target to render to. Used for array or 3D textures, or when rendering
   * to a specific layer of a layered render target. Optional.
   */
  renderStart({
    target,
    clear,
    clearColor,
    frame,
    mipLevel,
    layer
  }) {
    this._renderTargetStack.length = 0;
    this.push(
      target,
      clear,
      clearColor,
      frame,
      mipLevel ?? 0,
      layer ?? 0
    );
    this.rootViewPort.copyFrom(this.viewport);
    this.rootRenderTarget = this.renderTarget;
    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
    this.adaptor.prerender?.(this.rootRenderTarget);
  }
  postrender() {
    this.adaptor.postrender?.(this.rootRenderTarget);
  }
  /**
   * Binding a render surface! This is the main function of the render target system.
   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
   * Once bound all draw calls will be rendered to the render surface.
   *
   * If a frame is not provided and the render surface is a {@link Texture}, the frame of the texture will be used.
   *
   * IMPORTANT:
   * - `frame` is treated as **base mip (mip 0) pixel space**.
   * - When `mipLevel > 0`, the viewport derived from `frame` is scaled by \(2^{mipLevel}\) and clamped to the
   *   mip dimensions. This keeps "render the same region" semantics consistent across mip levels.
   * - When `renderSurface` is a {@link Texture}, `renderer.render({ container, target: texture, mipLevel })` will
   *   render into
   *   the underlying {@link TextureSource} (Pixi will create/use a {@link RenderTarget} for the source) using the
   *   texture's frame to define the region (in mip 0 space).
   * @param renderSurface - the render surface to bind
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to render to
   * @param mipLevel - the mip level to render to
   * @param layer - the layer (or slice) of the render surface to render to. For array textures,
   * 3D textures, or cubemaps, this specifies the target layer or face. Defaults to 0 (the first layer/face).
   * Ignored for surfaces that do not support layers.
   * @returns the render target that was bound
   */
  bind(renderSurface, clear = true, clearColor, frame, mipLevel = 0, layer = 0) {
    const renderTarget = this.getRenderTarget(renderSurface);
    const didChange = this.renderTarget !== renderTarget;
    this.renderTarget = renderTarget;
    this.renderSurface = renderSurface;
    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
      this.adaptor.resizeGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.pixelWidth;
      gpuRenderTarget.height = renderTarget.pixelHeight;
    }
    const source = renderTarget.colorTexture;
    const viewport = this.viewport;
    const arrayLayerCount = source.arrayLayerCount || 1;
    if ((layer | 0) !== layer) {
      layer |= 0;
    }
    if (layer < 0 || layer >= arrayLayerCount) {
      throw new Error(`[RenderTargetSystem] layer ${layer} is out of bounds (arrayLayerCount=${arrayLayerCount}).`);
    }
    this.mipLevel = mipLevel | 0;
    this.layer = layer | 0;
    const pixelWidth = Math.max(source.pixelWidth >> mipLevel, 1);
    const pixelHeight = Math.max(source.pixelHeight >> mipLevel, 1);
    if (!frame && renderSurface instanceof Texture) {
      frame = renderSurface.frame;
    }
    if (frame) {
      const resolution = source._resolution;
      const scale = 1 << Math.max(mipLevel | 0, 0);
      const baseX = frame.x * resolution + 0.5 | 0;
      const baseY = frame.y * resolution + 0.5 | 0;
      const baseW = frame.width * resolution + 0.5 | 0;
      const baseH = frame.height * resolution + 0.5 | 0;
      let x = Math.floor(baseX / scale);
      let y = Math.floor(baseY / scale);
      let w = Math.ceil(baseW / scale);
      let h = Math.ceil(baseH / scale);
      x = Math.min(Math.max(x, 0), pixelWidth - 1);
      y = Math.min(Math.max(y, 0), pixelHeight - 1);
      w = Math.min(Math.max(w, 1), pixelWidth - x);
      h = Math.min(Math.max(h, 1), pixelHeight - y);
      viewport.x = x;
      viewport.y = y;
      viewport.width = w;
      viewport.height = h;
    } else {
      viewport.x = 0;
      viewport.y = 0;
      viewport.width = pixelWidth;
      viewport.height = pixelHeight;
    }
    calculateProjection(
      this.projectionMatrix,
      0,
      0,
      viewport.width / source.resolution,
      viewport.height / source.resolution,
      !renderTarget.isRoot
    );
    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);
    if (didChange) {
      this.onRenderTargetChange.emit(renderTarget);
    }
    return renderTarget;
  }
  clear(target, clear = CLEAR.ALL, clearColor, mipLevel = this.mipLevel, layer = this.layer) {
    if (!clear) return;
    if (target) {
      target = this.getRenderTarget(target);
    }
    this.adaptor.clear(
      target || this.renderTarget,
      clear,
      clearColor,
      this.viewport,
      mipLevel,
      layer
    );
  }
  contextChange() {
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  /**
   * Push a render surface to the renderer. This will bind the render surface to the renderer,
   * @param renderSurface - the render surface to push
   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
   * @param clearColor - the color to clear to
   * @param frame - the frame to use when rendering to the render surface
   * @param mipLevel - the mip level to render to
   * @param layer - The layer of the render surface to render to. For array textures or cube maps, this specifies
   * which layer or face to target. Defaults to 0 (the first layer).
   */
  push(renderSurface, clear = CLEAR.ALL, clearColor, frame, mipLevel = 0, layer = 0) {
    const renderTarget = this.bind(renderSurface, clear, clearColor, frame, mipLevel, layer);
    this._renderTargetStack.push({
      renderTarget,
      frame,
      mipLevel,
      layer
    });
    return renderTarget;
  }
  /** Pops the current render target from the renderer and restores the previous render target. */
  pop() {
    this._renderTargetStack.pop();
    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
    this.bind(
      currentRenderTargetData.renderTarget,
      false,
      null,
      currentRenderTargetData.frame,
      currentRenderTargetData.mipLevel,
      currentRenderTargetData.layer
    );
  }
  /**
   * Gets the render target from the provide render surface. Eg if its a texture,
   * it will return the render target for the texture.
   * If its a render target, it will return the same render target.
   * @param renderSurface - the render surface to get the render target for
   * @returns the render target for the render surface
   */
  getRenderTarget(renderSurface) {
    if (renderSurface.isTexture) {
      renderSurface = renderSurface.source;
    }
    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
  }
  /**
   * Copies a render surface to another texture.
   *
   * NOTE:
   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer
   *
   * The following is not valid:
   * @example
   * const canvas = document.createElement('canvas')
   * canvas.width = 200;
   * canvas.height = 200;
   *
   * const ctx = canvas2.getContext('2d')!
   * ctx.fillStyle = 'red'
   * ctx.fillRect(0, 0, 200, 200);
   *
   * const texture = RenderTexture.create({
   *   width: 200,
   *   height: 200,
   * })
   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);
   *
   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});
   *
   * The best way to copy a canvas is to create a texture from it. Then render with that.
   *
   * Parsing in a RenderTarget canvas context (with a 2d context)
   * @param sourceRenderSurfaceTexture - the render surface to copy from
   * @param {Texture} destinationTexture - the texture to copy to
   * @param {object} originSrc - the origin of the copy
   * @param {number} originSrc.x - the x origin of the copy
   * @param {number} originSrc.y - the y origin of the copy
   * @param {object} size - the size of the copy
   * @param {number} size.width - the width of the copy
   * @param {number} size.height - the height of the copy
   * @param {object} originDest - the destination origin (top left to paste from!)
   * @param {number} originDest.x - the x origin of the paste
   * @param {number} originDest.y - the y origin of the paste
   */
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    if (originSrc.x < 0) {
      size.width += originSrc.x;
      originDest.x -= originSrc.x;
      originSrc.x = 0;
    }
    if (originSrc.y < 0) {
      size.height += originSrc.y;
      originDest.y -= originSrc.y;
      originSrc.y = 0;
    }
    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
    size.width = Math.min(size.width, pixelWidth - originSrc.x);
    size.height = Math.min(size.height, pixelHeight - originSrc.y);
    return this.adaptor.copyToTexture(
      sourceRenderSurfaceTexture,
      destinationTexture,
      originSrc,
      size,
      originDest
    );
  }
  /**
   * ensures that we have a depth stencil buffer available to render to
   * This is used by the mask system to make sure we have a stencil buffer.
   */
  ensureDepthStencil() {
    if (!this.renderTarget.stencil) {
      this.renderTarget.stencil = true;
      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport, 0, this.layer);
    }
  }
  /** nukes the render target system */
  destroy() {
    this._renderer = null;
    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
      if (renderTarget !== key) {
        renderTarget.destroy();
      }
    });
    this._renderSurfaceToRenderTargetHash.clear();
    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
  }
  _initRenderTarget(renderSurface) {
    let renderTarget = null;
    if (CanvasSource.test(renderSurface)) {
      renderSurface = getCanvasTexture(renderSurface).source;
    }
    if (renderSurface instanceof RenderTarget) {
      renderTarget = renderSurface;
    } else if (renderSurface instanceof TextureSource) {
      renderTarget = new RenderTarget({
        colorTextures: [renderSurface]
      });
      if (renderSurface.source instanceof CanvasSource) {
        renderTarget.isRoot = true;
      }
      renderSurface.once("destroy", () => {
        renderTarget.destroy();
        this._renderSurfaceToRenderTargetHash.delete(renderSurface);
        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
        if (gpuRenderTarget) {
          this._gpuRenderTargetHash[renderTarget.uid] = null;
          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
        }
      });
    }
    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
    return renderTarget;
  }
  getGpuRenderTarget(renderTarget) {
    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
  }
  resetState() {
    this.renderTarget = null;
    this.renderSurface = null;
  }
}

class CanvasRenderTargetAdaptor {
  /**
   * Initializes the adaptor.
   * @param renderer - Canvas renderer instance.
   * @param renderTargetSystem - The render target system.
   * @advanced
   */
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
  }
  /**
   * Creates a GPU render target for canvas.
   * @param renderTarget - Render target to initialize.
   * @advanced
   */
  initGpuRenderTarget(renderTarget) {
    const colorTexture = renderTarget.colorTexture;
    const { canvas, context } = this._ensureCanvas(colorTexture);
    return {
      canvas,
      context,
      width: canvas.width,
      height: canvas.height
    };
  }
  /**
   * Resizes the backing canvas for a render target.
   * @param renderTarget - Render target to resize.
   * @advanced
   */
  resizeGpuRenderTarget(renderTarget) {
    const colorTexture = renderTarget.colorTexture;
    const { canvas } = this._ensureCanvas(colorTexture);
    canvas.width = renderTarget.pixelWidth;
    canvas.height = renderTarget.pixelHeight;
  }
  /**
   * Starts a render pass on the canvas target.
   * @param renderTarget - Target to render to.
   * @param clear - Clear mode.
   * @param clearColor - Optional clear color.
   * @param viewport - Optional viewport.
   * @advanced
   */
  startRenderPass(renderTarget, clear, clearColor, viewport) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    this._renderer.canvasContext.activeContext = gpuRenderTarget.context;
    this._renderer.canvasContext.activeResolution = renderTarget.resolution;
    if (clear) {
      this.clear(renderTarget, clear, clearColor, viewport);
    }
  }
  /**
   * Clears the render target.
   * @param renderTarget - Target to clear.
   * @param _clear - Clear mode (unused).
   * @param clearColor - Optional clear color.
   * @param viewport - Optional viewport rectangle.
   * @advanced
   */
  clear(renderTarget, _clear, clearColor, viewport) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    const context = gpuRenderTarget.context;
    const bounds = viewport || { x: 0, y: 0, width: renderTarget.pixelWidth, height: renderTarget.pixelHeight };
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
    if (clearColor) {
      const color = Color.shared.setValue(clearColor);
      if (color.alpha > 0) {
        context.globalAlpha = color.alpha;
        context.fillStyle = color.toHex();
        context.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
        context.globalAlpha = 1;
      }
    }
  }
  /**
   * Finishes the render pass (no-op for canvas).
   * @advanced
   */
  finishRenderPass() {
  }
  /**
   * Copies a render target into a texture source.
   * @param {RenderTarget} sourceRenderSurfaceTexture - Source render target.
   * @param {Texture} destinationTexture - Destination texture.
   * @param {object} originSrc - Source origin.
   * @param {number} originSrc.x - Source x origin.
   * @param {number} originSrc.y - Source y origin.
   * @param {object} size - Copy size.
   * @param {number} size.width - Copy width.
   * @param {number} size.height - Copy height.
   * @param {object} [originDest] - Destination origin.
   * @param {number} originDest.x - Destination x origin.
   * @param {number} originDest.y - Destination y origin.
   * @advanced
   */
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const sourceGpuTarget = this._renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
    const sourceCanvas = sourceGpuTarget.canvas;
    const destSource = destinationTexture.source;
    const { context } = this._ensureCanvas(destSource);
    const dx = originDest?.x ?? 0;
    const dy = originDest?.y ?? 0;
    context.drawImage(
      sourceCanvas,
      originSrc.x,
      originSrc.y,
      size.width,
      size.height,
      dx,
      dy,
      size.width,
      size.height
    );
    destSource.update();
    return destinationTexture;
  }
  /**
   * Destroys a GPU render target (no-op for canvas).
   * @param _gpuRenderTarget - Target to destroy.
   * @advanced
   */
  destroyGpuRenderTarget(_gpuRenderTarget) {
  }
  _ensureCanvas(source) {
    let canvas = source.resource;
    if (!canvas || !CanvasSource.test(canvas)) {
      canvas = DOMAdapter.get().createCanvas(source.pixelWidth, source.pixelHeight);
      source.resource = canvas;
    }
    if (canvas.width !== source.pixelWidth || canvas.height !== source.pixelHeight) {
      canvas.width = source.pixelWidth;
      canvas.height = source.pixelHeight;
    }
    const context = canvas.getContext("2d");
    return { canvas, context };
  }
}

class CanvasRenderTargetSystem extends RenderTargetSystem {
  constructor(renderer) {
    super(renderer);
    this.adaptor = new CanvasRenderTargetAdaptor();
    this.adaptor.init(renderer, this);
  }
}
/** @ignore */
CanvasRenderTargetSystem.extension = {
  type: [ExtensionType.CanvasSystem],
  name: "renderTarget"
};

class CanvasTextureSystem {
  /**
   * @param renderer - The owning CanvasRenderer.
   */
  constructor(renderer) {
  }
  /** Initializes the system (no-op for canvas). */
  init() {
  }
  /**
   * Initializes a texture source (no-op for canvas).
   * @param _source - Texture source.
   */
  initSource(_source) {
  }
  /**
   * Creates a canvas containing the texture's frame.
   * @param texture - Texture to render.
   */
  generateCanvas(texture) {
    const canvas = DOMAdapter.get().createCanvas();
    const context = canvas.getContext("2d");
    const source = canvasUtils.getCanvasSource(texture);
    if (!source) {
      return canvas;
    }
    const frame = texture.frame;
    const resolution = texture.source._resolution ?? texture.source.resolution ?? 1;
    const sx = frame.x * resolution;
    const sy = frame.y * resolution;
    const sw = frame.width * resolution;
    const sh = frame.height * resolution;
    canvas.width = Math.ceil(sw);
    canvas.height = Math.ceil(sh);
    context.drawImage(
      source,
      sx,
      sy,
      sw,
      sh,
      0,
      0,
      sw,
      sh
    );
    return canvas;
  }
  /**
   * Reads pixel data from a texture.
   * @param texture - Texture to read.
   */
  getPixels(texture) {
    const canvas = this.generateCanvas(texture);
    const context = canvas.getContext("2d", { willReadFrequently: true });
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    return {
      pixels: imageData.data,
      width: canvas.width,
      height: canvas.height
    };
  }
  /** Destroys the system (no-op for canvas). */
  destroy() {
  }
}
/** @ignore */
CanvasTextureSystem.extension = {
  type: [
    ExtensionType.CanvasSystem
  ],
  name: "texture"
};

const DefaultCanvasSystems = [
  ...SharedSystems,
  CanvasContextSystem,
  CanvasLimitsSystem,
  CanvasTextureSystem,
  CanvasRenderTargetSystem
];
const DefaultCanvasPipes = [
  BlendModePipe,
  BatcherPipe,
  SpritePipe,
  RenderGroupPipe,
  AlphaMaskPipe,
  CanvasStencilMaskPipe,
  CanvasColorMaskPipe,
  CustomRenderPipe
];
const DefaultCanvasAdapters = [
  CanvasBatchAdaptor,
  CanvasGraphicsAdaptor
];
const systems$2 = [];
const renderPipes$2 = [];
const renderPipeAdaptors$2 = [];
extensions.handleByNamedList(ExtensionType.CanvasSystem, systems$2);
extensions.handleByNamedList(ExtensionType.CanvasPipes, renderPipes$2);
extensions.handleByNamedList(ExtensionType.CanvasPipesAdaptor, renderPipeAdaptors$2);
extensions.add(...DefaultCanvasSystems, ...DefaultCanvasPipes, ...DefaultCanvasAdapters);
class CanvasRenderer extends AbstractRenderer {
  constructor() {
    const systemConfig = {
      name: "canvas",
      type: RendererType.CANVAS,
      systems: systems$2,
      renderPipes: renderPipes$2,
      renderPipeAdaptors: renderPipeAdaptors$2
    };
    super(systemConfig);
  }
}

var CanvasRenderer$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CanvasRenderer: CanvasRenderer
});

var BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
  BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
  return BUFFER_TYPE2;
})(BUFFER_TYPE || {});

class GlBuffer {
  constructor(buffer, type) {
    this._lastBindBaseLocation = -1;
    this._lastBindCallId = -1;
    this.buffer = buffer || null;
    this.updateID = -1;
    this.byteLength = -1;
    this.type = type;
  }
  destroy() {
    this.buffer = null;
    this.updateID = -1;
    this.byteLength = -1;
    this.type = -1;
    this._lastBindBaseLocation = -1;
    this._lastBindCallId = -1;
  }
}

class GlBufferSystem {
  /**
   * @param {Renderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    /** Cache keeping track of the base bound buffer bases */
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
    this._minBaseLocation = 0;
    this._nextBindBaseIndex = this._minBaseLocation;
    this._bindCallId = 0;
    this._renderer = renderer;
    this._managedBuffers = new GCManagedHash({
      renderer,
      type: "resource",
      onUnload: this.onBufferUnload.bind(this),
      name: "glBuffer"
    });
  }
  /** @ignore */
  destroy() {
    this._managedBuffers.destroy();
    this._renderer = null;
    this._gl = null;
    this._boundBufferBases = {};
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    this._gl = this._renderer.gl;
    this.destroyAll(true);
    this._maxBindings = this._renderer.limits.maxUniformBindings;
  }
  getGlBuffer(buffer) {
    buffer._gcLastUsed = this._renderer.gc.now;
    return buffer._gpuData[this._renderer.uid] || this.createGLBuffer(buffer);
  }
  /**
   * This binds specified buffer. On first run, it will create the webGL buffers for the context too
   * @param buffer - the buffer to bind to the renderer
   */
  bind(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
  }
  /**
   * Binds an uniform buffer to at the given index.
   *
   * A cache is used so a buffer will not be bound again if already bound.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind it to.
   */
  bindBufferBase(glBuffer, index) {
    const { _gl: gl } = this;
    if (this._boundBufferBases[index] !== glBuffer) {
      this._boundBufferBases[index] = glBuffer;
      glBuffer._lastBindBaseLocation = index;
      gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
    }
  }
  nextBindBase(hasTransformFeedback) {
    this._bindCallId++;
    this._minBaseLocation = 0;
    if (hasTransformFeedback) {
      this._boundBufferBases[0] = null;
      this._minBaseLocation = 1;
      if (this._nextBindBaseIndex < 1) {
        this._nextBindBaseIndex = 1;
      }
    }
  }
  freeLocationForBufferBase(glBuffer) {
    let freeIndex = this.getLastBindBaseLocation(glBuffer);
    if (freeIndex >= this._minBaseLocation) {
      glBuffer._lastBindCallId = this._bindCallId;
      return freeIndex;
    }
    let loop = 0;
    let nextIndex = this._nextBindBaseIndex;
    while (loop < 2) {
      if (nextIndex >= this._maxBindings) {
        nextIndex = this._minBaseLocation;
        loop++;
      }
      const curBuf = this._boundBufferBases[nextIndex];
      if (curBuf && curBuf._lastBindCallId === this._bindCallId) {
        nextIndex++;
        continue;
      }
      break;
    }
    freeIndex = nextIndex;
    this._nextBindBaseIndex = nextIndex + 1;
    if (loop >= 2) {
      return -1;
    }
    glBuffer._lastBindCallId = this._bindCallId;
    this._boundBufferBases[freeIndex] = null;
    return freeIndex;
  }
  getLastBindBaseLocation(glBuffer) {
    const index = glBuffer._lastBindBaseLocation;
    if (this._boundBufferBases[index] === glBuffer) {
      return index;
    }
    return -1;
  }
  /**
   * Binds a buffer whilst also binding its range.
   * This will make the buffer start from the offset supplied rather than 0 when it is read.
   * @param glBuffer - the buffer to bind
   * @param index - the base index to bind at, defaults to 0
   * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
   * @param size - the size to bind at (this is blocks of 256).
   */
  bindBufferRange(glBuffer, index, offset, size) {
    const { _gl: gl } = this;
    offset || (offset = 0);
    index || (index = 0);
    this._boundBufferBases[index] = null;
    gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);
  }
  /**
   * Will ensure the data in the buffer is uploaded to the GPU.
   * @param {Buffer} buffer - the buffer to update
   */
  updateBuffer(buffer) {
    const { _gl: gl } = this;
    const glBuffer = this.getGlBuffer(buffer);
    if (buffer._updateID === glBuffer.updateID) {
      return glBuffer;
    }
    glBuffer.updateID = buffer._updateID;
    gl.bindBuffer(glBuffer.type, glBuffer.buffer);
    const data = buffer.data;
    const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
    if (data) {
      if (glBuffer.byteLength >= data.byteLength) {
        gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
      } else {
        glBuffer.byteLength = data.byteLength;
        gl.bufferData(glBuffer.type, data, drawType);
      }
    } else {
      glBuffer.byteLength = buffer.descriptor.size;
      gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);
    }
    return glBuffer;
  }
  /**
   * dispose all WebGL resources of all managed buffers
   * @param contextLost
   */
  destroyAll(contextLost = false) {
    this._managedBuffers.removeAll(contextLost);
  }
  onBufferUnload(buffer, contextLost = false) {
    const glBuffer = buffer._gpuData[this._renderer.uid];
    if (!glBuffer) return;
    if (!contextLost) this._gl.deleteBuffer(glBuffer.buffer);
  }
  /**
   * creates and attaches a GLBuffer object tied to the current context.
   * @param buffer
   * @protected
   */
  createGLBuffer(buffer) {
    const { _gl: gl } = this;
    let type = BUFFER_TYPE.ARRAY_BUFFER;
    if (buffer.descriptor.usage & BufferUsage.INDEX) {
      type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
    } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
      type = BUFFER_TYPE.UNIFORM_BUFFER;
    }
    const glBuffer = new GlBuffer(gl.createBuffer(), type);
    buffer._gpuData[this._renderer.uid] = glBuffer;
    this._managedBuffers.add(buffer);
    return glBuffer;
  }
  resetState() {
    this._boundBufferBases = /* @__PURE__ */ Object.create(null);
  }
}
/** @ignore */
GlBufferSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "buffer"
};

const _GlContextSystem = class _GlContextSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    /**
     * Features supported by current renderer.
     * @type {object}
     * @readonly
     */
    this.supports = {
      /** Support for 32-bit indices buffer. */
      uint32Indices: true,
      /** Support for UniformBufferObjects */
      uniformBufferObject: true,
      /** Support for VertexArrayObjects */
      vertexArrayObject: true,
      /** Support for SRGB texture format */
      srgbTextures: true,
      /** Support for wrapping modes if a texture is non-power of two */
      nonPowOf2wrapping: true,
      /** Support for MSAA (antialiasing of dynamic textures) */
      msaa: true,
      /** Support for mipmaps if a texture is non-power of two */
      nonPowOf2mipmaps: true
    };
    this._renderer = renderer;
    this.extensions = /* @__PURE__ */ Object.create(null);
    this.handleContextLost = this.handleContextLost.bind(this);
    this.handleContextRestored = this.handleContextRestored.bind(this);
  }
  /**
   * `true` if the context is lost
   * @readonly
   */
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  /**
   * Handles the context change event.
   * @param {WebGLRenderingContext} gl - New WebGL context.
   */
  contextChange(gl) {
    this.gl = gl;
    this._renderer.gl = gl;
  }
  init(options) {
    options = { ..._GlContextSystem.defaultOptions, ...options };
    let multiView = this.multiView = options.multiView;
    if (options.context && multiView) {
      warn$2("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.");
      multiView = false;
    }
    if (multiView) {
      this.canvas = DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);
    } else {
      this.canvas = this._renderer.view.canvas;
    }
    if (options.context) {
      this.initFromContext(options.context);
    } else {
      const alpha = this._renderer.background.alpha < 1;
      const premultipliedAlpha = options.premultipliedAlpha ?? true;
      const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
      this.createContext(options.preferWebGLVersion, {
        alpha,
        premultipliedAlpha,
        antialias,
        stencil: true,
        preserveDrawingBuffer: options.preserveDrawingBuffer,
        powerPreference: options.powerPreference ?? "default"
      });
    }
  }
  ensureCanvasSize(targetCanvas) {
    if (!this.multiView) {
      if (targetCanvas !== this.canvas) {
        warn$2("multiView is disabled, but targetCanvas is not the main canvas");
      }
      return;
    }
    const { canvas } = this;
    if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
      canvas.width = Math.max(targetCanvas.width, targetCanvas.width);
      canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
    }
  }
  /**
   * Initializes the context.
   * @protected
   * @param {WebGLRenderingContext} gl - WebGL context
   */
  initFromContext(gl) {
    this.gl = gl;
    this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
    this.getExtensions();
    this.validateContext(gl);
    this._renderer.runners.contextChange.emit(gl);
    const element = this._renderer.view.canvas;
    element.addEventListener("webglcontextlost", this.handleContextLost, false);
    element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
  }
  /**
   * Initialize from context options
   * @protected
   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
   * @param preferWebGLVersion
   * @param {object} options - context attributes
   */
  createContext(preferWebGLVersion, options) {
    let gl;
    const canvas = this.canvas;
    if (preferWebGLVersion === 2) {
      gl = canvas.getContext("webgl2", options);
    }
    if (!gl) {
      gl = canvas.getContext("webgl", options);
      if (!gl) {
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      }
    }
    this.gl = gl;
    this.initFromContext(this.gl);
  }
  /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
  getExtensions() {
    const { gl } = this;
    const common = {
      anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
      floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
      s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
      s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
      // eslint-disable-line camelcase
      etc: gl.getExtension("WEBGL_compressed_texture_etc"),
      etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
      pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      atc: gl.getExtension("WEBGL_compressed_texture_atc"),
      astc: gl.getExtension("WEBGL_compressed_texture_astc"),
      bptc: gl.getExtension("EXT_texture_compression_bptc"),
      rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
      loseContext: gl.getExtension("WEBGL_lose_context")
    };
    if (this.webGLVersion === 1) {
      this.extensions = {
        ...common,
        drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
        depthTexture: gl.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: gl.getExtension("OES_texture_float"),
        floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
        textureHalfFloat: gl.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
        vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
        srgb: gl.getExtension("EXT_sRGB")
      };
    } else {
      this.extensions = {
        ...common,
        colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
      };
      const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
      if (provokeExt) {
        provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
  }
  /**
   * Handles a lost webgl context
   * @param {WebGLContextEvent} event - The context lost event.
   */
  handleContextLost(event) {
    event.preventDefault();
    if (this._contextLossForced) {
      this._contextLossForced = false;
      setTimeout(() => {
        if (this.gl.isContextLost()) {
          this.extensions.loseContext?.restoreContext();
        }
      }, 0);
    }
  }
  /** Handles a restored webgl context. */
  handleContextRestored() {
    this.getExtensions();
    this._renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const element = this._renderer.view.canvas;
    this._renderer = null;
    element.removeEventListener("webglcontextlost", this.handleContextLost);
    element.removeEventListener("webglcontextrestored", this.handleContextRestored);
    this.gl.useProgram(null);
    this.extensions.loseContext?.loseContext();
  }
  /**
   * this function can be called to force a webGL context loss
   * this will release all resources on the GPU.
   * Useful if you need to put Pixi to sleep, and save some GPU memory
   *
   * As soon as render is called - all resources will be created again.
   */
  forceContextLoss() {
    this.extensions.loseContext?.loseContext();
    this._contextLossForced = true;
  }
  /**
   * Validate context.
   * @param {WebGLRenderingContext} gl - Render context.
   */
  validateContext(gl) {
    const attributes = gl.getContextAttributes();
    if (attributes && !attributes.stencil) {
      warn$2("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
    }
    const supports = this.supports;
    const isWebGl2 = this.webGLVersion === 2;
    const extensions = this.extensions;
    supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;
    supports.uniformBufferObject = isWebGl2;
    supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;
    supports.srgbTextures = isWebGl2 || !!extensions.srgb;
    supports.nonPowOf2wrapping = isWebGl2;
    supports.nonPowOf2mipmaps = isWebGl2;
    supports.msaa = isWebGl2;
    if (!supports.uint32Indices) {
      warn$2("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  }
};
/** @ignore */
_GlContextSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "context"
};
/** The default options for the system. */
_GlContextSystem.defaultOptions = {
  /**
   * {@link WebGLOptions.context}
   * @default null
   */
  context: null,
  /**
   * {@link WebGLOptions.premultipliedAlpha}
   * @default true
   */
  premultipliedAlpha: true,
  /**
   * {@link WebGLOptions.preserveDrawingBuffer}
   * @default false
   */
  preserveDrawingBuffer: false,
  /**
   * {@link WebGLOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * {@link WebGLOptions.webGLVersion}
   * @default 2
   */
  preferWebGLVersion: 2,
  /**
   * {@link WebGLOptions.multiView}
   * @default false
   */
  multiView: false
};
let GlContextSystem = _GlContextSystem;

function ensureAttributes(geometry, extractedData) {
  for (const i in geometry.attributes) {
    const attribute = geometry.attributes[i];
    const attributeData = extractedData[i];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      warn$2(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j in buffers) {
    const buffer = buffers[j];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j in attributes) {
    const attribute = attributes[j];
    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
  for (const j in attributes) {
    const attribute = attributes[j];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
}

var GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
  GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
  GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
  GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
  GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
  GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
  GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
  GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
  GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
  GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
  GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
  return GL_FORMATS2;
})(GL_FORMATS || {});
var GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
  GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
  return GL_TARGETS2;
})(GL_TARGETS || {});
var GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
  GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
  GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
  GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
  GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
  GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
  GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
  GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
  GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
  GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
  return GL_TYPES2;
})(GL_TYPES || {});

const infoMap = {
  uint8x2: GL_TYPES.UNSIGNED_BYTE,
  uint8x4: GL_TYPES.UNSIGNED_BYTE,
  sint8x2: GL_TYPES.BYTE,
  sint8x4: GL_TYPES.BYTE,
  unorm8x2: GL_TYPES.UNSIGNED_BYTE,
  unorm8x4: GL_TYPES.UNSIGNED_BYTE,
  snorm8x2: GL_TYPES.BYTE,
  snorm8x4: GL_TYPES.BYTE,
  uint16x2: GL_TYPES.UNSIGNED_SHORT,
  uint16x4: GL_TYPES.UNSIGNED_SHORT,
  sint16x2: GL_TYPES.SHORT,
  sint16x4: GL_TYPES.SHORT,
  unorm16x2: GL_TYPES.UNSIGNED_SHORT,
  unorm16x4: GL_TYPES.UNSIGNED_SHORT,
  snorm16x2: GL_TYPES.SHORT,
  snorm16x4: GL_TYPES.SHORT,
  float16x2: GL_TYPES.HALF_FLOAT,
  float16x4: GL_TYPES.HALF_FLOAT,
  float32: GL_TYPES.FLOAT,
  float32x2: GL_TYPES.FLOAT,
  float32x3: GL_TYPES.FLOAT,
  float32x4: GL_TYPES.FLOAT,
  uint32: GL_TYPES.UNSIGNED_INT,
  uint32x2: GL_TYPES.UNSIGNED_INT,
  uint32x3: GL_TYPES.UNSIGNED_INT,
  uint32x4: GL_TYPES.UNSIGNED_INT,
  sint32: GL_TYPES.INT,
  sint32x2: GL_TYPES.INT,
  sint32x3: GL_TYPES.INT,
  sint32x4: GL_TYPES.INT
};
function getGlTypeFromFormat(format) {
  return infoMap[format] ?? infoMap.float32;
}

const topologyToGlMap = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 3,
  "triangle-list": 4,
  "triangle-strip": 5
};
class GlGeometryGpuData {
  constructor() {
    this.vaoCache = /* @__PURE__ */ Object.create(null);
  }
  destroy() {
    this.vaoCache = /* @__PURE__ */ Object.create(null);
  }
}
class GlGeometrySystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    this._renderer = renderer;
    this._activeGeometry = null;
    this._activeVao = null;
    this.hasVao = true;
    this.hasInstance = true;
    this._managedGeometries = new GCManagedHash({
      renderer,
      type: "resource",
      onUnload: this.onGeometryUnload.bind(this),
      name: "glGeometry"
    });
  }
  /** Sets up the renderer context and necessary buffers. */
  contextChange() {
    const gl = this.gl = this._renderer.gl;
    if (!this._renderer.context.supports.vertexArrayObject) {
      throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
    }
    this.destroyAll(true);
    const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
    if (nativeVaoExtension) {
      gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
      gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
      gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
    }
    const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
    if (nativeInstancedExtension) {
      gl.drawArraysInstanced = (a, b, c, d) => {
        nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);
      };
      gl.drawElementsInstanced = (a, b, c, d, e) => {
        nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);
      };
      gl.vertexAttribDivisor = (a, b) => nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);
    }
    this._activeGeometry = null;
    this._activeVao = null;
  }
  /**
   * Binds geometry so that is can be drawn. Creating a Vao if required
   * @param geometry - Instance of geometry to bind.
   * @param program - Instance of program to use vao for.
   */
  bind(geometry, program) {
    const gl = this.gl;
    this._activeGeometry = geometry;
    const vao = this.getVao(geometry, program);
    if (this._activeVao !== vao) {
      this._activeVao = vao;
      gl.bindVertexArray(vao);
    }
    this.updateBuffers();
  }
  /** Reset and unbind any active VAO and geometry. */
  resetState() {
    this.unbind();
  }
  /** Update buffers of the currently bound geometry. */
  updateBuffers() {
    const geometry = this._activeGeometry;
    const bufferSystem = this._renderer.buffer;
    for (let i = 0; i < geometry.buffers.length; i++) {
      const buffer = geometry.buffers[i];
      bufferSystem.updateBuffer(buffer);
    }
    geometry._gcLastUsed = this._renderer.gc.now;
  }
  /**
   * Check compatibility between a geometry and a program
   * @param geometry - Geometry instance.
   * @param program - Program instance.
   */
  checkCompatibility(geometry, program) {
    const geometryAttributes = geometry.attributes;
    const shaderAttributes = program._attributeData;
    for (const j in shaderAttributes) {
      if (!geometryAttributes[j]) {
        throw new Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
      }
    }
  }
  /**
   * Takes a geometry and program and generates a unique signature for them.
   * @param geometry - To get signature from.
   * @param program - To test geometry against.
   * @returns - Unique signature of the geometry and program
   */
  getSignature(geometry, program) {
    const attribs = geometry.attributes;
    const shaderAttributes = program._attributeData;
    const strings = ["g", geometry.uid];
    for (const i in attribs) {
      if (shaderAttributes[i]) {
        strings.push(i, shaderAttributes[i].location);
      }
    }
    return strings.join("-");
  }
  getVao(geometry, program) {
    return geometry._gpuData[this._renderer.uid]?.vaoCache[program._key] || this.initGeometryVao(geometry, program);
  }
  /**
   * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
   * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
   * attribute locations.
   * @param geometry - Instance of geometry to to generate Vao for.
   * @param program
   * @param _incRefCount - Increment refCount of all geometry buffers.
   */
  initGeometryVao(geometry, program, _incRefCount = true) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    this._renderer.shader._getProgramData(program);
    this.checkCompatibility(geometry, program);
    const signature = this.getSignature(geometry, program);
    let gpuData = geometry._gpuData[this._renderer.uid];
    if (!gpuData) {
      gpuData = new GlGeometryGpuData();
      geometry._gpuData[this._renderer.uid] = gpuData;
      this._managedGeometries.add(geometry);
    }
    const vaoObjectHash = gpuData.vaoCache;
    let vao = vaoObjectHash[signature];
    if (vao) {
      vaoObjectHash[program._key] = vao;
      return vao;
    }
    ensureAttributes(geometry, program._attributeData);
    const buffers = geometry.buffers;
    vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    for (let i = 0; i < buffers.length; i++) {
      const buffer = buffers[i];
      bufferSystem.bind(buffer);
    }
    this.activateVao(geometry, program);
    vaoObjectHash[program._key] = vao;
    vaoObjectHash[signature] = vao;
    gl.bindVertexArray(null);
    return vao;
  }
  onGeometryUnload(geometry, contextLost = false) {
    const gpuData = geometry._gpuData[this._renderer.uid];
    if (!gpuData) return;
    const vaoCache = gpuData.vaoCache;
    if (!contextLost) {
      for (const i in vaoCache) {
        if (this._activeVao !== vaoCache[i]) {
          this.resetState();
        }
        this.gl.deleteVertexArray(vaoCache[i]);
      }
    }
  }
  /**
   * Dispose all WebGL resources of all managed geometries.
   * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
   */
  destroyAll(contextLost = false) {
    this._managedGeometries.removeAll(contextLost);
  }
  /**
   * Activate vertex array object.
   * @param geometry - Geometry instance.
   * @param program - Shader program instance.
   */
  activateVao(geometry, program) {
    const gl = this._renderer.gl;
    const bufferSystem = this._renderer.buffer;
    const attributes = geometry.attributes;
    if (geometry.indexBuffer) {
      bufferSystem.bind(geometry.indexBuffer);
    }
    let lastBuffer = null;
    for (const j in attributes) {
      const attribute = attributes[j];
      const buffer = attribute.buffer;
      const glBuffer = bufferSystem.getGlBuffer(buffer);
      const programAttrib = program._attributeData[j];
      if (programAttrib) {
        if (lastBuffer !== glBuffer) {
          bufferSystem.bind(buffer);
          lastBuffer = glBuffer;
        }
        const location = programAttrib.location;
        gl.enableVertexAttribArray(location);
        const attributeInfo = getAttributeInfoFromFormat(attribute.format);
        const type = getGlTypeFromFormat(attribute.format);
        if (programAttrib.format?.substring(1, 4) === "int") {
          gl.vertexAttribIPointer(
            location,
            attributeInfo.size,
            type,
            attribute.stride,
            attribute.offset
          );
        } else {
          gl.vertexAttribPointer(
            location,
            attributeInfo.size,
            type,
            attributeInfo.normalised,
            attribute.stride,
            attribute.offset
          );
        }
        if (attribute.instance) {
          if (this.hasInstance) {
            const divisor = attribute.divisor ?? 1;
            gl.vertexAttribDivisor(location, divisor);
          } else {
            throw new Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
  }
  /**
   * Draws the currently bound geometry.
   * @param topology - The type primitive to render.
   * @param size - The number of elements to be rendered. If not specified, all vertices after the
   *  starting vertex will be drawn.
   * @param start - The starting vertex in the geometry to start drawing from. If not specified,
   *  drawing will start from the first vertex.
   * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
   *  all instances will be drawn.
   * @returns This instance of the geometry system.
   */
  draw(topology, size, start, instanceCount) {
    const { gl } = this._renderer;
    const geometry = this._activeGeometry;
    const glTopology = topologyToGlMap[topology || geometry.topology];
    instanceCount ?? (instanceCount = geometry.instanceCount);
    if (geometry.indexBuffer) {
      const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
      const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
      if (instanceCount !== 1) {
        gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);
      } else {
        gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);
      }
    } else if (instanceCount !== 1) {
      gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);
    } else {
      gl.drawArrays(glTopology, start || 0, size || geometry.getSize());
    }
    return this;
  }
  /** Unbind/reset everything. */
  unbind() {
    this.gl.bindVertexArray(null);
    this._activeVao = null;
    this._activeGeometry = null;
  }
  destroy() {
    this._managedGeometries.destroy();
    this._renderer = null;
    this.gl = null;
    this._activeVao = null;
    this._activeGeometry = null;
  }
}
/** @ignore */
GlGeometrySystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "geometry"
};

const bigTriangleGeometry = new Geometry({
  attributes: {
    aPosition: [
      -1,
      -1,
      // Bottom left corner
      3,
      -1,
      // Bottom right corner, extending beyond right edge
      -1,
      3
      // Top left corner, extending beyond top edge
    ]
  }
});
const _GlBackBufferSystem = class _GlBackBufferSystem {
  constructor(renderer) {
    /** if true, the back buffer is used */
    this.useBackBuffer = false;
    this._useBackBufferThisRender = false;
    this._renderer = renderer;
  }
  init(options = {}) {
    const { useBackBuffer, antialias } = { ..._GlBackBufferSystem.defaultOptions, ...options };
    this.useBackBuffer = useBackBuffer;
    this._antialias = antialias;
    if (!this._renderer.context.supports.msaa) {
      warn$2("antialiasing, is not supported on when using the back buffer");
      this._antialias = false;
    }
    this._state = State.for2d();
    const bigTriangleProgram = new GlProgram({
      vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
      fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
      name: "big-triangle"
    });
    this._bigTriangleShader = new Shader({
      glProgram: bigTriangleProgram,
      resources: {
        uTexture: Texture.WHITE.source
      }
    });
  }
  /**
   * This is called before the RenderTargetSystem is started. This is where
   * we replace the target with the back buffer if required.
   * @param options - The options for this render.
   */
  renderStart(options) {
    const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
    this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
    if (this._useBackBufferThisRender) {
      const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
      this._targetTexture = renderTarget2.colorTexture;
      options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
    }
  }
  renderEnd() {
    this._presentBackBuffer();
  }
  _presentBackBuffer() {
    const renderer = this._renderer;
    renderer.renderTarget.finishRenderPass();
    if (!this._useBackBufferThisRender) return;
    renderer.renderTarget.bind(this._targetTexture, false);
    this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
    renderer.encoder.draw({
      geometry: bigTriangleGeometry,
      shader: this._bigTriangleShader,
      state: this._state
    });
  }
  _getBackBufferTexture(targetSourceTexture) {
    this._backBufferTexture = this._backBufferTexture || new Texture({
      source: new TextureSource({
        width: targetSourceTexture.width,
        height: targetSourceTexture.height,
        resolution: targetSourceTexture._resolution,
        antialias: this._antialias
      })
    });
    this._backBufferTexture.source.resize(
      targetSourceTexture.width,
      targetSourceTexture.height,
      targetSourceTexture._resolution
    );
    return this._backBufferTexture;
  }
  /** destroys the back buffer */
  destroy() {
    if (this._backBufferTexture) {
      this._backBufferTexture.destroy();
      this._backBufferTexture = null;
    }
  }
};
/** @ignore */
_GlBackBufferSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "backBuffer",
  priority: 1
};
/** default options for the back buffer system */
_GlBackBufferSystem.defaultOptions = {
  /** if true will use the back buffer where required */
  useBackBuffer: false
};
let GlBackBufferSystem = _GlBackBufferSystem;

class GlColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask) return;
    this._colorMaskCache = colorMask;
    this._renderer.gl.colorMask(
      !!(colorMask & 8),
      !!(colorMask & 4),
      !!(colorMask & 2),
      !!(colorMask & 1)
    );
  }
}
/** @ignore */
GlColorMaskSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "colorMask"
};

class GlEncoderSystem {
  constructor(renderer) {
    this.commandFinished = Promise.resolve();
    this._renderer = renderer;
  }
  setGeometry(geometry, shader) {
    this._renderer.geometry.bind(geometry, shader.glProgram);
  }
  finishRenderPass() {
  }
  draw(options) {
    const renderer = this._renderer;
    const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;
    renderer.shader.bind(shader, skipSync);
    renderer.geometry.bind(geometry, renderer.shader._activeProgram);
    if (state) {
      renderer.state.set(state);
    }
    renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);
  }
  destroy() {
    this._renderer = null;
  }
}
/** @ignore */
GlEncoderSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "encoder"
};

class GlLimitsSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  contextChange() {
    const gl = this._renderer.gl;
    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);
    const isWebGl2 = this._renderer.context.webGLVersion === 2;
    this.maxUniformBindings = isWebGl2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  }
  destroy() {
  }
}
/** @ignore */
GlLimitsSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "limits"
};

class GlRenderTarget {
  constructor() {
    this.width = -1;
    this.height = -1;
    this.msaa = false;
    /**
     * Tracks which mip level is currently attached to this render target's framebuffer.
     * This lets us skip redundant framebufferTexture2D calls on the common path.
     * @internal
     */
    this._attachedMipLevel = 0;
    /**
     * Tracks which array layer (or cube face index) is currently attached to this render target's framebuffer.
     * For non-array 2D textures this will always be 0.
     * @internal
     */
    this._attachedLayer = 0;
    this.msaaRenderBuffer = [];
  }
}

const GpuStencilModesToPixi = [];
GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
  stencilWriteMask: 0,
  stencilReadMask: 0
};
GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
  stencilFront: {
    compare: "equal",
    passOp: "increment-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "increment-clamp"
  }
};
GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
  stencilFront: {
    compare: "equal",
    passOp: "decrement-clamp"
  },
  stencilBack: {
    compare: "equal",
    passOp: "decrement-clamp"
  }
};
GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "equal",
    passOp: "keep"
  }
};
GpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {
  stencilWriteMask: 0,
  stencilFront: {
    compare: "not-equal",
    passOp: "keep"
  },
  stencilBack: {
    compare: "not-equal",
    passOp: "keep"
  }
};

class GlStencilSystem {
  constructor(renderer) {
    this._stencilCache = {
      enabled: false,
      stencilReference: 0,
      stencilMode: STENCIL_MODES.NONE
    };
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  contextChange(gl) {
    this._gl = gl;
    this._comparisonFuncMapping = {
      always: gl.ALWAYS,
      never: gl.NEVER,
      equal: gl.EQUAL,
      "not-equal": gl.NOTEQUAL,
      less: gl.LESS,
      "less-equal": gl.LEQUAL,
      greater: gl.GREATER,
      "greater-equal": gl.GEQUAL
    };
    this._stencilOpsMapping = {
      keep: gl.KEEP,
      zero: gl.ZERO,
      replace: gl.REPLACE,
      invert: gl.INVERT,
      "increment-clamp": gl.INCR,
      "decrement-clamp": gl.DECR,
      "increment-wrap": gl.INCR_WRAP,
      "decrement-wrap": gl.DECR_WRAP
    };
    this.resetState();
  }
  onRenderTargetChange(renderTarget) {
    if (this._activeRenderTarget === renderTarget) return;
    this._activeRenderTarget = renderTarget;
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  resetState() {
    this._stencilCache.enabled = false;
    this._stencilCache.stencilMode = STENCIL_MODES.NONE;
    this._stencilCache.stencilReference = 0;
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    const gl = this._gl;
    const mode = GpuStencilModesToPixi[stencilMode];
    const _stencilCache = this._stencilCache;
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    if (stencilMode === STENCIL_MODES.DISABLED) {
      if (this._stencilCache.enabled) {
        this._stencilCache.enabled = false;
        gl.disable(gl.STENCIL_TEST);
      }
      return;
    }
    if (!this._stencilCache.enabled) {
      this._stencilCache.enabled = true;
      gl.enable(gl.STENCIL_TEST);
    }
    if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
      _stencilCache.stencilMode = stencilMode;
      _stencilCache.stencilReference = stencilReference;
      gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
      gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
    }
  }
}
/** @ignore */
GlStencilSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "stencil"
};

class UboSystem {
  constructor(adaptor) {
    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */
    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
    this._adaptor = adaptor;
    this._systemCheck();
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   */
  _systemCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  ensureUniformGroup(uniformGroup) {
    const uniformData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
      data: new Float32Array(uniformData.layout.size / 4),
      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
    }));
  }
  getUniformGroupData(uniformGroup) {
    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
  }
  _initUniformGroup(uniformGroup) {
    const uniformGroupSignature = uniformGroup._signature;
    let uniformData = this._syncFunctionHash[uniformGroupSignature];
    if (!uniformData) {
      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);
      const layout = this._adaptor.createUboElements(elements);
      const syncFunction = this._generateUboSync(layout.uboElements);
      uniformData = this._syncFunctionHash[uniformGroupSignature] = {
        layout,
        syncFunction
      };
    }
    return this._syncFunctionHash[uniformGroupSignature];
  }
  _generateUboSync(uboElements) {
    return this._adaptor.generateUboSync(uboElements);
  }
  syncUniformGroup(uniformGroup, data, offset) {
    const uniformGroupData = this.getUniformGroupData(uniformGroup);
    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({
      data: new Float32Array(uniformGroupData.layout.size / 4),
      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
    }));
    let dataInt32 = null;
    if (!data) {
      data = uniformGroup.buffer.data;
      dataInt32 = uniformGroup.buffer.dataInt32;
    }
    offset || (offset = 0);
    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
    return true;
  }
  updateUniformGroup(uniformGroup) {
    if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;
    uniformGroup._dirtyId = 0;
    const synced = this.syncUniformGroup(uniformGroup);
    uniformGroup.buffer.update();
    return synced;
  }
  destroy() {
    this._syncFunctionHash = null;
  }
}

const WGSL_TO_STD40_SIZE = {
  f32: 4,
  i32: 4,
  "vec2<f32>": 8,
  "vec3<f32>": 12,
  "vec4<f32>": 16,
  "vec2<i32>": 8,
  "vec3<i32>": 12,
  "vec4<i32>": 16,
  "mat2x2<f32>": 16 * 2,
  "mat3x3<f32>": 16 * 3,
  "mat4x4<f32>": 16 * 4
  // TODO - not essential for now but support these in the future
  // int:      4,
  // ivec2:    8,
  // ivec3:    12,
  // ivec4:    16,
  // uint:     4,
  // uvec2:    8,
  // uvec3:    12,
  // uvec4:    16,
  // bool:     4,
  // bvec2:    8,
  // bvec3:    12,
  // bvec4:    16,
  // mat2:     16 * 2,
  // mat3:     16 * 3,
  // mat4:     16 * 4,
};
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  const chunkSize = 16;
  let size = 0;
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, chunkSize) * uboElement.data.size;
    }
    const boundary = size === 12 ? 16 : size;
    uboElement.size = size;
    const curOffset = offset % chunkSize;
    if (curOffset > 0 && chunkSize - curOffset < boundary) {
      offset += (chunkSize - curOffset) % 16;
    } else {
      offset += (size - curOffset % size) % size;
    }
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}

const uniformParsers = [
  // uploading pixi matrix object to mat3
  {
    type: "mat3x3<f32>",
    test: (data) => {
      const value = data.value;
      return value.a !== void 0;
    },
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
  },
  // uploading a pixi rectangle as a vec4
  {
    type: "vec4<f32>",
    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
  },
  // uploading a pixi point as a vec2
  {
    type: "vec2<f32>",
    test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
  },
  // uploading a pixi color as a vec4
  {
    type: "vec4<f32>",
    test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
  },
  // uploading a pixi color as a vec3
  {
    type: "vec3<f32>",
    test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
  }
];

function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j = 0; j < uniformParsers.length; j++) {
      const uniformParser = uniformParsers[j];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `name = "${name}";`,
          `offset += ${offset - prev};`,
          uniformParsers[j][parserCode] || uniformParsers[j].ubo
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "dataInt32",
    "offset",
    fragmentSrc
  );
}

function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
const uboSyncFunctionsSTD40 = {
  f32: `
        data[offset] = v;`,
  i32: `
        dataInt32[offset] = v;`,
  "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
  "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
  "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
  "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
  "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
  "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
  "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
  "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
  "mat3x2<f32>": loopMatrix(3, 2),
  "mat4x2<f32>": loopMatrix(4, 2),
  "mat2x3<f32>": loopMatrix(2, 3),
  "mat4x3<f32>": loopMatrix(4, 3),
  "mat2x4<f32>": loopMatrix(2, 4),
  "mat3x4<f32>": loopMatrix(3, 4)
};
const uboSyncFunctionsWGSL = {
  ...uboSyncFunctionsSTD40,
  "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
};

function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                ${data}[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}

function createUboSyncFunctionSTD40(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboStd40",
    generateArraySyncSTD40,
    uboSyncFunctionsSTD40
  );
}

class GlUboSystem extends UboSystem {
  constructor() {
    super({
      createUboElements: createUboElementsSTD40,
      generateUboSync: createUboSyncFunctionSTD40
    });
  }
}
/** @ignore */
GlUboSystem.extension = {
  type: [ExtensionType.WebGLSystem],
  name: "ubo"
};

class GlRenderTargetAdaptor {
  constructor() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new Rectangle();
  }
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
    renderer.runners.contextChange.add(this);
  }
  contextChange() {
    this._clearColorCache = [0, 0, 0, 0];
    this._viewPortCache = new Rectangle();
    const gl = this._renderer.gl;
    this._drawBuffersCache = [];
    for (let i = 1; i <= 16; i++) {
      this._drawBuffersCache[i] = Array.from({ length: i }, (_, j) => gl.COLOR_ATTACHMENT0 + j);
    }
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderTargetSystem = this._renderTargetSystem;
    const renderer = this._renderer;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
    const gl = renderer.gl;
    this.finishRenderPass(sourceRenderSurfaceTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    renderer.texture.bind(destinationTexture, 0);
    gl.copyTexSubImage2D(
      gl.TEXTURE_2D,
      0,
      originDest.x,
      originDest.y,
      originSrc.x,
      originSrc.y,
      size.width,
      size.height
    );
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport, mipLevel = 0, layer = 0) {
    const renderTargetSystem = this._renderTargetSystem;
    const source = renderTarget.colorTexture;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (layer !== 0 && this._renderer.context.webGLVersion < 2) {
      throw new Error("[RenderTargetSystem] Rendering to array layers requires WebGL2.");
    }
    if (mipLevel > 0) {
      if (gpuRenderTarget.msaa) {
        throw new Error("[RenderTargetSystem] Rendering to mip levels is not supported with MSAA render targets.");
      }
      if (this._renderer.context.webGLVersion < 2) {
        throw new Error("[RenderTargetSystem] Rendering to mip levels requires WebGL2.");
      }
    }
    let viewPortY = viewport.y;
    if (renderTarget.isRoot) {
      viewPortY = source.pixelHeight - viewport.height - viewport.y;
    }
    renderTarget.colorTextures.forEach((texture) => {
      this._renderer.texture.unbind(texture);
    });
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
    if (!renderTarget.isRoot && (gpuRenderTarget._attachedMipLevel !== mipLevel || gpuRenderTarget._attachedLayer !== layer)) {
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        const glSource = this._renderer.texture.getGlSource(colorTexture);
        if (glSource.target === gl.TEXTURE_2D) {
          if (layer !== 0) {
            throw new Error("[RenderTargetSystem] layer must be 0 when rendering to 2D textures in WebGL.");
          }
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i,
            gl.TEXTURE_2D,
            glSource.texture,
            mipLevel
          );
        } else if (glSource.target === gl.TEXTURE_2D_ARRAY) {
          if (this._renderer.context.webGLVersion < 2) {
            throw new Error("[RenderTargetSystem] Rendering to 2D array textures requires WebGL2.");
          }
          gl.framebufferTextureLayer(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i,
            glSource.texture,
            mipLevel,
            layer
          );
        } else if (glSource.target === gl.TEXTURE_CUBE_MAP) {
          if (layer < 0 || layer > 5) {
            throw new Error("[RenderTargetSystem] Cube map layer must be between 0 and 5.");
          }
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i,
            gl.TEXTURE_CUBE_MAP_POSITIVE_X + layer,
            glSource.texture,
            mipLevel
          );
        } else {
          throw new Error("[RenderTargetSystem] Unsupported texture target for render-to-layer in WebGL.");
        }
      });
      gpuRenderTarget._attachedMipLevel = mipLevel;
      gpuRenderTarget._attachedLayer = layer;
    }
    if (renderTarget.colorTextures.length > 1) {
      this._setDrawBuffers(renderTarget, gl);
    }
    const viewPortCache = this._viewPortCache;
    if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
      viewPortCache.x = viewport.x;
      viewPortCache.y = viewPortY;
      viewPortCache.width = viewport.width;
      viewPortCache.height = viewport.height;
      gl.viewport(
        viewport.x,
        viewPortY,
        viewport.width,
        viewport.height
      );
    }
    if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
      this._initStencil(gpuRenderTarget);
    }
    this.clear(renderTarget, clear, clearColor);
  }
  finishRenderPass(renderTarget) {
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (!glRenderTarget.msaa) return;
    const gl = this._renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
    gl.blitFramebuffer(
      0,
      0,
      glRenderTarget.width,
      glRenderTarget.height,
      0,
      0,
      glRenderTarget.width,
      glRenderTarget.height,
      gl.COLOR_BUFFER_BIT,
      gl.NEAREST
    );
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
  }
  initGpuRenderTarget(renderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const glRenderTarget = new GlRenderTarget();
    glRenderTarget._attachedMipLevel = 0;
    glRenderTarget._attachedLayer = 0;
    const colorTexture = renderTarget.colorTexture;
    if (colorTexture instanceof CanvasSource) {
      this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);
      glRenderTarget.framebuffer = null;
      return glRenderTarget;
    }
    this._initColor(renderTarget, glRenderTarget);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return glRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    const gl = this._renderer.gl;
    if (gpuRenderTarget.framebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
      gpuRenderTarget.framebuffer = null;
    }
    if (gpuRenderTarget.resolveTargetFramebuffer) {
      gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
      gpuRenderTarget.resolveTargetFramebuffer = null;
    }
    if (gpuRenderTarget.depthStencilRenderBuffer) {
      gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
      gpuRenderTarget.depthStencilRenderBuffer = null;
    }
    gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
      gl.deleteRenderbuffer(renderBuffer);
    });
    gpuRenderTarget.msaaRenderBuffer = null;
  }
  clear(_renderTarget, clear, clearColor, _viewport, _mipLevel = 0, layer = 0) {
    if (!clear) return;
    if (layer !== 0) {
      throw new Error("[RenderTargetSystem] Clearing array layers is not supported in WebGL renderer.");
    }
    const renderTargetSystem = this._renderTargetSystem;
    if (typeof clear === "boolean") {
      clear = clear ? CLEAR.ALL : CLEAR.NONE;
    }
    const gl = this._renderer.gl;
    if (clear & CLEAR.COLOR) {
      clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
      const clearColorCache = this._clearColorCache;
      const clearColorArray = clearColor;
      if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
        clearColorCache[0] = clearColorArray[0];
        clearColorCache[1] = clearColorArray[1];
        clearColorCache[2] = clearColorArray[2];
        clearColorCache[3] = clearColorArray[3];
        gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
      }
    }
    gl.clear(clear);
  }
  resizeGpuRenderTarget(renderTarget) {
    if (renderTarget.isRoot) return;
    const renderTargetSystem = this._renderTargetSystem;
    const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    this._resizeColor(renderTarget, glRenderTarget);
    if (renderTarget.stencil || renderTarget.depth) {
      this._resizeStencil(glRenderTarget);
    }
  }
  _initColor(renderTarget, glRenderTarget) {
    const renderer = this._renderer;
    const gl = renderer.gl;
    const resolveTargetFramebuffer = gl.createFramebuffer();
    glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
    gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
    glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
    glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
    const colorTextures = renderTarget.colorTextures;
    colorTextures.forEach((colorTexture, i) => {
      const source = colorTexture.source;
      if (source.antialias) {
        if (renderer.context.supports.msaa) {
          glRenderTarget.msaa = true;
        } else {
          warn$2("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
        }
      }
      renderer.texture.bindSource(source, 0);
      const glSource = renderer.texture.getGlSource(source);
      const glTexture = glSource.texture;
      if (glSource.target === gl.TEXTURE_2D) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0 + i,
          gl.TEXTURE_2D,
          glTexture,
          0
        );
      } else if (glSource.target === gl.TEXTURE_2D_ARRAY) {
        if (renderer.context.webGLVersion < 2) {
          throw new Error("[RenderTargetSystem] TEXTURE_2D_ARRAY requires WebGL2.");
        }
        gl.framebufferTextureLayer(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0 + i,
          glTexture,
          0,
          0
        );
      } else if (glSource.target === gl.TEXTURE_CUBE_MAP) {
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0 + i,
          gl.TEXTURE_CUBE_MAP_POSITIVE_X,
          glTexture,
          0
        );
      } else {
        throw new Error("[RenderTargetSystem] Unsupported texture target for framebuffer attachment.");
      }
    });
    if (glRenderTarget.msaa) {
      const viewFramebuffer = gl.createFramebuffer();
      glRenderTarget.framebuffer = viewFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((_, i) => {
        const msaaRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;
      });
    } else {
      glRenderTarget.framebuffer = resolveTargetFramebuffer;
    }
    this._resizeColor(renderTarget, glRenderTarget);
  }
  _resizeColor(renderTarget, glRenderTarget) {
    const source = renderTarget.colorTexture.source;
    glRenderTarget.width = source.pixelWidth;
    glRenderTarget.height = source.pixelHeight;
    glRenderTarget._attachedMipLevel = 0;
    glRenderTarget._attachedLayer = 0;
    renderTarget.colorTextures.forEach((colorTexture, i) => {
      if (i === 0) return;
      colorTexture.source.resize(source.width, source.height, source._resolution);
    });
    if (glRenderTarget.msaa) {
      const renderer = this._renderer;
      const gl = renderer.gl;
      const viewFramebuffer = glRenderTarget.framebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        const source2 = colorTexture.source;
        renderer.texture.bindSource(source2, 0);
        const glSource = renderer.texture.getGlSource(source2);
        const glInternalFormat = glSource.internalFormat;
        const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          msaaRenderBuffer
        );
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          4,
          glInternalFormat,
          source2.pixelWidth,
          source2.pixelHeight
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0 + i,
          gl.RENDERBUFFER,
          msaaRenderBuffer
        );
      });
    }
  }
  _initStencil(glRenderTarget) {
    if (glRenderTarget.framebuffer === null) return;
    const gl = this._renderer.gl;
    const depthStencilRenderBuffer = gl.createRenderbuffer();
    glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
    gl.bindRenderbuffer(
      gl.RENDERBUFFER,
      depthStencilRenderBuffer
    );
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER,
      gl.DEPTH_STENCIL_ATTACHMENT,
      gl.RENDERBUFFER,
      depthStencilRenderBuffer
    );
    this._resizeStencil(glRenderTarget);
  }
  _resizeStencil(glRenderTarget) {
    const gl = this._renderer.gl;
    gl.bindRenderbuffer(
      gl.RENDERBUFFER,
      glRenderTarget.depthStencilRenderBuffer
    );
    if (glRenderTarget.msaa) {
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        4,
        gl.DEPTH24_STENCIL8,
        glRenderTarget.width,
        glRenderTarget.height
      );
    } else {
      gl.renderbufferStorage(
        gl.RENDERBUFFER,
        this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
        glRenderTarget.width,
        glRenderTarget.height
      );
    }
  }
  prerender(renderTarget) {
    const resource = renderTarget.colorTexture.resource;
    if (this._renderer.context.multiView && CanvasSource.test(resource)) {
      this._renderer.context.ensureCanvasSize(resource);
    }
  }
  postrender(renderTarget) {
    if (!this._renderer.context.multiView) return;
    if (CanvasSource.test(renderTarget.colorTexture.resource)) {
      const contextCanvas = this._renderer.context.canvas;
      const canvasSource = renderTarget.colorTexture;
      canvasSource.context2D.drawImage(
        contextCanvas,
        0,
        canvasSource.pixelHeight - contextCanvas.height
      );
    }
  }
  _setDrawBuffers(renderTarget, gl) {
    const count = renderTarget.colorTextures.length;
    const bufferArray = this._drawBuffersCache[count];
    if (this._renderer.context.webGLVersion === 1) {
      const ext = this._renderer.context.extensions.drawBuffers;
      if (!ext) {
        warn$2("[RenderTexture] This WebGL1 context does not support rendering to multiple targets");
      } else {
        ext.drawBuffersWEBGL(bufferArray);
      }
    } else {
      gl.drawBuffers(bufferArray);
    }
  }
}

class GlRenderTargetSystem extends RenderTargetSystem {
  constructor(renderer) {
    super(renderer);
    this.adaptor = new GlRenderTargetAdaptor();
    this.adaptor.init(renderer, this);
  }
}
/** @ignore */
GlRenderTargetSystem.extension = {
  type: [ExtensionType.WebGLSystem],
  name: "renderTarget"
};

class BufferResource extends EventEmitter {
  /**
   * Create a new Buffer Resource.
   * @param options - The options for the buffer resource
   * @param options.buffer - The underlying buffer that this resource is using
   * @param options.offset - The offset of the buffer this resource is using.
   * If not provided, then it will use the offset of the buffer.
   * @param options.size - The size of the buffer this resource is using.
   * If not provided, then it will use the size of the buffer.
   */
  constructor({ buffer, offset, size }) {
    super();
    /**
     * emits when the underlying buffer has changed shape (i.e. resized)
     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one
     * @event change
     */
    /** a unique id for this uniform group used through the renderer */
    this.uid = uid$1("buffer");
    /**
     * a resource type, used to identify how to handle it when its in a bind group / shader resource
     * @internal
     */
    this._resourceType = "bufferResource";
    /**
     * used internally to know if a uniform group was used in the last render pass
     * @internal
     */
    this._touched = 0;
    /**
     * the resource id used internally by the renderer to build bind group keys
     * @internal
     */
    this._resourceId = uid$1("resource");
    /**
     * A cheeky hint to the GL renderer to let it know this is a BufferResource
     * @internal
     */
    this._bufferResource = true;
    /**
     * Has the Buffer resource been destroyed?
     * @readonly
     */
    this.destroyed = false;
    this.buffer = buffer;
    this.offset = offset | 0;
    this.size = size;
    this.buffer.on("change", this.onBufferChange, this);
  }
  onBufferChange() {
    this._resourceId = uid$1("resource");
    this.emit("change", this);
  }
  /**
   * Destroys this resource. Make sure the underlying buffer is not used anywhere else
   * if you want to destroy it as well, or code will explode
   * @param destroyBuffer - Should the underlying buffer be destroyed as well?
   */
  destroy(destroyBuffer = false) {
    this.destroyed = true;
    if (destroyBuffer) {
      this.buffer.destroy();
    }
    this.emit("change", this);
    this.buffer = null;
    this.removeAllListeners();
  }
}

function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i in shader.groups) {
    const group = shader.groups[i];
    funcFragments.push(`
            resources = g[${i}].resources;
        `);
    for (const j in group.resources) {
      const resource = group.resources[j];
      if (resource instanceof UniformGroup) {
        if (resource.ubo) {
          const resName = shader._uniformBindMap[i][Number(j)];
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j}],
                            '${resName}',
                            ${shader.glProgram._uniformBlockData[resName].index}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j}], p, sD);
                    `);
        }
      } else if (resource instanceof BufferResource) {
        const resName = shader._uniformBindMap[i][Number(j)];
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j}],
                        '${resName}',
                        ${shader.glProgram._uniformBlockData[resName].index}
                    );
                `);
      } else if (resource instanceof TextureSource) {
        const uniformName = shader._uniformBindMap[i][j];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join("\n");
  return new Function("r", "s", "sD", functionSource);
}

class GlProgramData {
  /**
   * Makes a new Pixi program.
   * @param program - webgl program
   * @param uniformData - uniforms
   */
  constructor(program, uniformData) {
    this.program = program;
    this.uniformData = uniformData;
    this.uniformGroups = {};
    this.uniformDirtyGroups = {};
    this.uniformBlockBindings = {};
  }
  /** Destroys this program. */
  destroy() {
    this.uniformData = null;
    this.uniformGroups = null;
    this.uniformDirtyGroups = null;
    this.uniformBlockBindings = null;
    this.program = null;
  }
}

function compileShader(gl, type, src) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}

function booleanArray(size) {
  const array = new Array(size);
  for (let i = 0; i < array.length; i++) {
    array[i] = false;
  }
  return array;
}
function defaultValue(type, size) {
  switch (type) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}

let GL_TABLE = null;
const GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
const GLSL_TO_VERTEX_TYPES = {
  float: "float32",
  vec2: "float32x2",
  vec3: "float32x3",
  vec4: "float32x4",
  int: "sint32",
  ivec2: "sint32x2",
  ivec3: "sint32x3",
  ivec4: "sint32x4",
  uint: "uint32",
  uvec2: "uint32x2",
  uvec3: "uint32x3",
  uvec4: "uint32x4",
  bool: "uint32",
  bvec2: "uint32x2",
  bvec3: "uint32x3",
  bvec4: "uint32x4"
};
function mapType(gl, type) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i = 0; i < typeNames.length; ++i) {
      const tn = typeNames[i];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type];
}
function mapGlToVertexFormat(gl, type) {
  const typeValue = mapType(gl, type);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}

function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < totalAttributes; i++) {
    const attribData = gl.getActiveAttrib(program, i);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format = mapGlToVertexFormat(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      // set further down..
      format,
      stride: getAttributeInfoFromFormat(format).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys = Object.keys(attributes);
  if (sortAttributes) {
    keys.sort((a, b) => a > b ? 1 : -1);
    for (let i = 0; i < keys.length; i++) {
      attributes[keys[i]].location = i;
      gl.bindAttribLocation(program, i, keys[i]);
    }
    gl.linkProgram(program);
  } else {
    for (let i = 0; i < keys.length; i++) {
      attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);
    }
  }
  return attributes;
}

function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i = 0; i < totalUniformsBlocks; i++) {
    const name = gl.getActiveUniformBlockName(program, i);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}

function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < totalUniforms; i++) {
    const uniformData = gl.getActiveUniform(program, i);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray = !!uniformData.name.match(/\[.*?\]$/);
    const type = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i,
      type,
      size: uniformData.size,
      isArray,
      value: defaultValue(type, uniformData.size)
    };
  }
  return uniforms;
}

function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index) => `${index}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n) => {
    if (n && !dedupe[n]) {
      dedupe[n] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number) => {
    shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}

function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn$2(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = extractAttributesFromGlProgram(
    webGLProgram,
    gl,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
  );
  program._uniformData = getUniformData(webGLProgram, gl);
  program._uniformBlockData = getUboData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i in program._uniformData) {
    const data = program._uniformData[i];
    uniformData[i] = {
      location: gl.getUniformLocation(webGLProgram, i),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram = new GlProgramData(webGLProgram, uniformData);
  return glProgram;
}

const defaultSyncData = {
  textureCount: 0,
  blockIndex: 0
};
class GlShaderSystem {
  constructor(renderer) {
    /** @internal */
    this._activeProgram = null;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
  }
  contextChange(gl) {
    this._gl = gl;
    this._programDataHash = /* @__PURE__ */ Object.create(null);
    this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
    this._activeProgram = null;
  }
  /**
   * Changes the current shader to the one given in parameter.
   * @param shader - the new shader
   * @param skipSync - false if the shader should automatically sync its uniforms.
   * @returns the glProgram that belongs to the shader.
   */
  bind(shader, skipSync) {
    this._setProgram(shader.glProgram);
    if (skipSync) return;
    defaultSyncData.textureCount = 0;
    defaultSyncData.blockIndex = 0;
    let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
    if (!syncFunction) {
      syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
    }
    this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);
    syncFunction(this._renderer, shader, defaultSyncData);
  }
  /**
   * Updates the uniform group.
   * @param uniformGroup - the uniform group to update
   */
  updateUniformGroup(uniformGroup) {
    this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
  }
  /**
   * Binds a uniform block to the shader.
   * @param uniformGroup - the uniform group to bind
   * @param name - the name of the uniform block
   * @param index - the index of the uniform block
   */
  bindUniformBlock(uniformGroup, name, index = 0) {
    const bufferSystem = this._renderer.buffer;
    const programData = this._getProgramData(this._activeProgram);
    const isBufferResource = uniformGroup._bufferResource;
    if (!isBufferResource) {
      this._renderer.ubo.updateUniformGroup(uniformGroup);
    }
    const buffer = uniformGroup.buffer;
    const glBuffer = bufferSystem.updateBuffer(buffer);
    const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
    if (isBufferResource) {
      const { offset, size } = uniformGroup;
      if (offset === 0 && size === buffer.data.byteLength) {
        bufferSystem.bindBufferBase(glBuffer, boundLocation);
      } else {
        bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
      }
    } else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation) {
      bufferSystem.bindBufferBase(glBuffer, boundLocation);
    }
    const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
    if (programData.uniformBlockBindings[index] === boundLocation) return;
    programData.uniformBlockBindings[index] = boundLocation;
    this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);
  }
  _setProgram(program) {
    if (this._activeProgram === program) return;
    this._activeProgram = program;
    const programData = this._getProgramData(program);
    this._gl.useProgram(programData.program);
  }
  /**
   * @param program - the program to get the data for
   * @internal
   */
  _getProgramData(program) {
    return this._programDataHash[program._key] || this._createProgramData(program);
  }
  _createProgramData(program) {
    const key = program._key;
    this._programDataHash[key] = generateProgram(this._gl, program);
    return this._programDataHash[key];
  }
  destroy() {
    for (const key of Object.keys(this._programDataHash)) {
      this._programDataHash[key].destroy();
    }
    this._programDataHash = null;
    this._shaderSyncFunctions = null;
    this._activeProgram = null;
    this._renderer = null;
    this._gl = null;
  }
  /**
   * Creates a function that can be executed that will sync the shader as efficiently as possible.
   * Overridden by the unsafe eval package if you don't want eval used in your project.
   * @param shader - the shader to generate the sync function for
   * @param shaderSystem - the shader system to use
   * @returns - the generated sync function
   * @ignore
   */
  _generateShaderSync(shader, shaderSystem) {
    return generateShaderSyncCode(shader, shaderSystem);
  }
  resetState() {
    this._activeProgram = null;
  }
}
/** @ignore */
GlShaderSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "shader"
};

const UNIFORM_TO_SINGLE_SETTERS = {
  f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
  "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
  "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
  "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
  i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
  "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
  "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
  "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
  bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
  "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
  "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
  "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
};
const UNIFORM_TO_ARRAY_SETTERS = {
  f32: `gl.uniform1fv(location, v);`,
  "vec2<f32>": `gl.uniform2fv(location, v);`,
  "vec3<f32>": `gl.uniform3fv(location, v);`,
  "vec4<f32>": `gl.uniform4fv(location, v);`,
  "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
  "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
  "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
  i32: `gl.uniform1iv(location, v);`,
  "vec2<i32>": `gl.uniform2iv(location, v);`,
  "vec3<i32>": `gl.uniform3iv(location, v);`,
  "vec4<i32>": `gl.uniform4iv(location, v);`,
  u32: `gl.uniform1iv(location, v);`,
  "vec2<u32>": `gl.uniform2iv(location, v);`,
  "vec3<u32>": `gl.uniform3iv(location, v);`,
  "vec4<u32>": `gl.uniform4iv(location, v);`,
  bool: `gl.uniform1iv(location, v);`,
  "vec2<bool>": `gl.uniform2iv(location, v);`,
  "vec3<bool>": `gl.uniform3iv(location, v);`,
  "vec4<bool>": `gl.uniform4iv(location, v);`
};

function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i in group.uniforms) {
    if (!uniformData[i]) {
      if (group.uniforms[i] instanceof UniformGroup) {
        if (group.uniforms[i].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i}, "${i}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i});
                    `);
        }
      } else if (group.uniforms[i] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i}, "${i}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i];
    let parsed = false;
    for (let j = 0; j < uniformParsers.length; j++) {
      const parser = uniformParsers[j];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i}";`, uniformParsers[j].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i}"].location`);
      funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}

class GlUniformGroupSystem {
  /** @param renderer - The renderer this System works for. */
  constructor(renderer) {
    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */
    this._cache = {};
    this._uniformGroupSyncHash = {};
    this._renderer = renderer;
    this.gl = null;
    this._cache = {};
  }
  contextChange(gl) {
    this.gl = gl;
  }
  /**
   * Uploads the uniforms values to the currently bound shader.
   * @param group - the uniforms values that be applied to the current shader
   * @param program
   * @param syncData
   * @param syncData.textureCount
   */
  updateUniformGroup(group, program, syncData) {
    const programData = this._renderer.shader._getProgramData(program);
    if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
      programData.uniformDirtyGroups[group.uid] = group._dirtyId;
      const syncFunc = this._getUniformSyncFunction(group, program);
      syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
    }
  }
  /**
   * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
   * @param group
   * @param program
   */
  _getUniformSyncFunction(group, program) {
    return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
  }
  _createUniformSyncFunction(group, program) {
    const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
    const id = this._getSignature(group, program._uniformData, "u");
    if (!this._cache[id]) {
      this._cache[id] = this._generateUniformsSync(group, program._uniformData);
    }
    uniformGroupSyncHash[program._key] = this._cache[id];
    return uniformGroupSyncHash[program._key];
  }
  _generateUniformsSync(group, uniformData) {
    return generateUniformsSync(group, uniformData);
  }
  /**
   * Takes a uniform group and data and generates a unique signature for them.
   * @param group - The uniform group to get signature of
   * @param group.uniforms
   * @param uniformData - Uniform information generated by the shader
   * @param preFix
   * @returns Unique signature of the uniform group
   */
  _getSignature(group, uniformData, preFix) {
    const uniforms = group.uniforms;
    const strings = [`${preFix}-`];
    for (const i in uniforms) {
      strings.push(i);
      if (uniformData[i]) {
        strings.push(uniformData[i].type);
      }
    }
    return strings.join("-");
  }
  /** Destroys this System and removes all its textures. */
  destroy() {
    this._renderer = null;
    this._cache = null;
  }
}
/** @ignore */
GlUniformGroupSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "uniformGroup"
};

function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}

const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _GlStateSystem = class _GlStateSystem {
  constructor(renderer) {
    /**
     * Whether to invert the front face when rendering
     * This is used for render textures where the Y-coordinate is flipped
     * @default false
     */
    this._invertFrontFace = false;
    this.gl = null;
    this.stateId = 0;
    this.polygonOffset = 0;
    this.blendMode = "none";
    this._blendEq = false;
    this.map = [];
    this.map[BLEND] = this.setBlend;
    this.map[OFFSET] = this.setOffset;
    this.map[CULLING] = this.setCullFace;
    this.map[DEPTH_TEST] = this.setDepthTest;
    this.map[WINDING] = this.setFrontFace;
    this.map[DEPTH_MASK] = this.setDepthMask;
    this.checks = [];
    this.defaultState = State.for2d();
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    this._invertFrontFace = !renderTarget.isRoot;
    if (this._cullFace) {
      this.setFrontFace(this._frontFace);
    } else {
      this._frontFaceDirty = true;
    }
  }
  contextChange(gl) {
    this.gl = gl;
    this.blendModesMap = mapWebGLBlendModesToPixi(gl);
    this.resetState();
  }
  /**
   * Sets the current state
   * @param {*} state - The state to set.
   */
  set(state) {
    state || (state = this.defaultState);
    if (this.stateId !== state.data) {
      let diff = this.stateId ^ state.data;
      let i = 0;
      while (diff) {
        if (diff & 1) {
          this.map[i].call(this, !!(state.data & 1 << i));
        }
        diff >>= 1;
        i++;
      }
      this.stateId = state.data;
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
  }
  /**
   * Sets the state, when previous state is unknown.
   * @param {*} state - The state to set
   */
  forceState(state) {
    state || (state = this.defaultState);
    for (let i = 0; i < this.map.length; i++) {
      this.map[i].call(this, !!(state.data & 1 << i));
    }
    for (let i = 0; i < this.checks.length; i++) {
      this.checks[i](this, state);
    }
    this.stateId = state.data;
  }
  /**
   * Sets whether to enable or disable blending.
   * @param value - Turn on or off WebGl blending.
   */
  setBlend(value) {
    this._updateCheck(_GlStateSystem._checkBlendMode, value);
    this.gl[value ? "enable" : "disable"](this.gl.BLEND);
  }
  /**
   * Sets whether to enable or disable polygon offset fill.
   * @param value - Turn on or off webgl polygon offset testing.
   */
  setOffset(value) {
    this._updateCheck(_GlStateSystem._checkPolygonOffset, value);
    this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
  }
  /**
   * Sets whether to enable or disable depth test.
   * @param value - Turn on or off webgl depth testing.
   */
  setDepthTest(value) {
    this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
  }
  /**
   * Sets whether to enable or disable depth mask.
   * @param value - Turn on or off webgl depth mask.
   */
  setDepthMask(value) {
    this.gl.depthMask(value);
  }
  /**
   * Sets whether to enable or disable cull face.
   * @param {boolean} value - Turn on or off webgl cull face.
   */
  setCullFace(value) {
    this._cullFace = value;
    this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
    if (this._cullFace && this._frontFaceDirty) {
      this.setFrontFace(this._frontFace);
    }
  }
  /**
   * Sets the gl front face.
   * @param {boolean} value - true is clockwise and false is counter-clockwise
   */
  setFrontFace(value) {
    this._frontFace = value;
    this._frontFaceDirty = false;
    const faceMode = this._invertFrontFace ? !value : value;
    if (this._glFrontFace !== faceMode) {
      this._glFrontFace = faceMode;
      this.gl.frontFace(this.gl[faceMode ? "CW" : "CCW"]);
    }
  }
  /**
   * Sets the blend mode.
   * @param {number} value - The blend mode to set to.
   */
  setBlendMode(value) {
    if (!this.blendModesMap[value]) {
      value = "normal";
    }
    if (value === this.blendMode) {
      return;
    }
    this.blendMode = value;
    const mode = this.blendModesMap[value];
    const gl = this.gl;
    if (mode.length === 2) {
      gl.blendFunc(mode[0], mode[1]);
    } else {
      gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
    }
    if (mode.length === 6) {
      this._blendEq = true;
      gl.blendEquationSeparate(mode[4], mode[5]);
    } else if (this._blendEq) {
      this._blendEq = false;
      gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
    }
  }
  /**
   * Sets the polygon offset.
   * @param {number} value - the polygon offset
   * @param {number} scale - the polygon offset scale
   */
  setPolygonOffset(value, scale) {
    this.gl.polygonOffset(value, scale);
  }
  /** Resets all the logic and disables the VAOs. */
  resetState() {
    this._glFrontFace = false;
    this._frontFace = false;
    this._cullFace = false;
    this._frontFaceDirty = false;
    this._invertFrontFace = false;
    this.gl.frontFace(this.gl.CCW);
    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
    this.forceState(this.defaultState);
    this._blendEq = true;
    this.blendMode = "";
    this.setBlendMode("normal");
  }
  /**
   * Checks to see which updates should be checked based on which settings have been activated.
   *
   * For example, if blend is enabled then we should check the blend modes each time the state is changed
   * or if polygon fill is activated then we need to check if the polygon offset changes.
   * The idea is that we only check what we have too.
   * @param func - the checking function to add or remove
   * @param value - should the check function be added or removed.
   */
  _updateCheck(func, value) {
    const index = this.checks.indexOf(func);
    if (value && index === -1) {
      this.checks.push(func);
    } else if (!value && index !== -1) {
      this.checks.splice(index, 1);
    }
  }
  /**
   * A private little wrapper function that we call to check the blend mode.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkBlendMode(system, state) {
    system.setBlendMode(state.blendMode);
  }
  /**
   * A private little wrapper function that we call to check the polygon offset.
   * @param system - the System to perform the state check on
   * @param state - the state that the blendMode will pulled from
   */
  static _checkPolygonOffset(system, state) {
    system.setPolygonOffset(1, state.polygonOffset);
  }
  /** @ignore */
  destroy() {
    this.gl = null;
    this.checks.length = 0;
  }
};
/** @ignore */
_GlStateSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "state"
};
let GlStateSystem = _GlStateSystem;

class GlTexture {
  constructor(texture) {
    this.target = GL_TARGETS.TEXTURE_2D;
    /**
     * Bitmask tracking which array layers / sub-targets have been initialized at mip level 0.
     * Used by uploaders that need per-layer allocation semantics (e.g. cube faces).
     * @internal
     */
    this._layerInitMask = 0;
    this.texture = texture;
    this.width = -1;
    this.height = -1;
    this.type = GL_TYPES.UNSIGNED_BYTE;
    this.internalFormat = GL_FORMATS.RGBA;
    this.format = GL_FORMATS.RGBA;
    this.samplerType = 0;
  }
  destroy() {
  }
}

const glUploadBufferImageResource = {
  id: "buffer",
  upload(source, glTexture, gl, _webGLVersion, targetOverride, forceAllocation = false) {
    const target = targetOverride || glTexture.target;
    if (!forceAllocation && (glTexture.width === source.width && glTexture.height === source.height)) {
      gl.texSubImage2D(
        target,
        0,
        0,
        0,
        source.width,
        source.height,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    } else {
      gl.texImage2D(
        target,
        0,
        glTexture.internalFormat,
        source.width,
        source.height,
        0,
        glTexture.format,
        glTexture.type,
        source.resource
      );
    }
    glTexture.width = source.width;
    glTexture.height = source.height;
  }
};

const compressedFormatMap = {
  "bc1-rgba-unorm": true,
  "bc1-rgba-unorm-srgb": true,
  "bc2-rgba-unorm": true,
  "bc2-rgba-unorm-srgb": true,
  "bc3-rgba-unorm": true,
  "bc3-rgba-unorm-srgb": true,
  "bc4-r-unorm": true,
  "bc4-r-snorm": true,
  "bc5-rg-unorm": true,
  "bc5-rg-snorm": true,
  "bc6h-rgb-ufloat": true,
  "bc6h-rgb-float": true,
  "bc7-rgba-unorm": true,
  "bc7-rgba-unorm-srgb": true,
  // ETC2 compressed formats usable if "texture-compression-etc2" is both
  // supported by the device/user agent and enabled in requestDevice.
  "etc2-rgb8unorm": true,
  "etc2-rgb8unorm-srgb": true,
  "etc2-rgb8a1unorm": true,
  "etc2-rgb8a1unorm-srgb": true,
  "etc2-rgba8unorm": true,
  "etc2-rgba8unorm-srgb": true,
  "eac-r11unorm": true,
  "eac-r11snorm": true,
  "eac-rg11unorm": true,
  "eac-rg11snorm": true,
  // ASTC compressed formats usable if "texture-compression-astc" is both
  // supported by the device/user agent and enabled in requestDevice.
  "astc-4x4-unorm": true,
  "astc-4x4-unorm-srgb": true,
  "astc-5x4-unorm": true,
  "astc-5x4-unorm-srgb": true,
  "astc-5x5-unorm": true,
  "astc-5x5-unorm-srgb": true,
  "astc-6x5-unorm": true,
  "astc-6x5-unorm-srgb": true,
  "astc-6x6-unorm": true,
  "astc-6x6-unorm-srgb": true,
  "astc-8x5-unorm": true,
  "astc-8x5-unorm-srgb": true,
  "astc-8x6-unorm": true,
  "astc-8x6-unorm-srgb": true,
  "astc-8x8-unorm": true,
  "astc-8x8-unorm-srgb": true,
  "astc-10x5-unorm": true,
  "astc-10x5-unorm-srgb": true,
  "astc-10x6-unorm": true,
  "astc-10x6-unorm-srgb": true,
  "astc-10x8-unorm": true,
  "astc-10x8-unorm-srgb": true,
  "astc-10x10-unorm": true,
  "astc-10x10-unorm-srgb": true,
  "astc-12x10-unorm": true,
  "astc-12x10-unorm-srgb": true,
  "astc-12x12-unorm": true,
  "astc-12x12-unorm-srgb": true
};
const glUploadCompressedTextureResource = {
  id: "compressed",
  upload(source, glTexture, gl, _webGLVersion, targetOverride, _forceAllocation) {
    const target = targetOverride ?? glTexture.target;
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    let mipWidth = source.pixelWidth;
    let mipHeight = source.pixelHeight;
    const compressed = !!compressedFormatMap[source.format];
    for (let i = 0; i < source.resource.length; i++) {
      const levelBuffer = source.resource[i];
      if (compressed) {
        gl.compressedTexImage2D(
          target,
          i,
          glTexture.internalFormat,
          mipWidth,
          mipHeight,
          0,
          levelBuffer
        );
      } else {
        gl.texImage2D(
          target,
          i,
          glTexture.internalFormat,
          mipWidth,
          mipHeight,
          0,
          glTexture.format,
          glTexture.type,
          levelBuffer
        );
      }
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
  }
};

const FACE_ORDER$1 = ["right", "left", "top", "bottom", "front", "back"];
function createGlUploadCubeTextureResource(uploaders) {
  return {
    id: "cube",
    upload(source, glTexture, gl, webGLVersion) {
      const faces = source.faces;
      for (let faceIndex = 0; faceIndex < FACE_ORDER$1.length; faceIndex++) {
        const key = FACE_ORDER$1[faceIndex];
        const face = faces[key];
        const uploader = uploaders[face.uploadMethodId] || uploaders.image;
        uploader.upload(
          face,
          glTexture,
          gl,
          webGLVersion,
          // Use the face target for the current face. cube faces ids go up 1 so
          // GL_TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i addresses the i'th face target.
          GL_TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,
          // Force allocation for the first upload of each face.
          (glTexture._layerInitMask & 1 << faceIndex) === 0
        );
        glTexture._layerInitMask |= 1 << faceIndex;
      }
      glTexture.width = source.pixelWidth;
      glTexture.height = source.pixelHeight;
    }
  };
}

const glUploadImageResource = {
  id: "image",
  upload(source, glTexture, gl, webGLVersion, targetOverride, forceAllocation = false) {
    const target = targetOverride || glTexture.target;
    const textureWidth = source.pixelWidth;
    const textureHeight = source.pixelHeight;
    const resourceWidth = source.resourceWidth;
    const resourceHeight = source.resourceHeight;
    const isWebGL2 = webGLVersion === 2;
    const needsAllocation = forceAllocation || glTexture.width !== textureWidth || glTexture.height !== textureHeight;
    const resourceFitsTexture = resourceWidth >= textureWidth && resourceHeight >= textureHeight;
    const resource = source.resource;
    const uploadFunction = isWebGL2 ? uploadImageWebGL2 : uploadImageWebGL1;
    uploadFunction(
      gl,
      target,
      glTexture,
      textureWidth,
      textureHeight,
      resourceWidth,
      resourceHeight,
      resource,
      needsAllocation,
      resourceFitsTexture
    );
    glTexture.width = textureWidth;
    glTexture.height = textureHeight;
  }
};
function uploadImageWebGL2(gl, target, glTexture, textureWidth, textureHeight, resourceWidth, resourceHeight, resource, needsAllocation, resourceFitsTexture) {
  if (!resourceFitsTexture) {
    if (needsAllocation) {
      gl.texImage2D(
        target,
        0,
        glTexture.internalFormat,
        textureWidth,
        textureHeight,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
    }
    gl.texSubImage2D(
      target,
      0,
      0,
      0,
      resourceWidth,
      resourceHeight,
      glTexture.format,
      glTexture.type,
      resource
    );
    return;
  }
  if (!needsAllocation) {
    gl.texSubImage2D(
      target,
      0,
      0,
      0,
      glTexture.format,
      glTexture.type,
      resource
    );
    return;
  }
  gl.texImage2D(
    target,
    0,
    glTexture.internalFormat,
    textureWidth,
    textureHeight,
    0,
    glTexture.format,
    glTexture.type,
    resource
  );
}
function uploadImageWebGL1(gl, target, glTexture, textureWidth, textureHeight, _resourceWidth, _resourceHeight, resource, needsAllocation, resourceFitsTexture) {
  if (!resourceFitsTexture) {
    if (needsAllocation) {
      gl.texImage2D(
        target,
        0,
        glTexture.internalFormat,
        textureWidth,
        textureHeight,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
    }
    gl.texSubImage2D(
      target,
      0,
      0,
      0,
      glTexture.format,
      glTexture.type,
      resource
    );
    return;
  }
  if (!needsAllocation) {
    gl.texSubImage2D(
      target,
      0,
      0,
      0,
      glTexture.format,
      glTexture.type,
      resource
    );
    return;
  }
  gl.texImage2D(
    target,
    0,
    glTexture.internalFormat,
    glTexture.format,
    glTexture.type,
    resource
  );
}

const defaultForceAllocation = isSafari();
const glUploadVideoResource = {
  id: "video",
  upload(source, glTexture, gl, webGLVersion, targetOverride, forceAllocation = defaultForceAllocation) {
    if (!source.isValid) {
      const target = targetOverride ?? glTexture.target;
      gl.texImage2D(
        target,
        0,
        glTexture.internalFormat,
        1,
        1,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
      return;
    }
    glUploadImageResource.upload(source, glTexture, gl, webGLVersion, targetOverride, forceAllocation);
  }
};

const scaleModeToGlFilter = {
  linear: 9729,
  nearest: 9728
};
const mipmapScaleModeToGlFilter = {
  linear: {
    linear: 9987,
    nearest: 9985
  },
  nearest: {
    linear: 9986,
    nearest: 9984
  }
};
const wrapModeToGlAddress = {
  "clamp-to-edge": 33071,
  repeat: 10497,
  "mirror-repeat": 33648
};
const compareModeToGlCompare = {
  never: 512,
  less: 513,
  equal: 514,
  "less-equal": 515,
  greater: 516,
  "not-equal": 517,
  "greater-equal": 518,
  always: 519
};

function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}

function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}

function mapFormatToGlInternalFormat(gl, extensions) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    // Compressed formats
    ...extensions.s3tc ? {
      "bc1-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions.rgtc ? {
      "bc4-r-unorm": extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions.bptc ? {
      "bc6h-rgb-float": extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions.etc ? {
      "etc2-rgb8unorm": extensions.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...extensions.astc ? {
      "astc-4x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}

function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}

function mapViewDimensionToGlTarget(gl) {
  return {
    "2d": gl.TEXTURE_2D,
    cube: gl.TEXTURE_CUBE_MAP,
    "1d": null,
    // WebGL2 only
    "3d": gl?.TEXTURE_3D || null,
    "2d-array": gl?.TEXTURE_2D_ARRAY || null,
    "cube-array": gl?.TEXTURE_CUBE_MAP_ARRAY || null
  };
}

const BYTES_PER_PIXEL = 4;
class GlTextureSystem {
  constructor(renderer) {
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundTextures = [];
    this._activeTextureLocation = -1;
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._premultiplyAlpha = false;
    // TODO - separate samplers will be a cool thing to add, but not right now!
    this._useSeparateSamplers = false;
    this._renderer = renderer;
    this._managedTextures = new GCManagedHash({
      renderer,
      type: "resource",
      onUnload: this.onSourceUnload.bind(this),
      name: "glTexture"
    });
    const baseUploaders = {
      image: glUploadImageResource,
      buffer: glUploadBufferImageResource,
      video: glUploadVideoResource,
      compressed: glUploadCompressedTextureResource
    };
    this._uploads = {
      ...baseUploaders,
      cube: createGlUploadCubeTextureResource(baseUploaders)
    };
  }
  /**
   * @deprecated since 8.15.0
   */
  get managedTextures() {
    return Object.values(this._managedTextures.items);
  }
  contextChange(gl) {
    this._gl = gl;
    if (!this._mapFormatToInternalFormat) {
      this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
      this._mapFormatToType = mapFormatToGlType(gl);
      this._mapFormatToFormat = mapFormatToGlFormat(gl);
      this._mapViewDimensionToGlTarget = mapViewDimensionToGlTarget(gl);
    }
    this._managedTextures.removeAll(true);
    this._glSamplers = /* @__PURE__ */ Object.create(null);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    this._premultiplyAlpha = false;
    for (let i = 0; i < 16; i++) {
      this.bind(Texture.EMPTY, i);
    }
  }
  /**
   * Initializes a texture source, if it has already been initialized nothing will happen.
   * @param source - The texture source to initialize.
   * @returns The initialized texture source.
   */
  initSource(source) {
    this.bind(source);
  }
  bind(texture, location = 0) {
    const source = texture.source;
    if (texture) {
      this.bindSource(source, location);
      if (this._useSeparateSamplers) {
        this._bindSampler(source.style, location);
      }
    } else {
      this.bindSource(null, location);
      if (this._useSeparateSamplers) {
        this._bindSampler(null, location);
      }
    }
  }
  bindSource(source, location = 0) {
    const gl = this._gl;
    source._gcLastUsed = this._renderer.gc.now;
    if (this._boundTextures[location] !== source) {
      this._boundTextures[location] = source;
      this._activateLocation(location);
      source || (source = Texture.EMPTY.source);
      const glTexture = this.getGlSource(source);
      gl.bindTexture(glTexture.target, glTexture.texture);
    }
  }
  _bindSampler(style, location = 0) {
    const gl = this._gl;
    if (!style) {
      this._boundSamplers[location] = null;
      gl.bindSampler(location, null);
      return;
    }
    const sampler = this._getGlSampler(style);
    if (this._boundSamplers[location] !== sampler) {
      this._boundSamplers[location] = sampler;
      gl.bindSampler(location, sampler);
    }
  }
  unbind(texture) {
    const source = texture.source;
    const boundTextures = this._boundTextures;
    const gl = this._gl;
    for (let i = 0; i < boundTextures.length; i++) {
      if (boundTextures[i] === source) {
        this._activateLocation(i);
        const glTexture = this.getGlSource(source);
        gl.bindTexture(glTexture.target, null);
        boundTextures[i] = null;
      }
    }
  }
  _activateLocation(location) {
    if (this._activeTextureLocation !== location) {
      this._activeTextureLocation = location;
      this._gl.activeTexture(this._gl.TEXTURE0 + location);
    }
  }
  _initSource(source) {
    const gl = this._gl;
    const glTexture = new GlTexture(gl.createTexture());
    glTexture.type = this._mapFormatToType[source.format];
    glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];
    glTexture.format = this._mapFormatToFormat[source.format];
    glTexture.target = this._mapViewDimensionToGlTarget[source.viewDimension];
    if (glTexture.target === null) {
      throw new Error(`Unsupported view dimension: ${source.viewDimension} with this webgl version: ${this._renderer.context.webGLVersion}`);
    }
    if (source.uploadMethodId === "cube") {
      glTexture.target = gl.TEXTURE_CUBE_MAP;
    }
    if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo)) {
      const biggestDimension = Math.max(source.width, source.height);
      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    source._gpuData[this._renderer.uid] = glTexture;
    const added = this._managedTextures.add(source);
    if (added) {
      source.on("update", this.onSourceUpdate, this);
      source.on("resize", this.onSourceUpdate, this);
      source.on("styleChange", this.onStyleChange, this);
      source.on("updateMipmaps", this.onUpdateMipmaps, this);
    }
    this.onSourceUpdate(source);
    this.updateStyle(source, false);
    return glTexture;
  }
  onStyleChange(source) {
    this.updateStyle(source, false);
  }
  updateStyle(source, firstCreation) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source);
    gl.bindTexture(glTexture.target, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source;
    applyStyleParams(
      source.style,
      gl,
      source.mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "texParameteri",
      glTexture.target,
      // will force a clamp to edge if the texture is not a power of two
      !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,
      firstCreation
    );
  }
  onSourceUnload(source, contextLost = false) {
    const glTexture = source._gpuData[this._renderer.uid];
    if (!glTexture) return;
    if (!contextLost) {
      this.unbind(source);
      this._gl.deleteTexture(glTexture.texture);
    }
    source.off("update", this.onSourceUpdate, this);
    source.off("resize", this.onSourceUpdate, this);
    source.off("styleChange", this.onStyleChange, this);
    source.off("updateMipmaps", this.onUpdateMipmaps, this);
  }
  onSourceUpdate(source) {
    const gl = this._gl;
    const glTexture = this.getGlSource(source);
    gl.bindTexture(glTexture.target, glTexture.texture);
    this._boundTextures[this._activeTextureLocation] = source;
    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";
    if (this._premultiplyAlpha !== premultipliedAlpha) {
      this._premultiplyAlpha = premultipliedAlpha;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
    }
    if (this._uploads[source.uploadMethodId]) {
      this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);
    } else if (glTexture.target === gl.TEXTURE_2D) {
      this._initEmptyTexture2D(glTexture, source);
    } else if (glTexture.target === gl.TEXTURE_2D_ARRAY) {
      this._initEmptyTexture2DArray(glTexture, source);
    } else if (glTexture.target === gl.TEXTURE_CUBE_MAP) {
      this._initEmptyTextureCube(glTexture, source);
    } else {
      throw new Error("[GlTextureSystem] Unsupported texture target for empty allocation.");
    }
    this._applyMipRange(glTexture, source);
    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {
      this.onUpdateMipmaps(source, false);
    }
  }
  onUpdateMipmaps(source, bind = true) {
    if (bind) this.bindSource(source, 0);
    const glTexture = this.getGlSource(source);
    this._gl.generateMipmap(glTexture.target);
  }
  _initEmptyTexture2D(glTexture, source) {
    const gl = this._gl;
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      glTexture.internalFormat,
      source.pixelWidth,
      source.pixelHeight,
      0,
      glTexture.format,
      glTexture.type,
      null
    );
    let w = Math.max(source.pixelWidth >> 1, 1);
    let h = Math.max(source.pixelHeight >> 1, 1);
    for (let level = 1; level < source.mipLevelCount; level++) {
      gl.texImage2D(
        gl.TEXTURE_2D,
        level,
        glTexture.internalFormat,
        w,
        h,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
      w = Math.max(w >> 1, 1);
      h = Math.max(h >> 1, 1);
    }
  }
  _initEmptyTexture2DArray(glTexture, source) {
    if (this._renderer.context.webGLVersion !== 2) {
      throw new Error("[GlTextureSystem] TEXTURE_2D_ARRAY requires WebGL2.");
    }
    const gl2 = this._gl;
    const depth = Math.max(source.arrayLayerCount | 0, 1);
    gl2.texImage3D(
      gl2.TEXTURE_2D_ARRAY,
      0,
      glTexture.internalFormat,
      source.pixelWidth,
      source.pixelHeight,
      depth,
      0,
      glTexture.format,
      glTexture.type,
      null
    );
    let w = Math.max(source.pixelWidth >> 1, 1);
    let h = Math.max(source.pixelHeight >> 1, 1);
    for (let level = 1; level < source.mipLevelCount; level++) {
      gl2.texImage3D(
        gl2.TEXTURE_2D_ARRAY,
        level,
        glTexture.internalFormat,
        w,
        h,
        depth,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
      w = Math.max(w >> 1, 1);
      h = Math.max(h >> 1, 1);
    }
  }
  _initEmptyTextureCube(glTexture, source) {
    const gl = this._gl;
    const totalCubeFaces = 6;
    for (let face = 0; face < totalCubeFaces; face++) {
      gl.texImage2D(
        gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
        0,
        glTexture.internalFormat,
        source.pixelWidth,
        source.pixelHeight,
        0,
        glTexture.format,
        glTexture.type,
        null
      );
    }
    let w = Math.max(source.pixelWidth >> 1, 1);
    let h = Math.max(source.pixelHeight >> 1, 1);
    for (let level = 1; level < source.mipLevelCount; level++) {
      for (let face = 0; face < totalCubeFaces; face++) {
        gl.texImage2D(
          gl.TEXTURE_CUBE_MAP_POSITIVE_X + face,
          level,
          glTexture.internalFormat,
          w,
          h,
          0,
          glTexture.format,
          glTexture.type,
          null
        );
      }
      w = Math.max(w >> 1, 1);
      h = Math.max(h >> 1, 1);
    }
  }
  /**
   * Applies a mip range to the currently-bound texture so WebGL2 considers the texture "mipmap complete"
   * for the declared `mipLevelCount` (especially important for partial mip chains rendered via FBO).
   * @param glTexture - The GL texture wrapper.
   * @param source - The texture source describing mipLevelCount.
   */
  _applyMipRange(glTexture, source) {
    if (this._renderer.context.webGLVersion !== 2) return;
    const gl = this._gl;
    const maxLevel = Math.max((source.mipLevelCount | 0) - 1, 0);
    gl.texParameteri(glTexture.target, gl.TEXTURE_BASE_LEVEL, 0);
    gl.texParameteri(glTexture.target, gl.TEXTURE_MAX_LEVEL, maxLevel);
  }
  _initSampler(style) {
    const gl = this._gl;
    const glSampler = this._gl.createSampler();
    this._glSamplers[style._resourceId] = glSampler;
    applyStyleParams(
      style,
      gl,
      this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
      this._renderer.context.extensions.anisotropicFiltering,
      "samplerParameteri",
      glSampler,
      false,
      true
    );
    return this._glSamplers[style._resourceId];
  }
  _getGlSampler(sampler) {
    return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGlSource(source) {
    source._gcLastUsed = this._renderer.gc.now;
    return source._gpuData[this._renderer.uid] || this._initSource(source);
  }
  generateCanvas(texture) {
    const { pixels, width, height } = this.getPixels(texture);
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (ctx) {
      const imageData = ctx.createImageData(width, height);
      imageData.data.set(pixels);
      ctx.putImageData(imageData, 0, 0);
    }
    return canvas;
  }
  getPixels(texture) {
    const resolution = texture.source.resolution;
    const frame = texture.frame;
    const width = Math.max(Math.round(frame.width * resolution), 1);
    const height = Math.max(Math.round(frame.height * resolution), 1);
    const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
    const renderer = this._renderer;
    const renderTarget = renderer.renderTarget.getRenderTarget(texture);
    const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
    const gl = renderer.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
    gl.readPixels(
      Math.round(frame.x * resolution),
      Math.round(frame.y * resolution),
      width,
      height,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      pixels
    );
    return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
  }
  destroy() {
    this._managedTextures.destroy();
    this._glSamplers = null;
    this._boundTextures = null;
    this._boundSamplers = null;
    this._mapFormatToInternalFormat = null;
    this._mapFormatToType = null;
    this._mapFormatToFormat = null;
    this._uploads = null;
    this._renderer = null;
  }
  resetState() {
    this._activeTextureLocation = -1;
    this._boundTextures.fill(Texture.EMPTY.source);
    this._boundSamplers = /* @__PURE__ */ Object.create(null);
    const gl = this._gl;
    this._premultiplyAlpha = false;
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
  }
}
/** @ignore */
GlTextureSystem.extension = {
  type: [
    ExtensionType.WebGLSystem
  ],
  name: "texture"
};

class GlGraphicsAdaptor {
  contextChange(renderer) {
    const uniforms = new UniformGroup({
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    const maxTextures = renderer.limits.maxBatchableTextures;
    const glProgram = compileHighShaderGlProgram({
      name: "graphics",
      bits: [
        colorBitGl,
        generateTextureBatchBitGl(maxTextures),
        localUniformBitGl,
        roundPixelsBitGl
      ]
    });
    this.shader = new Shader({
      glProgram,
      resources: {
        localUniforms: uniforms,
        batchSamplers: getBatchSamplersUniformGroup(maxTextures)
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context = renderable.context;
    const shader = context.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context);
    shader.groups[0] = renderer.globalUniforms.bindGroup;
    renderer.state.set(graphicsPipe.state);
    renderer.shader.bind(shader);
    renderer.geometry.bind(batcher.geometry, shader.glProgram);
    const batches = instructions.instructions;
    for (let i = 0; i < instructions.instructionSize; i++) {
      const batch = batches[i];
      if (batch.size) {
        for (let j = 0; j < batch.textures.count; j++) {
          renderer.texture.bind(batch.textures.textures[j], j);
        }
        renderer.geometry.draw(batch.topology, batch.size, batch.start);
      }
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
/** @ignore */
GlGraphicsAdaptor.extension = {
  type: [
    ExtensionType.WebGLPipesAdaptor
  ],
  name: "graphics"
};

class GlMeshAdaptor {
  init() {
    const glProgram = compileHighShaderGlProgram({
      name: "mesh",
      bits: [
        localUniformBitGl,
        textureBitGl,
        roundPixelsBitGl
      ]
    });
    this._shader = new Shader({
      glProgram,
      resources: {
        uTexture: Texture.EMPTY.source,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      const texture = mesh.texture;
      const source = texture.source;
      shader.resources.uTexture = source;
      shader.resources.uSampler = source.style;
      shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
    } else if (!shader.glProgram) {
      warn$2("Mesh shader has no glProgram", mesh.shader);
      return;
    }
    shader.groups[100] = renderer.globalUniforms.bindGroup;
    shader.groups[101] = meshPipe.localUniformsBindGroup;
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
GlMeshAdaptor.extension = {
  type: [
    ExtensionType.WebGLPipesAdaptor
  ],
  name: "mesh"
};

const DefaultWebGLSystems = [
  ...SharedSystems,
  GlUboSystem,
  GlBackBufferSystem,
  GlContextSystem,
  GlLimitsSystem,
  GlBufferSystem,
  GlTextureSystem,
  GlRenderTargetSystem,
  GlGeometrySystem,
  GlUniformGroupSystem,
  GlShaderSystem,
  GlEncoderSystem,
  GlStateSystem,
  GlStencilSystem,
  GlColorMaskSystem
];
const DefaultWebGLPipes = [...SharedRenderPipes];
const DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
const systems$1 = [];
const renderPipes$1 = [];
const renderPipeAdaptors$1 = [];
extensions.handleByNamedList(ExtensionType.WebGLSystem, systems$1);
extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes$1);
extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors$1);
extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
class WebGLRenderer extends AbstractRenderer {
  constructor() {
    const systemConfig = {
      name: "webgl",
      type: RendererType.WEBGL,
      systems: systems$1,
      renderPipes: renderPipes$1,
      renderPipeAdaptors: renderPipeAdaptors$1
    };
    super(systemConfig);
  }
}

var WebGLRenderer$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebGLRenderer: WebGLRenderer
});

class BindGroupSystem {
  constructor(renderer) {
    this._hash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getBindGroup(bindGroup, program, groupIndex) {
    bindGroup._updateKey();
    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
    return gpuBindGroup;
  }
  _createBindGroup(group, program, groupIndex) {
    const device = this._gpu.device;
    const groupLayout = program.layout[groupIndex];
    const entries = [];
    const renderer = this._renderer;
    for (const j in groupLayout) {
      const resource = group.resources[j] ?? group.resources[groupLayout[j]];
      let gpuResource;
      if (resource._resourceType === "uniformGroup") {
        const uniformGroup = resource;
        renderer.ubo.updateUniformGroup(uniformGroup);
        const buffer = uniformGroup.buffer;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "buffer") {
        const buffer = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(buffer),
          offset: 0,
          size: buffer.descriptor.size
        };
      } else if (resource._resourceType === "bufferResource") {
        const bufferResource = resource;
        gpuResource = {
          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
          offset: bufferResource.offset,
          size: bufferResource.size
        };
      } else if (resource._resourceType === "textureSampler") {
        const sampler = resource;
        gpuResource = renderer.texture.getGpuSampler(sampler);
      } else if (resource._resourceType === "textureSource") {
        const texture = resource;
        gpuResource = renderer.texture.getTextureView(texture);
      }
      entries.push({
        binding: groupLayout[j],
        resource: gpuResource
      });
    }
    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
    const gpuBindGroup = device.createBindGroup({
      layout,
      entries
    });
    this._hash[group._key] = gpuBindGroup;
    return gpuBindGroup;
  }
  destroy() {
    this._hash = null;
    this._renderer = null;
  }
}
/** @ignore */
BindGroupSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "bindGroup"
};

class GpuBufferData {
  constructor(gpuBuffer) {
    this.gpuBuffer = gpuBuffer;
  }
  destroy() {
    this.gpuBuffer.destroy();
    this.gpuBuffer = null;
  }
}
class GpuBufferSystem {
  constructor(renderer) {
    this._renderer = renderer;
    this._managedBuffers = new GCManagedHash({
      renderer,
      type: "resource",
      onUnload: this.onBufferUnload.bind(this),
      name: "gpuBuffer"
    });
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getGPUBuffer(buffer) {
    buffer._gcLastUsed = this._renderer.gc.now;
    return buffer._gpuData[this._renderer.uid]?.gpuBuffer || this.createGPUBuffer(buffer);
  }
  updateBuffer(buffer) {
    const gpuBuffer = this.getGPUBuffer(buffer);
    const data = buffer.data;
    if (buffer._updateID && data) {
      buffer._updateID = 0;
      this._gpu.device.queue.writeBuffer(
        gpuBuffer,
        0,
        data.buffer,
        0,
        // round to the nearest 4 bytes
        (buffer._updateSize || data.byteLength) + 3 & -4
      );
    }
    return gpuBuffer;
  }
  /** dispose all WebGL resources of all managed buffers */
  destroyAll() {
    this._managedBuffers.removeAll();
  }
  onBufferUnload(buffer) {
    buffer.off("update", this.updateBuffer, this);
    buffer.off("change", this.onBufferChange, this);
  }
  createGPUBuffer(buffer) {
    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
    buffer._updateID = 0;
    buffer._resourceId = uid$1("resource");
    if (buffer.data) {
      fastCopy(
        buffer.data.buffer,
        gpuBuffer.getMappedRange(),
        buffer.data.byteOffset,
        buffer.data.byteLength
      );
      gpuBuffer.unmap();
    }
    buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);
    if (this._managedBuffers.add(buffer)) {
      buffer.on("update", this.updateBuffer, this);
      buffer.on("change", this.onBufferChange, this);
    }
    return gpuBuffer;
  }
  onBufferChange(buffer) {
    this._managedBuffers.remove(buffer);
    buffer._updateID = 0;
    this.createGPUBuffer(buffer);
  }
  destroy() {
    this._managedBuffers.destroy();
    this._renderer = null;
    this._gpu = null;
  }
}
/** @ignore */
GpuBufferSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "buffer"
};

class UboBatch {
  constructor({ minUniformOffsetAlignment }) {
    this._minUniformOffsetAlignment = 256;
    this.byteIndex = 0;
    this._minUniformOffsetAlignment = minUniformOffsetAlignment;
    this.data = new Float32Array(65535);
  }
  clear() {
    this.byteIndex = 0;
  }
  addEmptyGroup(size) {
    if (size > this._minUniformOffsetAlignment / 4) {
      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
    }
    const start = this.byteIndex;
    let newSize = start + size * 4;
    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
    if (newSize > this.data.length * 4) {
      throw new Error("UniformBufferBatch: ubo batch got too big");
    }
    this.byteIndex = newSize;
    return start;
  }
  addGroup(array) {
    const offset = this.addEmptyGroup(array.length);
    for (let i = 0; i < array.length; i++) {
      this.data[offset / 4 + i] = array[i];
    }
    return offset;
  }
  destroy() {
    this.data = null;
  }
}

class GpuColorMaskSystem {
  constructor(renderer) {
    this._colorMaskCache = 15;
    this._renderer = renderer;
  }
  setMask(colorMask) {
    if (this._colorMaskCache === colorMask) return;
    this._colorMaskCache = colorMask;
    this._renderer.pipeline.setColorMask(colorMask);
  }
  destroy() {
    this._renderer = null;
    this._colorMaskCache = null;
  }
}
/** @ignore */
GpuColorMaskSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "colorMask"
};

class GpuDeviceSystem {
  /**
   * @param {WebGPURenderer} renderer - The renderer this System works for.
   */
  constructor(renderer) {
    this._renderer = renderer;
  }
  async init(options) {
    if (this._initPromise) return this._initPromise;
    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {
      this.gpu = gpu;
      this._renderer.runners.contextChange.emit(this.gpu);
    });
    return this._initPromise;
  }
  /**
   * Handle the context change event
   * @param gpu
   */
  contextChange(gpu) {
    this._renderer.gpu = gpu;
  }
  /**
   * Helper class to create a WebGL Context
   * @param {object} options - An options object that gets passed in to the canvas element containing the
   *    context attributes
   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
   * @returns {WebGLRenderingContext} the WebGL context
   */
  async _createDeviceAndAdaptor(options) {
    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
      powerPreference: options.powerPreference,
      forceFallbackAdapter: options.forceFallbackAdapter
    });
    const requiredFeatures = [
      "texture-compression-bc",
      "texture-compression-astc",
      "texture-compression-etc2"
    ].filter((feature) => adapter.features.has(feature));
    const device = await adapter.requestDevice({
      requiredFeatures
    });
    return { adapter, device };
  }
  destroy() {
    this.gpu = null;
    this._renderer = null;
  }
}
/** @ignore */
GpuDeviceSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "device"
};
/** The default options for the GpuDeviceSystem. */
GpuDeviceSystem.defaultOptions = {
  /**
   * {@link WebGPUOptions.powerPreference}
   * @default default
   */
  powerPreference: void 0,
  /**
   * Force the use of the fallback adapter
   * @default false
   */
  forceFallbackAdapter: false
};

class GpuEncoderSystem {
  constructor(renderer) {
    this._boundBindGroup = /* @__PURE__ */ Object.create(null);
    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
  }
  renderStart() {
    this.commandFinished = new Promise((resolve) => {
      this._resolveCommandFinished = resolve;
    });
    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
  }
  beginRenderPass(gpuRenderTarget) {
    this.endRenderPass();
    this._clearCache();
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
  }
  endRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
    }
    this.renderPassEncoder = null;
  }
  setViewport(viewport) {
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
  }
  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
    this.setPipeline(pipeline);
  }
  setPipeline(pipeline) {
    if (this._boundPipeline === pipeline) return;
    this._boundPipeline = pipeline;
    this.renderPassEncoder.setPipeline(pipeline);
  }
  _setVertexBuffer(index, buffer) {
    if (this._boundVertexBuffer[index] === buffer) return;
    this._boundVertexBuffer[index] = buffer;
    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));
  }
  _setIndexBuffer(buffer) {
    if (this._boundIndexBuffer === buffer) return;
    this._boundIndexBuffer = buffer;
    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
  }
  resetBindGroup(index) {
    this._boundBindGroup[index] = null;
  }
  setBindGroup(index, bindGroup, program) {
    if (this._boundBindGroup[index] === bindGroup) return;
    this._boundBindGroup[index] = bindGroup;
    bindGroup._touch(this._renderer.gc.now, this._renderer.tick);
    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);
    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);
  }
  setGeometry(geometry, program) {
    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
    for (const i in buffersToBind) {
      this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);
    }
    if (geometry.indexBuffer) {
      this._setIndexBuffer(geometry.indexBuffer);
    }
  }
  _setShaderBindGroups(shader, skipSync) {
    for (const i in shader.groups) {
      const bindGroup = shader.groups[i];
      if (!skipSync) {
        this._syncBindGroup(bindGroup);
      }
      this.setBindGroup(i, bindGroup, shader.gpuProgram);
    }
  }
  _syncBindGroup(bindGroup) {
    for (const j in bindGroup.resources) {
      const resource = bindGroup.resources[j];
      if (resource.isUniformGroup) {
        this._renderer.ubo.updateUniformGroup(resource);
      }
    }
  }
  draw(options) {
    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;
    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
    this.setGeometry(geometry, shader.gpuProgram);
    this._setShaderBindGroups(shader, skipSync);
    if (geometry.indexBuffer) {
      this.renderPassEncoder.drawIndexed(
        size || geometry.indexBuffer.data.length,
        instanceCount ?? geometry.instanceCount,
        start || 0
      );
    } else {
      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
    }
  }
  finishRenderPass() {
    if (this.renderPassEncoder) {
      this.renderPassEncoder.end();
      this.renderPassEncoder = null;
    }
  }
  postrender() {
    this.finishRenderPass();
    this._gpu.device.queue.submit([this.commandEncoder.finish()]);
    this._resolveCommandFinished();
    this.commandEncoder = null;
  }
  // restores a render pass if finishRenderPass was called
  // not optimised as really used for debugging!
  // used when we want to stop drawing and log a texture..
  restoreRenderPass() {
    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
      this._renderer.renderTarget.renderTarget,
      false,
      [0, 0, 0, 1],
      this._renderer.renderTarget.mipLevel,
      this._renderer.renderTarget.layer
    );
    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
    const boundPipeline = this._boundPipeline;
    const boundVertexBuffer = { ...this._boundVertexBuffer };
    const boundIndexBuffer = this._boundIndexBuffer;
    const boundBindGroup = { ...this._boundBindGroup };
    this._clearCache();
    const viewport = this._renderer.renderTarget.viewport;
    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
    this.setPipeline(boundPipeline);
    for (const i in boundVertexBuffer) {
      this._setVertexBuffer(i, boundVertexBuffer[i]);
    }
    for (const i in boundBindGroup) {
      this.setBindGroup(i, boundBindGroup[i], null);
    }
    this._setIndexBuffer(boundIndexBuffer);
  }
  _clearCache() {
    for (let i = 0; i < 16; i++) {
      this._boundBindGroup[i] = null;
      this._boundVertexBuffer[i] = null;
    }
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  destroy() {
    this._renderer = null;
    this._gpu = null;
    this._boundBindGroup = null;
    this._boundVertexBuffer = null;
    this._boundIndexBuffer = null;
    this._boundPipeline = null;
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
}
/** @ignore */
GpuEncoderSystem.extension = {
  type: [ExtensionType.WebGPUSystem],
  name: "encoder",
  priority: 1
};

class GpuLimitsSystem {
  constructor(renderer) {
    this._renderer = renderer;
  }
  contextChange() {
    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;
    this.maxBatchableTextures = this.maxTextures;
  }
  destroy() {
  }
}
/** @ignore */
GpuLimitsSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "limits"
};

class GpuStencilSystem {
  constructor(renderer) {
    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.renderTarget.onRenderTargetChange.add(this);
  }
  onRenderTargetChange(renderTarget) {
    let stencilState = this._renderTargetStencilState[renderTarget.uid];
    if (!stencilState) {
      stencilState = this._renderTargetStencilState[renderTarget.uid] = {
        stencilMode: STENCIL_MODES.DISABLED,
        stencilReference: 0
      };
    }
    this._activeRenderTarget = renderTarget;
    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
  }
  setStencilMode(stencilMode, stencilReference) {
    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
    stencilState.stencilMode = stencilMode;
    stencilState.stencilReference = stencilReference;
    const renderer = this._renderer;
    renderer.pipeline.setStencilMode(stencilMode);
    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
  }
  destroy() {
    this._renderer.renderTarget.onRenderTargetChange.remove(this);
    this._renderer = null;
    this._activeRenderTarget = null;
    this._renderTargetStencilState = null;
  }
}
/** @ignore */
GpuStencilSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "stencil"
};

const WGSL_ALIGN_SIZE_DATA = {
  i32: { align: 4, size: 4 },
  u32: { align: 4, size: 4 },
  f32: { align: 4, size: 4 },
  f16: { align: 2, size: 2 },
  "vec2<i32>": { align: 8, size: 8 },
  "vec2<u32>": { align: 8, size: 8 },
  "vec2<f32>": { align: 8, size: 8 },
  "vec2<f16>": { align: 4, size: 4 },
  "vec3<i32>": { align: 16, size: 12 },
  "vec3<u32>": { align: 16, size: 12 },
  "vec3<f32>": { align: 16, size: 12 },
  "vec3<f16>": { align: 8, size: 6 },
  "vec4<i32>": { align: 16, size: 16 },
  "vec4<u32>": { align: 16, size: 16 },
  "vec4<f32>": { align: 16, size: 16 },
  "vec4<f16>": { align: 8, size: 8 },
  "mat2x2<f32>": { align: 8, size: 16 },
  "mat2x2<f16>": { align: 4, size: 8 },
  "mat3x2<f32>": { align: 8, size: 24 },
  "mat3x2<f16>": { align: 4, size: 12 },
  "mat4x2<f32>": { align: 8, size: 32 },
  "mat4x2<f16>": { align: 4, size: 16 },
  "mat2x3<f32>": { align: 16, size: 32 },
  "mat2x3<f16>": { align: 8, size: 16 },
  "mat3x3<f32>": { align: 16, size: 48 },
  "mat3x3<f16>": { align: 8, size: 24 },
  "mat4x3<f32>": { align: 16, size: 64 },
  "mat4x3<f16>": { align: 8, size: 32 },
  "mat2x4<f32>": { align: 16, size: 32 },
  "mat2x4<f16>": { align: 8, size: 16 },
  "mat3x4<f32>": { align: 16, size: 48 },
  "mat3x4<f16>": { align: 8, size: 24 },
  "mat4x4<f32>": { align: 16, size: 64 },
  "mat4x4<f16>": { align: 8, size: 32 }
};
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i = 0; i < uboElements.length; i++) {
    const uboElement = uboElements[i];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}

function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  const data = uboElement.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 ${data}[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}

function createUboSyncFunctionWGSL(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboWgsl",
    generateArraySyncWGSL,
    uboSyncFunctionsWGSL
  );
}

class GpuUboSystem extends UboSystem {
  constructor() {
    super({
      createUboElements: createUboElementsWGSL,
      generateUboSync: createUboSyncFunctionWGSL
    });
  }
}
/** @ignore */
GpuUboSystem.extension = {
  type: [ExtensionType.WebGPUSystem],
  name: "ubo"
};

const minUniformOffsetAlignment = 128;
class GpuUniformBatchPipe {
  constructor(renderer) {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    // number of buffers..
    this._buffers = [];
    this._bindGroups = [];
    this._bufferResources = [];
    this._renderer = renderer;
    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
    const totalBuffers = 256 / minUniformOffsetAlignment;
    for (let i = 0; i < totalBuffers; i++) {
      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
      if (i === 0) usage |= BufferUsage.COPY_SRC;
      this._buffers.push(new Buffer({
        data: this._batchBuffer.data,
        usage
      }));
    }
  }
  renderEnd() {
    this._uploadBindGroups();
    this._resetBindGroups();
  }
  _resetBindGroups() {
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    this._batchBuffer.clear();
  }
  // just works for single bind groups for now
  getUniformBindGroup(group, duplicate) {
    if (!duplicate && this._bindGroupHash[group.uid]) {
      return this._bindGroupHash[group.uid];
    }
    this._renderer.ubo.ensureUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addEmptyGroup(data.length);
    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
    return this._bindGroupHash[group.uid];
  }
  getUboResource(group) {
    this._renderer.ubo.updateUniformGroup(group);
    const data = group.buffer.data;
    const offset = this._batchBuffer.addGroup(data);
    return this._getBufferResource(offset / minUniformOffsetAlignment);
  }
  getArrayBindGroup(data) {
    const offset = this._batchBuffer.addGroup(data);
    return this._getBindGroup(offset / minUniformOffsetAlignment);
  }
  getArrayBufferResource(data) {
    const offset = this._batchBuffer.addGroup(data);
    const index = offset / minUniformOffsetAlignment;
    return this._getBufferResource(index);
  }
  _getBufferResource(index) {
    if (!this._bufferResources[index]) {
      const buffer = this._buffers[index % 2];
      this._bufferResources[index] = new BufferResource({
        buffer,
        offset: (index / 2 | 0) * 256,
        size: minUniformOffsetAlignment
      });
    }
    return this._bufferResources[index];
  }
  _getBindGroup(index) {
    if (!this._bindGroups[index]) {
      const bindGroup = new BindGroup({
        0: this._getBufferResource(index)
      });
      this._bindGroups[index] = bindGroup;
    }
    return this._bindGroups[index];
  }
  _uploadBindGroups() {
    const bufferSystem = this._renderer.buffer;
    const firstBuffer = this._buffers[0];
    firstBuffer.update(this._batchBuffer.byteIndex);
    bufferSystem.updateBuffer(firstBuffer);
    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    for (let i = 1; i < this._buffers.length; i++) {
      const buffer = this._buffers[i];
      commandEncoder.copyBufferToBuffer(
        bufferSystem.getGPUBuffer(firstBuffer),
        minUniformOffsetAlignment,
        bufferSystem.getGPUBuffer(buffer),
        0,
        this._batchBuffer.byteIndex
      );
    }
    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
  }
  destroy() {
    for (let i = 0; i < this._bindGroups.length; i++) {
      this._bindGroups[i]?.destroy();
    }
    this._bindGroups = null;
    this._bindGroupHash = null;
    for (let i = 0; i < this._buffers.length; i++) {
      this._buffers[i].destroy();
    }
    this._buffers = null;
    for (let i = 0; i < this._bufferResources.length; i++) {
      this._bufferResources[i].destroy();
    }
    this._bufferResources = null;
    this._batchBuffer.destroy();
    this._renderer = null;
  }
}
/** @ignore */
GpuUniformBatchPipe.extension = {
  type: [
    ExtensionType.WebGPUPipes
  ],
  name: "uniformBatch"
};

const topologyStringToId = {
  "point-list": 0,
  "line-list": 1,
  "line-strip": 2,
  "triangle-list": 3,
  "triangle-strip": 4
};
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget, colorTargetCount) {
  return colorMask << 8 | stencilStateId << 5 | renderTarget << 3 | colorTargetCount << 1 | multiSampleCount;
}
class PipelineSystem {
  constructor(renderer) {
    this._moduleCache = /* @__PURE__ */ Object.create(null);
    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
    this._pipeCache = /* @__PURE__ */ Object.create(null);
    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
    this._colorMask = 15;
    this._multisampleCount = 1;
    this._colorTargetCount = 1;
    this._renderer = renderer;
  }
  contextChange(gpu) {
    this._gpu = gpu;
    this.setStencilMode(STENCIL_MODES.DISABLED);
    this._updatePipeHash();
  }
  setMultisampleCount(multisampleCount) {
    if (this._multisampleCount === multisampleCount) return;
    this._multisampleCount = multisampleCount;
    this._updatePipeHash();
  }
  setRenderTarget(renderTarget) {
    this._multisampleCount = renderTarget.msaaSamples;
    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
    this._colorTargetCount = renderTarget.colorTargetCount;
    this._updatePipeHash();
  }
  setColorMask(colorMask) {
    if (this._colorMask === colorMask) return;
    this._colorMask = colorMask;
    this._updatePipeHash();
  }
  setStencilMode(stencilMode) {
    if (this._stencilMode === stencilMode) return;
    this._stencilMode = stencilMode;
    this._stencilState = GpuStencilModesToPixi[stencilMode];
    this._updatePipeHash();
  }
  setPipeline(geometry, program, state, passEncoder) {
    const pipeline = this.getPipeline(geometry, program, state);
    passEncoder.setPipeline(pipeline);
  }
  getPipeline(geometry, program, state, topology) {
    if (!geometry._layoutKey) {
      ensureAttributes(geometry, program.attributeData);
      this._generateBufferKey(geometry);
    }
    topology || (topology = geometry.topology);
    const key = getGraphicsStateKey(
      geometry._layoutKey,
      program._layoutKey,
      state.data,
      state._blendModeId,
      topologyStringToId[topology]
    );
    if (this._pipeCache[key]) return this._pipeCache[key];
    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
    return this._pipeCache[key];
  }
  _createPipeline(geometry, program, state, topology) {
    const device = this._gpu.device;
    const buffers = this._createVertexBufferLayouts(geometry, program);
    const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);
    const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
    for (let i = 0; i < blendModes.length; i++) {
      blendModes[i].writeMask = writeMask;
    }
    const layout = this._renderer.shader.getProgramData(program).pipeline;
    const descriptor = {
      // TODO later check if its helpful to create..
      // layout,
      vertex: {
        module: this._getModule(program.vertex.source),
        entryPoint: program.vertex.entryPoint,
        // geometry..
        buffers
      },
      fragment: {
        module: this._getModule(program.fragment.source),
        entryPoint: program.fragment.entryPoint,
        targets: blendModes
      },
      primitive: {
        topology,
        cullMode: state.cullMode
      },
      layout,
      multisample: {
        count: this._multisampleCount
      },
      // depthStencil,
      label: `PIXI Pipeline`
    };
    if (this._depthStencilAttachment) {
      descriptor.depthStencil = {
        ...this._stencilState,
        format: "depth24plus-stencil8",
        depthWriteEnabled: state.depthTest,
        depthCompare: state.depthTest ? "less" : "always"
      };
    }
    const pipeline = device.createRenderPipeline(descriptor);
    return pipeline;
  }
  _getModule(code) {
    return this._moduleCache[code] || this._createModule(code);
  }
  _createModule(code) {
    const device = this._gpu.device;
    this._moduleCache[code] = device.createShaderModule({
      code
    });
    return this._moduleCache[code];
  }
  _generateBufferKey(geometry) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(geometry.attributes).sort();
    for (let i = 0; i < attributeKeys.length; i++) {
      const attribute = geometry.attributes[attributeKeys[i]];
      keyGen[index++] = attribute.offset;
      keyGen[index++] = attribute.format;
      keyGen[index++] = attribute.stride;
      keyGen[index++] = attribute.instance;
    }
    const stringKey = keyGen.join("|");
    geometry._layoutKey = createIdFromString(stringKey, "geometry");
    return geometry._layoutKey;
  }
  _generateAttributeLocationsKey(program) {
    const keyGen = [];
    let index = 0;
    const attributeKeys = Object.keys(program.attributeData).sort();
    for (let i = 0; i < attributeKeys.length; i++) {
      const attribute = program.attributeData[attributeKeys[i]];
      keyGen[index++] = attribute.location;
    }
    const stringKey = keyGen.join("|");
    program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
    return program._attributeLocationsKey;
  }
  /**
   * Returns a hash of buffer names mapped to bind locations.
   * This is used to bind the correct buffer to the correct location in the shader.
   * @param geometry - The geometry where to get the buffer names
   * @param program - The program where to get the buffer names
   * @returns An object of buffer names mapped to the bind location.
   */
  getBufferNamesToBind(geometry, program) {
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];
    const data = this._createVertexBufferLayouts(geometry, program);
    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
    const attributeData = program.attributeData;
    for (let i = 0; i < data.length; i++) {
      const attributes = Object.values(data[i].attributes);
      const shaderLocation = attributes[0].shaderLocation;
      for (const j in attributeData) {
        if (attributeData[j].location === shaderLocation) {
          bufferNamesToBind[i] = j;
          break;
        }
      }
    }
    this._bindingNamesCache[key] = bufferNamesToBind;
    return bufferNamesToBind;
  }
  _createVertexBufferLayouts(geometry, program) {
    if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);
    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
    if (this._bufferLayoutsCache[key]) {
      return this._bufferLayoutsCache[key];
    }
    const vertexBuffersLayout = [];
    geometry.buffers.forEach((buffer) => {
      const bufferEntry = {
        arrayStride: 0,
        stepMode: "vertex",
        attributes: []
      };
      const bufferEntryAttributes = bufferEntry.attributes;
      for (const i in program.attributeData) {
        const attribute = geometry.attributes[i];
        if ((attribute.divisor ?? 1) !== 1) {
          warn$2(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
        }
        if (attribute.buffer === buffer) {
          bufferEntry.arrayStride = attribute.stride;
          bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
          bufferEntryAttributes.push({
            shaderLocation: program.attributeData[i].location,
            offset: attribute.offset,
            format: attribute.format
          });
        }
      }
      if (bufferEntryAttributes.length) {
        vertexBuffersLayout.push(bufferEntry);
      }
    });
    this._bufferLayoutsCache[key] = vertexBuffersLayout;
    return vertexBuffersLayout;
  }
  _updatePipeHash() {
    const key = getGlobalStateKey(
      this._stencilMode,
      this._multisampleCount,
      this._colorMask,
      this._depthStencilAttachment,
      this._colorTargetCount
    );
    if (!this._pipeStateCaches[key]) {
      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
    }
    this._pipeCache = this._pipeStateCaches[key];
  }
  destroy() {
    this._renderer = null;
    this._bufferLayoutsCache = null;
  }
}
/** @ignore */
PipelineSystem.extension = {
  type: [ExtensionType.WebGPUSystem],
  name: "pipeline"
};

class GpuRenderTarget {
  constructor() {
    this.contexts = [];
    this.msaaTextures = [];
    this.msaaSamples = 1;
  }
}

class GpuRenderTargetAdaptor {
  init(renderer, renderTargetSystem) {
    this._renderer = renderer;
    this._renderTargetSystem = renderTargetSystem;
  }
  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
    const renderer = this._renderer;
    const baseGpuTexture = this._getGpuColorTexture(
      sourceRenderSurfaceTexture
    );
    const backGpuTexture = renderer.texture.getGpuSource(
      destinationTexture.source
    );
    renderer.encoder.commandEncoder.copyTextureToTexture(
      {
        texture: baseGpuTexture,
        origin: originSrc
      },
      {
        texture: backGpuTexture,
        origin: originDest
      },
      size
    );
    return destinationTexture;
  }
  startRenderPass(renderTarget, clear = true, clearColor, viewport, mipLevel = 0, layer = 0) {
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (layer !== 0 && gpuRenderTarget.msaaTextures?.length) {
      throw new Error("[RenderTargetSystem] Rendering to array layers is not supported with MSAA render targets.");
    }
    if (mipLevel > 0 && gpuRenderTarget.msaaTextures?.length) {
      throw new Error("[RenderTargetSystem] Rendering to mip levels is not supported with MSAA render targets.");
    }
    const descriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);
    gpuRenderTarget.descriptor = descriptor;
    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
    this._renderer.encoder.beginRenderPass(gpuRenderTarget);
    this._renderer.encoder.setViewport(viewport);
  }
  finishRenderPass() {
    this._renderer.encoder.endRenderPass();
  }
  /**
   * returns the gpu texture for the first color texture in the render target
   * mainly used by the filter manager to get copy the texture for blending
   * @param renderTarget
   * @returns a gpu texture
   */
  _getGpuColorTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (gpuRenderTarget.contexts[0]) {
      return gpuRenderTarget.contexts[0].getCurrentTexture();
    }
    return this._renderer.texture.getGpuSource(
      renderTarget.colorTextures[0].source
    );
  }
  getDescriptor(renderTarget, clear, clearValue, mipLevel = 0, layer = 0) {
    if (typeof clear === "boolean") {
      clear = clear ? CLEAR.ALL : CLEAR.NONE;
    }
    const renderTargetSystem = this._renderTargetSystem;
    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
    const colorAttachments = renderTarget.colorTextures.map(
      (texture, i) => {
        const context = gpuRenderTarget.contexts[i];
        let view;
        let resolveTarget;
        if (context) {
          if (layer !== 0) {
            throw new Error("[RenderTargetSystem] Rendering to array layers is not supported for canvas targets.");
          }
          const currentTexture = context.getCurrentTexture();
          const canvasTextureView = currentTexture.createView();
          view = canvasTextureView;
        } else {
          view = this._renderer.texture.getGpuSource(texture).createView({
            // Render attachments must be 2d views; for array/cube textures we select a single layer.
            dimension: "2d",
            baseMipLevel: mipLevel,
            mipLevelCount: 1,
            baseArrayLayer: layer,
            arrayLayerCount: 1
          });
        }
        if (gpuRenderTarget.msaaTextures[i]) {
          resolveTarget = view;
          view = this._renderer.texture.getTextureView(
            gpuRenderTarget.msaaTextures[i]
          );
        }
        const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
        return {
          view,
          resolveTarget,
          clearValue,
          storeOp: "store",
          loadOp
        };
      }
    );
    let depthStencilAttachment;
    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
      renderTarget.ensureDepthStencilTexture();
      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
    }
    if (renderTarget.depthStencilTexture) {
      const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
      const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
      depthStencilAttachment = {
        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView({
          dimension: "2d",
          baseMipLevel: mipLevel,
          mipLevelCount: 1,
          baseArrayLayer: layer,
          arrayLayerCount: 1
        }),
        stencilStoreOp: "store",
        stencilLoadOp,
        depthClearValue: 1,
        depthLoadOp,
        depthStoreOp: "store"
      };
    }
    const descriptor = {
      colorAttachments,
      depthStencilAttachment
    };
    return descriptor;
  }
  clear(renderTarget, clear = true, clearColor, viewport, mipLevel = 0, layer = 0) {
    if (!clear) return;
    const { gpu, encoder } = this._renderer;
    const device = gpu.device;
    const standAlone = encoder.commandEncoder === null;
    if (standAlone) {
      const commandEncoder = device.createCommandEncoder();
      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor, mipLevel, layer);
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      passEncoder.end();
      const gpuCommands = commandEncoder.finish();
      device.queue.submit([gpuCommands]);
    } else {
      this.startRenderPass(renderTarget, clear, clearColor, viewport, mipLevel, layer);
    }
  }
  initGpuRenderTarget(renderTarget) {
    renderTarget.isRoot = true;
    const gpuRenderTarget = new GpuRenderTarget();
    gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;
    renderTarget.colorTextures.forEach((colorTexture, i) => {
      if (colorTexture instanceof CanvasSource) {
        const context = colorTexture.resource.getContext(
          "webgpu"
        );
        const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
        try {
          context.configure({
            device: this._renderer.gpu.device,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            format: "bgra8unorm",
            alphaMode
          });
        } catch (e) {
          console.error(e);
        }
        gpuRenderTarget.contexts[i] = context;
      }
      gpuRenderTarget.msaa = colorTexture.source.antialias;
      if (colorTexture.source.antialias) {
        const msaaTexture = new TextureSource({
          width: 0,
          height: 0,
          sampleCount: 4,
          arrayLayerCount: colorTexture.source.arrayLayerCount
        });
        gpuRenderTarget.msaaTextures[i] = msaaTexture;
      }
    });
    if (gpuRenderTarget.msaa) {
      gpuRenderTarget.msaaSamples = 4;
      if (renderTarget.depthStencilTexture) {
        renderTarget.depthStencilTexture.source.sampleCount = 4;
      }
    }
    return gpuRenderTarget;
  }
  destroyGpuRenderTarget(gpuRenderTarget) {
    gpuRenderTarget.contexts.forEach((context) => {
      context.unconfigure();
    });
    gpuRenderTarget.msaaTextures.forEach((texture) => {
      texture.destroy();
    });
    gpuRenderTarget.msaaTextures.length = 0;
    gpuRenderTarget.contexts.length = 0;
  }
  ensureDepthStencilTexture(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
      renderTarget.depthStencilTexture.source.sampleCount = 4;
    }
  }
  resizeGpuRenderTarget(renderTarget) {
    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
    gpuRenderTarget.width = renderTarget.width;
    gpuRenderTarget.height = renderTarget.height;
    if (gpuRenderTarget.msaa) {
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        const msaaTexture = gpuRenderTarget.msaaTextures[i];
        msaaTexture?.resize(
          colorTexture.source.width,
          colorTexture.source.height,
          colorTexture.source._resolution
        );
      });
    }
  }
}

class GpuRenderTargetSystem extends RenderTargetSystem {
  constructor(renderer) {
    super(renderer);
    this.adaptor = new GpuRenderTargetAdaptor();
    this.adaptor.init(renderer, this);
  }
}
/** @ignore */
GpuRenderTargetSystem.extension = {
  type: [ExtensionType.WebGPUSystem],
  name: "renderTarget"
};

class GpuShaderSystem {
  constructor() {
    this._gpuProgramData = /* @__PURE__ */ Object.create(null);
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  getProgramData(program) {
    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
  }
  _createGPUProgramData(program) {
    const device = this._gpu.device;
    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
    this._gpuProgramData[program._layoutKey] = {
      bindGroups,
      pipeline: device.createPipelineLayout(pipelineLayoutDesc)
    };
    return this._gpuProgramData[program._layoutKey];
  }
  destroy() {
    this._gpu = null;
    this._gpuProgramData = null;
  }
}
/** @ignore */
GpuShaderSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "shader"
};

const GpuBlendModesToPixi = {};
GpuBlendModesToPixi.normal = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi.add = {
  alpha: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  }
};
GpuBlendModesToPixi.multiply = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "dst",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi.screen = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.overlay = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.none = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "zero",
    operation: "add"
  }
};
GpuBlendModesToPixi["normal-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  }
};
GpuBlendModesToPixi["add-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one",
    operation: "add"
  }
};
GpuBlendModesToPixi["screen-npm"] = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "src-alpha",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.erase = {
  alpha: {
    srcFactor: "zero",
    dstFactor: "one-minus-src-alpha",
    operation: "add"
  },
  color: {
    srcFactor: "zero",
    dstFactor: "one-minus-src",
    operation: "add"
  }
};
GpuBlendModesToPixi.min = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "min"
  }
};
GpuBlendModesToPixi.max = {
  alpha: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  },
  color: {
    srcFactor: "one",
    dstFactor: "one",
    operation: "max"
  }
};

class GpuStateSystem {
  constructor() {
    this.defaultState = new State();
    this.defaultState.blend = true;
  }
  contextChange(gpu) {
    this.gpu = gpu;
  }
  /**
   * Gets the blend mode data for the current state
   * @param state - The state to get the blend mode from
   * @param count - The number of color targets to create
   */
  getColorTargets(state, count) {
    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
    const targets = [];
    const target = {
      format: "bgra8unorm",
      writeMask: 0,
      blend
    };
    for (let i = 0; i < count; i++) {
      targets[i] = target;
    }
    return targets;
  }
  destroy() {
    this.gpu = null;
  }
}
/** @ignore */
GpuStateSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "state"
};

const gpuUploadBufferImageResource = {
  type: "image",
  upload(source, gpuTexture, gpu, originZOverride = 0) {
    const resource = source.resource;
    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);
    const bytesPerPixel = resource.byteLength / total;
    gpu.device.queue.writeTexture(
      { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride } },
      resource,
      {
        offset: 0,
        rowsPerImage: source.pixelHeight,
        bytesPerRow: source.pixelWidth * bytesPerPixel
      },
      {
        width: source.pixelWidth,
        height: source.pixelHeight,
        depthOrArrayLayers: 1
      }
    );
  }
};

const blockDataMap = {
  "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
  "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
  "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
};
const defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
const gpuUploadCompressedTextureResource = {
  type: "compressed",
  upload(source, gpuTexture, gpu, originZOverride = 0) {
    let mipWidth = source.pixelWidth;
    let mipHeight = source.pixelHeight;
    const blockData = blockDataMap[source.format] || defaultBlockData;
    for (let i = 0; i < source.resource.length; i++) {
      const levelBuffer = source.resource[i];
      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
      gpu.device.queue.writeTexture(
        {
          texture: gpuTexture,
          mipLevel: i,
          origin: { x: 0, y: 0, z: originZOverride }
        },
        levelBuffer,
        {
          offset: 0,
          bytesPerRow
        },
        {
          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
          depthOrArrayLayers: 1
        }
      );
      mipWidth = Math.max(mipWidth >> 1, 1);
      mipHeight = Math.max(mipHeight >> 1, 1);
    }
  }
};

const FACE_ORDER = ["right", "left", "top", "bottom", "front", "back"];
function createGpuUploadCubeTextureResource(uploaders) {
  return {
    type: "cube",
    upload(source, gpuTexture, gpu) {
      const faces = source.faces;
      for (let i = 0; i < FACE_ORDER.length; i++) {
        const key = FACE_ORDER[i];
        const face = faces[key];
        const uploader = uploaders[face.uploadMethodId] || uploaders.image;
        uploader.upload(face, gpuTexture, gpu, i);
      }
    }
  };
}

const gpuUploadImageResource = {
  type: "image",
  upload(source, gpuTexture, gpu, originZOverride = 0) {
    const resource = source.resource;
    if (!resource) return;
    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {
      const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);
      const context = canvas.getContext("2d");
      context.drawImage(resource, 0, 0, resource.width, resource.height);
      source.resource = canvas;
      warn$2("ImageSource: Image element passed, converting to canvas and replacing resource.");
    }
    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);
    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);
    const premultipliedAlpha = source.alphaMode === "premultiply-alpha-on-upload";
    gpu.device.queue.copyExternalImageToTexture(
      { source: resource },
      { texture: gpuTexture, origin: { x: 0, y: 0, z: originZOverride }, premultipliedAlpha },
      {
        width,
        height
      }
    );
  }
};

const gpuUploadVideoResource = {
  type: "video",
  upload(source, gpuTexture, gpu, originZOverride) {
    gpuUploadImageResource.upload(source, gpuTexture, gpu, originZOverride);
  }
};

class GpuMipmapGenerator {
  constructor(device) {
    this.device = device;
    this.sampler = device.createSampler({ minFilter: "linear" });
    this.pipelines = {};
  }
  _getMipmapPipeline(format) {
    let pipeline = this.pipelines[format];
    if (!pipeline) {
      if (!this.mipmapShaderModule) {
        this.mipmapShaderModule = this.device.createShaderModule({
          code: (
            /* wgsl */
            `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
          )
        });
      }
      pipeline = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module: this.mipmapShaderModule,
          entryPoint: "vertexMain"
        },
        fragment: {
          module: this.mipmapShaderModule,
          entryPoint: "fragmentMain",
          targets: [{ format }]
        }
      });
      this.pipelines[format] = pipeline;
    }
    return pipeline;
  }
  /**
   * Generates mipmaps for the given GPUTexture from the data in level 0.
   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
   * @returns {module:External.GPUTexture} - The originally passed texture
   */
  generateMipmap(texture) {
    const pipeline = this._getMipmapPipeline(texture.format);
    if (texture.dimension === "3d" || texture.dimension === "1d") {
      throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
    }
    let mipTexture = texture;
    const arrayLayerCount = texture.depthOrArrayLayers || 1;
    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
    if (!renderToSource) {
      const mipTextureDescriptor = {
        size: {
          width: Math.ceil(texture.width / 2),
          height: Math.ceil(texture.height / 2),
          depthOrArrayLayers: arrayLayerCount
        },
        format: texture.format,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
        mipLevelCount: texture.mipLevelCount - 1
      };
      mipTexture = this.device.createTexture(mipTextureDescriptor);
    }
    const commandEncoder = this.device.createCommandEncoder({});
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
      let srcView = texture.createView({
        baseMipLevel: 0,
        mipLevelCount: 1,
        dimension: "2d",
        baseArrayLayer: arrayLayer,
        arrayLayerCount: 1
      });
      let dstMipLevel = renderToSource ? 1 : 0;
      for (let i = 1; i < texture.mipLevelCount; ++i) {
        const dstView = mipTexture.createView({
          baseMipLevel: dstMipLevel++,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: arrayLayer,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: dstView,
            storeOp: "store",
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0, a: 0 }
          }]
        });
        const bindGroup = this.device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: this.sampler
          }, {
            binding: 1,
            resource: srcView
          }]
        });
        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(3, 1, 0, 0);
        passEncoder.end();
        srcView = dstView;
      }
    }
    if (!renderToSource) {
      const mipLevelSize = {
        width: Math.ceil(texture.width / 2),
        height: Math.ceil(texture.height / 2),
        depthOrArrayLayers: arrayLayerCount
      };
      for (let i = 1; i < texture.mipLevelCount; ++i) {
        commandEncoder.copyTextureToTexture({
          texture: mipTexture,
          mipLevel: i - 1
        }, {
          texture,
          mipLevel: i
        }, mipLevelSize);
        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
      }
    }
    this.device.queue.submit([commandEncoder.finish()]);
    if (!renderToSource) {
      mipTexture.destroy();
    }
    return texture;
  }
}

class GPUTextureGpuData {
  constructor(gpuTexture) {
    this.textureView = null;
    this.gpuTexture = gpuTexture;
  }
  /** Destroys this GPU data instance. */
  destroy() {
    this.gpuTexture.destroy();
    this.textureView = null;
    this.gpuTexture = null;
  }
}
class GpuTextureSystem {
  constructor(renderer) {
    this._gpuSamplers = /* @__PURE__ */ Object.create(null);
    this._bindGroupHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.gc.addCollection(this, "_bindGroupHash", "hash");
    this._managedTextures = new GCManagedHash({
      renderer,
      type: "resource",
      onUnload: this.onSourceUnload.bind(this),
      name: "gpuTextureSource"
    });
    const baseUploaders = {
      image: gpuUploadImageResource,
      buffer: gpuUploadBufferImageResource,
      video: gpuUploadVideoResource,
      compressed: gpuUploadCompressedTextureResource
    };
    this._uploads = {
      ...baseUploaders,
      cube: createGpuUploadCubeTextureResource(baseUploaders)
    };
  }
  /**
   * @deprecated since 8.15.0
   */
  get managedTextures() {
    return Object.values(this._managedTextures.items);
  }
  contextChange(gpu) {
    this._gpu = gpu;
  }
  /**
   * Initializes a texture source, if it has already been initialized nothing will happen.
   * @param source - The texture source to initialize.
   * @returns The initialized texture source.
   */
  initSource(source) {
    return source._gpuData[this._renderer.uid]?.gpuTexture || this._initSource(source);
  }
  _initSource(source) {
    if (source.autoGenerateMipmaps) {
      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);
      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
    }
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    if (source.uploadMethodId !== "compressed") {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
      usage |= GPUTextureUsage.COPY_SRC;
    }
    const blockData = blockDataMap[source.format] || { blockWidth: 1, blockHeight: 1 };
    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
    const textureDescriptor = {
      label: source.label,
      size: { width, height, depthOrArrayLayers: source.arrayLayerCount },
      format: source.format,
      sampleCount: source.sampleCount,
      mipLevelCount: source.mipLevelCount,
      dimension: source.dimension,
      usage
    };
    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
    source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);
    const added = this._managedTextures.add(source);
    if (added) {
      source.on("update", this.onSourceUpdate, this);
      source.on("resize", this.onSourceResize, this);
      source.on("updateMipmaps", this.onUpdateMipmaps, this);
    }
    this.onSourceUpdate(source);
    return gpuTexture;
  }
  onSourceUpdate(source) {
    const gpuTexture = this.getGpuSource(source);
    if (!gpuTexture) return;
    if (this._uploads[source.uploadMethodId]) {
      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);
    }
    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {
      this.onUpdateMipmaps(source);
    }
  }
  onUpdateMipmaps(source) {
    if (!this._mipmapGenerator) {
      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
    }
    const gpuTexture = this.getGpuSource(source);
    this._mipmapGenerator.generateMipmap(gpuTexture);
  }
  onSourceUnload(source) {
    source.off("update", this.onSourceUpdate, this);
    source.off("resize", this.onSourceResize, this);
    source.off("updateMipmaps", this.onUpdateMipmaps, this);
  }
  onSourceResize(source) {
    source._gcLastUsed = this._renderer.gc.now;
    const gpuData = source._gpuData[this._renderer.uid];
    const gpuTexture = gpuData?.gpuTexture;
    if (!gpuTexture) {
      this.initSource(source);
    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {
      gpuData.destroy();
      this._bindGroupHash[source.uid] = null;
      source._gpuData[this._renderer.uid] = null;
      this.initSource(source);
    }
  }
  _initSampler(sampler) {
    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
    return this._gpuSamplers[sampler._resourceId];
  }
  getGpuSampler(sampler) {
    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
  }
  getGpuSource(source) {
    source._gcLastUsed = this._renderer.gc.now;
    return source._gpuData[this._renderer.uid]?.gpuTexture || this.initSource(source);
  }
  /**
   * this returns s bind group for a specific texture, the bind group contains
   * - the texture source
   * - the texture style
   * - the texture matrix
   * This is cached so the bind group should only be created once per texture
   * @param texture - the texture you want the bindgroup for
   * @returns the bind group for the texture
   */
  getTextureBindGroup(texture) {
    return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);
  }
  _createTextureBindGroup(texture) {
    const source = texture.source;
    this._bindGroupHash[texture.uid] = new BindGroup({
      0: source,
      1: source.style,
      2: new UniformGroup({
        uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
      })
    });
    return this._bindGroupHash[texture.uid];
  }
  getTextureView(texture) {
    const source = texture.source;
    source._gcLastUsed = this._renderer.gc.now;
    let gpuData = source._gpuData[this._renderer.uid];
    if (!gpuData) {
      this.initSource(source);
      gpuData = source._gpuData[this._renderer.uid];
    }
    gpuData.textureView || (gpuData.textureView = gpuData.gpuTexture.createView({ dimension: source.viewDimension }));
    return gpuData.textureView;
  }
  generateCanvas(texture) {
    const renderer = this._renderer;
    const commandEncoder = renderer.gpu.device.createCommandEncoder();
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = texture.source.pixelWidth;
    canvas.height = texture.source.pixelHeight;
    const context = canvas.getContext("webgpu");
    context.configure({
      device: renderer.gpu.device,
      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
      alphaMode: "premultiplied"
    });
    commandEncoder.copyTextureToTexture({
      texture: renderer.texture.getGpuSource(texture.source),
      origin: {
        x: 0,
        y: 0
      }
    }, {
      texture: context.getCurrentTexture()
    }, {
      width: canvas.width,
      height: canvas.height
    });
    renderer.gpu.device.queue.submit([commandEncoder.finish()]);
    return canvas;
  }
  getPixels(texture) {
    const webGPUCanvas = this.generateCanvas(texture);
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
    const context = canvasAndContext.context;
    context.drawImage(webGPUCanvas, 0, 0);
    const { width, height } = webGPUCanvas;
    const imageData = context.getImageData(0, 0, width, height);
    const pixels = new Uint8ClampedArray(imageData.data.buffer);
    CanvasPool.returnCanvasAndContext(canvasAndContext);
    return { pixels, width, height };
  }
  destroy() {
    this._managedTextures.destroy();
    for (const k of Object.keys(this._bindGroupHash)) {
      const key = Number(k);
      const bindGroup = this._bindGroupHash[key];
      bindGroup?.destroy();
    }
    this._renderer = null;
    this._gpu = null;
    this._mipmapGenerator = null;
    this._gpuSamplers = null;
    this._bindGroupHash = null;
  }
}
/** @ignore */
GpuTextureSystem.extension = {
  type: [
    ExtensionType.WebGPUSystem
  ],
  name: "texture"
};

class GpuGraphicsAdaptor {
  constructor() {
    this._maxTextures = 0;
  }
  contextChange(renderer) {
    const localUniforms = new UniformGroup({
      uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
      uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
      uRound: { value: 0, type: "f32" }
    });
    this._maxTextures = renderer.limits.maxBatchableTextures;
    const gpuProgram = compileHighShaderGpuProgram({
      name: "graphics",
      bits: [
        colorBit,
        generateTextureBatchBit(this._maxTextures),
        localUniformBitGroup2,
        roundPixelsBit
      ]
    });
    this.shader = new Shader({
      gpuProgram,
      resources: {
        // added on the fly!
        localUniforms
      }
    });
  }
  execute(graphicsPipe, renderable) {
    const context = renderable.context;
    const shader = context.customShader || this.shader;
    const renderer = graphicsPipe.renderer;
    const contextSystem = renderer.graphicsContext;
    const {
      batcher,
      instructions
    } = contextSystem.getContextRenderData(context);
    const encoder = renderer.encoder;
    encoder.setGeometry(batcher.geometry, shader.gpuProgram);
    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
    const batches = instructions.instructions;
    let topology = null;
    for (let i = 0; i < instructions.instructionSize; i++) {
      const batch = batches[i];
      if (batch.topology !== topology) {
        topology = batch.topology;
        encoder.setPipelineFromGeometryProgramAndState(
          batcher.geometry,
          shader.gpuProgram,
          graphicsPipe.state,
          batch.topology
        );
      }
      shader.groups[1] = batch.bindGroup;
      if (!batch.gpuBindGroup) {
        const textureBatch = batch.textures;
        batch.bindGroup = getTextureBatchBindGroup(
          textureBatch.textures,
          textureBatch.count,
          this._maxTextures
        );
        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          shader.gpuProgram,
          1
        );
      }
      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
    }
  }
  destroy() {
    this.shader.destroy(true);
    this.shader = null;
  }
}
/** @ignore */
GpuGraphicsAdaptor.extension = {
  type: [
    ExtensionType.WebGPUPipesAdaptor
  ],
  name: "graphics"
};

class GpuMeshAdapter {
  init() {
    const gpuProgram = compileHighShaderGpuProgram({
      name: "mesh",
      bits: [
        localUniformBit,
        textureBit,
        roundPixelsBit
      ]
    });
    this._shader = new Shader({
      gpuProgram,
      resources: {
        uTexture: Texture.EMPTY._source,
        uSampler: Texture.EMPTY._source.style,
        textureUniforms: {
          uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
        }
      }
    });
  }
  execute(meshPipe, mesh) {
    const renderer = meshPipe.renderer;
    let shader = mesh._shader;
    if (!shader) {
      shader = this._shader;
      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
    } else if (!shader.gpuProgram) {
      warn$2("Mesh shader has no gpuProgram", mesh.shader);
      return;
    }
    const gpuProgram = shader.gpuProgram;
    if (gpuProgram.autoAssignGlobalUniforms) {
      shader.groups[0] = renderer.globalUniforms.bindGroup;
    }
    if (gpuProgram.autoAssignLocalUniforms) {
      const localUniforms = meshPipe.localUniforms;
      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
    }
    renderer.encoder.draw({
      geometry: mesh._geometry,
      shader,
      state: mesh.state
    });
  }
  destroy() {
    this._shader.destroy(true);
    this._shader = null;
  }
}
/** @ignore */
GpuMeshAdapter.extension = {
  type: [
    ExtensionType.WebGPUPipesAdaptor
  ],
  name: "mesh"
};

const DefaultWebGPUSystems = [
  ...SharedSystems,
  GpuUboSystem,
  GpuEncoderSystem,
  GpuDeviceSystem,
  GpuLimitsSystem,
  GpuBufferSystem,
  GpuTextureSystem,
  GpuRenderTargetSystem,
  GpuShaderSystem,
  GpuStateSystem,
  PipelineSystem,
  GpuColorMaskSystem,
  GpuStencilSystem,
  BindGroupSystem
];
const DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
const DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
const systems = [];
const renderPipes = [];
const renderPipeAdaptors = [];
extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
class WebGPURenderer extends AbstractRenderer {
  constructor() {
    const systemConfig = {
      name: "webgpu",
      type: RendererType.WEBGPU,
      systems,
      renderPipes,
      renderPipeAdaptors
    };
    super(systemConfig);
  }
}

var WebGPURenderer$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebGPURenderer: WebGPURenderer
});

extensions.add(browserExt, webworkerExt);

var openseadragon$1 = {exports: {}};

var openseadragon = openseadragon$1.exports;

var hasRequiredOpenseadragon;

function requireOpenseadragon () {
	if (hasRequiredOpenseadragon) return openseadragon$1.exports;
	hasRequiredOpenseadragon = 1;
	(function (module) {
		//! openseadragon 5.0.1
		//! Built on 2024-12-09
		//! Git commit: v5.0.1-0-480de92d
		//! http://openseadragon.github.io
		//! License: http://openseadragon.github.io/license/

		/*
		 * OpenSeadragon
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		/*
		 * Portions of this source file taken from jQuery:
		 *
		 * Copyright 2011 John Resig
		 *
		 * Permission is hereby granted, free of charge, to any person obtaining
		 * a copy of this software and associated documentation files (the
		 * "Software"), to deal in the Software without restriction, including
		 * without limitation the rights to use, copy, modify, merge, publish,
		 * distribute, sublicense, and/or sell copies of the Software, and to
		 * permit persons to whom the Software is furnished to do so, subject to
		 * the following conditions:
		 *
		 * The above copyright notice and this permission notice shall be
		 * included in all copies or substantial portions of the Software.
		 *
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
		 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
		 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
		 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
		 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
		 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 */

		/*
		 * Portions of this source file taken from mattsnider.com:
		 *
		 * Copyright (c) 2006-2013 Matt Snider
		 *
		 * Permission is hereby granted, free of charge, to any person obtaining a
		 * copy of this software and associated documentation files (the "Software"),
		 * to deal in the Software without restriction, including without limitation
		 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
		 * and/or sell copies of the Software, and to permit persons to whom the
		 * Software is furnished to do so, subject to the following conditions:
		 *
		 * The above copyright notice and this permission notice shall be included
		 * in all copies or substantial portions of the Software.
		 *
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
		 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
		 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
		 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
		 * OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
		 * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 */


		/**
		 * @namespace OpenSeadragon
		 * @version openseadragon 5.0.1
		 * @classdesc The root namespace for OpenSeadragon.  All utility methods
		 * and classes are defined on or below this namespace.
		 *
		 */


		// Typedefs

		 /**
		  * All required and optional settings for instantiating a new instance of an OpenSeadragon image viewer.
		  *
		  * @typedef {Object} Options
		  * @memberof OpenSeadragon
		  *
		  * @property {String} id
		  *     Id of the element to append the viewer's container element to. If not provided, the 'element' property must be provided.
		  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
		  *
		  * @property {Element} element
		  *     The element to append the viewer's container element to. If not provided, the 'id' property must be provided.
		  *     If both the element and id properties are specified, the viewer is appended to the element provided in the element property.
		  *
		  * @property {Array|String|Function|Object} [tileSources=null]
		  *     Tile source(s) to open initially. This is a complex parameter; see
		  *     {@link OpenSeadragon.Viewer#open} for details.
		  *
		  * @property {Number} [tabIndex=0]
		  *     Tabbing order index to assign to the viewer element. Positive values are selected in increasing order. When tabIndex is 0
		  *     source order is used. A negative value omits the viewer from the tabbing order.
		  *
		  * @property {Array} overlays Array of objects defining permanent overlays of
		  *     the viewer. The overlays added via this option and later removed with
		  *     {@link OpenSeadragon.Viewer#removeOverlay} will be added back when a new
		  *     image is opened.
		  *     To add overlays which can be definitively removed, one must use
		  *     {@link OpenSeadragon.Viewer#addOverlay}
		  *     If displaying a sequence of images, the overlays can be associated
		  *     with a specific page by passing the overlays array to the page's
		  *     tile source configuration.
		  *     Expected properties:
		  *     * x, y, (or px, py for pixel coordinates) to define the location.
		  *     * width, height in point if using x,y or in pixels if using px,py. If width
		  *       and height are specified, the overlay size is adjusted when zooming,
		  *       otherwise the size stays the size of the content (or the size defined by CSS).
		  *     * className to associate a class to the overlay
		  *     * id to set the overlay element. If an element with this id already exists,
		  *       it is reused, otherwise it is created. If not specified, a new element is
		  *       created.
		  *     * placement a string to define the relative position to the viewport.
		  *       Only used if no width and height are specified. Default: 'TOP_LEFT'.
		  *       See {@link OpenSeadragon.Placement} for possible values.
		  *
		  * @property {String} [xmlPath=null]
		  *     <strong>DEPRECATED</strong>. A relative path to load a DZI file from the server.
		  *     Prefer the newer Options.tileSources.
		  *
		  * @property {String} [prefixUrl='/images/']
		  *     Prepends the prefixUrl to navImages paths, which is very useful
		  *     since the default paths are rarely useful for production
		  *     environments.
		  *
		  * @property {OpenSeadragon.NavImages} [navImages]
		  *     An object with a property for each button or other built-in navigation
		  *     control, eg the current 'zoomIn', 'zoomOut', 'home', and 'fullpage'.
		  *     Each of those in turn provides an image path for each state of the button
		  *     or navigation control, eg 'REST', 'GROUP', 'HOVER', 'PRESS'. Finally the
		  *     image paths, by default assume there is a folder on the servers root path
		  *     called '/images', eg '/images/zoomin_rest.png'.  If you need to adjust
		  *     these paths, prefer setting the option.prefixUrl rather than overriding
		  *     every image path directly through this setting.
		  *
		  * @property {Boolean} [debugMode=false]
		  *     TODO: provide an in-screen panel providing event detail feedback.
		  *
		  * @property {String} [debugGridColor=['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666']]
		  *     The colors of grids in debug mode. Each tiled image's grid uses a consecutive color.
		  *     If there are more tiled images than provided colors, the color vector is recycled.
		  *
		  * @property {Boolean} [silenceMultiImageWarnings=false]
		  *     Silences warnings when calling viewport coordinate functions with multi-image.
		  *     Useful when you're overlaying multiple images on top of one another.
		  *
		  * @property {Number} [blendTime=0]
		  *     Specifies the duration of animation as higher or lower level tiles are
		  *     replacing the existing tile.
		  *
		  * @property {Boolean} [alwaysBlend=false]
		  *     Forces the tile to always blend.  By default the tiles skip blending
		  *     when the blendTime is surpassed and the current animation frame would
		  *     not complete the blend.
		  *
		  * @property {Boolean} [autoHideControls=true]
		  *     If the user stops interacting with the viewport, fade the navigation
		  *     controls.  Useful for presentation since the controls are by default
		  *     floated on top of the image the user is viewing.
		  *
		  * @property {Boolean} [immediateRender=false]
		  *     Render the best closest level first, ignoring the lowering levels which
		  *     provide the effect of very blurry to sharp. It is recommended to change
		  *     setting to true for mobile devices.
		  *
		  * @property {Number} [defaultZoomLevel=0]
		  *     Zoom level to use when image is first opened or the home button is clicked.
		  *     If 0, adjusts to fit viewer.
		  *
		  * @property {String|DrawerImplementation|Array} [drawer = ['webgl', 'canvas', 'html']]
		  *     Which drawer to use. Valid strings are 'webgl', 'canvas', and 'html'. Valid drawer
		  *     implementations are constructors of classes that extend OpenSeadragon.DrawerBase.
		  *     An array of strings and/or constructors can be used to indicate the priority
		  *     of different implementations, which will be tried in order based on browser support.
		  *
		  * @property {Object} drawerOptions
		  *     Options to pass to the selected drawer implementation. For details
		  *     please see {@link OpenSeadragon.DrawerOptions}.
		  *
		  * @property {Number} [opacity=1]
		  *     Default proportional opacity of the tiled images (1=opaque, 0=hidden)
		  *     Hidden images do not draw and only load when preloading is allowed.
		  *
		  * @property {Boolean} [preload=false]
		  *     Default switch for loading hidden images (true loads, false blocks)
		  *
		  * @property {String} [compositeOperation=null]
		  *     Valid values are 'source-over', 'source-atop', 'source-in', 'source-out',
		  *     'destination-over', 'destination-atop', 'destination-in', 'destination-out',
		  *     'lighter', 'difference', 'copy', 'xor', etc.
		  *     For complete list of modes, please @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation/ globalCompositeOperation}
		  *
		  * @property {Boolean} [imageSmoothingEnabled=true]
		  *     Image smoothing for rendering (only if the canvas or webgl drawer is used). Note: Ignored
		  *     by some (especially older) browsers which do not support this canvas property.
		  *     This property can be changed in {@link Viewer.DrawerBase.setImageSmoothingEnabled}.
		  *
		  * @property {String|CanvasGradient|CanvasPattern|Function} [placeholderFillStyle=null]
		  *     Draws a colored rectangle behind the tile if it is not loaded yet.
		  *     You can pass a CSS color value like "#FF8800".
		  *     When passing a function the tiledImage and canvas context are available as argument which is useful when you draw a gradient or pattern.
		  *
		  * @property {Object} [subPixelRoundingForTransparency=null]
		  *     Determines when subpixel rounding should be applied for tiles when rendering images that support transparency.
		  *     This property is a subpixel rounding enum values dictionary [{@link BROWSERS}] --> {@link SUBPIXEL_ROUNDING_OCCURRENCES}.
		  *     The key is a {@link BROWSERS} value, and the value is one of {@link SUBPIXEL_ROUNDING_OCCURRENCES},
		  *     indicating, for a given browser, when to apply subpixel rounding.
		  *     Key '*' is the fallback value for any browser not specified in the dictionary.
		  *     This property has a simple mode, and one can set it directly to
		  *     {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER}, {@link SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST} or {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS}
		  *     in order to apply this rule for all browser. The values {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS} would be equivalent to { '*', SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS }.
		  *     The default is {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} for all browsers, for backward compatibility reason.
		  *
		  * @property {Number} [degrees=0]
		  *     Initial rotation.
		  *
		  * @property {Boolean} [flipped=false]
		  *     Initial flip state.
		  *
		  * @property {Boolean} [overlayPreserveContentDirection=true]
		  *     When the viewport is flipped (by pressing 'f'), the overlay is flipped using ScaleX.
		  *     Normally, this setting (default true) keeps the overlay's content readable by flipping it back.
		  *     To make the content flip with the overlay, set overlayPreserveContentDirection to false.
		  *
		  * @property {Number} [minZoomLevel=null]
		  *
		  * @property {Number} [maxZoomLevel=null]
		  *
		  * @property {Boolean} [homeFillsViewer=false]
		  *     Make the 'home' button fill the viewer and clip the image, instead
		  *     of fitting the image to the viewer and letterboxing.
		  *
		  * @property {Boolean} [panHorizontal=true]
		  *     Allow horizontal pan.
		  *
		  * @property {Boolean} [panVertical=true]
		  *     Allow vertical pan.
		  *
		  * @property {Boolean} [constrainDuringPan=false]
		  *
		  * @property {Boolean} [wrapHorizontal=false]
		  *     Set to true to force the image to wrap horizontally within the viewport.
		  *     Useful for maps or images representing the surface of a sphere or cylinder.
		  *
		  * @property {Boolean} [wrapVertical=false]
		  *     Set to true to force the image to wrap vertically within the viewport.
		  *     Useful for maps or images representing the surface of a sphere or cylinder.
		  *
		  * @property {Number} [minZoomImageRatio=0.9]
		  *     The minimum percentage ( expressed as a number between 0 and 1 ) of
		  *     the viewport height or width at which the zoom out will be constrained.
		  *     Setting it to 0, for example will allow you to zoom out infinity.
		  *
		  * @property {Number} [maxZoomPixelRatio=1.1]
		  *     The maximum ratio to allow a zoom-in to affect the highest level pixel
		  *     ratio. This can be set to Infinity to allow 'infinite' zooming into the
		  *     image though it is less effective visually if the HTML5 Canvas is not
		  *     available on the viewing device.
		  *
		  * @property {Number} [smoothTileEdgesMinZoom=1.1]
		  *     A zoom percentage ( where 1 is 100% ) of the highest resolution level.
		  *     When zoomed in beyond this value alternative compositing will be used to
		  *     smooth out the edges between tiles. This will have a performance impact.
		  *     Can be set to Infinity to turn it off.
		  *     Note: This setting is ignored on iOS devices due to a known bug (See {@link https://github.com/openseadragon/openseadragon/issues/952})
		  *
		  * @property {Boolean} [iOSDevice=?]
		  *     True if running on an iOS device, false otherwise.
		  *     Used to disable certain features that behave differently on iOS devices.
		  *
		  * @property {Boolean} [autoResize=true]
		  *     Set to false to prevent polling for viewer size changes. Useful for providing custom resize behavior.
		  *
		  * @property {Boolean} [preserveImageSizeOnResize=false]
		  *     Set to true to have the image size preserved when the viewer is resized. This requires autoResize=true (default).
		  *
		  * @property {Number} [minScrollDeltaTime=50]
		  *     Number of milliseconds between canvas-scroll events. This value helps normalize the rate of canvas-scroll
		  *     events between different devices, causing the faster devices to slow down enough to make the zoom control
		  *     more manageable.
		  *
		  * @property {Number} [rotationIncrement=90]
		  *     The number of degrees to rotate right or left when the rotate buttons or keyboard shortcuts are activated.
		  *
		  * @property {Number} [maxTilesPerFrame=1]
		  *     The number of tiles loaded per frame. As the frame rate of the client's machine is usually high (e.g., 50 fps),
		  *     one tile per frame should be a good choice. However, for large screens or lower frame rates, the number of
		  *     loaded tiles per frame can be adjusted here. Reasonable values might be 2 or 3 tiles per frame.
		  *     (Note that the actual frame rate is given by the client's browser and machine).
		  *
		  * @property {Number} [pixelsPerWheelLine=40]
		  *     For pixel-resolution scrolling devices, the number of pixels equal to one scroll line.
		  *
		  * @property {Number} [pixelsPerArrowPress=40]
		  *     The number of pixels viewport moves when an arrow key is pressed.
		  *
		  * @property {Number} [visibilityRatio=0.5]
		  *     The percentage ( as a number from 0 to 1 ) of the source image which
		  *     must be kept within the viewport.  If the image is dragged beyond that
		  *     limit, it will 'bounce' back until the minimum visibility ratio is
		  *     achieved.  Setting this to 0 and wrapHorizontal ( or wrapVertical ) to
		  *     true will provide the effect of an infinitely scrolling viewport.
		  *
		  * @property {Object} [viewportMargins={}]
		  *     Pushes the "home" region in from the sides by the specified amounts.
		  *     Possible subproperties (Numbers, in screen coordinates): left, top, right, bottom.
		  *
		  * @property {Number} [imageLoaderLimit=0]
		  *     The maximum number of image requests to make concurrently. By default
		  *     it is set to 0 allowing the browser to make the maximum number of
		  *     image requests in parallel as allowed by the browsers policy.
		  *
		  * @property {Number} [clickTimeThreshold=300]
		  *      The number of milliseconds within which a pointer down-up event combination
		  *      will be treated as a click gesture.
		  *
		  * @property {Number} [clickDistThreshold=5]
		  *      The maximum distance allowed between a pointer down event and a pointer up event
		  *      to be treated as a click gesture.
		  *
		  * @property {Number} [dblClickTimeThreshold=300]
		  *      The number of milliseconds within which two pointer down-up event combinations
		  *      will be treated as a double-click gesture.
		  *
		  * @property {Number} [dblClickDistThreshold=20]
		  *      The maximum distance allowed between two pointer click events
		  *      to be treated as a double-click gesture.
		  *
		  * @property {Number} [springStiffness=6.5]
		  *
		  * @property {Number} [animationTime=1.2]
		  *     Specifies the animation duration per each {@link OpenSeadragon.Spring}
		  *     which occur when the image is dragged, zoomed or rotated.
		  *
		  * @property {OpenSeadragon.GestureSettings} [gestureSettingsMouse]
		  *     Settings for gestures generated by a mouse pointer device. (See {@link OpenSeadragon.GestureSettings})
		  * @property {Boolean} [gestureSettingsMouse.dragToPan=true] - Pan on drag gesture
		  * @property {Boolean} [gestureSettingsMouse.scrollToZoom=true] - Zoom on scroll gesture
		  * @property {Boolean} [gestureSettingsMouse.clickToZoom=true] - Zoom on click gesture
		  * @property {Boolean} [gestureSettingsMouse.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  * @property {Boolean} [gestureSettingsMouse.dblClickDragToZoom=false] - Zoom on dragging through
		  * double-click gesture ( single click and next click to drag).  Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  * @property {Boolean} [gestureSettingsMouse.pinchToZoom=false] - Zoom on pinch gesture
		  * @property {Boolean} [gestureSettingsMouse.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
		  *     the zoom is centered at the canvas center.
		  * @property {Boolean} [gestureSettingsMouse.flickEnabled=false] - Enable flick gesture
		  * @property {Number} [gestureSettingsMouse.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
		  * @property {Number} [gestureSettingsMouse.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
		  * @property {Boolean} [gestureSettingsMouse.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
		  *
		  * @property {OpenSeadragon.GestureSettings} [gestureSettingsTouch]
		  *     Settings for gestures generated by a touch pointer device. (See {@link OpenSeadragon.GestureSettings})
		  * @property {Boolean} [gestureSettingsTouch.dragToPan=true] - Pan on drag gesture
		  * @property {Boolean} [gestureSettingsTouch.scrollToZoom=false] - Zoom on scroll gesture
		  * @property {Boolean} [gestureSettingsTouch.clickToZoom=false] - Zoom on click gesture
		  * @property {Boolean} [gestureSettingsTouch.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		    * @property {Boolean} [gestureSettingsTouch.dblClickDragToZoom=true] - Zoom on dragging through
		  * double-click gesture ( single click and next click to drag).  Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.

		  * @property {Boolean} [gestureSettingsTouch.pinchToZoom=true] - Zoom on pinch gesture
		  * @property {Boolean} [gestureSettingsTouch.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
		  *     the zoom is centered at the canvas center.
		  * @property {Boolean} [gestureSettingsTouch.flickEnabled=true] - Enable flick gesture
		  * @property {Number} [gestureSettingsTouch.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
		  * @property {Number} [gestureSettingsTouch.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
		  * @property {Boolean} [gestureSettingsTouch.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
		  *
		  * @property {OpenSeadragon.GestureSettings} [gestureSettingsPen]
		  *     Settings for gestures generated by a pen pointer device. (See {@link OpenSeadragon.GestureSettings})
		  * @property {Boolean} [gestureSettingsPen.dragToPan=true] - Pan on drag gesture
		  * @property {Boolean} [gestureSettingsPen.scrollToZoom=false] - Zoom on scroll gesture
		  * @property {Boolean} [gestureSettingsPen.clickToZoom=true] - Zoom on click gesture
		  * @property {Boolean} [gestureSettingsPen.dblClickToZoom=false] - Zoom on double-click gesture. Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  * @property {Boolean} [gestureSettingsPen.pinchToZoom=false] - Zoom on pinch gesture
		  * @property {Boolean} [gestureSettingsPen.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
		  *     the zoom is centered at the canvas center.
		  * @property {Boolean} [gestureSettingsPen.flickEnabled=false] - Enable flick gesture
		  * @property {Number} [gestureSettingsPen.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
		  * @property {Number} [gestureSettingsPen.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
		  * @property {Boolean} [gestureSettingsPen.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
		  *
		  * @property {OpenSeadragon.GestureSettings} [gestureSettingsUnknown]
		  *     Settings for gestures generated by unknown pointer devices. (See {@link OpenSeadragon.GestureSettings})
		  * @property {Boolean} [gestureSettingsUnknown.dragToPan=true] - Pan on drag gesture
		  * @property {Boolean} [gestureSettingsUnknown.scrollToZoom=true] - Zoom on scroll gesture
		  * @property {Boolean} [gestureSettingsUnknown.clickToZoom=false] - Zoom on click gesture
		  * @property {Boolean} [gestureSettingsUnknown.dblClickToZoom=true] - Zoom on double-click gesture. Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  * @property {Boolean} [gestureSettingsUnknown.dblClickDragToZoom=false] - Zoom on dragging through
		  * double-click gesture ( single click and next click to drag).  Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  * @property {Boolean} [gestureSettingsUnknown.pinchToZoom=true] - Zoom on pinch gesture
		  * @property {Boolean} [gestureSettingsUnknown.zoomToRefPoint=true] - If zoomToRefPoint is true, the zoom is centered at the pointer position. Otherwise,
		  *     the zoom is centered at the canvas center.
		  * @property {Boolean} [gestureSettingsUnknown.flickEnabled=true] - Enable flick gesture
		  * @property {Number} [gestureSettingsUnknown.flickMinSpeed=120] - If flickEnabled is true, the minimum speed to initiate a flick gesture (pixels-per-second)
		  * @property {Number} [gestureSettingsUnknown.flickMomentum=0.25] - If flickEnabled is true, the momentum factor for the flick gesture
		  * @property {Boolean} [gestureSettingsUnknown.pinchRotate=false] - If pinchRotate is true, the user will have the ability to rotate the image using their fingers.
		  *
		  * @property {Number} [zoomPerClick=2.0]
		  *     The "zoom distance" per mouse click or touch tap. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).</em>
		  *
		  * @property {Number} [zoomPerScroll=1.2]
		  *     The "zoom distance" per mouse scroll or touch pinch. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).</em>
		  *
		  * @property {Number} [zoomPerDblClickDrag=1.2]
		  *     The "zoom distance" per double-click mouse drag. <em><strong>Note:</strong> Setting this to 1.0 effectively disables the double-click-drag-to-Zoom feature (also see gestureSettings[Mouse|Touch|Pen].dblClickDragToZoom).</em>
		  *
		  * @property {Number} [zoomPerSecond=1.0]
		  *     Sets the zoom amount per second when zoomIn/zoomOut buttons are pressed and held.
		  *     The value is a factor of the current zoom, so 1.0 (the default) disables zooming when the zoomIn/zoomOut buttons
		  *     are held. Higher values will increase the rate of zoom when the zoomIn/zoomOut buttons are held. Note that values
		  *     < 1.0 will reverse the operation of the zoomIn/zoomOut buttons (zoomIn button will decrease the zoom, zoomOut will
		  *     increase the zoom).
		  *
		  * @property {Boolean} [showNavigator=false]
		  *     Set to true to make the navigator minimap appear.
		  *
		  * @property {Element} [navigatorElement=null]
		  *     The element to hold the navigator minimap.
		  *     If an element is specified, the Id option (see navigatorId) is ignored.
		  *     If no element nor ID is specified, a div element will be generated accordingly.
		  *
		  * @property {String} [navigatorId=navigator-GENERATED DATE]
		  *     The ID of a div to hold the navigator minimap.
		  *     If an ID is specified, the navigatorPosition, navigatorSizeRatio, navigatorMaintainSizeRatio, navigator[Top|Left|Height|Width] and navigatorAutoFade options will be ignored.
		  *     If an ID is not specified, a div element will be generated and placed on top of the main image.
		  *
		  * @property {String} [navigatorPosition='TOP_RIGHT']
		  *     Valid values are 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', 'BOTTOM_RIGHT', or 'ABSOLUTE'.<br>
		  *     If 'ABSOLUTE' is specified, then navigator[Top|Left|Height|Width] determines the size and position of the navigator minimap in the viewer, and navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.<br>
		  *     For 'TOP_LEFT', 'TOP_RIGHT', 'BOTTOM_LEFT', and 'BOTTOM_RIGHT', the navigatorSizeRatio or navigator[Height|Width] values determine the size of the navigator minimap.
		  *
		  * @property {Number} [navigatorSizeRatio=0.2]
		  *     Ratio of navigator size to viewer size. Ignored if navigator[Height|Width] are specified.
		  *
		  * @property {Boolean} [navigatorMaintainSizeRatio=false]
		  *     If true, the navigator minimap is resized (using navigatorSizeRatio) when the viewer size changes.
		  *
		  * @property {Number|String} [navigatorTop=null]
		  *     Specifies the location of the navigator minimap (see navigatorPosition).
		  *
		  * @property {Number|String} [navigatorLeft=null]
		  *     Specifies the location of the navigator minimap (see navigatorPosition).
		  *
		  * @property {Number|String} [navigatorHeight=null]
		  *     Specifies the size of the navigator minimap (see navigatorPosition).
		  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
		  *
		  * @property {Number|String} [navigatorWidth=null]
		  *     Specifies the size of the navigator minimap (see navigatorPosition).
		  *     If specified, navigatorSizeRatio and navigatorMaintainSizeRatio are ignored.
		  *
		  * @property {Boolean} [navigatorAutoResize=true]
		  *     Set to false to prevent polling for navigator size changes. Useful for providing custom resize behavior.
		  *     Setting to false can also improve performance when the navigator is configured to a fixed size.
		  *
		  * @property {Boolean} [navigatorAutoFade=true]
		  *     If the user stops interacting with the viewport, fade the navigator minimap.
		  *     Setting to false will make the navigator minimap always visible.
		  *
		  * @property {Boolean} [navigatorRotate=true]
		  *     If true, the navigator will be rotated together with the viewer.
		  *
		  * @property {String} [navigatorBackground='#000']
		  *     Specifies the background color of the navigator minimap
		  *
		  * @property {Number} [navigatorOpacity=0.8]
		  *     Specifies the opacity of the navigator minimap.
		  *
		  * @property {String} [navigatorBorderColor='#555']
		  *     Specifies the border color of the navigator minimap
		  *
		  * @property {String} [navigatorDisplayRegionColor='#900']
		  *     Specifies the border color of the display region rectangle of the navigator minimap
		  *
		  * @property {Number} [controlsFadeDelay=2000]
		  *     The number of milliseconds to wait once the user has stopped interacting
		  *     with the interface before beginning to fade the controls. Assumes
		  *     showNavigationControl and autoHideControls are both true.
		  *
		  * @property {Number} [controlsFadeLength=1500]
		  *     The number of milliseconds to animate the controls fading out.
		  *
		  * @property {Number} [maxImageCacheCount=200]
		  *     The max number of images we should keep in memory (per drawer).
		  *
		  * @property {Number} [timeout=30000]
		  *     The max number of milliseconds that an image job may take to complete.
		  *
		  * @property {Number} [tileRetryMax=0]
		  *     The max number of retries when a tile download fails. By default it's 0, so retries are disabled.
		  *
		  * @property {Number} [tileRetryDelay=2500]
		  *     Milliseconds to wait after each tile retry if tileRetryMax is set.
		  *
		  * @property {Boolean} [useCanvas=true]
		  *     Deprecated. Use the `drawer` option to specify preferred renderer.
		  *
		  * @property {Number} [minPixelRatio=0.5]
		  *     The higher the minPixelRatio, the lower the quality of the image that
		  *     is considered sufficient to stop rendering a given zoom level.  For
		  *     example, if you are targeting mobile devices with less bandwidth you may
		  *     try setting this to 1.5 or higher.
		  *
		  * @property {Boolean} [mouseNavEnabled=true]
		  *     Is the user able to interact with the image via mouse or touch. Default
		  *     interactions include draging the image in a plane, and zooming in toward
		  *     and away from the image.
		  *
		  * @property {Boolean} [showNavigationControl=true]
		  *     Set to false to prevent the appearance of the default navigation controls.<br>
		  *     Note that if set to false, the customs buttons set by the options
		  *     zoomInButton, zoomOutButton etc, are rendered inactive.
		  *
		  * @property {OpenSeadragon.ControlAnchor} [navigationControlAnchor=TOP_LEFT]
		  *     Placement of the default navigation controls.
		  *     To set the placement of the sequence controls, see the
		  *     sequenceControlAnchor option.
		  *
		  * @property {Boolean} [showZoomControl=true]
		  *     If true then + and - buttons to zoom in and out are displayed.<br>
		  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
		  *     this setting when set to false.
		  *
		  * @property {Boolean} [showHomeControl=true]
		  *     If true then the 'Go home' button is displayed to go back to the original
		  *     zoom and pan.<br>
		  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
		  *     this setting when set to false.
		  *
		  * @property {Boolean} [showFullPageControl=true]
		  *     If true then the 'Toggle full page' button is displayed to switch
		  *     between full page and normal mode.<br>
		  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
		  *     this setting when set to false.
		  *
		  * @property {Boolean} [showRotationControl=false]
		  *     If true then the rotate left/right controls will be displayed as part of the
		  *     standard controls. This is also subject to the browser support for rotate
		  *     (e.g. viewer.drawer.canRotate()).<br>
		  *     Note: {@link OpenSeadragon.Options.showNavigationControl} is overriding
		  *     this setting when set to false.
		  *
		  * @property {Boolean} [showFlipControl=false]
		  *     If true then the flip controls will be displayed as part of the
		  *     standard controls.
		  *
		  * @property {Boolean} [showSequenceControl=true]
		  *     If sequenceMode is true, then provide buttons for navigating forward and
		  *     backward through the images.
		  *
		  * @property {OpenSeadragon.ControlAnchor} [sequenceControlAnchor=TOP_LEFT]
		  *     Placement of the default sequence controls.
		  *
		  * @property {Boolean} [navPrevNextWrap=false]
		  *     If true then the 'previous' button will wrap to the last image when
		  *     viewing the first image and the 'next' button will wrap to the first
		  *     image when viewing the last image.
		  *
		  *@property {String|Element} zoomInButton
		  *     Set the id or element of the custom 'Zoom in' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} zoomOutButton
		  *     Set the id or element of the custom 'Zoom out' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} homeButton
		  *     Set the id or element of the custom 'Go home' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} fullPageButton
		  *     Set the id or element of the custom 'Toggle full page' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} rotateLeftButton
		  *     Set the id or element of the custom 'Rotate left' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} rotateRightButton
		  *     Set the id or element of the custom 'Rotate right' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} previousButton
		  *     Set the id or element of the custom 'Previous page' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {String|Element} nextButton
		  *     Set the id or element of the custom 'Next page' button to use.
		  *     This is useful to have a custom button anywhere in the web page.<br>
		  *     To only change the button images, consider using
		  *     {@link OpenSeadragon.Options.navImages}
		  *
		  * @property {Boolean} [sequenceMode=false]
		  *     Set to true to have the viewer treat your tilesources as a sequence of images to
		  *     be opened one at a time rather than all at once.
		  *
		  * @property {Number} [initialPage=0]
		  *     If sequenceMode is true, display this page initially.
		  *
		  * @property {Boolean} [preserveViewport=false]
		  *     If sequenceMode is true, then normally navigating through each image resets the
		  *     viewport to 'home' position.  If preserveViewport is set to true, then the viewport
		  *     position is preserved when navigating between images in the sequence.
		  *
		  * @property {Boolean} [preserveOverlays=false]
		  *     If sequenceMode is true, then normally navigating through each image
		  *     resets the overlays.
		  *     If preserveOverlays is set to true, then the overlays added with {@link OpenSeadragon.Viewer#addOverlay}
		  *     are preserved when navigating between images in the sequence.
		  *     Note: setting preserveOverlays overrides any overlays specified in the global
		  *     "overlays" option for the Viewer. It's also not compatible with specifying
		  *     per-tileSource overlays via the options, as those overlays will persist
		  *     even after the tileSource is closed.
		  *
		  * @property {Boolean} [showReferenceStrip=false]
		  *     If sequenceMode is true, then display a scrolling strip of image thumbnails for
		  *     navigating through the images.
		  *
		  * @property {String} [referenceStripScroll='horizontal']
		  *
		  * @property {Element} [referenceStripElement=null]
		  *
		  * @property {Number} [referenceStripHeight=null]
		  *
		  * @property {Number} [referenceStripWidth=null]
		  *
		  * @property {String} [referenceStripPosition='BOTTOM_LEFT']
		  *
		  * @property {Number} [referenceStripSizeRatio=0.2]
		  *
		  * @property {Boolean} [collectionMode=false]
		  *     Set to true to have the viewer arrange your TiledImages in a grid or line.
		  *
		  * @property {Number} [collectionRows=3]
		  *     If collectionMode is true, specifies how many rows the grid should have. Use 1 to make a line.
		  *     If collectionLayout is 'vertical', specifies how many columns instead.
		  *
		  * @property {Number} [collectionColumns=0]
		  *     If collectionMode is true, specifies how many columns the grid should have. Use 1 to make a line.
		  *     If collectionLayout is 'vertical', specifies how many rows instead. Ignored if collectionRows is not set to a falsy value.
		  *
		  * @property {String} [collectionLayout='horizontal']
		  *     If collectionMode is true, specifies whether to arrange vertically or horizontally.
		  *
		  * @property {Number} [collectionTileSize=800]
		  *     If collectionMode is true, specifies the size, in viewport coordinates, for each TiledImage to fit into.
		  *     The TiledImage will be centered within a square of the specified size.
		  *
		  * @property {Number} [collectionTileMargin=80]
		  *     If collectionMode is true, specifies the margin, in viewport coordinates, between each TiledImage.
		  *
		  * @property {String|Boolean} [crossOriginPolicy=false]
		  *     Valid values are 'Anonymous', 'use-credentials', and false. If false, canvas requests will
		  *     not use CORS, and the canvas will be tainted.
		  *
		  * @property {Boolean} [ajaxWithCredentials=false]
		  *     Whether to set the withCredentials XHR flag for AJAX requests.
		  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
		  *
		  * @property {Boolean} [loadTilesWithAjax=false]
		  *     Whether to load tile data using AJAX requests.
		  *     Note that this can be overridden at the {@link OpenSeadragon.TileSource} level.
		  *
		  * @property {Object} [ajaxHeaders={}]
		  *     A set of headers to include when making AJAX requests for tile sources or tiles.
		  *
		  * @property {Boolean} [splitHashDataForPost=false]
		  *     Allows to treat _first_ hash ('#') symbol as a separator for POST data:
		  *     URL to be opened by a {@link OpenSeadragon.TileSource} can thus look like: http://some.url#postdata=here.
		  *     The whole URL is used to fetch image info metadata and it is then split to 'http://some.url' and
		  *     'postdata=here'; post data is given to the {@link OpenSeadragon.TileSource} of the choice and can be further
		  *     used within tile requests (see TileSource methods).
		  *     NOTE: {@link OpenSeadragon.TileSource.prototype.configure} return value should contain the post data
		  *     if you want to use it later - so that it is given to your constructor later.
		  *     NOTE: usually, post data is expected to be ampersand-separated (just like GET parameters), and is NOT USED
		  *     to fetch tile image data unless explicitly programmed, or if loadTilesWithAjax=false 4
		  *     (but it is still used for the initial image info request).
		  *     NOTE: passing POST data from URL by this feature only supports string values, however,
		  *     TileSource can send any data using POST as long as the header is correct
		  *     (@see OpenSeadragon.TileSource.prototype.getTilePostData)
		  */

		 /**
		  * Settings for gestures generated by a pointer device.
		  *
		  * @typedef {Object} GestureSettings
		  * @memberof OpenSeadragon
		  *
		  * @property {Boolean} dragToPan
		  *     Set to false to disable panning on drag gestures.
		  *
		  * @property {Boolean} scrollToZoom
		  *     Set to false to disable zooming on scroll gestures.
		  *
		  * @property {Boolean} clickToZoom
		  *     Set to false to disable zooming on click gestures.
		  *
		  * @property {Boolean} dblClickToZoom
		  *     Set to false to disable zooming on double-click gestures. Note: If set to true
		  *     then clickToZoom should be set to false to prevent multiple zooms.
		  *
		  * @property {Boolean} pinchToZoom
		  *     Set to false to disable zooming on pinch gestures.
		  *
		  * @property {Boolean} flickEnabled
		  *     Set to false to disable the kinetic panning effect (flick) at the end of a drag gesture.
		  *
		  * @property {Number} flickMinSpeed
		  *     If flickEnabled is true, the minimum speed (in pixels-per-second) required to cause the kinetic panning effect (flick) at the end of a drag gesture.
		  *
		  * @property {Number} flickMomentum
		  *     If flickEnabled is true, a constant multiplied by the velocity to determine the distance of the kinetic panning effect (flick) at the end of a drag gesture.
		  *     A larger value will make the flick feel "lighter", while a smaller value will make the flick feel "heavier".
		  *     Note: springStiffness and animationTime also affect the "spring" used to stop the flick animation.
		  *
		  */

		 /**
		  * @typedef {Object} DrawerOptions
		  * @memberof OpenSeadragon
		  * @property {Object} webgl - options if the WebGLDrawer is used. No options are currently supported.
		  * @property {Object} canvas - options if the CanvasDrawer is used. No options are currently supported.
		  * @property {Object} html - options if the HTMLDrawer is used. No options are currently supported.
		  * @property {Object} custom - options if a custom drawer is used. No options are currently supported.
		  */


		/**
		  * The names for the image resources used for the image navigation buttons.
		  *
		  * @typedef {Object} NavImages
		  * @memberof OpenSeadragon
		  *
		  * @property {Object} zoomIn - Images for the zoom-in button.
		  * @property {String} zoomIn.REST
		  * @property {String} zoomIn.GROUP
		  * @property {String} zoomIn.HOVER
		  * @property {String} zoomIn.DOWN
		  *
		  * @property {Object} zoomOut - Images for the zoom-out button.
		  * @property {String} zoomOut.REST
		  * @property {String} zoomOut.GROUP
		  * @property {String} zoomOut.HOVER
		  * @property {String} zoomOut.DOWN
		  *
		  * @property {Object} home - Images for the home button.
		  * @property {String} home.REST
		  * @property {String} home.GROUP
		  * @property {String} home.HOVER
		  * @property {String} home.DOWN
		  *
		  * @property {Object} fullpage - Images for the full-page button.
		  * @property {String} fullpage.REST
		  * @property {String} fullpage.GROUP
		  * @property {String} fullpage.HOVER
		  * @property {String} fullpage.DOWN
		  *
		  * @property {Object} rotateleft - Images for the rotate left button.
		  * @property {String} rotateleft.REST
		  * @property {String} rotateleft.GROUP
		  * @property {String} rotateleft.HOVER
		  * @property {String} rotateleft.DOWN
		  *
		  * @property {Object} rotateright - Images for the rotate right button.
		  * @property {String} rotateright.REST
		  * @property {String} rotateright.GROUP
		  * @property {String} rotateright.HOVER
		  * @property {String} rotateright.DOWN
		  *
		  * @property {Object} flip - Images for the flip button.
		  * @property {String} flip.REST
		  * @property {String} flip.GROUP
		  * @property {String} flip.HOVER
		  * @property {String} flip.DOWN
		  *
		  * @property {Object} previous - Images for the previous button.
		  * @property {String} previous.REST
		  * @property {String} previous.GROUP
		  * @property {String} previous.HOVER
		  * @property {String} previous.DOWN
		  *
		  * @property {Object} next - Images for the next button.
		  * @property {String} next.REST
		  * @property {String} next.GROUP
		  * @property {String} next.HOVER
		  * @property {String} next.DOWN
		  *
		  */

		/* eslint-disable no-redeclare */
		function OpenSeadragon( options ){
		    return new OpenSeadragon.Viewer( options );
		}

		(function( $ ){


		    /**
		     * The OpenSeadragon version.
		     *
		     * @member {Object} OpenSeadragon.version
		     * @property {String} versionStr - The version number as a string ('major.minor.revision').
		     * @property {Number} major - The major version number.
		     * @property {Number} minor - The minor version number.
		     * @property {Number} revision - The revision number.
		     * @since 1.0.0
		     */
		    $.version = {
		        versionStr: '5.0.1',
		        major: parseInt('5', 10),
		        minor: parseInt('0', 10),
		        revision: parseInt('1', 10)
		    };


		    /**
		     * Taken from jquery 1.6.1
		     * [[Class]] -> type pairs
		     * @private
		     */
		    var class2type = {
		            '[object Boolean]':       'boolean',
		            '[object Number]':        'number',
		            '[object String]':        'string',
		            '[object Function]':      'function',
		            '[object AsyncFunction]': 'function',
		            '[object Promise]':       'promise',
		            '[object Array]':         'array',
		            '[object Date]':          'date',
		            '[object RegExp]':        'regexp',
		            '[object Object]':        'object'
		        },
		        // Save a reference to some core methods
		        toString    = Object.prototype.toString,
		        hasOwn      = Object.prototype.hasOwnProperty;

		    /**
		     * Taken from jQuery 1.6.1
		     * @function isFunction
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.isFunction = function( obj ) {
		        return $.type(obj) === "function";
		    };

		    /**
		     * Taken from jQuery 1.6.1
		     * @function isArray
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.isArray = Array.isArray || function( obj ) {
		        return $.type(obj) === "array";
		    };


		    /**
		     * A crude way of determining if an object is a window.
		     * Taken from jQuery 1.6.1
		     * @function isWindow
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.isWindow = function( obj ) {
		        return obj && typeof obj === "object" && "setInterval" in obj;
		    };


		    /**
		     * Taken from jQuery 1.6.1
		     * @function type
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.type = function( obj ) {
		        return ( obj === null ) || ( obj === undefined ) ?
		            String( obj ) :
		            class2type[ toString.call(obj) ] || "object";
		    };


		    /**
		     * Taken from jQuery 1.6.1
		     * @function isPlainObject
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.isPlainObject = function( obj ) {
		        // Must be an Object.
		        // Because of IE, we also have to check the presence of the constructor property.
		        // Make sure that DOM nodes and window objects don't pass through, as well
		        if ( !obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow( obj ) ) {
		            return false;
		        }

		        // Not own constructor property must be Object
		        if ( obj.constructor &&
		            !hasOwn.call(obj, "constructor") &&
		            !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
		            return false;
		        }

		        // Own properties are enumerated firstly, so to speed up,
		        // if last one is own, then all properties are own.

		        var lastKey;
		        for (var key in obj ) {
		            lastKey = key;
		        }

		        return lastKey === undefined || hasOwn.call( obj, lastKey );
		    };


		    /**
		     * Taken from jQuery 1.6.1
		     * @function isEmptyObject
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.isEmptyObject = function( obj ) {
		        for ( var name in obj ) {
		            return false;
		        }
		        return true;
		    };

		    /**
		     * Shim around Object.freeze. Does nothing if Object.freeze is not supported.
		     * @param {Object} obj The object to freeze.
		     * @returns {Object} obj The frozen object.
		     */
		    $.freezeObject = function(obj) {
		        if (Object.freeze) {
		            $.freezeObject = Object.freeze;
		        } else {
		            $.freezeObject = function(obj) {
		                return obj;
		            };
		        }
		        return $.freezeObject(obj);
		    };

		    /**
		     * True if the browser supports the HTML5 canvas element
		     * @member {Boolean} supportsCanvas
		     * @memberof OpenSeadragon
		     */
		    $.supportsCanvas = (function () {
		        var canvasElement = document.createElement( 'canvas' );
		        return !!( $.isFunction( canvasElement.getContext ) &&
		                    canvasElement.getContext( '2d' ) );
		    }());

		    /**
		     * Test whether the submitted canvas is tainted or not.
		     * @argument {Canvas} canvas The canvas to test.
		     * @returns {Boolean} True if the canvas is tainted.
		     */
		    $.isCanvasTainted = function(canvas) {
		        var isTainted = false;
		        try {
		            // We test if the canvas is tainted by retrieving data from it.
		            // An exception will be raised if the canvas is tainted.
		            canvas.getContext('2d').getImageData(0, 0, 1, 1);
		        } catch (e) {
		            isTainted = true;
		        }
		        return isTainted;
		    };

		    /**
		     * True if the browser supports the EventTarget.addEventListener() method
		     * @member {Boolean} supportsAddEventListener
		     * @memberof OpenSeadragon
		     */
		    $.supportsAddEventListener = (function () {
		        return !!(document.documentElement.addEventListener && document.addEventListener);
		    }());

		    /**
		     * True if the browser supports the EventTarget.removeEventListener() method
		     * @member {Boolean} supportsRemoveEventListener
		     * @memberof OpenSeadragon
		     */
		    $.supportsRemoveEventListener = (function () {
		        return !!(document.documentElement.removeEventListener && document.removeEventListener);
		    }());

		    /**
		     * True if the browser supports the newer EventTarget.addEventListener options argument
		     * @member {Boolean} supportsEventListenerOptions
		     * @memberof OpenSeadragon
		     */
		    $.supportsEventListenerOptions = (function () {
		        var supported = 0;

		        if ( $.supportsAddEventListener ) {
		            try {
		                var options = {
		                    get capture() {
		                        supported++;
		                        return false;
		                    },
		                    get once() {
		                        supported++;
		                        return false;
		                    },
		                    get passive() {
		                        supported++;
		                        return false;
		                    }
		                };
		                window.addEventListener("test", null, options);
		                window.removeEventListener("test", null, options);
		            } catch ( e ) {
		                supported = 0;
		            }
		        }

		        return supported >= 3;
		    }());

		    /**
		     * A ratio comparing the device screen's pixel density to the canvas's backing store pixel density,
		     * clamped to a minimum of 1. Defaults to 1 if canvas isn't supported by the browser.
		     * @function getCurrentPixelDensityRatio
		     * @memberof OpenSeadragon
		     * @returns {Number}
		     */
		    $.getCurrentPixelDensityRatio = function() {
		        if ( $.supportsCanvas ) {
		            var context = document.createElement('canvas').getContext('2d');
		            var devicePixelRatio = window.devicePixelRatio || 1;
		            var backingStoreRatio = context.webkitBackingStorePixelRatio ||
		                                    context.mozBackingStorePixelRatio ||
		                                    context.msBackingStorePixelRatio ||
		                                    context.oBackingStorePixelRatio ||
		                                    context.backingStorePixelRatio || 1;
		            return Math.max(devicePixelRatio, 1) / backingStoreRatio;
		        } else {
		            return 1;
		        }
		    };

		    /**
		     * A ratio comparing the device screen's pixel density to the canvas's backing store pixel density,
		     * clamped to a minimum of 1. Defaults to 1 if canvas isn't supported by the browser.
		     * @member {Number} pixelDensityRatio
		     * @memberof OpenSeadragon
		     */
		    $.pixelDensityRatio = $.getCurrentPixelDensityRatio();

		}( OpenSeadragon ));

		/**
		 *  This closure defines all static methods available to the OpenSeadragon
		 *  namespace.  Many, if not most, are taken directly from jQuery for use
		 *  to simplify and reduce common programming patterns.  More static methods
		 *  from jQuery may eventually make their way into this though we are
		 *  attempting to avoid an explicit dependency on jQuery only because
		 *  OpenSeadragon is a broadly useful code base and would be made less broad
		 *  by requiring jQuery fully.
		 *
		 *  Some static methods have also been refactored from the original OpenSeadragon
		 *  project.
		 */
		(function( $ ){

		    /**
		     * Taken from jQuery 1.6.1
		     * @function extend
		     * @memberof OpenSeadragon
		     * @see {@link http://www.jquery.com/ jQuery}
		     */
		    $.extend = function() {
		        var options,
		            name,
		            src,
		            copy,
		            copyIsArray,
		            clone,
		            target  = arguments[ 0 ] || {},
		            length  = arguments.length,
		            deep    = false,
		            i       = 1;

		        // Handle a deep copy situation
		        if ( typeof target === "boolean" ) {
		            deep    = target;
		            target  = arguments[ 1 ] || {};
		            // skip the boolean and the target
		            i = 2;
		        }

		        // Handle case when target is a string or something (possible in deep copy)
		        if ( typeof target !== "object" && !OpenSeadragon.isFunction( target ) ) {
		            target = {};
		        }

		        // extend jQuery itself if only one argument is passed
		        if ( length === i ) {
		            target = this;
		            --i;
		        }

		        for ( ; i < length; i++ ) {
		            // Only deal with non-null/undefined values
		            options = arguments[ i ];
		            if ( options !== null || options !== undefined ) {
		                // Extend the base object
		                for ( name in options ) {
		                    var descriptor = Object.getOwnPropertyDescriptor(options, name);

		                    if (descriptor !== undefined) {
		                        if (descriptor.get || descriptor.set) {
		                            Object.defineProperty(target, name, descriptor);
		                            continue;
		                        }

		                        copy = descriptor.value;
		                    } else {
		                        $.console.warn('Could not copy inherited property "' + name + '".');
		                        continue;
		                    }

		                    // Prevent never-ending loop
		                    if ( target === copy ) {
		                        continue;
		                    }

		                    // Recurse if we're merging plain objects or arrays
		                    if ( deep && copy && ( OpenSeadragon.isPlainObject( copy ) || ( copyIsArray = OpenSeadragon.isArray( copy ) ) ) ) {
		                        src = target[ name ];

		                        if ( copyIsArray ) {
		                            copyIsArray = false;
		                            clone = src && OpenSeadragon.isArray( src ) ? src : [];

		                        } else {
		                            clone = src && OpenSeadragon.isPlainObject( src ) ? src : {};
		                        }

		                        // Never move original objects, clone them
		                        target[ name ] = OpenSeadragon.extend( deep, clone, copy );

		                    // Don't bring in undefined values
		                    } else if ( copy !== undefined ) {
		                        target[ name ] = copy;
		                    }
		                }
		            }
		        }

		        // Return the modified object
		        return target;
		    };

		    var isIOSDevice = function () {
		        if (typeof navigator !== 'object') {
		            return false;
		        }
		        var userAgent = navigator.userAgent;
		        if (typeof userAgent !== 'string') {
		            return false;
		        }
		        return userAgent.indexOf('iPhone') !== -1 ||
		               userAgent.indexOf('iPad') !== -1 ||
		               userAgent.indexOf('iPod') !== -1;
		    };

		    $.extend( $, /** @lends OpenSeadragon */{
		        /**
		         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
		         * @static
		         * @type {Object}
		         */
		        DEFAULT_SETTINGS: {
		            //DATA SOURCE DETAILS
		            xmlPath:                null,
		            tileSources:            null,
		            tileHost:               null,
		            initialPage:            0,
		            crossOriginPolicy:      false,
		            ajaxWithCredentials:    false,
		            loadTilesWithAjax:      false,
		            ajaxHeaders:            {},
		            splitHashDataForPost:   false,

		            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
		            panHorizontal:          true,
		            panVertical:            true,
		            constrainDuringPan:     false,
		            wrapHorizontal:         false,
		            wrapVertical:           false,
		            visibilityRatio:        0.5, //-> how much of the viewer can be negative space
		            minPixelRatio:          0.5, //->closer to 0 draws tiles meant for a higher zoom at this zoom
		            defaultZoomLevel:       0,
		            minZoomLevel:           null,
		            maxZoomLevel:           null,
		            homeFillsViewer:        false,

		            //UI RESPONSIVENESS AND FEEL
		            clickTimeThreshold:     300,
		            clickDistThreshold:     5,
		            dblClickTimeThreshold:  300,
		            dblClickDistThreshold:  20,
		            springStiffness:        6.5,
		            animationTime:          1.2,
		            gestureSettingsMouse:   {
		                dragToPan: true,
		                scrollToZoom: true,
		                clickToZoom: true,
		                dblClickToZoom: false,
		                dblClickDragToZoom: false,
		                pinchToZoom: false,
		                zoomToRefPoint: true,
		                flickEnabled: false,
		                flickMinSpeed: 120,
		                flickMomentum: 0.25,
		                pinchRotate: false
		            },
		            gestureSettingsTouch:   {
		                dragToPan: true,
		                scrollToZoom: false,
		                clickToZoom: false,
		                dblClickToZoom: true,
		                dblClickDragToZoom: true,
		                pinchToZoom: true,
		                zoomToRefPoint: true,
		                flickEnabled: true,
		                flickMinSpeed: 120,
		                flickMomentum: 0.25,
		                pinchRotate: false
		            },
		            gestureSettingsPen:     {
		                dragToPan: true,
		                scrollToZoom: false,
		                clickToZoom: true,
		                dblClickToZoom: false,
		                dblClickDragToZoom: false,
		                pinchToZoom: false,
		                zoomToRefPoint: true,
		                flickEnabled: false,
		                flickMinSpeed: 120,
		                flickMomentum: 0.25,
		                pinchRotate: false
		            },
		            gestureSettingsUnknown: {
		                dragToPan: true,
		                scrollToZoom: false,
		                clickToZoom: false,
		                dblClickToZoom: true,
		                dblClickDragToZoom: false,
		                pinchToZoom: true,
		                zoomToRefPoint: true,
		                flickEnabled: true,
		                flickMinSpeed: 120,
		                flickMomentum: 0.25,
		                pinchRotate: false
		            },
		            zoomPerClick:           2,
		            zoomPerScroll:          1.2,
		            zoomPerDblClickDrag:    1.2,
		            zoomPerSecond:          1.0,
		            blendTime:              0,
		            alwaysBlend:            false,
		            autoHideControls:       true,
		            immediateRender:        false,
		            minZoomImageRatio:      0.9, //-> closer to 0 allows zoom out to infinity
		            maxZoomPixelRatio:      1.1, //-> higher allows 'over zoom' into pixels
		            smoothTileEdgesMinZoom: 1.1, //-> higher than maxZoomPixelRatio disables it
		            iOSDevice:              isIOSDevice(),
		            pixelsPerWheelLine:     40,
		            pixelsPerArrowPress:    40,
		            autoResize:             true,
		            preserveImageSizeOnResize: false, // requires autoResize=true
		            minScrollDeltaTime:     50,
		            rotationIncrement:      90,
		            maxTilesPerFrame:       1,

		            //DEFAULT CONTROL SETTINGS
		            showSequenceControl:     true,  //SEQUENCE
		            sequenceControlAnchor:   null,  //SEQUENCE
		            preserveViewport:        false, //SEQUENCE
		            preserveOverlays:        false, //SEQUENCE
		            navPrevNextWrap:         false, //SEQUENCE
		            showNavigationControl:   true,  //ZOOM/HOME/FULL/ROTATION
		            navigationControlAnchor: null,  //ZOOM/HOME/FULL/ROTATION
		            showZoomControl:         true,  //ZOOM
		            showHomeControl:         true,  //HOME
		            showFullPageControl:     true,  //FULL
		            showRotationControl:     false, //ROTATION
		            showFlipControl:         false,  //FLIP
		            controlsFadeDelay:       2000,  //ZOOM/HOME/FULL/SEQUENCE
		            controlsFadeLength:      1500,  //ZOOM/HOME/FULL/SEQUENCE
		            mouseNavEnabled:         true,  //GENERAL MOUSE INTERACTIVITY

		            //VIEWPORT NAVIGATOR SETTINGS
		            showNavigator:              false,
		            navigatorElement:           null,
		            navigatorId:                null,
		            navigatorPosition:          null,
		            navigatorSizeRatio:         0.2,
		            navigatorMaintainSizeRatio: false,
		            navigatorTop:               null,
		            navigatorLeft:              null,
		            navigatorHeight:            null,
		            navigatorWidth:             null,
		            navigatorAutoResize:        true,
		            navigatorAutoFade:          true,
		            navigatorRotate:            true,
		            navigatorBackground:        '#000',
		            navigatorOpacity:           0.8,
		            navigatorBorderColor:       '#555',
		            navigatorDisplayRegionColor: '#900',

		            // INITIAL ROTATION
		            degrees:                    0,

		            // INITIAL FLIP STATE
		            flipped:                          false,
		            overlayPreserveContentDirection:  true,

		            // APPEARANCE
		            opacity:                           1, // to be passed into each TiledImage
		            compositeOperation:                null, // to be passed into each TiledImage

		            // DRAWER SETTINGS
		            drawer:                            ['webgl', 'canvas', 'html'], // prefer using webgl, then canvas (i.e. context2d), then fallback to html

		            drawerOptions: {
		                webgl: {

		                },
		                canvas: {

		                },
		                html: {

		                },
		                custom: {

		                }
		            },

		            // TILED IMAGE SETTINGS
		            preload:                           false, // to be passed into each TiledImage
		            imageSmoothingEnabled:             true,  // to be passed into each TiledImage
		            placeholderFillStyle:              null,  // to be passed into each TiledImage
		            subPixelRoundingForTransparency:   null,  // to be passed into each TiledImage

		            //REFERENCE STRIP SETTINGS
		            showReferenceStrip:          false,
		            referenceStripScroll:       'horizontal',
		            referenceStripElement:       null,
		            referenceStripHeight:        null,
		            referenceStripWidth:         null,
		            referenceStripPosition:      'BOTTOM_LEFT',
		            referenceStripSizeRatio:     0.2,

		            //COLLECTION VISUALIZATION SETTINGS
		            collectionRows:         3, //or columns depending on layout
		            collectionColumns:      0, //columns in horizontal layout, rows in vertical layout
		            collectionLayout:       'horizontal', //vertical
		            collectionMode:         false,
		            collectionTileSize:     800,
		            collectionTileMargin:   80,

		            //PERFORMANCE SETTINGS
		            imageLoaderLimit:       0,
		            maxImageCacheCount:     200,
		            timeout:                30000,
		            tileRetryMax:           0,
		            tileRetryDelay:         2500,

		            //INTERFACE RESOURCE SETTINGS
		            prefixUrl:              "/images/",
		            navImages: {
		                zoomIn: {
		                    REST:   'zoomin_rest.png',
		                    GROUP:  'zoomin_grouphover.png',
		                    HOVER:  'zoomin_hover.png',
		                    DOWN:   'zoomin_pressed.png'
		                },
		                zoomOut: {
		                    REST:   'zoomout_rest.png',
		                    GROUP:  'zoomout_grouphover.png',
		                    HOVER:  'zoomout_hover.png',
		                    DOWN:   'zoomout_pressed.png'
		                },
		                home: {
		                    REST:   'home_rest.png',
		                    GROUP:  'home_grouphover.png',
		                    HOVER:  'home_hover.png',
		                    DOWN:   'home_pressed.png'
		                },
		                fullpage: {
		                    REST:   'fullpage_rest.png',
		                    GROUP:  'fullpage_grouphover.png',
		                    HOVER:  'fullpage_hover.png',
		                    DOWN:   'fullpage_pressed.png'
		                },
		                rotateleft: {
		                    REST:   'rotateleft_rest.png',
		                    GROUP:  'rotateleft_grouphover.png',
		                    HOVER:  'rotateleft_hover.png',
		                    DOWN:   'rotateleft_pressed.png'
		                },
		                rotateright: {
		                    REST:   'rotateright_rest.png',
		                    GROUP:  'rotateright_grouphover.png',
		                    HOVER:  'rotateright_hover.png',
		                    DOWN:   'rotateright_pressed.png'
		                },
		                flip: { // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
		                    REST:   'flip_rest.png',
		                    GROUP:  'flip_grouphover.png',
		                    HOVER:  'flip_hover.png',
		                    DOWN:   'flip_pressed.png'
		                },
		                previous: {
		                    REST:   'previous_rest.png',
		                    GROUP:  'previous_grouphover.png',
		                    HOVER:  'previous_hover.png',
		                    DOWN:   'previous_pressed.png'
		                },
		                next: {
		                    REST:   'next_rest.png',
		                    GROUP:  'next_grouphover.png',
		                    HOVER:  'next_hover.png',
		                    DOWN:   'next_pressed.png'
		                }
		            },

		            //DEVELOPER SETTINGS
		            debugMode:              false,
		            debugGridColor:         ['#437AB2', '#1B9E77', '#D95F02', '#7570B3', '#E7298A', '#66A61E', '#E6AB02', '#A6761D', '#666666'],
		            silenceMultiImageWarnings: false

		        },

		        /**
		         * Returns a function which invokes the method as if it were a method belonging to the object.
		         * @function
		         * @param {Object} object
		         * @param {Function} method
		         * @returns {Function}
		         */
		        delegate: function( object, method ) {
		            return function(){
		                var args = arguments;
		                if ( args === undefined ){
		                    args = [];
		                }
		                return method.apply( object, args );
		            };
		        },


		        /**
		         * An enumeration of Browser vendors.
		         * @static
		         * @type {Object}
		         * @property {Number} UNKNOWN
		         * @property {Number} IE
		         * @property {Number} FIREFOX
		         * @property {Number} SAFARI
		         * @property {Number} CHROME
		         * @property {Number} OPERA
		         * @property {Number} EDGE
		         * @property {Number} CHROMEEDGE
		         */
		        BROWSERS: {
		            UNKNOWN:    0,
		            IE:         1,
		            FIREFOX:    2,
		            SAFARI:     3,
		            CHROME:     4,
		            OPERA:      5,
		            EDGE:       6,
		            CHROMEEDGE: 7
		        },

		        /**
		         * An enumeration of when subpixel rounding should occur.
		         * @static
		         * @type {Object}
		         * @property {Number} NEVER Never apply subpixel rounding for transparency.
		         * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
		         * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
		         */
		        SUBPIXEL_ROUNDING_OCCURRENCES: {
		            NEVER:        0,
		            ONLY_AT_REST: 1,
		            ALWAYS:       2
		        },

		        /**
		         * Keep track of which {@link Viewer}s have been created.
		         * - Key: {@link Element} to which a Viewer is attached.
		         * - Value: {@link Viewer} of the element defined by the key.
		         * @private
		         * @static
		         * @type {Object}
		         */
		        _viewers: new Map(),

		       /**
		         * Returns the {@link Viewer} attached to a given DOM element. If there is
		         * no viewer attached to the provided element, undefined is returned.
		         * @function
		         * @param {String|Element} element Accepts an id or element.
		         * @returns {Viewer} The viewer attached to the given element, or undefined.
		         */
		        getViewer: function(element) {
		            return $._viewers.get(this.getElement(element));
		        },

		        /**
		         * Returns a DOM Element for the given id or element.
		         * @function
		         * @param {String|Element} element Accepts an id or element.
		         * @returns {Element} The element with the given id, null, or the element itself.
		         */
		        getElement: function( element ) {
		            if ( typeof ( element ) === "string" ) {
		                element = document.getElementById( element );
		            }
		            return element;
		        },


		        /**
		         * Determines the position of the upper-left corner of the element.
		         * @function
		         * @param {Element|String} element - the element we want the position for.
		         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
		         */
		        getElementPosition: function( element ) {
		            var result = new $.Point(),
		                isFixed,
		                offsetParent;

		            element      = $.getElement( element );
		            isFixed      = $.getElementStyle( element ).position === "fixed";
		            offsetParent = getOffsetParent( element, isFixed );

		            while ( offsetParent ) {

		                result.x += element.offsetLeft;
		                result.y += element.offsetTop;

		                if ( isFixed ) {
		                    result = result.plus( $.getPageScroll() );
		                }

		                element = offsetParent;
		                isFixed = $.getElementStyle( element ).position === "fixed";
		                offsetParent = getOffsetParent( element, isFixed );
		            }

		            return result;
		        },


		        /**
		         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
		         * @function
		         * @param {Element|String} element - the element we want the position for.
		         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
		         */
		        getElementOffset: function( element ) {
		            element = $.getElement( element );

		            var doc = element && element.ownerDocument,
		                docElement,
		                win,
		                boundingRect = { top: 0, left: 0 };

		            if ( !doc ) {
		                return new $.Point();
		            }

		            docElement = doc.documentElement;

		            if ( typeof element.getBoundingClientRect !== typeof undefined ) {
		                boundingRect = element.getBoundingClientRect();
		            }

		            win = ( doc === doc.window ) ?
		                doc :
		                ( doc.nodeType === 9 ) ?
		                    doc.defaultView || doc.parentWindow :
		                    false;

		            return new $.Point(
		                boundingRect.left + ( win.pageXOffset || docElement.scrollLeft ) - ( docElement.clientLeft || 0 ),
		                boundingRect.top + ( win.pageYOffset || docElement.scrollTop ) - ( docElement.clientTop || 0 )
		            );
		        },


		        /**
		         * Determines the height and width of the given element.
		         * @function
		         * @param {Element|String} element
		         * @returns {OpenSeadragon.Point}
		         */
		        getElementSize: function( element ) {
		            element = $.getElement( element );

		            return new $.Point(
		                element.clientWidth,
		                element.clientHeight
		            );
		        },


		        /**
		         * Returns the CSSStyle object for the given element.
		         * @function
		         * @param {Element|String} element
		         * @returns {CSSStyle}
		         */
		        getElementStyle:
		            document.documentElement.currentStyle ?
		            function( element ) {
		                element = $.getElement( element );
		                return element.currentStyle;
		            } :
		            function( element ) {
		                element = $.getElement( element );
		                return window.getComputedStyle( element, "" );
		            },

		        /**
		         * Returns the property with the correct vendor prefix appended.
		         * @param {String} property the property name
		         * @returns {String} the property with the correct prefix or null if not
		         * supported.
		         */
		        getCssPropertyWithVendorPrefix: function(property) {
		            var memo = {};

		            $.getCssPropertyWithVendorPrefix = function(property) {
		                if (memo[property] !== undefined) {
		                    return memo[property];
		                }
		                var style = document.createElement('div').style;
		                var result = null;
		                if (style[property] !== undefined) {
		                    result = property;
		                } else {
		                    var prefixes = ['Webkit', 'Moz', 'MS', 'O',
		                        'webkit', 'moz', 'ms', 'o'];
		                    var suffix = $.capitalizeFirstLetter(property);
		                    for (var i = 0; i < prefixes.length; i++) {
		                        var prop = prefixes[i] + suffix;
		                        if (style[prop] !== undefined) {
		                            result = prop;
		                            break;
		                        }
		                    }
		                }
		                memo[property] = result;
		                return result;
		            };
		            return $.getCssPropertyWithVendorPrefix(property);
		        },

		        /**
		         * Capitalizes the first letter of a string
		         * @param {String} string
		         * @returns {String} The string with the first letter capitalized
		         */
		        capitalizeFirstLetter: function(string) {
		            return string.charAt(0).toUpperCase() + string.slice(1);
		        },

		        /**
		         * Compute the modulo of a number but makes sure to always return
		         * a positive value (also known as Euclidean modulo).
		         * @param {Number} number the number to compute the modulo of
		         * @param {Number} modulo the modulo
		         * @returns {Number} the result of the modulo of number
		         */
		        positiveModulo: function(number, modulo) {
		            var result = number % modulo;
		            if (result < 0) {
		                result += modulo;
		            }
		            return result;
		        },


		        /**
		         * Determines if a point is within the bounding rectangle of the given element (hit-test).
		         * @function
		         * @param {Element|String} element
		         * @param {OpenSeadragon.Point} point
		         * @returns {Boolean}
		         */
		        pointInElement: function( element, point ) {
		            element = $.getElement( element );
		            var offset = $.getElementOffset( element ),
		                size = $.getElementSize( element );
		            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
		        },


		        /**
		         * Gets the position of the mouse on the screen for a given event.
		         * @function
		         * @param {Event} [event]
		         * @returns {OpenSeadragon.Point}
		         */
		        getMousePosition: function( event ) {

		            if ( typeof ( event.pageX ) === "number" ) {
		                $.getMousePosition = function( event ){
		                    var result = new $.Point();

		                    result.x = event.pageX;
		                    result.y = event.pageY;

		                    return result;
		                };
		            } else if ( typeof ( event.clientX ) === "number" ) {
		                $.getMousePosition = function( event ){
		                    var result = new $.Point();

		                    result.x =
		                        event.clientX +
		                        document.body.scrollLeft +
		                        document.documentElement.scrollLeft;
		                    result.y =
		                        event.clientY +
		                        document.body.scrollTop +
		                        document.documentElement.scrollTop;

		                    return result;
		                };
		            } else {
		                throw new Error(
		                    "Unknown event mouse position, no known technique."
		                );
		            }

		            return $.getMousePosition( event );
		        },


		        /**
		         * Determines the page's current scroll position.
		         * @function
		         * @returns {OpenSeadragon.Point}
		         */
		        getPageScroll: function() {
		            var docElement  = document.documentElement || {},
		                body        = document.body || {};

		            if ( typeof ( window.pageXOffset ) === "number" ) {
		                $.getPageScroll = function(){
		                    return new $.Point(
		                        window.pageXOffset,
		                        window.pageYOffset
		                    );
		                };
		            } else if ( body.scrollLeft || body.scrollTop ) {
		                $.getPageScroll = function(){
		                    return new $.Point(
		                        document.body.scrollLeft,
		                        document.body.scrollTop
		                    );
		                };
		            } else if ( docElement.scrollLeft || docElement.scrollTop ) {
		                $.getPageScroll = function(){
		                    return new $.Point(
		                        document.documentElement.scrollLeft,
		                        document.documentElement.scrollTop
		                    );
		                };
		            } else {
		                // We can't reassign the function yet, as there was no scroll.
		                return new $.Point(0, 0);
		            }

		            return $.getPageScroll();
		        },

		        /**
		         * Set the page scroll position.
		         * @function
		         * @returns {OpenSeadragon.Point}
		         */
		        setPageScroll: function( scroll ) {
		            if ( typeof ( window.scrollTo ) !== "undefined" ) {
		                $.setPageScroll = function( scroll ) {
		                    window.scrollTo( scroll.x, scroll.y );
		                };
		            } else {
		                var originalScroll = $.getPageScroll();
		                if ( originalScroll.x === scroll.x &&
		                    originalScroll.y === scroll.y ) {
		                    // We are already correctly positioned and there
		                    // is no way to detect the correct method.
		                    return;
		                }

		                document.body.scrollLeft = scroll.x;
		                document.body.scrollTop = scroll.y;
		                var currentScroll = $.getPageScroll();
		                if ( currentScroll.x !== originalScroll.x &&
		                    currentScroll.y !== originalScroll.y ) {
		                    $.setPageScroll = function( scroll ) {
		                        document.body.scrollLeft = scroll.x;
		                        document.body.scrollTop = scroll.y;
		                    };
		                    return;
		                }

		                document.documentElement.scrollLeft = scroll.x;
		                document.documentElement.scrollTop = scroll.y;
		                currentScroll = $.getPageScroll();
		                if ( currentScroll.x !== originalScroll.x &&
		                    currentScroll.y !== originalScroll.y ) {
		                    $.setPageScroll = function( scroll ) {
		                        document.documentElement.scrollLeft = scroll.x;
		                        document.documentElement.scrollTop = scroll.y;
		                    };
		                    return;
		                }

		                // We can't find anything working, so we do nothing.
		                $.setPageScroll = function( scroll ) {
		                };
		            }

		            $.setPageScroll( scroll );
		        },

		        /**
		         * Determines the size of the browsers window.
		         * @function
		         * @returns {OpenSeadragon.Point}
		         */
		        getWindowSize: function() {
		            var docElement = document.documentElement || {},
		                body    = document.body || {};

		            if ( typeof ( window.innerWidth ) === 'number' ) {
		                $.getWindowSize = function(){
		                    return new $.Point(
		                        window.innerWidth,
		                        window.innerHeight
		                    );
		                };
		            } else if ( docElement.clientWidth || docElement.clientHeight ) {
		                $.getWindowSize = function(){
		                    return new $.Point(
		                        document.documentElement.clientWidth,
		                        document.documentElement.clientHeight
		                    );
		                };
		            } else if ( body.clientWidth || body.clientHeight ) {
		                $.getWindowSize = function(){
		                    return new $.Point(
		                        document.body.clientWidth,
		                        document.body.clientHeight
		                    );
		                };
		            } else {
		                throw new Error("Unknown window size, no known technique.");
		            }

		            return $.getWindowSize();
		        },


		        /**
		         * Wraps the given element in a nest of divs so that the element can
		         * be easily centered using CSS tables
		         * @function
		         * @param {Element|String} element
		         * @returns {Element} outermost wrapper element
		         */
		        makeCenteredNode: function( element ) {
		            // Convert a possible ID to an actual HTMLElement
		            element = $.getElement( element );

		            /*
		                CSS tables require you to have a display:table/row/cell hierarchy so we need to create
		                three nested wrapper divs:
		             */

		            var wrappers = [
		                $.makeNeutralElement( 'div' ),
		                $.makeNeutralElement( 'div' ),
		                $.makeNeutralElement( 'div' )
		            ];

		            // It feels like we should be able to pass style dicts to makeNeutralElement:
		            $.extend(wrappers[0].style, {
		                display: "table",
		                height: "100%",
		                width: "100%"
		            });

		            $.extend(wrappers[1].style, {
		                display: "table-row"
		            });

		            $.extend(wrappers[2].style, {
		                display: "table-cell",
		                verticalAlign: "middle",
		                textAlign: "center"
		            });

		            wrappers[0].appendChild(wrappers[1]);
		            wrappers[1].appendChild(wrappers[2]);
		            wrappers[2].appendChild(element);

		            return wrappers[0];
		        },


		        /**
		         * Creates an easily positionable element of the given type that therefor
		         * serves as an excellent container element.
		         * @function
		         * @param {String} tagName
		         * @returns {Element}
		         */
		        makeNeutralElement: function( tagName ) {
		            var element = document.createElement( tagName ),
		                style   = element.style;

		            style.background = "transparent none";
		            style.border     = "none";
		            style.margin     = "0px";
		            style.padding    = "0px";
		            style.position   = "static";

		            return element;
		        },


		        /**
		         * Returns the current milliseconds, using Date.now() if available
		         * @function
		         */
		        now: function( ) {
		            if (Date.now) {
		                $.now = Date.now;
		            } else {
		                $.now = function() {
		                    return new Date().getTime();
		                };
		            }

		            return $.now();
		        },


		        /**
		         * Ensures an image is loaded correctly to support alpha transparency.
		         * @function
		         * @param {String} src
		         * @returns {Element}
		         */
		        makeTransparentImage: function( src ) {
		            var img = $.makeNeutralElement( "img" );

		            img.src = src;

		            return img;
		        },


		        /**
		         * Sets the opacity of the specified element.
		         * @function
		         * @param {Element|String} element
		         * @param {Number} opacity
		         * @param {Boolean} [usesAlpha]
		         */
		        setElementOpacity: function( element, opacity, usesAlpha ) {

		            var ieOpacity,
		                ieFilter;

		            element = $.getElement( element );

		            if ( usesAlpha && !$.Browser.alpha ) {
		                opacity = Math.round( opacity );
		            }

		            if ( $.Browser.opacity ) {
		                element.style.opacity = opacity < 1 ? opacity : "";
		            } else {
		                if ( opacity < 1 ) {
		                    ieOpacity = Math.round( 100 * opacity );
		                    ieFilter  = "alpha(opacity=" + ieOpacity + ")";
		                    element.style.filter = ieFilter;
		                } else {
		                    element.style.filter = "";
		                }
		            }
		        },


		        /**
		         * Sets the specified element's touch-action style attribute to 'none'.
		         * @function
		         * @param {Element|String} element
		         */
		        setElementTouchActionNone: function( element ) {
		            element = $.getElement( element );
		            if ( typeof element.style.touchAction !== 'undefined' ) {
		                element.style.touchAction = 'none';
		            } else if ( typeof element.style.msTouchAction !== 'undefined' ) {
		                element.style.msTouchAction = 'none';
		            }
		        },


		        /**
		         * Sets the specified element's pointer-events style attribute to the passed value.
		         * @function
		         * @param {Element|String} element
		         * @param {String} value
		         */
		        setElementPointerEvents: function( element, value ) {
		            element = $.getElement( element );
		            if (typeof element.style !== 'undefined' && typeof element.style.pointerEvents !== 'undefined' ) {
		                element.style.pointerEvents = value;
		            }
		        },


		        /**
		         * Sets the specified element's pointer-events style attribute to 'none'.
		         * @function
		         * @param {Element|String} element
		         */
		        setElementPointerEventsNone: function( element ) {
		            $.setElementPointerEvents( element, 'none' );
		        },


		        /**
		         * Add the specified CSS class to the element if not present.
		         * @function
		         * @param {Element|String} element
		         * @param {String} className
		         */
		        addClass: function( element, className ) {
		            element = $.getElement( element );

		            if (!element.className) {
		                element.className = className;
		            } else if ( ( ' ' + element.className + ' ' ).
		                indexOf( ' ' + className + ' ' ) === -1 ) {
		                element.className += ' ' + className;
		            }
		        },

		        /**
		         * Find the first index at which an element is found in an array or -1
		         * if not present.
		         *
		         * Code taken and adapted from
		         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
		         *
		         * @function
		         * @param {Array} array The array from which to find the element
		         * @param {Object} searchElement The element to find
		         * @param {Number} [fromIndex=0] Index to start research.
		         * @returns {Number} The index of the element in the array.
		         */
		        indexOf: function( array, searchElement, fromIndex ) {
		            if ( Array.prototype.indexOf ) {
		                this.indexOf = function( array, searchElement, fromIndex ) {
		                    return array.indexOf( searchElement, fromIndex );
		                };
		            } else {
		                this.indexOf = function( array, searchElement, fromIndex ) {
		                    var i,
		                        pivot = ( fromIndex ) ? fromIndex : 0,
		                        length;
		                    if ( !array ) {
		                        throw new TypeError( );
		                    }

		                    length = array.length;
		                    if ( length === 0 || pivot >= length ) {
		                        return -1;
		                    }

		                    if ( pivot < 0 ) {
		                        pivot = length - Math.abs( pivot );
		                    }

		                    for ( i = pivot; i < length; i++ ) {
		                        if ( array[i] === searchElement ) {
		                            return i;
		                        }
		                    }
		                    return -1;
		                };
		            }
		            return this.indexOf( array, searchElement, fromIndex );
		        },

		        /**
		         * Remove the specified CSS class from the element.
		         * @function
		         * @param {Element|String} element
		         * @param {String} className
		         */
		        removeClass: function( element, className ) {
		            var oldClasses,
		                newClasses = [],
		                i;

		            element = $.getElement( element );
		            oldClasses = element.className.split( /\s+/ );
		            for ( i = 0; i < oldClasses.length; i++ ) {
		                if ( oldClasses[ i ] && oldClasses[ i ] !== className ) {
		                    newClasses.push( oldClasses[ i ] );
		                }
		            }
		            element.className = newClasses.join(' ');
		        },

		        /**
		         * Convert passed addEventListener() options to boolean or options object,
		         * depending on browser support.
		         * @function
		         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
		         * @param {Boolean} [options.capture]
		         * @param {Boolean} [options.passive]
		         * @param {Boolean} [options.once]
		         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
		         */
		        normalizeEventListenerOptions: function (options) {
		            var opts;
		            if ( typeof options !== 'undefined' ) {
		                if ( typeof options === 'boolean' ) {
		                    // Legacy Boolean useCapture
		                    opts = $.supportsEventListenerOptions ? { capture: options } : options;
		                } else {
		                    // Options object
		                    opts = $.supportsEventListenerOptions ? options :
		                        ( ( typeof options.capture !== 'undefined' ) ? options.capture : false );
		                }
		            } else {
		                // No options specified - Legacy optional useCapture argument
		                //   (for IE, first supported on version 9, so we'll pass a Boolean)
		                opts = $.supportsEventListenerOptions ? { capture: false } : false;
		            }
		            return opts;
		        },

		        /**
		         * Adds an event listener for the given element, eventName and handler.
		         * @function
		         * @param {Element|String} element
		         * @param {String} eventName
		         * @param {Function} handler
		         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
		         * @param {Boolean} [options.capture]
		         * @param {Boolean} [options.passive]
		         * @param {Boolean} [options.once]
		         */
		        addEvent: (function () {
		            if ( $.supportsAddEventListener ) {
		                return function ( element, eventName, handler, options ) {
		                    options = $.normalizeEventListenerOptions(options);
		                    element = $.getElement( element );
		                    element.addEventListener( eventName, handler, options );
		                };
		            } else if ( document.documentElement.attachEvent && document.attachEvent ) {
		                return function ( element, eventName, handler ) {
		                    element = $.getElement( element );
		                    element.attachEvent( 'on' + eventName, handler );
		                };
		            } else {
		                throw new Error( "No known event model." );
		            }
		        }()),


		        /**
		         * Remove a given event listener for the given element, event type and
		         * handler.
		         * @function
		         * @param {Element|String} element
		         * @param {String} eventName
		         * @param {Function} handler
		         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
		         * @param {Boolean} [options.capture]
		         */
		        removeEvent: (function () {
		            if ( $.supportsRemoveEventListener ) {
		                return function ( element, eventName, handler, options ) {
		                    options = $.normalizeEventListenerOptions(options);
		                    element = $.getElement( element );
		                    element.removeEventListener( eventName, handler, options );
		                };
		            } else if ( document.documentElement.detachEvent && document.detachEvent ) {
		                return function( element, eventName, handler ) {
		                    element = $.getElement( element );
		                    element.detachEvent( 'on' + eventName, handler );
		                };
		            } else {
		                throw new Error( "No known event model." );
		            }
		        }()),


		        /**
		         * Cancels the default browser behavior had the event propagated all
		         * the way up the DOM to the window object.
		         * @function
		         * @param {Event} [event]
		         */
		        cancelEvent: function( event ) {
		            event.preventDefault();
		        },


		        /**
		         * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
		         * the event, otherwise returns false.
		         * @function
		         * @param {Event} [event]
		         */
		        eventIsCanceled: function( event ) {
		            return event.defaultPrevented;
		        },


		        /**
		         * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
		         * @function
		         * @param {Event} [event]
		         */
		        stopEvent: function( event ) {
		            event.stopPropagation();
		        },

		        // Deprecated
		        createCallback: function( object, method ) {
		            //TODO: This pattern is painful to use and debug.  It's much cleaner
		            //      to use pinning plus anonymous functions.  Get rid of this
		            //      pattern!
		            console.error('The createCallback function is deprecated and will be removed in future versions. Please use alternativeFunction instead.');
		            var initialArgs = [],
		                i;
		            for ( i = 2; i < arguments.length; i++ ) {
		                initialArgs.push( arguments[ i ] );
		            }

		            return function() {
		                var args = initialArgs.concat( [] ),
		                    i;
		                for ( i = 0; i < arguments.length; i++ ) {
		                    args.push( arguments[ i ] );
		                }

		                return method.apply( object, args );
		            };
		        },


		        /**
		         * Retrieves the value of a url parameter from the window.location string.
		         * @function
		         * @param {String} key
		         * @returns {String} The value of the url parameter or null if no param matches.
		         */
		        getUrlParameter: function( key ) {
		            // eslint-disable-next-line no-use-before-define
		            var value = URLPARAMS[ key ];
		            return value ? value : null;
		        },

		        /**
		         * Retrieves the protocol used by the url. The url can either be absolute
		         * or relative.
		         * @function
		         * @private
		         * @param {String} url The url to retrieve the protocol from.
		         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
		         */
		        getUrlProtocol: function( url ) {
		            var match = url.match(/^([a-z]+:)\/\//i);
		            if ( match === null ) {
		                // Relative URL, retrive the protocol from window.location
		                return window.location.protocol;
		            }
		            return match[1].toLowerCase();
		        },

		        /**
		         * Create an XHR object
		         * @private
		         * @param {type} [local] Deprecated. Ignored (IE/ActiveXObject file protocol no longer supported).
		         * @returns {XMLHttpRequest}
		         */
		        createAjaxRequest: function() {
		            if ( window.XMLHttpRequest ) {
		                $.createAjaxRequest = function() {
		                    return new XMLHttpRequest();
		                };
		                return new XMLHttpRequest();
		            } else {
		                throw new Error( "Browser doesn't support XMLHttpRequest." );
		            }
		        },

		        /**
		         * Makes an AJAX request.
		         * @param {Object} options
		         * @param {String} options.url - the url to request
		         * @param {Function} options.success - a function to call on a successful response
		         * @param {Function} options.error - a function to call on when an error occurs
		         * @param {Object} options.headers - headers to add to the AJAX request
		         * @param {String} options.responseType - the response type of the AJAX request
		         * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		         *      see TileSource::getPostData), GET method used if null
		         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
		         * @throws {Error}
		         * @returns {XMLHttpRequest}
		         */
		        makeAjaxRequest: function( url, onSuccess, onError ) {
		            var withCredentials;
		            var headers;
		            var responseType;
		            var postData;

		            // Note that our preferred API is that you pass in a single object; the named
		            // arguments are for legacy support.
		            if( $.isPlainObject( url ) ){
		                onSuccess = url.success;
		                onError = url.error;
		                withCredentials = url.withCredentials;
		                headers = url.headers;
		                responseType = url.responseType || null;
		                postData = url.postData || null;
		                url = url.url;
		            }

		            var protocol = $.getUrlProtocol( url );
		            var request = $.createAjaxRequest();

		            if ( !$.isFunction( onSuccess ) ) {
		                throw new Error( "makeAjaxRequest requires a success callback" );
		            }

		            request.onreadystatechange = function() {
		                // 4 = DONE (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#Properties)
		                if ( request.readyState === 4 ) {
		                    request.onreadystatechange = function(){};

		                    // With protocols other than http/https, a successful request status is in
		                    // the 200's on Firefox and 0 on other browsers
		                    if ( (request.status >= 200 && request.status < 300) ||
		                        ( request.status === 0 &&
		                          protocol !== "http:" &&
		                          protocol !== "https:" )) {
		                        onSuccess( request );
		                    } else {
		                        if ( $.isFunction( onError ) ) {
		                            onError( request );
		                        } else {
		                            $.console.error( "AJAX request returned %d: %s", request.status, url );
		                        }
		                    }
		                }
		            };

		            var method = postData ? "POST" : "GET";
		            try {
		                request.open( method, url, true );

		                if (responseType) {
		                    request.responseType = responseType;
		                }

		                if (headers) {
		                    for (var headerName in headers) {
		                        if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
		                            request.setRequestHeader(headerName, headers[headerName]);
		                        }
		                    }
		                }

		                if (withCredentials) {
		                    request.withCredentials = true;
		                }

		                request.send(postData);
		            } catch (e) {
		                $.console.error( "%s while making AJAX request: %s", e.name, e.message );

		                request.onreadystatechange = function(){};

		                if ( $.isFunction( onError ) ) {
		                    onError( request, e );
		                }
		            }

		            return request;
		        },

		        /**
		         * Taken from jQuery 1.6.1
		         * @function
		         * @param {Object} options
		         * @param {String} options.url
		         * @param {Function} options.callback
		         * @param {String} [options.param='callback'] The name of the url parameter
		         *      to request the jsonp provider with.
		         * @param {String} [options.callbackName=] The name of the callback to
		         *      request the jsonp provider with.
		         */
		        jsonp: function( options ){
		            var script,
		                url     = options.url,
		                head    = document.head ||
		                    document.getElementsByTagName( "head" )[ 0 ] ||
		                    document.documentElement,
		                jsonpCallback = options.callbackName || 'openseadragon' + $.now(),
		                previous      = window[ jsonpCallback ],
		                replace       = "$1" + jsonpCallback + "$2",
		                callbackParam = options.param || 'callback',
		                callback      = options.callback;

		            url = url.replace( /(=)\?(&|$)|\?\?/i, replace );
		            // Add callback manually
		            url += (/\?/.test( url ) ? "&" : "?") + callbackParam + "=" + jsonpCallback;

		            // Install callback
		            window[ jsonpCallback ] = function( response ) {
		                if ( !previous ){
		                    try{
		                        delete window[ jsonpCallback ];
		                    }catch(e){
		                        //swallow
		                    }
		                } else {
		                    window[ jsonpCallback ] = previous;
		                }
		                if( callback && $.isFunction( callback ) ){
		                    callback( response );
		                }
		            };

		            script = document.createElement( "script" );

		            //TODO: having an issue with async info requests
		            if( undefined !== options.async || false !== options.async ){
		                script.async = "async";
		            }

		            if ( options.scriptCharset ) {
		                script.charset = options.scriptCharset;
		            }

		            script.src = url;

		            // Attach handlers for all browsers
		            script.onload = script.onreadystatechange = function( _, isAbort ) {

		                if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

		                    // Handle memory leak in IE
		                    script.onload = script.onreadystatechange = null;

		                    // Remove the script
		                    if ( head && script.parentNode ) {
		                        head.removeChild( script );
		                    }

		                    // Dereference the script
		                    script = undefined;
		                }
		            };
		            // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
		            // This arises when a base node is used (#2709 and #4378).
		            head.insertBefore( script, head.firstChild );

		        },


		        /**
		         * Fully deprecated. Will throw an error.
		         * @function
		         * @deprecated use {@link OpenSeadragon.Viewer#open}
		         */
		        createFromDZI: function() {
		            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
		        },

		        /**
		         * Parses an XML string into a DOM Document.
		         * @function
		         * @param {String} string
		         * @returns {Document}
		         */
		        parseXml: function( string ) {
		            if ( window.DOMParser ) {

		                $.parseXml = function( string ) {
		                    var xmlDoc = null,
		                        parser;

		                    parser = new DOMParser();
		                    xmlDoc = parser.parseFromString( string, "text/xml" );
		                    return xmlDoc;
		                };

		            } else {
		                throw new Error( "Browser doesn't support XML DOM." );
		            }

		            return $.parseXml( string );
		        },

		        /**
		         * Parses a JSON string into a Javascript object.
		         * @function
		         * @param {String} string
		         * @returns {Object}
		         */
		        parseJSON: function(string) {
		            $.parseJSON = window.JSON.parse;
		            return $.parseJSON(string);
		        },

		        /**
		         * Reports whether the image format is supported for tiling in this
		         * version.
		         * @function
		         * @param {String} [extension]
		         * @returns {Boolean}
		         */
		        imageFormatSupported: function( extension ) {
		            extension = extension ? extension : "";
		            // eslint-disable-next-line no-use-before-define
		            return !!FILEFORMATS[ extension.toLowerCase() ];
		        },

		        /**
		         * Updates supported image formats with user-specified values.
		         * Preexisting formats that are not being updated are left unchanged.
		         * By default, the defined formats are
		         * <pre><code>{
		         *      avif: true,
		         *      bmp:  false,
		         *      jpeg: true,
		         *      jpg:  true,
		         *      png:  true,
		         *      tif:  false,
		         *      wdp:  false,
		         *      webp: true
		         * }
		         * </code></pre>
		         * @function
		         * @example
		         * // sets bmp as supported and png as unsupported
		         * setImageFormatsSupported({bmp: true, png: false});
		         * @param {Object} formats An object containing format extensions as
		         * keys and booleans as values.
		         */
		        setImageFormatsSupported: function(formats) {
		            // eslint-disable-next-line no-use-before-define
		            $.extend(FILEFORMATS, formats);
		        }

		    });


		    //TODO: $.console is often used inside a try/catch block which generally
		    //      prevents allowings errors to occur with detection until a debugger
		    //      is attached.  Although I've been guilty of the same anti-pattern
		    //      I eventually was convinced that errors should naturally propagate in
		    //      all but the most special cases.
		    /**
		     * A convenient alias for console when available, and a simple null
		     * function when console is unavailable.
		     * @static
		     * @private
		     */
		    var nullfunction = function( msg ){
		        //document.location.hash = msg;
		    };

		    $.console = window.console || {
		        log:    nullfunction,
		        debug:  nullfunction,
		        info:   nullfunction,
		        warn:   nullfunction,
		        error:  nullfunction,
		        assert: nullfunction
		    };


		    /**
		     * The current browser vendor, version, and related information regarding detected features.
		     * @member {Object} Browser
		     * @memberof OpenSeadragon
		     * @static
		     * @type {Object}
		     * @property {OpenSeadragon.BROWSERS} vendor - One of the {@link OpenSeadragon.BROWSERS} enumeration values.
		     * @property {Number} version
		     * @property {Boolean} alpha - Does the browser support image alpha transparency.
		     */
		    $.Browser = {
		        vendor:     $.BROWSERS.UNKNOWN,
		        version:    0,
		        alpha:      true
		    };


		    var FILEFORMATS = {
		            avif: true,
		            bmp:  false,
		            jpeg: true,
		            jpg:  true,
		            png:  true,
		            tif:  false,
		            wdp:  false,
		            webp: true
		        },
		        URLPARAMS = {};

		    (function() {
		        //A small auto-executing routine to determine the browser vendor,
		        //version and supporting feature sets.
		        var ver = navigator.appVersion,
		            ua  = navigator.userAgent,
		            regex;

		        //console.error( 'appName: ' + navigator.appName );
		        //console.error( 'appVersion: ' + navigator.appVersion );
		        //console.error( 'userAgent: ' + navigator.userAgent );

		        //TODO navigator.appName is deprecated. Should be 'Netscape' for all browsers
		        //  but could be dropped at any time
		        //  See https://developer.mozilla.org/en-US/docs/Web/API/Navigator/appName
		        //      https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
		        switch( navigator.appName ){
		            case "Microsoft Internet Explorer":
		                if( !!window.attachEvent &&
		                    !!window.ActiveXObject ) {

		                    $.Browser.vendor = $.BROWSERS.IE;
		                    $.Browser.version = parseFloat(
		                        ua.substring(
		                            ua.indexOf( "MSIE" ) + 5,
		                            ua.indexOf( ";", ua.indexOf( "MSIE" ) ) )
		                        );
		                }
		                break;
		            case "Netscape":
		                if (window.addEventListener) {
		                    if ( ua.indexOf( "Edge" ) >= 0 ) {
		                        $.Browser.vendor = $.BROWSERS.EDGE;
		                        $.Browser.version = parseFloat(
		                            ua.substring( ua.indexOf( "Edge" ) + 5 )
		                        );
		                    } else if ( ua.indexOf( "Edg" ) >= 0 ) {
		                        $.Browser.vendor = $.BROWSERS.CHROMEEDGE;
		                        $.Browser.version = parseFloat(
		                            ua.substring( ua.indexOf( "Edg" ) + 4 )
		                        );
		                    } else if ( ua.indexOf( "Firefox" ) >= 0 ) {
		                        $.Browser.vendor = $.BROWSERS.FIREFOX;
		                        $.Browser.version = parseFloat(
		                            ua.substring( ua.indexOf( "Firefox" ) + 8 )
		                        );
		                    } else if ( ua.indexOf( "Safari" ) >= 0 ) {
		                        $.Browser.vendor = ua.indexOf( "Chrome" ) >= 0 ?
		                            $.BROWSERS.CHROME :
		                            $.BROWSERS.SAFARI;
		                        $.Browser.version = parseFloat(
		                            ua.substring(
		                                ua.substring( 0, ua.indexOf( "Safari" ) ).lastIndexOf( "/" ) + 1,
		                                ua.indexOf( "Safari" )
		                            )
		                        );
		                    } else {
		                        regex = new RegExp( "Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
		                        if ( regex.exec( ua ) !== null ) {
		                            $.Browser.vendor = $.BROWSERS.IE;
		                            $.Browser.version = parseFloat( RegExp.$1 );
		                        }
		                    }
		                }
		                break;
		            case "Opera":
		                $.Browser.vendor = $.BROWSERS.OPERA;
		                $.Browser.version = parseFloat( ver );
		                break;
		        }

		            // ignore '?' portion of query string
		        var query = window.location.search.substring( 1 ),
		            parts = query.split('&'),
		            part,
		            sep,
		            i;

		        for ( i = 0; i < parts.length; i++ ) {
		            part = parts[ i ];
		            sep  = part.indexOf( '=' );

		            if ( sep > 0 ) {
		                var key = part.substring( 0, sep ),
		                    value = part.substring( sep + 1 );
		                try {
		                    URLPARAMS[ key ] = decodeURIComponent( value );
		                } catch (e) {
		                    $.console.error( "Ignoring malformed URL parameter: %s=%s", key, value );
		                }
		            }
		        }

		        //determine if this browser supports image alpha transparency
		        $.Browser.alpha = !(
		            $.Browser.vendor === $.BROWSERS.CHROME && $.Browser.version < 2
		        );

		        //determine if this browser supports element.style.opacity
		        $.Browser.opacity = true;

		        if ( $.Browser.vendor === $.BROWSERS.IE ) {
		            $.console.error('Internet Explorer is not supported by OpenSeadragon');
		        }
		    })();


		    // Adding support for HTML5's requestAnimationFrame as suggested by acdha.
		    // Implementation taken from matt synder's post here:
		    // http://mattsnider.com/cross-browser-and-legacy-supported-requestframeanimation/
		    (function( w ) {

		        // most browsers have an implementation
		        var requestAnimationFrame = w.requestAnimationFrame ||
		            w.mozRequestAnimationFrame ||
		            w.webkitRequestAnimationFrame ||
		            w.msRequestAnimationFrame;

		        var cancelAnimationFrame = w.cancelAnimationFrame ||
		            w.mozCancelAnimationFrame ||
		            w.webkitCancelAnimationFrame ||
		            w.msCancelAnimationFrame;

		        // polyfill, when necessary
		        if ( requestAnimationFrame && cancelAnimationFrame ) {
		            // We can't assign these window methods directly to $ because they
		            // expect their "this" to be "window", so we call them in wrappers.
		            $.requestAnimationFrame = function(){
		                return requestAnimationFrame.apply( w, arguments );
		            };
		            $.cancelAnimationFrame = function(){
		                return cancelAnimationFrame.apply( w, arguments );
		            };
		        } else {
		            var aAnimQueue = [],
		                processing = [],
		                iRequestId = 0,
		                iIntervalId;

		            // create a mock requestAnimationFrame function
		            $.requestAnimationFrame = function( callback ) {
		                aAnimQueue.push( [ ++iRequestId, callback ] );

		                if ( !iIntervalId ) {
		                    iIntervalId = setInterval( function() {
		                        if ( aAnimQueue.length ) {
		                            var time = $.now();
		                            // Process all of the currently outstanding frame
		                            // requests, but none that get added during the
		                            // processing.
		                            // Swap the arrays so we don't have to create a new
		                            // array every frame.
		                            var temp = processing;
		                            processing = aAnimQueue;
		                            aAnimQueue = temp;
		                            while ( processing.length ) {
		                                processing.shift()[ 1 ]( time );
		                            }
		                        } else {
		                            // don't continue the interval, if unnecessary
		                            clearInterval( iIntervalId );
		                            iIntervalId = undefined;
		                        }
		                    }, 1000 / 50);  // estimating support for 50 frames per second
		                }

		                return iRequestId;
		            };

		            // create a mock cancelAnimationFrame function
		            $.cancelAnimationFrame = function( requestId ) {
		                // find the request ID and remove it
		                var i, j;
		                for ( i = 0, j = aAnimQueue.length; i < j; i += 1 ) {
		                    if ( aAnimQueue[ i ][ 0 ] === requestId ) {
		                        aAnimQueue.splice( i, 1 );
		                        return;
		                    }
		                }

		                // If it's not in the queue, it may be in the set we're currently
		                // processing (if cancelAnimationFrame is called from within a
		                // requestAnimationFrame callback).
		                for ( i = 0, j = processing.length; i < j; i += 1 ) {
		                    if ( processing[ i ][ 0 ] === requestId ) {
		                        processing.splice( i, 1 );
		                        return;
		                    }
		                }
		            };
		        }
		    })( window );

		    /**
		     * @private
		     * @inner
		     * @function
		     * @param {Element} element
		     * @param {Boolean} [isFixed]
		     * @returns {Element}
		     */
		    function getOffsetParent( element, isFixed ) {
		        if ( isFixed && element !== document.body ) {
		            return document.body;
		        } else {
		            return element.offsetParent;
		        }
		    }

		}(OpenSeadragon));


		// Universal Module Definition, supports CommonJS, AMD and simple script tag
		(function (root, factory) {
		    if (module.exports) {
		        // expose as commonjs module
		        module.exports = factory();
		    } else {
		        // expose as window.OpenSeadragon
		        root.OpenSeadragon = factory();
		    }
		}(openseadragon, function () {
		    return OpenSeadragon;
		}));

		/*
		 * OpenSeadragon - Mat3
		 *
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 *
		 */


		/*
		 * Portions of this source file are taken from WegGL Fundamentals:
		 *
		 * Copyright 2012, Gregg Tavares.
		 * All rights reserved.
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 *     * Redistributions of source code must retain the above copyright
		 * notice, this list of conditions and the following disclaimer.
		 *     * Redistributions in binary form must reproduce the above
		 * copyright notice, this list of conditions and the following disclaimer
		 * in the documentation and/or other materials provided with the
		 * distribution.
		 *     * Neither the name of Gregg Tavares. nor the names of his
		 * contributors may be used to endorse or promote products derived from
		 * this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
		 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
		 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
		 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
		 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 *
		 */




		(function( $ ){

		// Modified from https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html

		/**
		 *
		 *
		 * @class Mat3
		 * @classdesc A left-to-right matrix representation, useful for affine transforms for
		 * positioning tiles for drawing
		 *
		 * @memberof OpenSeadragon
		 *
		 * @param {Array} [values] - Initial values for the matrix
		 *
		 **/
		class Mat3{
		    constructor(values){
		        if(!values) {
		            values = [
		                0, 0, 0,
		                0, 0, 0,
		                0, 0, 0
		            ];
		        }
		        this.values = values;
		    }

		    /**
		     * @function makeIdentity
		     * @memberof OpenSeadragon.Mat3
		     * @static
		     * @returns {OpenSeadragon.Mat3} an identity matrix
		     */
		    static makeIdentity(){
		        return new Mat3([
		            1, 0, 0,
		            0, 1, 0,
		            0, 0, 1
		        ]);
		    }

		    /**
		     * @function makeTranslation
		     * @memberof OpenSeadragon.Mat3
		     * @static
		     * @param {Number} tx The x value of the translation
		     * @param {Number} ty The y value of the translation
		     * @returns {OpenSeadragon.Mat3} A translation matrix
		     */
		    static makeTranslation(tx, ty) {
		        return new Mat3([
		            1, 0, 0,
		            0, 1, 0,
		            tx, ty, 1,
		        ]);
		    }

		    /**
		     * @function makeRotation
		     * @memberof OpenSeadragon.Mat3
		     * @static
		     * @param {Number} angleInRadians The desired rotation angle, in radians
		     * @returns {OpenSeadragon.Mat3} A rotation matrix
		     */
		    static makeRotation(angleInRadians) {
		        var c = Math.cos(angleInRadians);
		        var s = Math.sin(angleInRadians);
		        return new Mat3([
		            c, -s, 0,
		            s, c, 0,
		            0, 0, 1,
		        ]);
		    }

		    /**
		     * @function makeScaling
		     * @memberof OpenSeadragon.Mat3
		     * @static
		     * @param {Number} sx The x value of the scaling
		     * @param {Number} sy The y value of the scaling
		     * @returns {OpenSeadragon.Mat3} A scaling matrix
		     */
		    static makeScaling(sx, sy) {
		        return new Mat3([
		            sx, 0, 0,
		            0, sy, 0,
		            0, 0, 1,
		        ]);
		    }

		    /**
		     * @alias multiply
		     * @memberof! OpenSeadragon.Mat3
		     * @param {OpenSeadragon.Mat3} other the matrix to multiply with
		     * @returns {OpenSeadragon.Mat3} The result of matrix multiplication
		     */
		    multiply(other) {
		        let a = this.values;
		        let b = other.values;

		        var a00 = a[0 * 3 + 0];
		        var a01 = a[0 * 3 + 1];
		        var a02 = a[0 * 3 + 2];
		        var a10 = a[1 * 3 + 0];
		        var a11 = a[1 * 3 + 1];
		        var a12 = a[1 * 3 + 2];
		        var a20 = a[2 * 3 + 0];
		        var a21 = a[2 * 3 + 1];
		        var a22 = a[2 * 3 + 2];
		        var b00 = b[0 * 3 + 0];
		        var b01 = b[0 * 3 + 1];
		        var b02 = b[0 * 3 + 2];
		        var b10 = b[1 * 3 + 0];
		        var b11 = b[1 * 3 + 1];
		        var b12 = b[1 * 3 + 2];
		        var b20 = b[2 * 3 + 0];
		        var b21 = b[2 * 3 + 1];
		        var b22 = b[2 * 3 + 2];
		        return new Mat3([
		            b00 * a00 + b01 * a10 + b02 * a20,
		            b00 * a01 + b01 * a11 + b02 * a21,
		            b00 * a02 + b01 * a12 + b02 * a22,
		            b10 * a00 + b11 * a10 + b12 * a20,
		            b10 * a01 + b11 * a11 + b12 * a21,
		            b10 * a02 + b11 * a12 + b12 * a22,
		            b20 * a00 + b21 * a10 + b22 * a20,
		            b20 * a01 + b21 * a11 + b22 * a21,
		            b20 * a02 + b21 * a12 + b22 * a22,
		        ]);
		    }
		}


		$.Mat3 = Mat3;

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - full-screen support functions
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ) {
		    /**
		     * Determine native full screen support we can get from the browser.
		     * @member fullScreenApi
		     * @memberof OpenSeadragon
		     * @type {object}
		     * @property {Boolean} supportsFullScreen Return true if full screen API is supported.
		     * @property {Function} isFullScreen Return true if currently in full screen mode.
		     * @property {Function} getFullScreenElement Return the element currently in full screen mode.
		     * @property {Function} requestFullScreen Make a request to go in full screen mode.
		     * @property {Function} exitFullScreen Make a request to exit full screen mode.
		     * @property {Function} cancelFullScreen Deprecated, use exitFullScreen instead.
		     * @property {String} fullScreenEventName Event fired when the full screen mode change.
		     * @property {String} fullScreenErrorEventName Event fired when a request to go
		     * in full screen mode failed.
		     */
		    var fullScreenApi = {
		        supportsFullScreen: false,
		        isFullScreen: function() { return false; },
		        getFullScreenElement: function() { return null; },
		        requestFullScreen: function() {},
		        exitFullScreen: function() {},
		        cancelFullScreen: function() {},
		        fullScreenEventName: '',
		        fullScreenErrorEventName: ''
		    };

		    // check for native support
		    if ( document.exitFullscreen ) {
		        // W3C standard
		        fullScreenApi.supportsFullScreen = true;
		        fullScreenApi.getFullScreenElement = function() {
		            return document.fullscreenElement;
		        };
		        fullScreenApi.requestFullScreen = function( element ) {
		            return element.requestFullscreen().catch(function (msg) {
		                $.console.error('Fullscreen request failed: ', msg);
		            });
		        };
		        fullScreenApi.exitFullScreen = function() {
		            document.exitFullscreen().catch(function (msg) {
		                $.console.error('Error while exiting fullscreen: ', msg);
		            });
		        };
		        fullScreenApi.fullScreenEventName = "fullscreenchange";
		        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
		    } else if ( document.msExitFullscreen ) {
		        // IE 11
		        fullScreenApi.supportsFullScreen = true;
		        fullScreenApi.getFullScreenElement = function() {
		            return document.msFullscreenElement;
		        };
		        fullScreenApi.requestFullScreen = function( element ) {
		            return element.msRequestFullscreen();
		        };
		        fullScreenApi.exitFullScreen = function() {
		            document.msExitFullscreen();
		        };
		        fullScreenApi.fullScreenEventName = "MSFullscreenChange";
		        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
		    } else if ( document.webkitExitFullscreen ) {
		        // Recent webkit
		        fullScreenApi.supportsFullScreen = true;
		        fullScreenApi.getFullScreenElement = function() {
		            return document.webkitFullscreenElement;
		        };
		        fullScreenApi.requestFullScreen = function( element ) {
		            return element.webkitRequestFullscreen();
		        };
		        fullScreenApi.exitFullScreen = function() {
		            document.webkitExitFullscreen();
		        };
		        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
		        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
		    } else if ( document.webkitCancelFullScreen ) {
		        // Old webkit
		        fullScreenApi.supportsFullScreen = true;
		        fullScreenApi.getFullScreenElement = function() {
		            return document.webkitCurrentFullScreenElement;
		        };
		        fullScreenApi.requestFullScreen = function( element ) {
		            return element.webkitRequestFullScreen();
		        };
		        fullScreenApi.exitFullScreen = function() {
		            document.webkitCancelFullScreen();
		        };
		        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
		        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
		    } else if ( document.mozCancelFullScreen ) {
		        // Firefox
		        fullScreenApi.supportsFullScreen = true;
		        fullScreenApi.getFullScreenElement = function() {
		            return document.mozFullScreenElement;
		        };
		        fullScreenApi.requestFullScreen = function( element ) {
		            return element.mozRequestFullScreen();
		        };
		        fullScreenApi.exitFullScreen = function() {
		            document.mozCancelFullScreen();
		        };
		        fullScreenApi.fullScreenEventName = "mozfullscreenchange";
		        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
		    }
		    fullScreenApi.isFullScreen = function() {
		        return fullScreenApi.getFullScreenElement() !== null;
		    };
		    fullScreenApi.cancelFullScreen = function() {
		        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
		        fullScreenApi.exitFullScreen();
		    };

		    // export api
		    $.extend( $, fullScreenApi );

		})( OpenSeadragon );

		/*
		 * OpenSeadragon - EventSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($){

		/**
		 * Event handler method signature used by all OpenSeadragon events.
		 *
		 * @callback EventHandler
		 * @memberof OpenSeadragon
		 * @param {Object} event - See individual events for event-specific properties.
		 */


		/**
		 * @class EventSource
		 * @classdesc For use by classes which want to support custom, non-browser events.
		 *
		 * @memberof OpenSeadragon
		 */
		$.EventSource = function() {
		    this.events = {};
		    this._rejectedEventList = {};
		};

		/** @lends OpenSeadragon.EventSource.prototype */
		$.EventSource.prototype = {

		    /**
		     * Add an event handler to be triggered only once (or a given number of times)
		     * for a given event. It is not removable with removeHandler().
		     * @function
		     * @param {String} eventName - Name of event to register.
		     * @param {OpenSeadragon.EventHandler} handler - Function to call when event
		     * is triggered.
		     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
		     * to the handler.
		     * @param {Number} [times=1] - The number of times to handle the event
		     * before removing it.
		     * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
		     * @returns {Boolean} - True if the handler was added, false if it was rejected
		     */
		    addOnceHandler: function(eventName, handler, userData, times, priority) {
		        var self = this;
		        times = times || 1;
		        var count = 0;
		        var onceHandler = function(event) {
		            count++;
		            if (count === times) {
		                self.removeHandler(eventName, onceHandler);
		            }
		            return handler(event);
		        };
		        return this.addHandler(eventName, onceHandler, userData, priority);
		    },

		    /**
		     * Add an event handler for a given event.
		     * @function
		     * @param {String} eventName - Name of event to register.
		     * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
		     * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
		     * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
		     * @returns {Boolean} - True if the handler was added, false if it was rejected
		     */
		    addHandler: function ( eventName, handler, userData, priority ) {

		        if(Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)){
		            $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
		            return false;
		        }

		        var events = this.events[ eventName ];
		        if ( !events ) {
		            this.events[ eventName ] = events = [];
		        }
		        if ( handler && $.isFunction( handler ) ) {
		            var index = events.length,
		                event = { handler: handler, userData: userData || null, priority: priority || 0 };
		            events[ index ] = event;
		            while ( index > 0 && events[ index - 1 ].priority < events[ index ].priority ) {
		                events[ index ] = events[ index - 1 ];
		                events[ index - 1 ] = event;
		                index--;
		            }
		        }
		        return true;
		    },

		    /**
		     * Remove a specific event handler for a given event.
		     * @function
		     * @param {String} eventName - Name of event for which the handler is to be removed.
		     * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
		     */
		    removeHandler: function ( eventName, handler ) {
		        var events = this.events[ eventName ],
		            handlers = [],
		            i;
		        if ( !events ) {
		            return;
		        }
		        if ( $.isArray( events ) ) {
		            for ( i = 0; i < events.length; i++ ) {
		                if ( events[i].handler !== handler ) {
		                    handlers.push( events[ i ] );
		                }
		            }
		            this.events[ eventName ] = handlers;
		        }
		    },

		    /**
		     * Get the amount of handlers registered for a given event.
		     * @param {String} eventName - Name of event to inspect.
		     * @returns {number} amount of events
		     */
		    numberOfHandlers: function (eventName) {
		        var events = this.events[ eventName ];
		        if ( !events ) {
		            return 0;
		        }
		        return events.length;
		    },

		    /**
		     * Remove all event handlers for a given event type. If no type is given all
		     * event handlers for every event type are removed.
		     * @function
		     * @param {String} eventName - Name of event for which all handlers are to be removed.
		     */
		    removeAllHandlers: function( eventName ) {
		        if ( eventName ){
		            this.events[ eventName ] = [];
		        } else {
		            for ( var eventType in this.events ) {
		                this.events[ eventType ] = [];
		            }
		        }
		    },

		    /**
		     * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
		     * @function
		     * @param {String} eventName - Name of event to get handlers for.
		     */
		    getHandler: function ( eventName) {
		        var events = this.events[ eventName ];
		        if ( !events || !events.length ) {
		            return null;
		        }
		        events = events.length === 1 ?
		            [ events[ 0 ] ] :
		            Array.apply( null, events );
		        return function ( source, args ) {
		            var i,
		                length = events.length;
		            for ( i = 0; i < length; i++ ) {
		                if ( events[ i ] ) {
		                    args.eventSource = source;
		                    args.userData = events[ i ].userData;
		                    events[ i ].handler( args );
		                }
		            }
		        };
		    },

		    /**
		     * Trigger an event, optionally passing additional information.
		     * @function
		     * @param {String} eventName - Name of event to register.
		     * @param {Object} eventArgs - Event-specific data.
		     * @returns {Boolean} True if the event was fired, false if it was rejected because of rejectEventHandler(eventName)
		     */
		    raiseEvent: function( eventName, eventArgs ) {
		        //uncomment if you want to get a log of all events
		        //$.console.log( eventName );

		        if(Object.prototype.hasOwnProperty.call(this._rejectedEventList, eventName)){
		            $.console.error(`Error adding handler for ${eventName}. ${this._rejectedEventList[eventName]}`);
		            return false;
		        }

		        var handler = this.getHandler( eventName );
		        if ( handler ) {
		            handler( this, eventArgs || {} );
		        }
		        return true;
		    },

		    /**
		     * Set an event name as being disabled, and provide an optional error message
		     * to be printed to the console
		     * @param {String} eventName - Name of the event
		     * @param {String} [errorMessage] - Optional string to print to the console
		     * @private
		     */
		    rejectEventHandler(eventName, errorMessage = ''){
		        this._rejectedEventList[eventName] = errorMessage;
		    },

		    /**
		     * Explicitly allow an event handler to be added for this event type, undoing
		     * the effects of rejectEventHandler
		     * @param {String} eventName - Name of the event
		     * @private
		     */
		    allowEventHandler(eventName){
		        delete this._rejectedEventList[eventName];
		    }

		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - MouseTracker
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function ( $ ) {

		    // dictionary from hash to private properties
		    var THIS           = {};


		    /**
		     * @class MouseTracker
		     * @classdesc Provides simplified handling of common pointer device (mouse, touch, pen, etc.) gestures
		     *            and keyboard events on a specified element.
		     * @memberof OpenSeadragon
		     * @param {Object} options
		     *      Allows configurable properties to be entirely specified by passing
		     *      an options object to the constructor.  The constructor also supports
		     *      the original positional arguments 'element', 'clickTimeThreshold',
		     *      and 'clickDistThreshold' in that order.
		     * @param {Element|String} options.element
		     *      A reference to an element or an element id for which the pointer/key
		     *      events will be monitored.
		     * @param {Boolean} [options.startDisabled=false]
		     *      If true, event tracking on the element will not start until
		     *      {@link OpenSeadragon.MouseTracker.setTracking|setTracking} is called.
		     * @param {Number} [options.clickTimeThreshold=300]
		     *      The number of milliseconds within which a pointer down-up event combination
		     *      will be treated as a click gesture.
		     * @param {Number} [options.clickDistThreshold=5]
		     *      The maximum distance allowed between a pointer down event and a pointer up event
		     *      to be treated as a click gesture.
		     * @param {Number} [options.dblClickTimeThreshold=300]
		     *      The number of milliseconds within which two pointer down-up event combinations
		     *      will be treated as a double-click gesture.
		     * @param {Number} [options.dblClickDistThreshold=20]
		     *      The maximum distance allowed between two pointer click events
		     *      to be treated as a click gesture.
		     * @param {Number} [options.stopDelay=50]
		     *      The number of milliseconds without pointer move before the stop
		     *      event is fired.
		     * @param {OpenSeadragon.EventHandler} [options.preProcessEventHandler=null]
		     *      An optional handler for controlling DOM event propagation and processing.
		     * @param {OpenSeadragon.EventHandler} [options.contextMenuHandler=null]
		     *      An optional handler for contextmenu.
		     * @param {OpenSeadragon.EventHandler} [options.enterHandler=null]
		     *      An optional handler for pointer enter.
		     * @param {OpenSeadragon.EventHandler} [options.leaveHandler=null]
		     *      An optional handler for pointer leave.
		     * @param {OpenSeadragon.EventHandler} [options.exitHandler=null]
		     *      An optional handler for pointer leave. <span style="color:red;">Deprecated. Use leaveHandler instead.</span>
		     * @param {OpenSeadragon.EventHandler} [options.overHandler=null]
		     *      An optional handler for pointer over.
		     * @param {OpenSeadragon.EventHandler} [options.outHandler=null]
		     *      An optional handler for pointer out.
		     * @param {OpenSeadragon.EventHandler} [options.pressHandler=null]
		     *      An optional handler for pointer press.
		     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryPressHandler=null]
		     *      An optional handler for pointer non-primary button press.
		     * @param {OpenSeadragon.EventHandler} [options.releaseHandler=null]
		     *      An optional handler for pointer release.
		     * @param {OpenSeadragon.EventHandler} [options.nonPrimaryReleaseHandler=null]
		     *      An optional handler for pointer non-primary button release.
		     * @param {OpenSeadragon.EventHandler} [options.moveHandler=null]
		     *      An optional handler for pointer move.
		     * @param {OpenSeadragon.EventHandler} [options.scrollHandler=null]
		     *      An optional handler for mouse wheel scroll.
		     * @param {OpenSeadragon.EventHandler} [options.clickHandler=null]
		     *      An optional handler for pointer click.
		     * @param {OpenSeadragon.EventHandler} [options.dblClickHandler=null]
		     *      An optional handler for pointer double-click.
		     * @param {OpenSeadragon.EventHandler} [options.dragHandler=null]
		     *      An optional handler for the drag gesture.
		     * @param {OpenSeadragon.EventHandler} [options.dragEndHandler=null]
		     *      An optional handler for after a drag gesture.
		     * @param {OpenSeadragon.EventHandler} [options.pinchHandler=null]
		     *      An optional handler for the pinch gesture.
		     * @param {OpenSeadragon.EventHandler} [options.keyDownHandler=null]
		     *      An optional handler for keydown.
		     * @param {OpenSeadragon.EventHandler} [options.keyUpHandler=null]
		     *      An optional handler for keyup.
		     * @param {OpenSeadragon.EventHandler} [options.keyHandler=null]
		     *      An optional handler for keypress.
		     * @param {OpenSeadragon.EventHandler} [options.focusHandler=null]
		     *      An optional handler for focus.
		     * @param {OpenSeadragon.EventHandler} [options.blurHandler=null]
		     *      An optional handler for blur.
		     * @param {Object} [options.userData=null]
		     *      Arbitrary object to be passed unchanged to any attached handler methods.
		     */
		    $.MouseTracker = function ( options ) {

		        var args = arguments;

		        if ( !$.isPlainObject( options ) ) {
		            options = {
		                element:            args[ 0 ],
		                clickTimeThreshold: args[ 1 ],
		                clickDistThreshold: args[ 2 ]
		            };
		        }

		        this.hash               = Math.random(); // An unique hash for this tracker.
		        /**
		         * The element for which pointer events are being monitored.
		         * @member {Element} element
		         * @memberof OpenSeadragon.MouseTracker#
		         */
		        this.element            = $.getElement( options.element );
		        /**
		         * The number of milliseconds within which a pointer down-up event combination
		         * will be treated as a click gesture.
		         * @member {Number} clickTimeThreshold
		         * @memberof OpenSeadragon.MouseTracker#
		         */
		        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
		        /**
		         * The maximum distance allowed between a pointer down event and a pointer up event
		         * to be treated as a click gesture.
		         * @member {Number} clickDistThreshold
		         * @memberof OpenSeadragon.MouseTracker#
		         */
		        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
		        /**
		         * The number of milliseconds within which two pointer down-up event combinations
		         * will be treated as a double-click gesture.
		         * @member {Number} dblClickTimeThreshold
		         * @memberof OpenSeadragon.MouseTracker#
		         */
		        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
		        /**
		         * The maximum distance allowed between two pointer click events
		         * to be treated as a double-click gesture.
		         * @member {Number} dblClickDistThreshold
		         * @memberof OpenSeadragon.MouseTracker#
		         */
		        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
		        /*eslint-disable no-multi-spaces*/
		        this.userData              = options.userData          || null;
		        this.stopDelay             = options.stopDelay         || 50;

		        this.preProcessEventHandler   = options.preProcessEventHandler   || null;
		        this.contextMenuHandler       = options.contextMenuHandler       || null;
		        this.enterHandler             = options.enterHandler             || null;
		        this.leaveHandler             = options.leaveHandler             || null;
		        this.exitHandler              = options.exitHandler              || null; // Deprecated v2.5.0
		        this.overHandler              = options.overHandler              || null;
		        this.outHandler               = options.outHandler               || null;
		        this.pressHandler             = options.pressHandler             || null;
		        this.nonPrimaryPressHandler   = options.nonPrimaryPressHandler   || null;
		        this.releaseHandler           = options.releaseHandler           || null;
		        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
		        this.moveHandler              = options.moveHandler              || null;
		        this.scrollHandler            = options.scrollHandler            || null;
		        this.clickHandler             = options.clickHandler             || null;
		        this.dblClickHandler          = options.dblClickHandler          || null;
		        this.dragHandler              = options.dragHandler              || null;
		        this.dragEndHandler           = options.dragEndHandler           || null;
		        this.pinchHandler             = options.pinchHandler             || null;
		        this.stopHandler              = options.stopHandler              || null;
		        this.keyDownHandler           = options.keyDownHandler           || null;
		        this.keyUpHandler             = options.keyUpHandler             || null;
		        this.keyHandler               = options.keyHandler               || null;
		        this.focusHandler             = options.focusHandler             || null;
		        this.blurHandler              = options.blurHandler              || null;
		        /*eslint-enable no-multi-spaces*/

		        //Store private properties in a scope sealed hash map
		        var _this = this;

		        /**
		         * @private
		         * @property {Boolean} tracking
		         *      Are we currently tracking pointer events for this element.
		         */
		        THIS[ this.hash ] = {
		            click:                 function ( event ) { onClick( _this, event ); },
		            dblclick:              function ( event ) { onDblClick( _this, event ); },
		            keydown:               function ( event ) { onKeyDown( _this, event ); },
		            keyup:                 function ( event ) { onKeyUp( _this, event ); },
		            keypress:              function ( event ) { onKeyPress( _this, event ); },
		            focus:                 function ( event ) { onFocus( _this, event ); },
		            blur:                  function ( event ) { onBlur( _this, event ); },
		            contextmenu:           function ( event ) { onContextMenu( _this, event ); },

		            wheel:                 function ( event ) { onWheel( _this, event ); },
		            mousewheel:            function ( event ) { onMouseWheel( _this, event ); },
		            DOMMouseScroll:        function ( event ) { onMouseWheel( _this, event ); },
		            MozMousePixelScroll:   function ( event ) { onMouseWheel( _this, event ); },

		            losecapture:           function ( event ) { onLoseCapture( _this, event ); },

		            mouseenter:            function ( event ) { onPointerEnter( _this, event ); },
		            mouseleave:            function ( event ) { onPointerLeave( _this, event ); },
		            mouseover:             function ( event ) { onPointerOver( _this, event ); },
		            mouseout:              function ( event ) { onPointerOut( _this, event ); },
		            mousedown:             function ( event ) { onPointerDown( _this, event ); },
		            mouseup:               function ( event ) { onPointerUp( _this, event ); },
		            mousemove:             function ( event ) { onPointerMove( _this, event ); },

		            touchstart:            function ( event ) { onTouchStart( _this, event ); },
		            touchend:              function ( event ) { onTouchEnd( _this, event ); },
		            touchmove:             function ( event ) { onTouchMove( _this, event ); },
		            touchcancel:           function ( event ) { onTouchCancel( _this, event ); },

		            gesturestart:          function ( event ) { onGestureStart( _this, event ); }, // Safari/Safari iOS
		            gesturechange:         function ( event ) { onGestureChange( _this, event ); }, // Safari/Safari iOS

		            gotpointercapture:     function ( event ) { onGotPointerCapture( _this, event ); },
		            lostpointercapture:    function ( event ) { onLostPointerCapture( _this, event ); },
		            pointerenter:          function ( event ) { onPointerEnter( _this, event ); },
		            pointerleave:          function ( event ) { onPointerLeave( _this, event ); },
		            pointerover:           function ( event ) { onPointerOver( _this, event ); },
		            pointerout:            function ( event ) { onPointerOut( _this, event ); },
		            pointerdown:           function ( event ) { onPointerDown( _this, event ); },
		            pointerup:             function ( event ) { onPointerUp( _this, event ); },
		            pointermove:           function ( event ) { onPointerMove( _this, event ); },
		            pointercancel:         function ( event ) { onPointerCancel( _this, event ); },
		            pointerupcaptured:     function ( event ) { onPointerUpCaptured( _this, event ); },
		            pointermovecaptured:   function ( event ) { onPointerMoveCaptured( _this, event ); },

		            tracking:              false,

		            // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
		            // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
		            // Active pointers are any pointer being tracked for this element which are in the hit-test area
		            //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
		            activePointersLists:   [],

		            // Tracking for double-click gesture
		            lastClickPos:          null,
		            dblClickTimeOut:       null,

		            // Tracking for pinch gesture
		            pinchGPoints:          [],
		            lastPinchDist:         0,
		            currentPinchDist:      0,
		            lastPinchCenter:       null,
		            currentPinchCenter:    null,

		            // Tracking for drag
		            sentDragEvent:         false
		        };

		        this.hasGestureHandlers = !!( this.pressHandler || this.nonPrimaryPressHandler ||
		                                this.releaseHandler || this.nonPrimaryReleaseHandler ||
		                                this.clickHandler || this.dblClickHandler ||
		                                this.dragHandler || this.dragEndHandler ||
		                                this.pinchHandler );
		        this.hasScrollHandler = !!this.scrollHandler;

		        if ( $.MouseTracker.havePointerEvents ) {
		            $.setElementPointerEvents( this.element, 'auto' );
		        }

		        if (this.exitHandler) {
		            $.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead.");
		        }

		        if ( !options.startDisabled ) {
		            this.setTracking( true );
		        }
		    };

		    /** @lends OpenSeadragon.MouseTracker.prototype */
		    $.MouseTracker.prototype = {

		        /**
		         * Clean up any events or objects created by the tracker.
		         * @function
		         */
		        destroy: function () {

		            stopTracking( this );
		            this.element = null;

		            THIS[ this.hash ] = null;
		            delete THIS[ this.hash ];
		        },

		        /**
		         * Are we currently tracking events on this element.
		         * @deprecated Just use this.tracking
		         * @function
		         * @returns {Boolean} Are we currently tracking events on this element.
		         */
		        isTracking: function () {
		            return THIS[ this.hash ].tracking;
		        },

		        /**
		         * Enable or disable whether or not we are tracking events on this element.
		         * @function
		         * @param {Boolean} track True to start tracking, false to stop tracking.
		         * @returns {OpenSeadragon.MouseTracker} Chainable.
		         */
		        setTracking: function ( track ) {
		            if ( track ) {
		                startTracking( this );
		            } else {
		                stopTracking( this );
		            }
		            //chain
		            return this;
		        },

		        /**
		         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
		         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
		         * @function
		         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
		         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
		         */
		        getActivePointersListByType: function ( type ) {
		            var delegate = THIS[ this.hash ],
		                i,
		                len = delegate ? delegate.activePointersLists.length : 0,
		                list;

		            for ( i = 0; i < len; i++ ) {
		                if ( delegate.activePointersLists[ i ].type === type ) {
		                    return delegate.activePointersLists[ i ];
		                }
		            }

		            list = new $.MouseTracker.GesturePointList( type );
		            if(delegate){
		                delegate.activePointersLists.push( list );
		            }
		            return list;
		        },

		        /**
		         * Returns the total number of pointers currently active on the tracked element.
		         * @function
		         * @returns {Number}
		         */
		        getActivePointerCount: function () {
		            var delegate = THIS[ this.hash ],
		                i,
		                len = delegate.activePointersLists.length,
		                count = 0;

		            for ( i = 0; i < len; i++ ) {
		                count += delegate.activePointersLists[ i ].getLength();
		            }

		            return count;
		        },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		         */
		        preProcessEventHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Boolean} event.preventDefault
		         *      Set to true to prevent the default user-agent's handling of the contextmenu event.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        contextMenuHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Number} event.pointers
		         *      Number of pointers (all types) active in the tracked element.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.buttonDownAny
		         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        enterHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @since v2.5.0
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Number} event.pointers
		         *      Number of pointers (all types) active in the tracked element.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.buttonDownAny
		         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        leaveHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @deprecated v2.5.0 Use leaveHandler instead
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Number} event.pointers
		         *      Number of pointers (all types) active in the tracked element.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.buttonDownAny
		         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        exitHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @since v2.5.0
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Number} event.pointers
		         *      Number of pointers (all types) active in the tracked element.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.buttonDownAny
		         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        overHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @since v2.5.0
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Number} event.pointers
		         *      Number of pointers (all types) active in the tracked element.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.buttonDownAny
		         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        outHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        pressHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.button
		         *      Button which caused the event.
		         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        nonPrimaryPressHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.insideElementPressed
		         *      True if the left mouse button is currently being pressed and was
		         *      initiated inside the tracked element, otherwise false.
		         * @param {Boolean} event.insideElementReleased
		         *      True if the cursor inside the tracked element when the button was released.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        releaseHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.button
		         *      Button which caused the event.
		         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        nonPrimaryReleaseHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        moveHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.scroll
		         *      The scroll delta for the event.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Boolean} event.preventDefault
		         *      Set to true to prevent the default user-agent's handling of the wheel event.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        scrollHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Boolean} event.quick
		         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Element} event.originalTarget
		         *      The DOM element clicked on.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        clickHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        dblClickHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {OpenSeadragon.Point} event.delta
		         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
		         * @param {Number} event.speed
		         *     Current computed speed, in pixels per second.
		         * @param {Number} event.direction
		         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        dragHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.speed
		         *     Speed at the end of a drag gesture, in pixels per second.
		         * @param {Number} event.direction
		         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        dragEndHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
		         *      Gesture points associated with the gesture. Velocity data can be found here.
		         * @param {OpenSeadragon.Point} event.lastCenter
		         *      The previous center point of the two pinch contact points relative to the tracked element.
		         * @param {OpenSeadragon.Point} event.center
		         *      The center point of the two pinch contact points relative to the tracked element.
		         * @param {Number} event.lastDistance
		         *      The previous distance between the two pinch contact points in CSS pixels.
		         * @param {Number} event.distance
		         *      The distance between the two pinch contact points in CSS pixels.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        pinchHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {String} event.pointerType
		         *     "mouse", "touch", "pen", etc.
		         * @param {OpenSeadragon.Point} event.position
		         *      The position of the event relative to the tracked element.
		         * @param {Number} event.buttons
		         *      Current buttons pressed.
		         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @param {Boolean} event.isTouchEvent
		         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        stopHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {Number} event.keyCode
		         *      The key code that was pressed.
		         * @param {Boolean} event.ctrl
		         *      True if the ctrl key was pressed during this event.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.alt
		         *      True if the alt key was pressed during this event.
		         * @param {Boolean} event.meta
		         *      True if the meta key was pressed during this event.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Boolean} event.preventDefault
		         *      Set to true to prevent the default user-agent's handling of the keydown event.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        keyDownHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {Number} event.keyCode
		         *      The key code that was pressed.
		         * @param {Boolean} event.ctrl
		         *      True if the ctrl key was pressed during this event.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.alt
		         *      True if the alt key was pressed during this event.
		         * @param {Boolean} event.meta
		         *      True if the meta key was pressed during this event.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Boolean} event.preventDefault
		         *      Set to true to prevent the default user-agent's handling of the keyup event.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        keyUpHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {Number} event.keyCode
		         *      The key code that was pressed.
		         * @param {Boolean} event.ctrl
		         *      True if the ctrl key was pressed during this event.
		         * @param {Boolean} event.shift
		         *      True if the shift key was pressed during this event.
		         * @param {Boolean} event.alt
		         *      True if the alt key was pressed during this event.
		         * @param {Boolean} event.meta
		         *      True if the meta key was pressed during this event.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Boolean} event.preventDefault
		         *      Set to true to prevent the default user-agent's handling of the keypress event.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        keyHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        focusHandler: function () { },

		        /**
		         * Implement or assign implementation to these handlers during or after
		         * calling the constructor.
		         * @function
		         * @param {Object} event
		         * @param {OpenSeadragon.MouseTracker} event.eventSource
		         *      A reference to the tracker instance.
		         * @param {Object} event.originalEvent
		         *      The original event object.
		         * @param {Object} event.userData
		         *      Arbitrary user-defined object.
		         */
		        blurHandler: function () { }
		    };

		    // https://github.com/openseadragon/openseadragon/pull/790
		    /**
		     * True if inside an iframe, otherwise false.
		     * @member {Boolean} isInIframe
		     * @private
		     * @inner
		     */
		    var isInIframe = (function() {
		        try {
		            return window.self !== window.top;
		        } catch (e) {
		            return true;
		        }
		    })();

		    // https://github.com/openseadragon/openseadragon/pull/790
		    /**
		     * @function
		     * @private
		     * @inner
		     * @returns {Boolean} True if the target supports DOM Level 2 event subscription methods, otherwise false.
		     */
		    function canAccessEvents (target) {
		        try {
		            return target.addEventListener && target.removeEventListener;
		        } catch (e) {
		            return false;
		        }
		    }

		    /**
		     * Provides continuous computation of velocity (speed and direction) of active pointers.
		     * This is a singleton, used by all MouseTracker instances, as it is unlikely there will ever be more than
		     * two active gesture pointers at a time.
		     *
		     * @private
		     * @member gesturePointVelocityTracker
		     * @memberof OpenSeadragon.MouseTracker
		     */
		    $.MouseTracker.gesturePointVelocityTracker = (function () {
		        var trackerPoints = [],
		            intervalId = 0,
		            lastTime = 0;

		        // Generates a unique identifier for a tracked gesture point
		        var _generateGuid = function ( tracker, gPoint ) {
		            return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
		        };

		        // Interval timer callback. Computes velocity for all tracked gesture points.
		        var _doTracking = function () {
		            var i,
		                len = trackerPoints.length,
		                trackPoint,
		                gPoint,
		                now = $.now(),
		                elapsedTime,
		                distance,
		                speed;

		            elapsedTime = now - lastTime;
		            lastTime = now;

		            for ( i = 0; i < len; i++ ) {
		                trackPoint = trackerPoints[ i ];
		                gPoint = trackPoint.gPoint;
		                // Math.atan2 gives us just what we need for a velocity vector, as we can simply
		                //   use cos()/sin() to extract the x/y velocity components.
		                gPoint.direction = Math.atan2( gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x );
		                // speed = distance / elapsed time
		                distance = trackPoint.lastPos.distanceTo( gPoint.currentPos );
		                trackPoint.lastPos = gPoint.currentPos;
		                speed = 1000 * distance / ( elapsedTime + 1 );
		                // Simple biased average, favors the most recent speed computation. Smooths out erratic gestures a bit.
		                gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
		            }
		        };

		        // Public. Add a gesture point to be tracked
		        var addPoint = function ( tracker, gPoint ) {
		            var guid = _generateGuid( tracker, gPoint );

		            trackerPoints.push(
		                {
		                    guid: guid,
		                    gPoint: gPoint,
		                    lastPos: gPoint.currentPos
		                } );

		            // Only fire up the interval timer when there's gesture pointers to track
		            if ( trackerPoints.length === 1 ) {
		                lastTime = $.now();
		                intervalId = window.setInterval( _doTracking, 50 );
		            }
		        };

		        // Public. Stop tracking a gesture point
		        var removePoint = function ( tracker, gPoint ) {
		            var guid = _generateGuid( tracker, gPoint ),
		                i,
		                len = trackerPoints.length;
		            for ( i = 0; i < len; i++ ) {
		                if ( trackerPoints[ i ].guid === guid ) {
		                    trackerPoints.splice( i, 1 );
		                    // Only run the interval timer if theres gesture pointers to track
		                    len--;
		                    if ( len === 0 ) {
		                        window.clearInterval( intervalId );
		                    }
		                    break;
		                }
		            }
		        };

		        return {
		            addPoint:    addPoint,
		            removePoint: removePoint
		        };
		    } )();


		///////////////////////////////////////////////////////////////////////////////
		// Pointer event model and feature detection
		///////////////////////////////////////////////////////////////////////////////

		    $.MouseTracker.captureElement = document;

		    /**
		     * Detect available mouse wheel event name.
		     */
		    $.MouseTracker.wheelEventName = ( 'onwheel' in document.createElement( 'div' ) ) ? 'wheel' : // Modern browsers support 'wheel'
		                                    document.onmousewheel !== undefined ? 'mousewheel' :         // Webkit (and unsupported IE) support at least 'mousewheel'
		                                    'DOMMouseScroll';                                            // Assume old Firefox (deprecated)

		    /**
		     * Detect browser pointer device event model(s) and build appropriate list of events to subscribe to.
		     */
		    $.MouseTracker.subscribeEvents = [ "click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", $.MouseTracker.wheelEventName ];

		    if( $.MouseTracker.wheelEventName === "DOMMouseScroll" ) {
		        // Older Firefox
		        $.MouseTracker.subscribeEvents.push( "MozMousePixelScroll" );
		    }

		    if ( window.PointerEvent ) {
		        // W3C Pointer Event implementations (see http://www.w3.org/TR/pointerevents)
		        $.MouseTracker.havePointerEvents = true;
		        $.MouseTracker.subscribeEvents.push( "pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel" );
		        // Pointer events capture support
		        $.MouseTracker.havePointerCapture = (function () {
		            var divElement = document.createElement( 'div' );
		            return $.isFunction( divElement.setPointerCapture ) && $.isFunction( divElement.releasePointerCapture );
		        }());
		        if ( $.MouseTracker.havePointerCapture ) {
		            $.MouseTracker.subscribeEvents.push( "gotpointercapture", "lostpointercapture" );
		        }
		    } else {
		        // Legacy W3C mouse events
		        $.MouseTracker.havePointerEvents = false;
		        $.MouseTracker.subscribeEvents.push( "mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove" );
		        $.MouseTracker.mousePointerId = "legacy-mouse";
		        // Legacy mouse events capture support (IE/Firefox only?)
		        $.MouseTracker.havePointerCapture = (function () {
		            var divElement = document.createElement( 'div' );
		            return $.isFunction( divElement.setCapture ) && $.isFunction( divElement.releaseCapture );
		        }());
		        if ( $.MouseTracker.havePointerCapture ) {
		            $.MouseTracker.subscribeEvents.push( "losecapture" );
		        }
		        // Legacy touch events
		        if ( 'ontouchstart' in window ) {
		            // iOS, Android, and other W3c Touch Event implementations
		            //    (see http://www.w3.org/TR/touch-events/)
		            //    (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
		            //    (see https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
		            $.MouseTracker.subscribeEvents.push( "touchstart", "touchend", "touchmove", "touchcancel" );
		        }
		        if ( 'ongesturestart' in window ) {
		            // iOS (see https://developer.apple.com/library/ios/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html)
		            //   Subscribe to these to prevent default gesture handling
		            $.MouseTracker.subscribeEvents.push( "gesturestart", "gesturechange" );
		        }
		    }


		///////////////////////////////////////////////////////////////////////////////
		// Classes and typedefs
		///////////////////////////////////////////////////////////////////////////////

		    /**
		     * Used for the processing/disposition of DOM events (propagation, default handling, capture, etc.)
		     *
		     * @typedef {Object} EventProcessInfo
		     * @memberof OpenSeadragon.MouseTracker
		     * @since v2.5.0
		     *
		     * @property {OpenSeadragon.MouseTracker} eventSource
		     *      A reference to the tracker instance.
		     * @property {Object} originalEvent
		     *      The original DOM event object.
		     * @property {Number} eventPhase
		     *      0 == NONE, 1 == CAPTURING_PHASE, 2 == AT_TARGET, 3 == BUBBLING_PHASE.
		     * @property {String} eventType
		     *     "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", "gotpointercapture", "lostpointercapture", "pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel", "wheel", "click", "dblclick".
		     * @property {String} pointerType
		     *     "mouse", "touch", "pen", etc.
		     * @property {Boolean} isEmulated
		     *      True if this is an emulated event. If true, originalEvent is either the event that caused
		     *      the emulated event, a synthetic event object created with values from the actual DOM event,
		     *      or null if no DOM event applies. Emulated events can occur on eventType "wheel" on legacy mouse-scroll
		     *      event emitting user agents.
		     * @property {Boolean} isStoppable
		     *      True if propagation of the event (e.g. bubbling) can be stopped with stopPropagation/stopImmediatePropagation.
		     * @property {Boolean} isCancelable
		     *      True if the event's default handling by the browser can be prevented with preventDefault.
		     * @property {Boolean} defaultPrevented
		     *      True if the event's default handling has already been prevented by a descendent element.
		     * @property {Boolean} preventDefault
		     *      Set to true to prevent the event's default handling by the browser.
		     * @property {Boolean} preventGesture
		     *      Set to true to prevent this MouseTracker from generating a gesture from the event.
		     *      Valid on eventType "pointerdown".
		     * @property {Boolean} stopPropagation
		     *      Set to true prevent the event from propagating to ancestor/descendent elements on capture/bubble phase.
		     * @property {Boolean} shouldCapture
		     *      (Internal Use) Set to true if the pointer should be captured (events (re)targeted to tracker element).
		     * @property {Boolean} shouldReleaseCapture
		     *      (Internal Use) Set to true if the captured pointer should be released.
		     * @property {Object} userData
		     *      Arbitrary user-defined object.
		     */


		    /**
		     * Represents a point of contact on the screen made by a mouse cursor, pen, touch, or other pointer device.
		     *
		     * @typedef {Object} GesturePoint
		     * @memberof OpenSeadragon.MouseTracker
		     *
		     * @property {Number} id
		     *     Identifier unique from all other active GesturePoints for a given pointer device.
		     * @property {String} type
		     *     The pointer device type: "mouse", "touch", "pen", etc.
		     * @property {Boolean} captured
		     *     True if events for the gesture point are captured to the tracked element.
		     * @property {Boolean} isPrimary
		     *     True if the gesture point is a master pointer amongst the set of active pointers for each pointer type. True for mouse and primary (first) touch/pen pointers.
		     * @property {Boolean} insideElementPressed
		     *     True if button pressed or contact point initiated inside the screen area of the tracked element.
		     * @property {Boolean} insideElement
		     *     True if pointer or contact point is currently inside the bounds of the tracked element.
		     * @property {Number} speed
		     *     Current computed speed, in pixels per second.
		     * @property {Number} direction
		     *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		     * @property {OpenSeadragon.Point} contactPos
		     *     The initial pointer contact position, relative to the page including any scrolling. Only valid if the pointer has contact (pressed, touch contact, pen contact).
		     * @property {Number} contactTime
		     *     The initial pointer contact time, in milliseconds. Only valid if the pointer has contact (pressed, touch contact, pen contact).
		     * @property {OpenSeadragon.Point} lastPos
		     *     The last pointer position, relative to the page including any scrolling.
		     * @property {Number} lastTime
		     *     The last pointer contact time, in milliseconds.
		     * @property {OpenSeadragon.Point} currentPos
		     *     The current pointer position, relative to the page including any scrolling.
		     * @property {Number} currentTime
		     *     The current pointer contact time, in milliseconds.
		     */


		    /**
		     * @class GesturePointList
		     * @classdesc Provides an abstraction for a set of active {@link OpenSeadragon.MouseTracker.GesturePoint|GesturePoint} objects for a given pointer device type.
		     *            Active pointers are any pointer being tracked for this element which are in the hit-test area
		     *            of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
		     * @memberof OpenSeadragon.MouseTracker
		     * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
		     */
		    $.MouseTracker.GesturePointList = function ( type ) {
		        this._gPoints = [];
		        /**
		         * The pointer device type: "mouse", "touch", "pen", etc.
		         * @member {String} type
		         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
		         */
		        this.type = type;
		        /**
		         * Current buttons pressed for the device.
		         * Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		         * @member {Number} buttons
		         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
		         */
		        this.buttons = 0;
		        /**
		         * Current number of contact points (touch points, mouse down, etc.) for the device.
		         * @member {Number} contacts
		         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
		         */
		        this.contacts = 0;
		        /**
		         * Current number of clicks for the device. Used for multiple click gesture tracking.
		         * @member {Number} clicks
		         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
		         */
		        this.clicks = 0;
		        /**
		         * Current number of captured pointers for the device.
		         * @member {Number} captureCount
		         * @memberof OpenSeadragon.MouseTracker.GesturePointList#
		         */
		        this.captureCount = 0;
		    };

		    /** @lends OpenSeadragon.MouseTracker.GesturePointList.prototype */
		    $.MouseTracker.GesturePointList.prototype = {
		        /**
		         * @function
		         * @returns {Number} Number of gesture points in the list.
		         */
		        getLength: function () {
		            return this._gPoints.length;
		        },
		        /**
		         * @function
		         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
		         */
		        asArray: function () {
		            return this._gPoints;
		        },
		        /**
		         * @function
		         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
		         * @returns {Number} Number of gesture points in the list.
		         */
		        add: function ( gp ) {
		            return this._gPoints.push( gp );
		        },
		        /**
		         * @function
		         * @param {Number} id - The id of the gesture point to remove from the list.
		         * @returns {Number} Number of gesture points in the list.
		         */
		        removeById: function ( id ) {
		            var i,
		                len = this._gPoints.length;
		            for ( i = 0; i < len; i++ ) {
		                if ( this._gPoints[ i ].id === id ) {
		                    this._gPoints.splice( i, 1 );
		                    break;
		                }
		            }
		            return this._gPoints.length;
		        },
		        /**
		         * @function
		         * @param {Number} index - The index of the gesture point to retrieve from the list.
		         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
		         */
		        getByIndex: function ( index ) {
		            if ( index < this._gPoints.length) {
		                return this._gPoints[ index ];
		            }

		            return null;
		        },
		        /**
		         * @function
		         * @param {Number} id - The id of the gesture point to retrieve from the list.
		         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
		         */
		        getById: function ( id ) {
		            var i,
		                len = this._gPoints.length;
		            for ( i = 0; i < len; i++ ) {
		                if ( this._gPoints[ i ].id === id ) {
		                    return this._gPoints[ i ];
		                }
		            }
		            return null;
		        },
		        /**
		         * @function
		         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
		         */
		        getPrimary: function ( id ) {
		            var i,
		                len = this._gPoints.length;
		            for ( i = 0; i < len; i++ ) {
		                if ( this._gPoints[ i ].isPrimary ) {
		                    return this._gPoints[ i ];
		                }
		            }
		            return null;
		        },

		        /**
		         * Increment this pointer list's contact count.
		         * It will evaluate whether this pointer type is allowed to have multiple contacts.
		         * @function
		         */
		        addContact: function() {
		            ++this.contacts;

		            if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
		                $.console.warn('GesturePointList.addContact() Implausible contacts value');
		                this.contacts = 1;
		            }
		        },

		        /**
		         * Decrement this pointer list's contact count.
		         * It will make sure the count does not go below 0.
		         * @function
		         */
		        removeContact: function() {
		            --this.contacts;

		            if (this.contacts < 0) {
		                this.contacts = 0;
		            }
		        }
		    };


		///////////////////////////////////////////////////////////////////////////////
		// Utility functions
		///////////////////////////////////////////////////////////////////////////////

		    /**
		     * Removes all tracked pointers.
		     * @private
		     * @inner
		     */
		    function clearTrackedPointers( tracker ) {
		        var delegate = THIS[ tracker.hash ],
		            i, j,
		            pointsList,
		            gPoints,
		            gPointsToRemove,
		            pointerListCount = delegate.activePointersLists.length;

		        for ( i = 0; i < pointerListCount; i++ ) {
		            pointsList = delegate.activePointersLists[ i ];

		            if ( pointsList.getLength() > 0 ) {
		                // Make an array containing references to the gPoints in the pointer list
		                //   (because calls to stopTrackingPointer() are going to modify the pointer list)
		                gPointsToRemove = [];
		                gPoints = pointsList.asArray();
		                for ( j = 0; j < gPoints.length; j++ ) {
		                    gPointsToRemove.push( gPoints[ j ] );
		                }

		                // Release and remove all gPoints from the pointer list
		                for ( j = 0; j < gPointsToRemove.length; j++ ) {
		                    stopTrackingPointer( tracker, pointsList, gPointsToRemove[ j ] );
		                }
		            }
		        }

		        for ( i = 0; i < pointerListCount; i++ ) {
		            delegate.activePointersLists.pop();
		        }

		        delegate.sentDragEvent = false;
		    }

		    /**
		     * Starts tracking pointer events on the tracked element.
		     * @private
		     * @inner
		     */
		    function startTracking( tracker ) {
		        var delegate = THIS[ tracker.hash ],
		            event,
		            i;

		        if ( !delegate.tracking ) {
		            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {
		                event = $.MouseTracker.subscribeEvents[ i ];
		                $.addEvent(
		                    tracker.element,
		                    event,
		                    delegate[ event ],
		                    event === $.MouseTracker.wheelEventName ? { passive: false, capture: false } : false
		                );
		            }

		            clearTrackedPointers( tracker );

		            delegate.tracking = true;
		        }
		    }

		    /**
		     * Stops tracking pointer events on the tracked element.
		     * @private
		     * @inner
		     */
		    function stopTracking( tracker ) {
		        var delegate = THIS[ tracker.hash ],
		            event,
		            i;

		        if ( delegate.tracking ) {
		            for ( i = 0; i < $.MouseTracker.subscribeEvents.length; i++ ) {
		                event = $.MouseTracker.subscribeEvents[ i ];
		                $.removeEvent(
		                    tracker.element,
		                    event,
		                    delegate[ event ],
		                    false
		                );
		            }

		            clearTrackedPointers( tracker );

		            delegate.tracking = false;
		        }
		    }

		    /**
		     * @private
		     * @inner
		     */
		    function getCaptureEventParams( tracker, pointerType ) {
		        var delegate = THIS[ tracker.hash ];

		        if ( pointerType === 'pointerevent' ) {
		            return {
		                upName: 'pointerup',
		                upHandler: delegate.pointerupcaptured,
		                moveName: 'pointermove',
		                moveHandler: delegate.pointermovecaptured
		            };
		        } else if ( pointerType === 'mouse' ) {
		            return {
		                upName: 'pointerup',
		                upHandler: delegate.pointerupcaptured,
		                moveName: 'pointermove',
		                moveHandler: delegate.pointermovecaptured
		            };
		        } else if ( pointerType === 'touch' ) {
		            return {
		                upName: 'touchend',
		                upHandler: delegate.touchendcaptured,
		                moveName: 'touchmove',
		                moveHandler: delegate.touchmovecaptured
		            };
		        } else {
		            throw new Error( "MouseTracker.getCaptureEventParams: Unknown pointer type." );
		        }
		    }

		    /**
		     * Begin capturing pointer events to the tracked element.
		     * @private
		     * @inner
		     */
		    function capturePointer( tracker, gPoint ) {
		        var eventParams;

		        if ( $.MouseTracker.havePointerCapture ) {
		            if ( $.MouseTracker.havePointerEvents ) {
		                // Can throw NotFoundError (InvalidPointerId Firefox < 82)
		                //   (should never happen so we'll log a warning)
		                try {
		                    tracker.element.setPointerCapture( gPoint.id );
		                    //$.console.log('element.setPointerCapture() called');
		                } catch ( e ) {
		                    $.console.warn('setPointerCapture() called on invalid pointer ID');
		                    return;
		                }
		            } else {
		                tracker.element.setCapture( true );
		                //$.console.log('element.setCapture() called');
		            }
		        } else {
		            // Emulate mouse capture by hanging listeners on the document object.
		            //    (Note we listen on the capture phase so the captured handlers will get called first)
		            // eslint-disable-next-line no-use-before-define
		            //$.console.log('Emulated mouse capture set');
		            eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : gPoint.type );
		            // https://github.com/openseadragon/openseadragon/pull/790
		            if (isInIframe && canAccessEvents(window.top)) {
		                $.addEvent(
		                    window.top,
		                    eventParams.upName,
		                    eventParams.upHandler,
		                    true
		                );
		            }
		            $.addEvent(
		                $.MouseTracker.captureElement,
		                eventParams.upName,
		                eventParams.upHandler,
		                true
		            );
		            $.addEvent(
		                $.MouseTracker.captureElement,
		                eventParams.moveName,
		                eventParams.moveHandler,
		                true
		            );
		        }

		        updatePointerCaptured( tracker, gPoint, true );
		    }


		    /**
		     * Stop capturing pointer events to the tracked element.
		     * @private
		     * @inner
		     */
		    function releasePointer( tracker, gPoint ) {
		        var eventParams;
		        var pointsList;
		        var cachedGPoint;

		        if ( $.MouseTracker.havePointerCapture ) {
		            if ( $.MouseTracker.havePointerEvents ) {
		                pointsList = tracker.getActivePointersListByType( gPoint.type );
		                cachedGPoint = pointsList.getById( gPoint.id );
		                if ( !cachedGPoint || !cachedGPoint.captured ) {
		                    return;
		                }
		                // Can throw NotFoundError (InvalidPointerId Firefox < 82)
		                //   (should never happen, but it does on Firefox 79 touch so we won't log a warning)
		                try {
		                    tracker.element.releasePointerCapture( gPoint.id );
		                    //$.console.log('element.releasePointerCapture() called');
		                } catch ( e ) {
		                    //$.console.warn('releasePointerCapture() called on invalid pointer ID');
		                }
		            } else {
		                tracker.element.releaseCapture();
		                //$.console.log('element.releaseCapture() called');
		            }
		        } else {
		            // Emulate mouse capture by hanging listeners on the document object.
		            //    (Note we listen on the capture phase so the captured handlers will get called first)
		            //$.console.log('Emulated mouse capture release');
		            eventParams = getCaptureEventParams( tracker, $.MouseTracker.havePointerEvents ? 'pointerevent' : gPoint.type );
		            // https://github.com/openseadragon/openseadragon/pull/790
		            if (isInIframe && canAccessEvents(window.top)) {
		                $.removeEvent(
		                    window.top,
		                    eventParams.upName,
		                    eventParams.upHandler,
		                    true
		                );
		            }
		            $.removeEvent(
		                $.MouseTracker.captureElement,
		                eventParams.moveName,
		                eventParams.moveHandler,
		                true
		            );
		            $.removeEvent(
		                $.MouseTracker.captureElement,
		                eventParams.upName,
		                eventParams.upHandler,
		                true
		            );
		        }

		        updatePointerCaptured( tracker, gPoint, false );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     * @private
		     * @inner
		     */
		    function getPointerId( event ) {
		        return ( $.MouseTracker.havePointerEvents ) ? event.pointerId : $.MouseTracker.mousePointerId;
		    }


		    /**
		     * Gets a W3C Pointer Events model compatible pointer type string from a DOM pointer event.
		     *
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     * @private
		     * @inner
		     */
		    function getPointerType( event ) {
		        return $.MouseTracker.havePointerEvents && event.pointerType ? event.pointerType : 'mouse';
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     * @private
		     * @inner
		     */
		    function getIsPrimary( event ) {
		        return ( $.MouseTracker.havePointerEvents ) ? event.isPrimary : true;
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function getMouseAbsolute( event ) {
		        return $.getMousePosition( event );
		    }

		    /**
		     * @private
		     * @inner
		     */
		    function getMouseRelative( event, element ) {
		        return getPointRelativeToAbsolute( getMouseAbsolute( event ), element );
		    }

		    /**
		     * @private
		     * @inner
		     */
		    function getPointRelativeToAbsolute( point, element ) {
		        var offset = $.getElementOffset( element );
		        return point.minus( offset );
		    }

		    /**
		     * @private
		     * @inner
		     */
		    function getCenterPoint( point1, point2 ) {
		        return new $.Point( ( point1.x + point2.x ) / 2, ( point1.y + point2.y ) / 2 );
		    }


		///////////////////////////////////////////////////////////////////////////////
		// Device-specific DOM event handlers
		///////////////////////////////////////////////////////////////////////////////

		    /**
		     * @private
		     * @inner
		     */
		    function onClick( tracker, event ) {
		        //$.console.log('click ' + (tracker.userData ? tracker.userData.toString() : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'click',
		            pointerType: 'mouse',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onDblClick( tracker, event ) {
		        //$.console.log('dblclick ' + (tracker.userData ? tracker.userData.toString() : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'dblclick',
		            pointerType: 'mouse',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onKeyDown( tracker, event ) {
		        //$.console.log( "keydown %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );
		        var eventArgs = null;

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'keydown',
		            pointerType: '',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.keyDownHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventArgs = {
		                eventSource:          tracker,
		                keyCode:              event.keyCode ? event.keyCode : event.charCode,
		                ctrl:                 event.ctrlKey,
		                shift:                event.shiftKey,
		                alt:                  event.altKey,
		                meta:                 event.metaKey,
		                originalEvent:        event,
		                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
		                userData:             tracker.userData
		            };

		            tracker.keyDownHandler( eventArgs );
		        }

		        if ( ( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
		                $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onKeyUp( tracker, event ) {
		        //$.console.log( "keyup %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );

		        var eventArgs = null;

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'keyup',
		            pointerType: '',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.keyUpHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventArgs = {
		                eventSource:          tracker,
		                keyCode:              event.keyCode ? event.keyCode : event.charCode,
		                ctrl:                 event.ctrlKey,
		                shift:                event.shiftKey,
		                alt:                  event.altKey,
		                meta:                 event.metaKey,
		                originalEvent:        event,
		                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
		                userData:             tracker.userData
		            };

		            tracker.keyUpHandler( eventArgs );
		        }

		        if ( ( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onKeyPress( tracker, event ) {
		        //$.console.log( "keypress %s %s %s %s %s", event.keyCode, event.charCode, event.ctrlKey, event.shiftKey, event.altKey );

		        var eventArgs = null;

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'keypress',
		            pointerType: '',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.keyHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventArgs = {
		                eventSource:          tracker,
		                keyCode:              event.keyCode ? event.keyCode : event.charCode,
		                ctrl:                 event.ctrlKey,
		                shift:                event.shiftKey,
		                alt:                  event.altKey,
		                meta:                 event.metaKey,
		                originalEvent:        event,
		                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
		                userData:             tracker.userData
		            };

		            tracker.keyHandler( eventArgs );
		        }

		        if ( ( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onFocus( tracker, event ) {
		        //$.console.log('focus  ' + (tracker.userData ? tracker.userData.toString() : ''));

		        // focus doesn't bubble and is not cancelable, but we call
		        //   preProcessEvent() so it's dispatched to preProcessEventHandler
		        //   if necessary
		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'focus',
		            pointerType: '',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.focusHandler && !eventInfo.preventGesture ) {
		            tracker.focusHandler(
		                {
		                    eventSource:          tracker,
		                    originalEvent:        event,
		                    userData:             tracker.userData
		                }
		            );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onBlur( tracker, event ) {
		        //$.console.log('blur  ' + (tracker.userData ? tracker.userData.toString() : ''));

		        // blur doesn't bubble and is not cancelable, but we call
		        //   preProcessEvent() so it's dispatched to preProcessEventHandler
		        //   if necessary
		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'blur',
		            pointerType: '',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.blurHandler && !eventInfo.preventGesture ) {
		            tracker.blurHandler(
		                {
		                    eventSource:          tracker,
		                    originalEvent:        event,
		                    userData:             tracker.userData
		                }
		            );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onContextMenu( tracker, event ) {
		        //$.console.log('contextmenu ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var eventArgs = null;

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'contextmenu',
		            pointerType: 'mouse',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        // ContextMenu
		        if ( tracker.contextMenuHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventArgs = {
		                eventSource:          tracker,
		                position:             getPointRelativeToAbsolute( getMouseAbsolute( event ), tracker.element ),
		                originalEvent:        eventInfo.originalEvent,
		                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
		                userData:             tracker.userData
		            };

		            tracker.contextMenuHandler( eventArgs );
		        }

		        if ( ( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * Handler for 'wheel' events
		     *
		     * @private
		     * @inner
		     */
		    function onWheel( tracker, event ) {
		        handleWheelEvent( tracker, event, event );
		    }


		    /**
		     * Handler for 'mousewheel', 'DOMMouseScroll', and 'MozMousePixelScroll' events
		     *
		     * @private
		     * @inner
		     */
		    function onMouseWheel( tracker, event ) {
		        // Simulate a 'wheel' event
		        var simulatedEvent = {
		            target:     event.target || event.srcElement,
		            type:       "wheel",
		            shiftKey:   event.shiftKey || false,
		            clientX:    event.clientX,
		            clientY:    event.clientY,
		            pageX:      event.pageX ? event.pageX : event.clientX,
		            pageY:      event.pageY ? event.pageY : event.clientY,
		            deltaMode:  event.type === "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page
		            deltaX:     0,
		            deltaZ:     0
		        };

		        // Calculate deltaY
		        if ( $.MouseTracker.wheelEventName === "mousewheel" ) {
		            simulatedEvent.deltaY = -event.wheelDelta / $.DEFAULT_SETTINGS.pixelsPerWheelLine;
		        } else {
		            simulatedEvent.deltaY = event.detail;
		        }

		        handleWheelEvent( tracker, simulatedEvent, event );
		    }


		    /**
		     * Handles 'wheel' events.
		     * The event may be simulated by the legacy mouse wheel event handler (onMouseWheel()).
		     *
		     * @private
		     * @inner
		     */
		    function handleWheelEvent( tracker, event, originalEvent ) {
		        var nDelta = 0,
		            eventInfo;

		        var eventArgs = null;

		        // The nDelta variable is gated to provide smooth z-index scrolling
		        //   since the mouse wheel allows for substantial deltas meant for rapid
		        //   y-index scrolling.
		        // event.deltaMode: 0=pixel, 1=line, 2=page
		        // TODO: Deltas in pixel mode should be accumulated then a scroll value computed after $.DEFAULT_SETTINGS.pixelsPerWheelLine threshold reached
		        nDelta = event.deltaY ? (event.deltaY < 0 ? 1 : -1) : 0;

		        eventInfo = {
		            originalEvent: event,
		            eventType: 'wheel',
		            pointerType: 'mouse',
		            isEmulated: event !== originalEvent
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( tracker.scrollHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventArgs = {
		                eventSource:          tracker,
		                pointerType:          'mouse',
		                position:             getMouseRelative( event, tracker.element ),
		                scroll:               nDelta,
		                shift:                event.shiftKey,
		                isTouchEvent:         false,
		                originalEvent:        originalEvent,
		                preventDefault:       eventInfo.preventDefault || eventInfo.defaultPrevented,
		                userData:             tracker.userData
		            };


		            tracker.scrollHandler( eventArgs );
		        }

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( originalEvent );
		        }
		        if ( ( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
		                $.cancelEvent( originalEvent );
		        }
		}


		    /**
		     * TODO Never actually seen this event fired, and documentation is tough to find
		     * @private
		     * @inner
		     */
		    function onLoseCapture( tracker, event ) {
		        //$.console.log('losecapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var gPoint = {
		            id: $.MouseTracker.mousePointerId,
		            type: 'mouse'
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'lostpointercapture',
		            pointerType: 'mouse',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( event.target === tracker.element ) {
		            updatePointerCaptured( tracker, gPoint, false );
		        }

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onTouchStart( tracker, event ) {
		        var time,
		            i,
		            touchCount = event.changedTouches.length,
		            gPoint,
		            pointsList = tracker.getActivePointersListByType( 'touch' );

		        time = $.now();

		        //$.console.log('touchstart ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        if ( pointsList.getLength() > event.touches.length - touchCount ) {
		            $.console.warn('Tracked touch contact count doesn\'t match event.touches.length');
		        }

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerdown',
		            pointerType: 'touch',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        for ( i = 0; i < touchCount; i++ ) {
		            gPoint = {
		                id: event.changedTouches[ i ].identifier,
		                type: 'touch',
		                // Simulate isPrimary
		                isPrimary: pointsList.getLength() === 0,
		                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
		                currentTime: time
		            };

		            // simulate touchenter on our tracked element
		            updatePointerEnter( tracker, eventInfo, gPoint );

		            updatePointerDown( tracker, eventInfo, gPoint, 0 );

		            updatePointerCaptured( tracker, gPoint, true );
		        }

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onTouchEnd( tracker, event ) {
		        var time,
		            i,
		            touchCount = event.changedTouches.length,
		            gPoint;

		        time = $.now();

		        //$.console.log('touchend ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerup',
		            pointerType: 'touch',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        for ( i = 0; i < touchCount; i++ ) {
		            gPoint = {
		                id: event.changedTouches[ i ].identifier,
		                type: 'touch',
		                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
		                currentTime: time
		            };

		            updatePointerUp( tracker, eventInfo, gPoint, 0 );

		            updatePointerCaptured( tracker, gPoint, false );

		            // simulate touchleave on our tracked element
		            updatePointerLeave( tracker, eventInfo, gPoint );
		        }

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onTouchMove( tracker, event ) {
		        var time,
		            i,
		            touchCount = event.changedTouches.length,
		            gPoint;

		        time = $.now();

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointermove',
		            pointerType: 'touch',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        for ( i = 0; i < touchCount; i++ ) {
		            gPoint = {
		                id: event.changedTouches[ i ].identifier,
		                type: 'touch',
		                currentPos: getMouseAbsolute( event.changedTouches[ i ] ),
		                currentTime: time
		            };

		            updatePointerMove( tracker, eventInfo, gPoint );
		        }

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onTouchCancel( tracker, event ) {
		        var touchCount = event.changedTouches.length,
		            i,
		            gPoint;

		        //$.console.log('touchcancel ' + (tracker.userData ? tracker.userData.toString() : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointercancel',
		            pointerType: 'touch',
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        for ( i = 0; i < touchCount; i++ ) {
		            gPoint = {
		                id: event.changedTouches[ i ].identifier,
		                type: 'touch'
		            };

		            //TODO need to only do this if our element is target?
		            updatePointerCancel( tracker, eventInfo, gPoint );
		        }

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onGestureStart( tracker, event ) {
		        if ( !$.eventIsCanceled( event ) ) {
		            event.preventDefault();
		        }
		        return false;
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onGestureChange( tracker, event ) {
		        if ( !$.eventIsCanceled( event ) ) {
		            event.preventDefault();
		        }
		        return false;
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onGotPointerCapture( tracker, event ) {
		        //$.console.log('gotpointercapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'gotpointercapture',
		            pointerType: getPointerType( event ),
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( event.target === tracker.element ) {
		            //$.console.log('gotpointercapture ' + (tracker.userData ? tracker.userData.toString() : ''));
		            updatePointerCaptured( tracker, {
		                id: event.pointerId,
		                type: getPointerType( event )
		            }, true );
		        }

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onLostPointerCapture( tracker, event ) {
		        //$.console.log('lostpointercapture ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'lostpointercapture',
		            pointerType: getPointerType( event ),
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        if ( event.target === tracker.element ) {
		            //$.console.log('lostpointercapture ' + (tracker.userData ? tracker.userData.toString() : ''));
		            updatePointerCaptured( tracker, {
		                id: event.pointerId,
		                type: getPointerType( event )
		            }, false );
		        }

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerEnter( tracker, event ) {
		        //$.console.log('pointerenter ' + (tracker.userData ? tracker.userData.toString() : ''));

		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        // pointerenter doesn't bubble and is not cancelable, but we call
		        //   preProcessEvent() so it's dispatched to preProcessEventHandler
		        //   if necessary
		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerenter',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerEnter( tracker, eventInfo, gPoint );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerLeave( tracker, event ) {
		        //$.console.log('pointerleave ' + (tracker.userData ? tracker.userData.toString() : ''));

		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        // pointerleave doesn't bubble and is not cancelable, but we call
		        //   preProcessEvent() so it's dispatched to preProcessEventHandler
		        //   if necessary
		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerleave',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerLeave( tracker, eventInfo, gPoint );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerOver( tracker, event ) {
		        //$.console.log('pointerover ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerover',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerOver( tracker, eventInfo, gPoint );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerOut( tracker, event ) {
		        //$.console.log('pointerout ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerout',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerOut( tracker, eventInfo, gPoint );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerDown( tracker, event ) {
		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        // Most browsers implicitly capture touch pointer events
		        // Note no IE versions (unsupported) have element.hasPointerCapture() so
		        //    no implicit pointer capture possible
		        // var implicitlyCaptured = ($.MouseTracker.havePointerEvents &&
		        //                         event.target.hasPointerCapture &&
		        //                         $.Browser.vendor !== $.BROWSERS.IE) ?
		        //                         event.target.hasPointerCapture(event.pointerId) : false;
		        var implicitlyCaptured = $.MouseTracker.havePointerEvents &&
		                                gPoint.type === 'touch';

		        //$.console.log('pointerdown ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerdown',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerDown( tracker, eventInfo, gPoint, event.button );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		        if ( eventInfo.shouldCapture ) {
		            if ( implicitlyCaptured ) {
		                updatePointerCaptured( tracker, gPoint, true );
		            } else {
		                capturePointer( tracker, gPoint );
		            }
		        }
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerUp( tracker, event ) {
		        handlePointerUp( tracker, event );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
		     * onPointerUp is still attached to the tracked element, so stop propagation to avoid processing twice.
		     *
		     * @private
		     * @inner
		     */
		    function onPointerUpCaptured( tracker, event ) {
		        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
		        if ( pointsList.getById( event.pointerId ) ) {
		            handlePointerUp( tracker, event );
		        }
		        $.stopEvent( event );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function handlePointerUp( tracker, event ) {
		        var gPoint;

		        //$.console.log('pointerup ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointerup',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerUp( tracker, eventInfo, gPoint, event.button );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }

		        // Per spec, pointerup events are supposed to release capture. Not all browser
		        //   versions have adhered to the spec, and there's no harm in releasing
		        //   explicitly
		        if ( eventInfo.shouldReleaseCapture ) {
		            if ( event.target === tracker.element ) {
		                releasePointer( tracker, gPoint );
		            } else {
		                updatePointerCaptured( tracker, gPoint, false );
		            }
		        }
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function onPointerMove( tracker, event ) {
		        handlePointerMove( tracker, event );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * This handler is attached to the window object (on the capture phase) to emulate mouse capture.
		     * onPointerMove is still attached to the tracked element, so stop propagation to avoid processing twice.
		     *
		     * @private
		     * @inner
		     */
		    function onPointerMoveCaptured( tracker, event ) {
		        var pointsList = tracker.getActivePointersListByType( getPointerType( event ) );
		        if ( pointsList.getById( event.pointerId ) ) {
		            handlePointerMove( tracker, event );
		        }
		        $.stopEvent( event );
		    }


		    /**
		     * Note: Called for both pointer events and legacy mouse events
		     *         ($.MouseTracker.havePointerEvents determines which)
		     *
		     * @private
		     * @inner
		     */
		    function handlePointerMove( tracker, event ) {
		        // Pointer changed coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)

		        var gPoint = {
		            id: getPointerId( event ),
		            type: getPointerType( event ),
		            isPrimary: getIsPrimary( event ),
		            currentPos: getMouseAbsolute( event ),
		            currentTime: $.now()
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointermove',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        updatePointerMove( tracker, eventInfo, gPoint );

		        if ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) {
		            $.cancelEvent( event );
		        }
		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function onPointerCancel( tracker, event ) {
		        //$.console.log('pointercancel ' + (tracker.userData ? tracker.userData.toString() : '') + ' ' + (event.target === tracker.element ? 'tracker.element' : ''));

		        var gPoint = {
		            id: event.pointerId,
		            type: getPointerType( event )
		        };

		        var eventInfo = {
		            originalEvent: event,
		            eventType: 'pointercancel',
		            pointerType: gPoint.type,
		            isEmulated: false
		        };
		        preProcessEvent( tracker, eventInfo );

		        //TODO need to only do this if our element is target?
		        updatePointerCancel( tracker, eventInfo, gPoint );

		        if ( eventInfo.stopPropagation ) {
		            $.stopEvent( event );
		        }
		    }


		///////////////////////////////////////////////////////////////////////////////
		// Device-agnostic DOM event handlers
		///////////////////////////////////////////////////////////////////////////////

		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
		     *     The GesturePointList to track the pointer in.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point to track.
		     * @returns {Number} Number of gesture points in pointsList.
		     */
		    function startTrackingPointer( pointsList, gPoint ) {
		        //$.console.log('startTrackingPointer *** ' + pointsList.type + ' ' + gPoint.id.toString());
		        gPoint.speed = 0;
		        gPoint.direction = 0;
		        gPoint.contactPos = gPoint.currentPos;
		        gPoint.contactTime = gPoint.currentTime;
		        gPoint.lastPos = gPoint.currentPos;
		        gPoint.lastTime = gPoint.currentTime;

		        return pointsList.add( gPoint );
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.GesturePointList} pointsList
		     *     The GesturePointList to stop tracking the pointer on.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point to stop tracking.
		     * @returns {Number} Number of gesture points in pointsList.
		     */
		    function stopTrackingPointer( tracker, pointsList, gPoint ) {
		        //$.console.log('stopTrackingPointer *** ' + pointsList.type + ' ' + gPoint.id.toString());
		        var listLength;

		        var trackedGPoint = pointsList.getById( gPoint.id );

		        if ( trackedGPoint ) {
		            if ( trackedGPoint.captured ) {
		                $.console.warn('stopTrackingPointer() called on captured pointer');
		                releasePointer( tracker, trackedGPoint );
		            }

		            // If child element relinquishes capture to a parent we may get here
		            //   from a pointerleave event while a pointerup event will never be received.
		            //   In that case, we'll clean up the contact count
		            pointsList.removeContact();

		            listLength = pointsList.removeById( gPoint.id );
		        } else {
		            listLength = pointsList.getLength();
		        }

		        return listLength;
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     */
		    function getEventProcessDefaults( tracker, eventInfo ) {
		        switch ( eventInfo.eventType ) {
		            case 'pointermove':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = false;
		                eventInfo.preventGesture = !tracker.hasGestureHandlers;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'pointerover':
		            case 'pointerout':
		            case 'contextmenu':
		            case 'keydown':
		            case 'keyup':
		            case 'keypress':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = false; // onContextMenu(), onKeyDown(), onKeyUp(), onKeyPress() may set true
		                eventInfo.preventGesture = false;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'pointerdown':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = false; // updatePointerDown() may set true (tracker.hasGestureHandlers)
		                eventInfo.preventGesture = !tracker.hasGestureHandlers;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'pointerup':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = false;
		                eventInfo.preventGesture = !tracker.hasGestureHandlers;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'wheel':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = false; // handleWheelEvent() may set true
		                eventInfo.preventGesture = !tracker.hasScrollHandler;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'gotpointercapture':
		            case 'lostpointercapture':
		            case 'pointercancel':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = false;
		                eventInfo.preventDefault = false;
		                eventInfo.preventGesture = false;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'click':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = !!tracker.clickHandler;
		                eventInfo.preventGesture = false;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'dblclick':
		                eventInfo.isStoppable = true;
		                eventInfo.isCancelable = true;
		                eventInfo.preventDefault = !!tracker.dblClickHandler;
		                eventInfo.preventGesture = false;
		                eventInfo.stopPropagation = false;
		                break;
		            case 'focus':
		            case 'blur':
		            case 'pointerenter':
		            case 'pointerleave':
		            default:
		                eventInfo.isStoppable = false;
		                eventInfo.isCancelable = false;
		                eventInfo.preventDefault = false;
		                eventInfo.preventGesture = false;
		                eventInfo.stopPropagation = false;
		                break;
		        }
		    }


		    /**
		     * Sets up for and calls preProcessEventHandler. Call with the following parameters -
		     * this function will fill in the rest of the preProcessEventHandler event object
		     * properties
		     *
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     * @param {Object} eventInfo.originalEvent
		     * @param {String} eventInfo.eventType
		     * @param {String} eventInfo.pointerType
		     * @param {Boolean} eventInfo.isEmulated
		     */
		    function preProcessEvent( tracker, eventInfo ) {
		        eventInfo.eventSource = tracker;
		        eventInfo.eventPhase = eventInfo.originalEvent ?
		                        ((typeof eventInfo.originalEvent.eventPhase !== 'undefined') ?
		                                            eventInfo.originalEvent.eventPhase : 0) : 0;
		        eventInfo.defaultPrevented = $.eventIsCanceled( eventInfo.originalEvent );
		        eventInfo.shouldCapture = false;
		        eventInfo.shouldReleaseCapture = false;
		        eventInfo.userData = tracker.userData;

		        getEventProcessDefaults( tracker, eventInfo );

		        if ( tracker.preProcessEventHandler ) {
		            tracker.preProcessEventHandler( eventInfo );
		        }
		    }


		    /**
		     * Sets or resets the captured property on the tracked pointer matching the passed gPoint's id/type
		     *
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {Object} gPoint
		     *     An object with id and type properties describing the pointer to update.
		     * @param {Boolean} isCaptured
		     *      Value to set the captured property to.
		     */
		    function updatePointerCaptured( tracker, gPoint, isCaptured ) {
		        var pointsList = tracker.getActivePointersListByType( gPoint.type );
		        var updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            if ( isCaptured && !updateGPoint.captured ) {
		                updateGPoint.captured = true;
		                pointsList.captureCount++;
		            } else if ( !isCaptured && updateGPoint.captured ) {
		                updateGPoint.captured = false;
		                pointsList.captureCount--;
		                if ( pointsList.captureCount < 0 ) {
		                    pointsList.captureCount = 0;
		                    $.console.warn('updatePointerCaptured() - pointsList.captureCount went negative');
		                }
		            }
		        } else {
		            $.console.warn('updatePointerCaptured() called on untracked pointer');
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point associated with the event.
		     */
		    function updatePointerEnter( tracker, eventInfo, gPoint ) {
		        var pointsList = tracker.getActivePointersListByType( gPoint.type ),
		            updateGPoint;

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            // Already tracking the pointer...update it
		            updateGPoint.insideElement = true;
		            updateGPoint.lastPos = updateGPoint.currentPos;
		            updateGPoint.lastTime = updateGPoint.currentTime;
		            updateGPoint.currentPos = gPoint.currentPos;
		            updateGPoint.currentTime = gPoint.currentTime;

		            gPoint = updateGPoint;
		        } else {
		            // Initialize for tracking and add to the tracking list
		            gPoint.captured = false; // Handled by updatePointerCaptured()
		            gPoint.insideElementPressed = false;
		            gPoint.insideElement = true;
		            startTrackingPointer( pointsList, gPoint );
		        }

		        // Enter (doesn't bubble and not cancelable)
		        if ( tracker.enterHandler ) {
		            tracker.enterHandler(
		                {
		                    eventSource:          tracker,
		                    pointerType:          gPoint.type,
		                    position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                    buttons:              pointsList.buttons,
		                    pointers:             tracker.getActivePointerCount(),
		                    insideElementPressed: gPoint.insideElementPressed,
		                    buttonDownAny:        pointsList.buttons !== 0,
		                    isTouchEvent:         gPoint.type === 'touch',
		                    originalEvent:        eventInfo.originalEvent,
		                    userData:             tracker.userData
		                }
		            );
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point associated with the event.
		     */
		    function updatePointerLeave( tracker, eventInfo, gPoint ) {
		        var pointsList = tracker.getActivePointersListByType(gPoint.type),
		            updateGPoint,
		            dispatchEventObj;

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            // Already tracking the pointer. If captured then update it, else stop tracking it
		            if ( updateGPoint.captured ) {
		                updateGPoint.insideElement = false;
		                updateGPoint.lastPos = updateGPoint.currentPos;
		                updateGPoint.lastTime = updateGPoint.currentTime;
		                updateGPoint.currentPos = gPoint.currentPos;
		                updateGPoint.currentTime = gPoint.currentTime;
		            } else {
		                stopTrackingPointer( tracker, pointsList, updateGPoint );
		            }

		            gPoint = updateGPoint;
		        } else {
		            gPoint.captured = false; // Handled by updatePointerCaptured()
		            gPoint.insideElementPressed = false;
		        }

		        // Leave (doesn't bubble and not cancelable)
		        //   Note: exitHandler is deprecated (v2.5.0), replaced by leaveHandler
		        if ( tracker.leaveHandler || tracker.exitHandler ) {
		            dispatchEventObj = {
		                eventSource:          tracker,
		                pointerType:          gPoint.type,
		                // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
		                position:             gPoint.currentPos && getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                buttons:              pointsList.buttons,
		                pointers:             tracker.getActivePointerCount(),
		                insideElementPressed: gPoint.insideElementPressed,
		                buttonDownAny:        pointsList.buttons !== 0,
		                isTouchEvent:         gPoint.type === 'touch',
		                originalEvent:        eventInfo.originalEvent,
		                userData:             tracker.userData
		            };

		            if ( tracker.leaveHandler ) {
		                tracker.leaveHandler( dispatchEventObj );
		            }
		            // Deprecated
		            if ( tracker.exitHandler ) {
		                tracker.exitHandler( dispatchEventObj );
		            }
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point associated with the event.
		     */
		    function updatePointerOver( tracker, eventInfo, gPoint ) {
		        var pointsList,
		            updateGPoint;

		        pointsList = tracker.getActivePointersListByType( gPoint.type );

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            gPoint = updateGPoint;
		        } else {
		            gPoint.captured = false;
		            gPoint.insideElementPressed = false;
		            //gPoint.insideElement = true; // Tracked by updatePointerEnter
		        }

		        if ( tracker.overHandler ) {
		            // Over
		            tracker.overHandler(
		                {
		                    eventSource:          tracker,
		                    pointerType:          gPoint.type,
		                    position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                    buttons:              pointsList.buttons,
		                    pointers:             tracker.getActivePointerCount(),
		                    insideElementPressed: gPoint.insideElementPressed,
		                    buttonDownAny:        pointsList.buttons !== 0,
		                    isTouchEvent:         gPoint.type === 'touch',
		                    originalEvent:        eventInfo.originalEvent,
		                    userData:             tracker.userData
		                }
		            );
		        }
		    }

		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point associated with the event.
		     */
		    function updatePointerOut( tracker, eventInfo, gPoint ) {
		        var pointsList,
		            updateGPoint;

		        pointsList = tracker.getActivePointersListByType(gPoint.type);

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            gPoint = updateGPoint;
		        } else {
		            gPoint.captured = false;
		            gPoint.insideElementPressed = false;
		            //gPoint.insideElement = true; // Tracked by updatePointerEnter
		        }

		        if ( tracker.outHandler ) {
		            // Out
		            tracker.outHandler( {
		                eventSource:          tracker,
		                pointerType:          gPoint.type,
		                position:             gPoint.currentPos && getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                buttons:              pointsList.buttons,
		                pointers:             tracker.getActivePointerCount(),
		                insideElementPressed: gPoint.insideElementPressed,
		                buttonDownAny:        pointsList.buttons !== 0,
		                isTouchEvent:         gPoint.type === 'touch',
		                originalEvent:        eventInfo.originalEvent,
		                userData:             tracker.userData
		            } );
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture point associated with the event.
		     * @param {Number} buttonChanged
		     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
		     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
		     */
		    function updatePointerDown( tracker, eventInfo, gPoint, buttonChanged ) {
		        var delegate = THIS[ tracker.hash ],
		            pointsList = tracker.getActivePointersListByType( gPoint.type ),
		            updateGPoint;

		        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
		            pointsList.buttons = eventInfo.originalEvent.buttons;
		        } else {
		            if ( buttonChanged === 0 ) {
		                // Primary
		                pointsList.buttons |= 1;
		            } else if ( buttonChanged === 1 ) {
		                // Aux
		                pointsList.buttons |= 4;
		            } else if ( buttonChanged === 2 ) {
		                // Secondary
		                pointsList.buttons |= 2;
		            } else if ( buttonChanged === 3 ) {
		                // X1 (Back)
		                pointsList.buttons |= 8;
		            } else if ( buttonChanged === 4 ) {
		                // X2 (Forward)
		                pointsList.buttons |= 16;
		            } else if ( buttonChanged === 5 ) {
		                // Pen Eraser
		                pointsList.buttons |= 32;
		            }
		        }

		        // Only capture and track primary button, pen, and touch contacts
		        if ( buttonChanged !== 0 ) {
		            eventInfo.shouldCapture = false;
		            eventInfo.shouldReleaseCapture = false;

		            // Aux Press
		            if ( tracker.nonPrimaryPressHandler &&
		                                !eventInfo.preventGesture &&
		                                !eventInfo.defaultPrevented ) {
		                eventInfo.preventDefault = true;

		                tracker.nonPrimaryPressHandler(
		                    {
		                        eventSource:          tracker,
		                        pointerType:          gPoint.type,
		                        position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                        button:               buttonChanged,
		                        buttons:              pointsList.buttons,
		                        isTouchEvent:         gPoint.type === 'touch',
		                        originalEvent:        eventInfo.originalEvent,
		                        userData:             tracker.userData
		                    }
		                );
		            }

		            return;
		        }

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            // Already tracking the pointer...update it
		            //updateGPoint.captured = true; // Handled by updatePointerCaptured()
		            updateGPoint.insideElementPressed = true;
		            updateGPoint.insideElement = true;
		            updateGPoint.originalTarget = eventInfo.originalEvent.target;
		            updateGPoint.contactPos = gPoint.currentPos;
		            updateGPoint.contactTime = gPoint.currentTime;
		            updateGPoint.lastPos = updateGPoint.currentPos;
		            updateGPoint.lastTime = updateGPoint.currentTime;
		            updateGPoint.currentPos = gPoint.currentPos;
		            updateGPoint.currentTime = gPoint.currentTime;

		            gPoint = updateGPoint;
		        } else {
		            // Initialize for tracking and add to the tracking list (no pointerenter event occurred before this)
		            // NOTE: pointerdown event on untracked pointer
		            gPoint.captured = false; // Handled by updatePointerCaptured()
		            gPoint.insideElementPressed = true;
		            gPoint.insideElement = true;
		            gPoint.originalTarget = eventInfo.originalEvent.target;
		            startTrackingPointer( pointsList, gPoint );
		        }

		        pointsList.addContact();
		        //$.console.log('contacts++ ', pointsList.contacts);

		        if ( !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            eventInfo.shouldCapture = true;
		            eventInfo.shouldReleaseCapture = false;
		            eventInfo.preventDefault = true;

		            if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
		                $.MouseTracker.gesturePointVelocityTracker.addPoint( tracker, gPoint );
		            }

		            if ( pointsList.contacts === 1 ) {
		                // Press
		                if ( tracker.pressHandler && !eventInfo.preventGesture ) {
		                    tracker.pressHandler(
		                        {
		                            eventSource:          tracker,
		                            pointerType:          gPoint.type,
		                            position:             getPointRelativeToAbsolute( gPoint.contactPos, tracker.element ),
		                            buttons:              pointsList.buttons,
		                            isTouchEvent:         gPoint.type === 'touch',
		                            originalEvent:        eventInfo.originalEvent,
		                            userData:             tracker.userData
		                        }
		                    );
		                }
		            } else if ( pointsList.contacts === 2 ) {
		                if ( tracker.pinchHandler && gPoint.type === 'touch' ) {
		                    // Initialize for pinch
		                    delegate.pinchGPoints = pointsList.asArray();
		                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
		                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
		                }
		            }
		        } else {
		            eventInfo.shouldCapture = false;
		            eventInfo.shouldReleaseCapture = false;
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture points associated with the event.
		     * @param {Number} buttonChanged
		     *      The button involved in the event: -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		     *      Note on chorded button presses (a button pressed when another button is already pressed): In the W3C Pointer Events model,
		     *      only one pointerdown/pointerup event combo is fired. Chorded button state changes instead fire pointermove events.
		     */
		    function updatePointerUp( tracker, eventInfo, gPoint, buttonChanged ) {
		        var delegate = THIS[ tracker.hash ],
		            pointsList = tracker.getActivePointersListByType( gPoint.type ),
		            releasePoint,
		            releaseTime,
		            updateGPoint,
		            wasCaptured = false,
		            quick;

		        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
		            pointsList.buttons = eventInfo.originalEvent.buttons;
		        } else {
		            if ( buttonChanged === 0 ) {
		                // Primary
		                pointsList.buttons ^= -2;
		            } else if ( buttonChanged === 1 ) {
		                // Aux
		                pointsList.buttons ^= -5;
		            } else if ( buttonChanged === 2 ) {
		                // Secondary
		                pointsList.buttons ^= -3;
		            } else if ( buttonChanged === 3 ) {
		                // X1 (Back)
		                pointsList.buttons ^= -9;
		            } else if ( buttonChanged === 4 ) {
		                // X2 (Forward)
		                pointsList.buttons ^= -17;
		            } else if ( buttonChanged === 5 ) {
		                // Pen Eraser
		                pointsList.buttons ^= -33;
		            }
		        }

		        eventInfo.shouldCapture = false;

		        // Only capture and track primary button, pen, and touch contacts
		        if ( buttonChanged !== 0 ) {
		            eventInfo.shouldReleaseCapture = false;

		            // Aux Release
		            if ( tracker.nonPrimaryReleaseHandler &&
		                                !eventInfo.preventGesture &&
		                                !eventInfo.defaultPrevented ) {
		                eventInfo.preventDefault = true;

		                tracker.nonPrimaryReleaseHandler(
		                    {
		                        eventSource:           tracker,
		                        pointerType:           gPoint.type,
		                        position:              getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
		                        button:                buttonChanged,
		                        buttons:               pointsList.buttons,
		                        isTouchEvent:          gPoint.type === 'touch',
		                        originalEvent:         eventInfo.originalEvent,
		                        userData:              tracker.userData
		                    }
		                );
		            }

		            return;
		        }

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            pointsList.removeContact();
		            //$.console.log('contacts-- ', pointsList.contacts);

		            // Update the pointer, stop tracking it if not still in this element
		            if ( updateGPoint.captured ) {
		                //updateGPoint.captured = false; // Handled by updatePointerCaptured()
		                wasCaptured = true;
		            }
		            updateGPoint.lastPos = updateGPoint.currentPos;
		            updateGPoint.lastTime = updateGPoint.currentTime;
		            updateGPoint.currentPos = gPoint.currentPos;
		            updateGPoint.currentTime = gPoint.currentTime;
		            if ( !updateGPoint.insideElement ) {
		                stopTrackingPointer( tracker, pointsList, updateGPoint );
		            }

		            releasePoint = updateGPoint.currentPos;
		            releaseTime = updateGPoint.currentTime;
		        } else {
		            // NOTE: updatePointerUp(): pointerup on untracked gPoint
		            // ...we'll start to track pointer again
		            gPoint.captured = false; // Handled by updatePointerCaptured()
		            gPoint.insideElementPressed = false;
		            gPoint.insideElement = true;
		            startTrackingPointer( pointsList, gPoint );

		            updateGPoint = gPoint;
		        }

		        if ( !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		            if ( wasCaptured ) {
		                // Pointer was activated in our element but could have been removed in any element since events are captured to our element

		                eventInfo.shouldReleaseCapture = true;
		                eventInfo.preventDefault = true;

		                if ( tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler ) {
		                    $.MouseTracker.gesturePointVelocityTracker.removePoint( tracker, updateGPoint );
		                }

		                if ( pointsList.contacts === 0 ) {

		                    // Release (pressed in our element)
		                    if ( tracker.releaseHandler && releasePoint ) {
		                        tracker.releaseHandler(
		                            {
		                                eventSource:           tracker,
		                                pointerType:           updateGPoint.type,
		                                position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
		                                buttons:               pointsList.buttons,
		                                insideElementPressed:  updateGPoint.insideElementPressed,
		                                insideElementReleased: updateGPoint.insideElement,
		                                isTouchEvent:          updateGPoint.type === 'touch',
		                                originalEvent:         eventInfo.originalEvent,
		                                userData:              tracker.userData
		                            }
		                        );
		                    }

		                    // Drag End
		                    if ( tracker.dragEndHandler && delegate.sentDragEvent ) {
		                        tracker.dragEndHandler(
		                            {
		                                eventSource:          tracker,
		                                pointerType:          updateGPoint.type,
		                                position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
		                                speed:                updateGPoint.speed,
		                                direction:            updateGPoint.direction,
		                                shift:                eventInfo.originalEvent.shiftKey,
		                                isTouchEvent:         updateGPoint.type === 'touch',
		                                originalEvent:        eventInfo.originalEvent,
		                                userData:             tracker.userData
		                            }
		                        );
		                    }

		                    // We want to clear this flag regardless of whether we fired the dragEndHandler
		                    delegate.sentDragEvent = false;

		                    // Click / Double-Click
		                    if ( ( tracker.clickHandler || tracker.dblClickHandler ) && updateGPoint.insideElement ) {
		                        quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold &&
		                                        updateGPoint.contactPos.distanceTo( releasePoint ) <= tracker.clickDistThreshold;

		                        // Click
		                        if ( tracker.clickHandler ) {
		                            tracker.clickHandler(
		                                {
		                                    eventSource:          tracker,
		                                    pointerType:          updateGPoint.type,
		                                    position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
		                                    quick:                quick,
		                                    shift:                eventInfo.originalEvent.shiftKey,
		                                    isTouchEvent:         updateGPoint.type === 'touch',
		                                    originalEvent:        eventInfo.originalEvent,
		                                    originalTarget:       updateGPoint.originalTarget,
		                                    userData:             tracker.userData
		                                }
		                            );
		                        }

		                        // Double-Click
		                        if ( tracker.dblClickHandler && quick ) {
		                            pointsList.clicks++;
		                            if ( pointsList.clicks === 1 ) {
		                                delegate.lastClickPos = releasePoint;
		                                /*jshint loopfunc:true*/
		                                delegate.dblClickTimeOut = setTimeout( function() {
		                                    pointsList.clicks = 0;
		                                }, tracker.dblClickTimeThreshold );
		                                /*jshint loopfunc:false*/
		                            } else if ( pointsList.clicks === 2 ) {
		                                clearTimeout( delegate.dblClickTimeOut );
		                                pointsList.clicks = 0;
		                                if ( delegate.lastClickPos.distanceTo( releasePoint ) <= tracker.dblClickDistThreshold ) {
		                                    tracker.dblClickHandler(
		                                        {
		                                            eventSource:          tracker,
		                                            pointerType:          updateGPoint.type,
		                                            position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
		                                            shift:                eventInfo.originalEvent.shiftKey,
		                                            isTouchEvent:         updateGPoint.type === 'touch',
		                                            originalEvent:        eventInfo.originalEvent,
		                                            userData:             tracker.userData
		                                        }
		                                    );
		                                }
		                                delegate.lastClickPos = null;
		                            }
		                        }
		                    }
		                } else if ( pointsList.contacts === 2 ) {
		                    if ( tracker.pinchHandler && updateGPoint.type === 'touch' ) {
		                        // Reset for pinch
		                        delegate.pinchGPoints = pointsList.asArray();
		                        delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
		                        delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
		                    }
		                }
		            } else {
		                // Pointer was activated in another element but removed in our element

		                eventInfo.shouldReleaseCapture = false;

		                // Release (pressed in another element)
		                if ( tracker.releaseHandler && releasePoint ) {
		                    tracker.releaseHandler(
		                        {
		                            eventSource:           tracker,
		                            pointerType:           updateGPoint.type,
		                            position:              getPointRelativeToAbsolute( releasePoint, tracker.element ),
		                            buttons:               pointsList.buttons,
		                            insideElementPressed:  updateGPoint.insideElementPressed,
		                            insideElementReleased: updateGPoint.insideElement,
		                            isTouchEvent:          updateGPoint.type === 'touch',
		                            originalEvent:         eventInfo.originalEvent,
		                            userData:              tracker.userData
		                        }
		                    );
		                    eventInfo.preventDefault = true;
		                }
		            }
		        }
		    }


		    /**
		     * Call when pointer(s) change coordinates, button state, pressure, tilt, or contact geometry (e.g. width and height)
		     *
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture points associated with the event.
		     */
		    function updatePointerMove( tracker, eventInfo, gPoint ) {
		        var delegate = THIS[ tracker.hash ],
		            pointsList = tracker.getActivePointersListByType( gPoint.type ),
		            updateGPoint,
		            gPointArray,
		            delta;

		        if ( typeof eventInfo.originalEvent.buttons !== 'undefined' ) {
		            pointsList.buttons = eventInfo.originalEvent.buttons;
		        }

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            // Already tracking the pointer...update it
		            updateGPoint.lastPos = updateGPoint.currentPos;
		            updateGPoint.lastTime = updateGPoint.currentTime;
		            updateGPoint.currentPos = gPoint.currentPos;
		            updateGPoint.currentTime = gPoint.currentTime;
		        } else {
		            // Should never get here, but due to user agent bugs (e.g. legacy touch) it sometimes happens
		            return;
		        }

		        eventInfo.shouldCapture = false;
		        eventInfo.shouldReleaseCapture = false;

		        // Stop (mouse only)
		        if ( tracker.stopHandler && gPoint.type === 'mouse' ) {
		            clearTimeout( tracker.stopTimeOut );
		            tracker.stopTimeOut = setTimeout( function() {
		                handlePointerStop( tracker, eventInfo.originalEvent, gPoint.type );
		            }, tracker.stopDelay );
		        }

		        if ( pointsList.contacts === 0 ) {
		            // Move (no contacts: hovering mouse or other hover-capable device)
		            if ( tracker.moveHandler ) {
		                tracker.moveHandler(
		                    {
		                        eventSource:          tracker,
		                        pointerType:          gPoint.type,
		                        position:             getPointRelativeToAbsolute( gPoint.currentPos, tracker.element ),
		                        buttons:              pointsList.buttons,
		                        isTouchEvent:         gPoint.type === 'touch',
		                        originalEvent:        eventInfo.originalEvent,
		                        userData:             tracker.userData
		                    }
		                );
		            }
		        } else if ( pointsList.contacts === 1 ) {
		            // Move (1 contact)
		            if ( tracker.moveHandler ) {
		                updateGPoint = pointsList.asArray()[ 0 ];
		                tracker.moveHandler(
		                    {
		                        eventSource:          tracker,
		                        pointerType:          updateGPoint.type,
		                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
		                        buttons:              pointsList.buttons,
		                        isTouchEvent:         updateGPoint.type === 'touch',
		                        originalEvent:        eventInfo.originalEvent,
		                        userData:             tracker.userData
		                    }
		                );
		            }

		            // Drag
		            if ( tracker.dragHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		                updateGPoint = pointsList.asArray()[ 0 ];
		                delta = updateGPoint.currentPos.minus( updateGPoint.lastPos );
		                tracker.dragHandler(
		                    {
		                        eventSource:          tracker,
		                        pointerType:          updateGPoint.type,
		                        position:             getPointRelativeToAbsolute( updateGPoint.currentPos, tracker.element ),
		                        buttons:              pointsList.buttons,
		                        delta:                delta,
		                        speed:                updateGPoint.speed,
		                        direction:            updateGPoint.direction,
		                        shift:                eventInfo.originalEvent.shiftKey,
		                        isTouchEvent:         updateGPoint.type === 'touch',
		                        originalEvent:        eventInfo.originalEvent,
		                        userData:             tracker.userData
		                    }
		                );
		                eventInfo.preventDefault = true;
		                delegate.sentDragEvent = true;
		            }
		        } else if ( pointsList.contacts === 2 ) {
		            // Move (2 contacts, use center)
		            if ( tracker.moveHandler ) {
		                gPointArray = pointsList.asArray();
		                tracker.moveHandler(
		                    {
		                        eventSource:          tracker,
		                        pointerType:          gPointArray[ 0 ].type,
		                        position:             getPointRelativeToAbsolute( getCenterPoint( gPointArray[ 0 ].currentPos, gPointArray[ 1 ].currentPos ), tracker.element ),
		                        buttons:              pointsList.buttons,
		                        isTouchEvent:         gPointArray[ 0 ].type === 'touch',
		                        originalEvent:        eventInfo.originalEvent,
		                        userData:             tracker.userData
		                    }
		                );
		            }

		            // Pinch
		            if ( tracker.pinchHandler && gPoint.type === 'touch' &&
		                                !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
		                delta = delegate.pinchGPoints[ 0 ].currentPos.distanceTo( delegate.pinchGPoints[ 1 ].currentPos );
		                if ( delta !== delegate.currentPinchDist ) {
		                    delegate.lastPinchDist = delegate.currentPinchDist;
		                    delegate.currentPinchDist = delta;
		                    delegate.lastPinchCenter = delegate.currentPinchCenter;
		                    delegate.currentPinchCenter = getCenterPoint( delegate.pinchGPoints[ 0 ].currentPos, delegate.pinchGPoints[ 1 ].currentPos );
		                    tracker.pinchHandler(
		                        {
		                            eventSource:          tracker,
		                            pointerType:          'touch',
		                            gesturePoints:        delegate.pinchGPoints,
		                            lastCenter:           getPointRelativeToAbsolute( delegate.lastPinchCenter, tracker.element ),
		                            center:               getPointRelativeToAbsolute( delegate.currentPinchCenter, tracker.element ),
		                            lastDistance:         delegate.lastPinchDist,
		                            distance:             delegate.currentPinchDist,
		                            shift:                eventInfo.originalEvent.shiftKey,
		                            originalEvent:        eventInfo.originalEvent,
		                            userData:             tracker.userData
		                        }
		                    );
		                    eventInfo.preventDefault = true;
		                }
		            }
		        }
		    }


		    /**
		     * @function
		     * @private
		     * @inner
		     * @param {OpenSeadragon.MouseTracker} tracker
		     *     A reference to the MouseTracker instance.
		     * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
		     *     Processing info for originating DOM event.
		     * @param {OpenSeadragon.MouseTracker.GesturePoint} gPoint
		     *      Gesture points associated with the event.
		     */
		    function updatePointerCancel( tracker, eventInfo, gPoint ) {
		        var pointsList = tracker.getActivePointersListByType( gPoint.type ),
		            updateGPoint;

		        updateGPoint = pointsList.getById( gPoint.id );

		        if ( updateGPoint ) {
		            stopTrackingPointer( tracker, pointsList, updateGPoint );
		        }
		    }


		    /**
		     * @private
		     * @inner
		     */
		    function handlePointerStop( tracker, originalMoveEvent, pointerType ) {
		        if ( tracker.stopHandler ) {
		            tracker.stopHandler( {
		                eventSource:          tracker,
		                pointerType:          pointerType,
		                position:             getMouseRelative( originalMoveEvent, tracker.element ),
		                buttons:              tracker.getActivePointersListByType( pointerType ).buttons,
		                isTouchEvent:         pointerType === 'touch',
		                originalEvent:        originalMoveEvent,
		                userData:             tracker.userData
		            } );
		        }
		    }

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - Control
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * An enumeration of supported locations where controls can be anchored.
		 * The anchoring is always relative to the container.
		 * @member ControlAnchor
		 * @memberof OpenSeadragon
		 * @static
		 * @type {Object}
		 * @property {Number} NONE
		 * @property {Number} TOP_LEFT
		 * @property {Number} TOP_RIGHT
		 * @property {Number} BOTTOM_LEFT
		 * @property {Number} BOTTOM_RIGHT
		 * @property {Number} ABSOLUTE
		 */
		$.ControlAnchor = {
		    NONE: 0,
		    TOP_LEFT: 1,
		    TOP_RIGHT: 2,
		    BOTTOM_RIGHT: 3,
		    BOTTOM_LEFT: 4,
		    ABSOLUTE: 5
		};

		/**
		 * @class Control
		 * @classdesc A Control represents any interface element which is meant to allow the user
		 * to interact with the zoomable interface. Any control can be anchored to any
		 * element.
		 *
		 * @memberof OpenSeadragon
		 * @param {Element} element - the control element to be anchored in the container.
		 * @param {Object } options - All required and optional settings for configuring a control element.
		 * @param {OpenSeadragon.ControlAnchor} [options.anchor=OpenSeadragon.ControlAnchor.NONE] - the position of the control
		 *  relative to the container.
		 * @param {Boolean} [options.attachToViewer=true] - Whether the control should be added directly to the viewer, or
		 *  directly to the container
		 * @param {Boolean} [options.autoFade=true] - Whether the control should have the autofade behavior
		 * @param {Element} container - the element to control will be anchored too.
		 */
		$.Control = function ( element, options, container ) {

		    var parent = element.parentNode;
		    if (typeof options === 'number')
		    {
		        $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; " +
		                        "please use an options object instead.  " +
		                        "Support for this deprecated variant is scheduled for removal in December 2013");
		         options = {anchor: options};
		    }
		    options.attachToViewer = (typeof options.attachToViewer === 'undefined') ? true : options.attachToViewer;
		    /**
		     * True if the control should have autofade behavior.
		     * @member {Boolean} autoFade
		     * @memberof OpenSeadragon.Control#
		     */
		    this.autoFade = (typeof options.autoFade === 'undefined') ? true : options.autoFade;
		    /**
		     * The element providing the user interface with some type of control (e.g. a zoom-in button).
		     * @member {Element} element
		     * @memberof OpenSeadragon.Control#
		     */
		    this.element    = element;
		    /**
		     * The position of the Control relative to its container.
		     * @member {OpenSeadragon.ControlAnchor} anchor
		     * @memberof OpenSeadragon.Control#
		     */
		    this.anchor     = options.anchor;
		    /**
		     * The Control's containing element.
		     * @member {Element} container
		     * @memberof OpenSeadragon.Control#
		     */
		    this.container  = container;
		    /**
		     * A neutral element surrounding the control element.
		     * @member {Element} wrapper
		     * @memberof OpenSeadragon.Control#
		     */
		    if ( this.anchor === $.ControlAnchor.ABSOLUTE ) {
		        this.wrapper    = $.makeNeutralElement( "div" );
		        this.wrapper.style.position = "absolute";
		        this.wrapper.style.top = typeof (options.top) === "number" ? (options.top + 'px') : options.top;
		        this.wrapper.style.left  = typeof (options.left) === "number" ? (options.left + 'px') : options.left;
		        this.wrapper.style.height = typeof (options.height) === "number" ? (options.height + 'px') : options.height;
		        this.wrapper.style.width  = typeof (options.width) === "number" ? (options.width + 'px') : options.width;
		        this.wrapper.style.margin = "0px";
		        this.wrapper.style.padding = "0px";

		        this.element.style.position = "relative";
		        this.element.style.top = "0px";
		        this.element.style.left = "0px";
		        this.element.style.height = "100%";
		        this.element.style.width = "100%";
		    } else {
		        this.wrapper    = $.makeNeutralElement( "div" );
		        this.wrapper.style.display = "inline-block";
		        if ( this.anchor === $.ControlAnchor.NONE ) {
		            // IE6 fix
		            this.wrapper.style.width = this.wrapper.style.height = "100%";
		        }
		    }
		    this.wrapper.appendChild( this.element );

		    if (options.attachToViewer ) {
		        if ( this.anchor === $.ControlAnchor.TOP_RIGHT ||
		             this.anchor === $.ControlAnchor.BOTTOM_RIGHT ) {
		            this.container.insertBefore(
		                this.wrapper,
		                this.container.firstChild
		            );
		        } else {
		            this.container.appendChild( this.wrapper );
		        }
		    } else {
		        parent.appendChild( this.wrapper );
		    }

		};

		/** @lends OpenSeadragon.Control.prototype */
		$.Control.prototype = {

		    /**
		     * Removes the control from the container.
		     * @function
		     */
		    destroy: function() {
		        this.wrapper.removeChild( this.element );
		        if (this.anchor !== $.ControlAnchor.NONE) {
		            this.container.removeChild(this.wrapper);
		        }
		    },

		    /**
		     * Determines if the control is currently visible.
		     * @function
		     * @returns {Boolean} true if currently visible, false otherwise.
		     */
		    isVisible: function() {
		        return this.wrapper.style.display !== "none";
		    },

		    /**
		     * Toggles the visibility of the control.
		     * @function
		     * @param {Boolean} visible - true to make visible, false to hide.
		     */
		    setVisible: function( visible ) {
		        this.wrapper.style.display = visible ?
		            ( this.anchor === $.ControlAnchor.ABSOLUTE ? 'block' : 'inline-block' ) :
		            "none";
		    },

		    /**
		     * Sets the opacity level for the control.
		     * @function
		     * @param {Number} opactiy - a value between 1 and 0 inclusively.
		     */
		    setOpacity: function( opacity ) {
		        $.setElementOpacity( this.wrapper, opacity, true );
		    }
		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - ControlDock
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){
		    /**
		     * @class ControlDock
		     * @classdesc Provides a container element (a &lt;form&gt; element) with support for the layout of control elements.
		     *
		     * @memberof OpenSeadragon
		     */
		    $.ControlDock = function( options ){
		        var layouts = [ 'topleft', 'topright', 'bottomright', 'bottomleft'],
		            layout,
		            i;

		        $.extend( true, this, {
		            id: 'controldock-' + $.now() + '-' + Math.floor(Math.random() * 1000000),
		            container: $.makeNeutralElement( 'div' ),
		            controls: []
		        }, options );

		        // Disable the form's submit; otherwise button clicks and return keys
		        // can trigger it.
		        this.container.onsubmit = function() {
		            return false;
		        };

		        if( this.element ){
		            this.element = $.getElement( this.element );
		            this.element.appendChild( this.container );
		            if( $.getElementStyle(this.element).position === 'static' ){
		                this.element.style.position = 'relative';
		            }
		            this.container.style.width = '100%';
		            this.container.style.height = '100%';
		        }

		        for( i = 0; i < layouts.length; i++ ){
		            layout = layouts[ i ];
		            this.controls[ layout ] = $.makeNeutralElement( "div" );
		            this.controls[ layout ].style.position = 'absolute';
		            if ( layout.match( 'left' ) ){
		                this.controls[ layout ].style.left = '0px';
		            }
		            if ( layout.match( 'right' ) ){
		                this.controls[ layout ].style.right = '0px';
		            }
		            if ( layout.match( 'top' ) ){
		                this.controls[ layout ].style.top = '0px';
		            }
		            if ( layout.match( 'bottom' ) ){
		                this.controls[ layout ].style.bottom = '0px';
		            }
		        }

		        this.container.appendChild( this.controls.topleft );
		        this.container.appendChild( this.controls.topright );
		        this.container.appendChild( this.controls.bottomright );
		        this.container.appendChild( this.controls.bottomleft );
		    };

		    /** @lends OpenSeadragon.ControlDock.prototype */
		    $.ControlDock.prototype = {

		        /**
		         * @function
		         */
		        addControl: function ( element, controlOptions ) {
		            element = $.getElement( element );
		            var div = null;

		            if ( getControlIndex( this, element ) >= 0 ) {
		                return;     // they're trying to add a duplicate control
		            }

		            switch ( controlOptions.anchor ) {
		                case $.ControlAnchor.TOP_RIGHT:
		                    div = this.controls.topright;
		                    element.style.position = "relative";
		                    element.style.paddingRight = "0px";
		                    element.style.paddingTop = "0px";
		                    break;
		                case $.ControlAnchor.BOTTOM_RIGHT:
		                    div = this.controls.bottomright;
		                    element.style.position = "relative";
		                    element.style.paddingRight = "0px";
		                    element.style.paddingBottom = "0px";
		                    break;
		                case $.ControlAnchor.BOTTOM_LEFT:
		                    div = this.controls.bottomleft;
		                    element.style.position = "relative";
		                    element.style.paddingLeft = "0px";
		                    element.style.paddingBottom = "0px";
		                    break;
		                case $.ControlAnchor.TOP_LEFT:
		                    div = this.controls.topleft;
		                    element.style.position = "relative";
		                    element.style.paddingLeft = "0px";
		                    element.style.paddingTop = "0px";
		                    break;
		                case $.ControlAnchor.ABSOLUTE:
		                    div = this.container;
		                    element.style.margin = "0px";
		                    element.style.padding = "0px";
		                    break;
		                default:
		                case $.ControlAnchor.NONE:
		                    div = this.container;
		                    element.style.margin = "0px";
		                    element.style.padding = "0px";
		                    break;
		            }

		            this.controls.push(
		                new $.Control( element, controlOptions, div )
		            );
		            element.style.display = "inline-block";
		        },


		        /**
		         * @function
		         * @returns {OpenSeadragon.ControlDock} Chainable.
		         */
		        removeControl: function ( element ) {
		            element = $.getElement( element );
		            var i = getControlIndex( this, element );

		            if ( i >= 0 ) {
		                this.controls[ i ].destroy();
		                this.controls.splice( i, 1 );
		            }

		            return this;
		        },

		        /**
		         * @function
		         * @returns {OpenSeadragon.ControlDock} Chainable.
		         */
		        clearControls: function () {
		            while ( this.controls.length > 0 ) {
		                this.controls.pop().destroy();
		            }

		            return this;
		        },


		        /**
		         * @function
		         * @returns {Boolean}
		         */
		        areControlsEnabled: function () {
		            var i;

		            for ( i = this.controls.length - 1; i >= 0; i-- ) {
		                if ( this.controls[ i ].isVisible() ) {
		                    return true;
		                }
		            }

		            return false;
		        },


		        /**
		         * @function
		         * @returns {OpenSeadragon.ControlDock} Chainable.
		         */
		        setControlsEnabled: function( enabled ) {
		            var i;

		            for ( i = this.controls.length - 1; i >= 0; i-- ) {
		                this.controls[ i ].setVisible( enabled );
		            }

		            return this;
		        }

		    };


		    ///////////////////////////////////////////////////////////////////////////////
		    // Utility methods
		    ///////////////////////////////////////////////////////////////////////////////
		    function getControlIndex( dock, element ) {
		        var controls = dock.controls,
		            i;

		        for ( i = controls.length - 1; i >= 0; i-- ) {
		            if ( controls[ i ].element === element ) {
		                return i;
		            }
		        }

		        return -1;
		    }

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Placement
		 *
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($) {

		    /**
		     * An enumeration of positions to anchor an element.
		     * @member Placement
		     * @memberOf OpenSeadragon
		     * @static
		     * @readonly
		     * @property {OpenSeadragon.Placement} CENTER
		     * @property {OpenSeadragon.Placement} TOP_LEFT
		     * @property {OpenSeadragon.Placement} TOP
		     * @property {OpenSeadragon.Placement} TOP_RIGHT
		     * @property {OpenSeadragon.Placement} RIGHT
		     * @property {OpenSeadragon.Placement} BOTTOM_RIGHT
		     * @property {OpenSeadragon.Placement} BOTTOM
		     * @property {OpenSeadragon.Placement} BOTTOM_LEFT
		     * @property {OpenSeadragon.Placement} LEFT
		     */
		    $.Placement = $.freezeObject({
		        CENTER:       0,
		        TOP_LEFT:     1,
		        TOP:          2,
		        TOP_RIGHT:    3,
		        RIGHT:        4,
		        BOTTOM_RIGHT: 5,
		        BOTTOM:       6,
		        BOTTOM_LEFT:  7,
		        LEFT:         8,
		        properties: {
		            0: {
		                isLeft: false,
		                isHorizontallyCentered: true,
		                isRight: false,
		                isTop: false,
		                isVerticallyCentered: true,
		                isBottom: false
		            },
		            1: {
		                isLeft: true,
		                isHorizontallyCentered: false,
		                isRight: false,
		                isTop: true,
		                isVerticallyCentered: false,
		                isBottom: false
		            },
		            2: {
		                isLeft: false,
		                isHorizontallyCentered: true,
		                isRight: false,
		                isTop: true,
		                isVerticallyCentered: false,
		                isBottom: false
		            },
		            3: {
		                isLeft: false,
		                isHorizontallyCentered: false,
		                isRight: true,
		                isTop: true,
		                isVerticallyCentered: false,
		                isBottom: false
		            },
		            4: {
		                isLeft: false,
		                isHorizontallyCentered: false,
		                isRight: true,
		                isTop: false,
		                isVerticallyCentered: true,
		                isBottom: false
		            },
		            5: {
		                isLeft: false,
		                isHorizontallyCentered: false,
		                isRight: true,
		                isTop: false,
		                isVerticallyCentered: false,
		                isBottom: true
		            },
		            6: {
		                isLeft: false,
		                isHorizontallyCentered: true,
		                isRight: false,
		                isTop: false,
		                isVerticallyCentered: false,
		                isBottom: true
		            },
		            7: {
		                isLeft: true,
		                isHorizontallyCentered: false,
		                isRight: false,
		                isTop: false,
		                isVerticallyCentered: false,
		                isBottom: true
		            },
		            8: {
		                isLeft: true,
		                isHorizontallyCentered: false,
		                isRight: false,
		                isTop: false,
		                isVerticallyCentered: true,
		                isBottom: false
		            }
		        }
		    });

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - Viewer
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		// dictionary from hash to private properties
		var THIS = {};
		var nextHash = 1;

		/**
		 *
		 * The main point of entry into creating a zoomable image on the page.<br>
		 * <br>
		 * We have provided an idiomatic javascript constructor which takes
		 * a single object, but still support the legacy positional arguments.<br>
		 * <br>
		 * The options below are given in order that they appeared in the constructor
		 * as arguments and we translate a positional call into an idiomatic call.<br>
		 * <br>
		 * To create a viewer, you can use either of this methods:<br>
		 * <ul>
		 * <li><code>var viewer = new OpenSeadragon.Viewer(options);</code></li>
		 * <li><code>var viewer = OpenSeadragon(options);</code></li>
		 * </ul>
		 * @class Viewer
		 * @classdesc The main OpenSeadragon viewer class.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.EventSource
		 * @extends OpenSeadragon.ControlDock
		 * @param {OpenSeadragon.Options} options - Viewer options.
		 *
		 **/
		$.Viewer = function( options ) {

		    var args  = arguments,
		        _this = this,
		        i;


		    //backward compatibility for positional args while preferring more
		    //idiomatic javascript options object as the only argument
		    if( !$.isPlainObject( options ) ){
		        options = {
		            id:                 args[ 0 ],
		            xmlPath:            args.length > 1 ? args[ 1 ] : undefined,
		            prefixUrl:          args.length > 2 ? args[ 2 ] : undefined,
		            controls:           args.length > 3 ? args[ 3 ] : undefined,
		            overlays:           args.length > 4 ? args[ 4 ] : undefined
		        };
		    }

		    //options.config and the general config argument are deprecated
		    //in favor of the more direct specification of optional settings
		    //being pass directly on the options object
		    if ( options.config ){
		        $.extend( true, options, options.config );
		        delete options.config;
		    }

		    // Move deprecated drawer options from the base options object into a sub-object
		    // This is an array to make it easy to add additional properties to convert to
		    // drawer options later if it makes sense to set at the drawer level rather than
		    // per tiled image (for example, subPixelRoundingForTransparency).
		    let drawerOptionList = [
		            'useCanvas', // deprecated
		        ];
		    options.drawerOptions = Object.assign({},
		        drawerOptionList.reduce((drawerOptions, option) => {
		            drawerOptions[option] = options[option];
		            delete options[option];
		            return drawerOptions;
		        }, {}),
		        options.drawerOptions);

		    //Public properties
		    //Allow the options object to override global defaults
		    $.extend( true, this, {

		        //internal state and dom identifiers
		        id:             options.id,
		        hash:           options.hash || nextHash++,
		        /**
		         * Index for page to be shown first next time open() is called (only used in sequenceMode).
		         * @member {Number} initialPage
		         * @memberof OpenSeadragon.Viewer#
		         */
		        initialPage:    0,

		        //dom nodes
		        /**
		         * The parent element of this Viewer instance, passed in when the Viewer was created.
		         * @member {Element} element
		         * @memberof OpenSeadragon.Viewer#
		         */
		        element:        null,
		        /**
		         * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
		         * Child element of {@link OpenSeadragon.Viewer#element}.
		         * @member {Element} container
		         * @memberof OpenSeadragon.Viewer#
		         */
		        container:      null,
		        /**
		         * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
		         * Child element of {@link OpenSeadragon.Viewer#container},
		         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
		         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
		         * @member {Element} canvas
		         * @memberof OpenSeadragon.Viewer#
		         */
		        canvas:         null,

		        // Overlays list. An overlay allows to add html on top of the viewer.
		        overlays:           [],
		        // Container inside the canvas where overlays are drawn.
		        overlaysContainer:  null,

		        //private state properties
		        previousBody:   [],

		        //This was originally initialized in the constructor and so could never
		        //have anything in it.  now it can because we allow it to be specified
		        //in the options and is only empty by default if not specified. Also
		        //this array was returned from get_controls which I find confusing
		        //since this object has a controls property which is treated in other
		        //functions like clearControls.  I'm removing the accessors.
		        customControls: [],

		        //These are originally not part options but declared as members
		        //in initialize.  It's still considered idiomatic to put them here
		        //source is here for backwards compatibility. It is not an official
		        //part of the API and should not be relied upon.
		        source:         null,
		        /**
		         * Handles rendering of tiles in the viewer. Created for each TileSource opened.
		         * @member {OpenSeadragon.Drawer} drawer
		         * @memberof OpenSeadragon.Viewer#
		         */
		        drawer:             null,
		        /**
		         * Keeps track of all of the tiled images in the scene.
		         * @member {OpenSeadragon.World} world
		         * @memberof OpenSeadragon.Viewer#
		         */
		        world:              null,
		        /**
		         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
		         * @member {OpenSeadragon.Viewport} viewport
		         * @memberof OpenSeadragon.Viewer#
		         */
		        viewport:       null,
		        /**
		         * @member {OpenSeadragon.Navigator} navigator
		         * @memberof OpenSeadragon.Viewer#
		         */
		        navigator:      null,

		        //A collection viewport is a separate viewport used to provide
		        //simultaneous rendering of sets of tiles
		        collectionViewport:     null,
		        collectionDrawer:       null,

		        //UI image resources
		        //TODO: rename navImages to uiImages
		        navImages:      null,

		        //interface button controls
		        buttonGroup:        null,

		        //TODO: this is defunct so safely remove it
		        profiler:       null

		    }, $.DEFAULT_SETTINGS, options );

		    if ( typeof ( this.hash) === "undefined" ) {
		        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
		    }
		    if ( typeof ( THIS[ this.hash ] ) !== "undefined" ) {
		        // We don't want to throw an error here, as the user might have discarded
		        // the previous viewer with the same hash and now want to recreate it.
		        $.console.warn("Hash " + this.hash + " has already been used.");
		    }


		    //Private state properties
		    THIS[ this.hash ] = {
		        fsBoundsDelta:     new $.Point( 1, 1 ),
		        prevContainerSize: null,
		        animating:         false,
		        forceRedraw:       false,
		        needsResize:       false,
		        forceResize:       false,
		        mouseInside:       false,
		        group:             null,
		        // whether we should be continuously zooming
		        zooming:           false,
		        // how much we should be continuously zooming by
		        zoomFactor:        null,
		        lastZoomTime:      null,
		        fullPage:          false,
		        onfullscreenchange: null,
		        lastClickTime: null,
		        draggingToZoom: false,
		    };

		    this._sequenceIndex = 0;
		    this._firstOpen = true;
		    this._updateRequestId = null;
		    this._loadQueue = [];
		    this.currentOverlays = [];
		    this._updatePixelDensityRatioBind = null;

		    this._lastScrollTime = $.now(); // variable used to help normalize the scroll event speed of different devices

		    //Inherit some behaviors and properties
		    $.EventSource.call( this );

		    this.addHandler( 'open-failed', function ( event ) {
		        var msg = $.getString( "Errors.OpenFailed", event.eventSource, event.message);
		        _this._showMessage( msg );
		    });

		    $.ControlDock.call( this, options );

		    //Deal with tile sources
		    if (this.xmlPath) {
		        //Deprecated option.  Now it is preferred to use the tileSources option
		        this.tileSources = [ this.xmlPath ];
		    }

		    this.element              = this.element || document.getElementById( this.id );
		    this.canvas               = $.makeNeutralElement( "div" );

		    this.canvas.className = "openseadragon-canvas";
		    (function( style ){
		        style.width    = "100%";
		        style.height   = "100%";
		        style.overflow = "hidden";
		        style.position = "absolute";
		        style.top      = "0px";
		        style.left     = "0px";
		    }(this.canvas.style));
		    $.setElementTouchActionNone( this.canvas );
		    if (options.tabIndex !== "") {
		        this.canvas.tabIndex = (options.tabIndex === undefined ? 0 : options.tabIndex);
		    }

		    //the container is created through applying the ControlDock constructor above
		    this.container.className = "openseadragon-container";
		    (function( style ){
		        style.width     = "100%";
		        style.height    = "100%";
		        style.position  = "relative";
		        style.overflow  = "hidden";
		        style.left      = "0px";
		        style.top       = "0px";
		        style.textAlign = "left";  // needed to protect against
		    }( this.container.style ));
		    $.setElementTouchActionNone( this.container );

		    this.container.insertBefore( this.canvas, this.container.firstChild );
		    this.element.appendChild( this.container );

		    //Used for toggling between fullscreen and default container size
		    //TODO: these can be closure private and shared across Viewer
		    //      instances.
		    this.bodyWidth      = document.body.style.width;
		    this.bodyHeight     = document.body.style.height;
		    this.bodyOverflow   = document.body.style.overflow;
		    this.docOverflow    = document.documentElement.style.overflow;

		    this.innerTracker = new $.MouseTracker({
		        userData:                 'Viewer.innerTracker',
		        element:                  this.canvas,
		        startDisabled:            !this.mouseNavEnabled,
		        clickTimeThreshold:       this.clickTimeThreshold,
		        clickDistThreshold:       this.clickDistThreshold,
		        dblClickTimeThreshold:    this.dblClickTimeThreshold,
		        dblClickDistThreshold:    this.dblClickDistThreshold,
		        contextMenuHandler:       $.delegate( this, onCanvasContextMenu ),
		        keyDownHandler:           $.delegate( this, onCanvasKeyDown ),
		        keyHandler:               $.delegate( this, onCanvasKeyPress ),
		        clickHandler:             $.delegate( this, onCanvasClick ),
		        dblClickHandler:          $.delegate( this, onCanvasDblClick ),
		        dragHandler:              $.delegate( this, onCanvasDrag ),
		        dragEndHandler:           $.delegate( this, onCanvasDragEnd ),
		        enterHandler:             $.delegate( this, onCanvasEnter ),
		        leaveHandler:             $.delegate( this, onCanvasLeave ),
		        pressHandler:             $.delegate( this, onCanvasPress ),
		        releaseHandler:           $.delegate( this, onCanvasRelease ),
		        nonPrimaryPressHandler:   $.delegate( this, onCanvasNonPrimaryPress ),
		        nonPrimaryReleaseHandler: $.delegate( this, onCanvasNonPrimaryRelease ),
		        scrollHandler:            $.delegate( this, onCanvasScroll ),
		        pinchHandler:             $.delegate( this, onCanvasPinch ),
		        focusHandler:             $.delegate( this, onCanvasFocus ),
		        blurHandler:              $.delegate( this, onCanvasBlur ),
		    });

		    this.outerTracker = new $.MouseTracker({
		        userData:              'Viewer.outerTracker',
		        element:               this.container,
		        startDisabled:         !this.mouseNavEnabled,
		        clickTimeThreshold:    this.clickTimeThreshold,
		        clickDistThreshold:    this.clickDistThreshold,
		        dblClickTimeThreshold: this.dblClickTimeThreshold,
		        dblClickDistThreshold: this.dblClickDistThreshold,
		        enterHandler:          $.delegate( this, onContainerEnter ),
		        leaveHandler:          $.delegate( this, onContainerLeave )
		    });

		    if( this.toolbar ){
		        this.toolbar = new $.ControlDock({ element: this.toolbar });
		    }

		    this.bindStandardControls();

		    THIS[ this.hash ].prevContainerSize = _getSafeElemSize( this.container );

		    if(window.ResizeObserver){
		        this._autoResizePolling = false;
		        this._resizeObserver = new ResizeObserver(function(){
		            THIS[_this.hash].needsResize = true;
		        });

		        this._resizeObserver.observe(this.container, {});
		    } else {
		        this._autoResizePolling = true;
		    }

		    // Create the world
		    this.world = new $.World({
		        viewer: this
		    });

		    this.world.addHandler('add-item', function(event) {
		        // For backwards compatibility, we maintain the source property
		        _this.source = _this.world.getItemAt(0).source;

		        THIS[ _this.hash ].forceRedraw = true;

		        if (!_this._updateRequestId) {
		            _this._updateRequestId = scheduleUpdate( _this, updateMulti );
		        }
		    });

		    this.world.addHandler('remove-item', function(event) {
		        // For backwards compatibility, we maintain the source property
		        if (_this.world.getItemCount()) {
		            _this.source = _this.world.getItemAt(0).source;
		        } else {
		            _this.source = null;
		        }

		        THIS[ _this.hash ].forceRedraw = true;
		    });

		    this.world.addHandler('metrics-change', function(event) {
		        if (_this.viewport) {
		            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
		        }
		    });

		    this.world.addHandler('item-index-change', function(event) {
		        // For backwards compatibility, we maintain the source property
		        _this.source = _this.world.getItemAt(0).source;
		    });

		    // Create the viewport
		    this.viewport = new $.Viewport({
		        containerSize:                      THIS[ this.hash ].prevContainerSize,
		        springStiffness:                    this.springStiffness,
		        animationTime:                      this.animationTime,
		        minZoomImageRatio:                  this.minZoomImageRatio,
		        maxZoomPixelRatio:                  this.maxZoomPixelRatio,
		        visibilityRatio:                    this.visibilityRatio,
		        wrapHorizontal:                     this.wrapHorizontal,
		        wrapVertical:                       this.wrapVertical,
		        defaultZoomLevel:                   this.defaultZoomLevel,
		        minZoomLevel:                       this.minZoomLevel,
		        maxZoomLevel:                       this.maxZoomLevel,
		        viewer:                             this,
		        degrees:                            this.degrees,
		        flipped:                            this.flipped,
		        overlayPreserveContentDirection:    this.overlayPreserveContentDirection,
		        navigatorRotate:                    this.navigatorRotate,
		        homeFillsViewer:                    this.homeFillsViewer,
		        margins:                            this.viewportMargins,
		        silenceMultiImageWarnings:          this.silenceMultiImageWarnings
		    });

		    this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());

		    // Create the image loader
		    this.imageLoader = new $.ImageLoader({
		        jobLimit: this.imageLoaderLimit,
		        timeout: options.timeout,
		        tileRetryMax: this.tileRetryMax,
		        tileRetryDelay: this.tileRetryDelay
		    });

		    // Create the tile cache
		    this.tileCache = new $.TileCache({
		        maxImageCacheCount: this.maxImageCacheCount
		    });

		    //Create the drawer based on selected options
		    if (Object.prototype.hasOwnProperty.call(this.drawerOptions, 'useCanvas') ){
		        $.console.error('useCanvas is deprecated, use the "drawer" option to indicate preferred drawer(s)');

		        // for backwards compatibility, use HTMLDrawer if useCanvas is defined and is falsey
		        if (!this.drawerOptions.useCanvas){
		            this.drawer = $.HTMLDrawer;
		        }

		        delete this.drawerOptions.useCanvas;
		    }
		    let drawerCandidates = Array.isArray(this.drawer) ? this.drawer : [this.drawer];
		    if (drawerCandidates.length === 0){
		        // if an empty array was passed in, throw a warning and use the defaults
		        // note: if the drawer option is not specified, the defaults will already be set so this won't apply
		        drawerCandidates = [$.DEFAULT_SETTINGS.drawer].flat(); // ensure it is a list
		        $.console.warn('No valid drawers were selected. Using the default value.');
		    }


		    this.drawer = null;
		    for (const drawerCandidate of drawerCandidates){
		        let success = this.requestDrawer(drawerCandidate, {mainDrawer: true, redrawImmediately: false});
		        if(success){
		            break;
		        }
		    }

		    if (!this.drawer){
		        $.console.error('No drawer could be created!');
		        throw('Error with creating the selected drawer(s)');
		    }

		    // Pass the imageSmoothingEnabled option along to the drawer
		    this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);

		    // Overlay container
		    this.overlaysContainer    = $.makeNeutralElement( "div" );
		    this.canvas.appendChild( this.overlaysContainer );

		    // Now that we have a drawer, see if it supports rotate. If not we need to remove the rotate buttons
		    if (!this.drawer.canRotate()) {
		        // Disable/remove the rotate left/right buttons since they aren't supported
		        if (this.rotateLeft) {
		            i = this.buttonGroup.buttons.indexOf(this.rotateLeft);
		            this.buttonGroup.buttons.splice(i, 1);
		            this.buttonGroup.element.removeChild(this.rotateLeft.element);
		        }
		        if (this.rotateRight) {
		            i = this.buttonGroup.buttons.indexOf(this.rotateRight);
		            this.buttonGroup.buttons.splice(i, 1);
		            this.buttonGroup.element.removeChild(this.rotateRight.element);
		        }
		    }

		    this._addUpdatePixelDensityRatioEvent();

		    //Instantiate a navigator if configured
		    if ( this.showNavigator){
		        this.navigator = new $.Navigator({
		            element:           this.navigatorElement,
		            id:                this.navigatorId,
		            position:          this.navigatorPosition,
		            sizeRatio:         this.navigatorSizeRatio,
		            maintainSizeRatio: this.navigatorMaintainSizeRatio,
		            top:               this.navigatorTop,
		            left:              this.navigatorLeft,
		            width:             this.navigatorWidth,
		            height:            this.navigatorHeight,
		            autoResize:        this.navigatorAutoResize,
		            autoFade:          this.navigatorAutoFade,
		            prefixUrl:         this.prefixUrl,
		            viewer:            this,
		            navigatorRotate:   this.navigatorRotate,
		            background:        this.navigatorBackground,
		            opacity:           this.navigatorOpacity,
		            borderColor:       this.navigatorBorderColor,
		            displayRegionColor: this.navigatorDisplayRegionColor,
		            crossOriginPolicy: this.crossOriginPolicy,
		            animationTime:     this.animationTime,
		            drawer:            this.drawer.getType(),
		            loadTilesWithAjax: this.loadTilesWithAjax,
		            ajaxHeaders:       this.ajaxHeaders,
		            ajaxWithCredentials: this.ajaxWithCredentials,
		        });
		    }

		    // Sequence mode
		    if (this.sequenceMode) {
		        this.bindSequenceControls();
		    }

		    // Open initial tilesources
		    if (this.tileSources) {
		        this.open( this.tileSources );
		    }

		    // Add custom controls
		    for ( i = 0; i < this.customControls.length; i++ ) {
		        this.addControl(
		            this.customControls[ i ].id,
		            {anchor: this.customControls[ i ].anchor}
		        );
		    }

		    // Initial fade out
		    $.requestAnimationFrame( function(){
		        beginControlsAutoHide( _this );
		    } );

		    // Register the viewer
		    $._viewers.set(this.element, this);
		};

		$.extend( $.Viewer.prototype, $.EventSource.prototype, $.ControlDock.prototype, /** @lends OpenSeadragon.Viewer.prototype */{


		    /**
		     * @function
		     * @returns {Boolean}
		     */
		    isOpen: function () {
		        return !!this.world.getItemCount();
		    },

		    // deprecated
		    openDzi: function ( dzi ) {
		        $.console.error( "[Viewer.openDzi] this function is deprecated; use Viewer.open() instead." );
		        return this.open( dzi );
		    },

		    // deprecated
		    openTileSource: function ( tileSource ) {
		        $.console.error( "[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead." );
		        return this.open( tileSource );
		    },

		    //deprecated
		    get buttons () {
		        $.console.warn('Viewer.buttons is deprecated; Please use Viewer.buttonGroup');
		        return this.buttonGroup;
		    },

		    /**
		     * Open tiled images into the viewer, closing any others.
		     * To get the TiledImage instance created by open, add an event listener for
		     * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
		     * to the instance, i.e., viewer.world.getItemAt(0).
		     * @function
		     * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
		     * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
		     * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
		     * except for the index property; images are added in sequence.
		     * A TileSource specifier is anything you could pass as the tileSource property
		     * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
		     * @param {Number} initialPage - If sequenceMode is true, display this page initially
		     * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:open
		     * @fires OpenSeadragon.Viewer.event:open-failed
		     */
		    open: function (tileSources, initialPage) {
		        var _this = this;

		        this.close();

		        if (!tileSources) {
		            return this;
		        }

		        if (this.sequenceMode && $.isArray(tileSources)) {
		            if (this.referenceStrip) {
		                this.referenceStrip.destroy();
		                this.referenceStrip = null;
		            }

		            if (typeof initialPage !== 'undefined' && !isNaN(initialPage)) {
		              this.initialPage = initialPage;
		            }

		            this.tileSources = tileSources;
		            this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
		            if (this.tileSources.length) {
		                this.open(this.tileSources[this._sequenceIndex]);

		                if ( this.showReferenceStrip ){
		                    this.addReferenceStrip();
		                }
		            }

		            this._updateSequenceButtons( this._sequenceIndex );
		            return this;
		        }

		        if (!$.isArray(tileSources)) {
		            tileSources = [tileSources];
		        }

		        if (!tileSources.length) {
		            return this;
		        }

		        this._opening = true;

		        var expected = tileSources.length;
		        var successes = 0;
		        var failures = 0;
		        var failEvent;

		        var checkCompletion = function() {
		            if (successes + failures === expected) {
		                if (successes) {
		                    if (_this._firstOpen || !_this.preserveViewport) {
		                        _this.viewport.goHome( true );
		                        _this.viewport.update();
		                    }

		                    _this._firstOpen = false;

		                    var source = tileSources[0];
		                    if (source.tileSource) {
		                        source = source.tileSource;
		                    }

		                    // Global overlays
		                    if( _this.overlays && !_this.preserveOverlays ){
		                        for ( var i = 0; i < _this.overlays.length; i++ ) {
		                            _this.currentOverlays[ i ] = getOverlayObject( _this, _this.overlays[ i ] );
		                        }
		                    }

		                    _this._drawOverlays();
		                    _this._opening = false;

		                    /**
		                     * Raised when the viewer has opened and loaded one or more TileSources.
		                     *
		                     * @event open
		                     * @memberof OpenSeadragon.Viewer
		                     * @type {object}
		                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		                     * @property {OpenSeadragon.TileSource} source - The tile source that was opened.
		                     * @property {?Object} userData - Arbitrary subscriber-defined object.
		                     */
		                    // TODO: what if there are multiple sources?
		                    _this.raiseEvent( 'open', { source: source } );
		                } else {
		                    _this._opening = false;

		                    /**
		                     * Raised when an error occurs loading a TileSource.
		                     *
		                     * @event open-failed
		                     * @memberof OpenSeadragon.Viewer
		                     * @type {object}
		                     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		                     * @property {String} message - Information about what failed.
		                     * @property {String} source - The tile source that failed.
		                     * @property {?Object} userData - Arbitrary subscriber-defined object.
		                     */
		                    _this.raiseEvent( 'open-failed', failEvent );
		                }
		            }
		        };

		        var doOne = function(options) {
		            if (!$.isPlainObject(options) || !options.tileSource) {
		                options = {
		                    tileSource: options
		                };
		            }

		            if (options.index !== undefined) {
		                $.console.error('[Viewer.open] setting indexes here is not supported; use addTiledImage instead');
		                delete options.index;
		            }

		            if (options.collectionImmediately === undefined) {
		                options.collectionImmediately = true;
		            }

		            var originalSuccess = options.success;
		            options.success = function(event) {
		                successes++;

		                // TODO: now that options has other things besides tileSource, the overlays
		                // should probably be at the options level, not the tileSource level.
		                if (options.tileSource.overlays) {
		                    for (var i = 0; i < options.tileSource.overlays.length; i++) {
		                        _this.addOverlay(options.tileSource.overlays[i]);
		                    }
		                }

		                if (originalSuccess) {
		                    originalSuccess(event);
		                }

		                checkCompletion();
		            };

		            var originalError = options.error;
		            options.error = function(event) {
		                failures++;

		                if (!failEvent) {
		                    failEvent = event;
		                }

		                if (originalError) {
		                    originalError(event);
		                }

		                checkCompletion();
		            };

		            _this.addTiledImage(options);
		        };

		        // TileSources
		        for (var i = 0; i < tileSources.length; i++) {
		            doOne(tileSources[i]);
		        }

		        return this;
		    },


		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:close
		     */
		    close: function ( ) {
		        if ( !THIS[ this.hash ] ) {
		            //this viewer has already been destroyed: returning immediately
		            return this;
		        }

		        this._opening = false;

		        if ( this.navigator ) {
		            this.navigator.close();
		        }

		        if (!this.preserveOverlays) {
		            this.clearOverlays();
		            this.overlaysContainer.innerHTML = "";
		        }

		        THIS[ this.hash ].animating = false;

		        this.world.removeAll();
		        this.imageLoader.clear();

		        /**
		         * Raised when the viewer is closed (see {@link OpenSeadragon.Viewer#close}).
		         *
		         * @event close
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'close' );

		        return this;
		    },


		    /**
		     * Function to destroy the viewer and clean up everything created by OpenSeadragon.
		     *
		     * Example:
		     * var viewer = OpenSeadragon({
		     *   [...]
		     * });
		     *
		     * //when you are done with the viewer:
		     * viewer.destroy();
		     * viewer = null; //important
		     *
		     * @function
		     * @fires OpenSeadragon.Viewer.event:before-destroy
		     * @fires OpenSeadragon.Viewer.event:destroy
		     */
		    destroy: function( ) {
		        if ( !THIS[ this.hash ] ) {
		            //this viewer has already been destroyed: returning immediately
		            return;
		        }

		        /**
		         * Raised when the viewer is about to be destroyed (see {@link OpenSeadragon.Viewer#before-destroy}).
		         *
		         * @event before-destroy
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'before-destroy' );

		        this._removeUpdatePixelDensityRatioEvent();

		        this.close();

		        this.clearOverlays();
		        this.overlaysContainer.innerHTML = "";

		        //TODO: implement this...
		        //this.unbindSequenceControls()
		        //this.unbindStandardControls()
		        if (this._resizeObserver){
		            this._resizeObserver.disconnect();
		        }

		        if (this.referenceStrip) {
		            this.referenceStrip.destroy();
		            this.referenceStrip = null;
		        }

		        if ( this._updateRequestId !== null ) {
		            $.cancelAnimationFrame( this._updateRequestId );
		            this._updateRequestId = null;
		        }

		        if ( this.drawer ) {
		            this.drawer.destroy();
		        }

		        if ( this.navigator ) {
		            this.navigator.destroy();
		            THIS[ this.navigator.hash ] = null;
		            delete THIS[ this.navigator.hash ];
		            this.navigator = null;
		        }


		        if (this.buttonGroup) {
		            this.buttonGroup.destroy();
		        } else if (this.customButtons) {
		            while (this.customButtons.length) {
		                this.customButtons.pop().destroy();
		            }
		        }

		        if (this.paging) {
		            this.paging.destroy();
		        }

		        // Go through top element (passed to us) and remove all children
		        // Use removeChild to make sure it handles SVG or any non-html
		        // also it performs better - http://jsperf.com/innerhtml-vs-removechild/15
		        if (this.element){
		            while (this.element.firstChild) {
		                this.element.removeChild(this.element.firstChild);
		            }
		        }

		        this.container.onsubmit = null;
		        this.clearControls();

		        // destroy the mouse trackers
		        if (this.innerTracker){
		            this.innerTracker.destroy();
		        }
		        if (this.outerTracker){
		            this.outerTracker.destroy();
		        }

		        THIS[ this.hash ] = null;
		        delete THIS[ this.hash ];

		        // clear all our references to dom objects
		        this.canvas = null;
		        this.container = null;

		        // Unregister the viewer
		        $._viewers.delete(this.element);

		        // clear our reference to the main element - they will need to pass it in again, creating a new viewer
		        this.element = null;

		        /**
		         * Raised when the viewer is destroyed (see {@link OpenSeadragon.Viewer#destroy}).
		         *
		         * @event destroy
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'destroy' );

		        this.removeAllHandlers();
		    },

		    /**
		     * Request a drawer for this viewer, as a supported string or drawer constructor.
		     * @param {String | OpenSeadragon.DrawerBase} drawerCandidate The type of drawer to try to construct.
		     * @param { Object } options
		     * @param { Boolean } [options.mainDrawer] Whether to use this as the viewer's main drawer. Default = true.
		     * @param { Boolean } [options.redrawImmediately] Whether to immediately draw a new frame. Only used if options.mainDrawer = true. Default = true.
		     * @param { Object } [options.drawerOptions] Options for this drawer. Defaults to viewer.drawerOptions.
		     * for this viewer type. See {@link OpenSeadragon.Options}.
		     * @returns {Object | Boolean} The drawer that was created, or false if the requested drawer is not supported
		     */
		    requestDrawer(drawerCandidate, options){
		        const defaultOpts = {
		            mainDrawer: true,
		            redrawImmediately: true,
		            drawerOptions: null
		        };
		        options = $.extend(true, defaultOpts, options);
		        const mainDrawer = options.mainDrawer;
		        const redrawImmediately = options.redrawImmediately;
		        const drawerOptions = options.drawerOptions;

		        const oldDrawer = this.drawer;

		        let Drawer = null;

		        //if the candidate inherits from a drawer base, use it
		        if (drawerCandidate && drawerCandidate.prototype instanceof $.DrawerBase) {
		            Drawer = drawerCandidate;
		            drawerCandidate = 'custom';
		        } else if (typeof drawerCandidate === "string") {
		            Drawer = $.determineDrawer(drawerCandidate);
		        }

		        if(!Drawer){
		            $.console.warn('Unsupported drawer! Drawer must be an existing string type, or a class that extends OpenSeadragon.DrawerBase.');
		        }

		        // if the drawer is supported, create it and return true
		        if (Drawer && Drawer.isSupported()) {

		            // first destroy the previous drawer
		            if(oldDrawer && mainDrawer){
		                oldDrawer.destroy();
		            }

		            // create the new drawer
		            const newDrawer = new Drawer({
		                viewer:             this,
		                viewport:           this.viewport,
		                element:            this.canvas,
		                debugGridColor:     this.debugGridColor,
		                options:            drawerOptions || this.drawerOptions[drawerCandidate],
		            });

		            if(mainDrawer){
		                this.drawer = newDrawer;
		                if(redrawImmediately){
		                    this.forceRedraw();
		                }
		            }

		            return newDrawer;
		        }

		        return false;
		    },

		    /**
		     * @function
		     * @returns {Boolean}
		     */
		    isMouseNavEnabled: function () {
		        return this.innerTracker.isTracking();
		    },

		    /**
		     * @function
		     * @param {Boolean} enabled - true to enable, false to disable
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:mouse-enabled
		     */
		    setMouseNavEnabled: function( enabled ){
		        this.innerTracker.setTracking( enabled );
		        this.outerTracker.setTracking( enabled );
		        /**
		         * Raised when mouse/touch navigation is enabled or disabled (see {@link OpenSeadragon.Viewer#setMouseNavEnabled}).
		         *
		         * @event mouse-enabled
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} enabled
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'mouse-enabled', { enabled: enabled } );
		        return this;
		    },


		    /**
		     * @function
		     * @returns {Boolean}
		     */
		    areControlsEnabled: function () {
		        var enabled = this.controls.length,
		            i;
		        for( i = 0; i < this.controls.length; i++ ){
		            enabled = enabled && this.controls[ i ].isVisible();
		        }
		        return enabled;
		    },


		    /**
		     * Shows or hides the controls (e.g. the default navigation buttons).
		     *
		     * @function
		     * @param {Boolean} true to show, false to hide.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:controls-enabled
		     */
		    setControlsEnabled: function( enabled ) {
		        if( enabled ){
		            abortControlsAutoHide( this );
		        } else {
		            beginControlsAutoHide( this );
		        }
		        /**
		         * Raised when the navigation controls are shown or hidden (see {@link OpenSeadragon.Viewer#setControlsEnabled}).
		         *
		         * @event controls-enabled
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} enabled
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'controls-enabled', { enabled: enabled } );
		        return this;
		    },

		    /**
		     * Turns debugging mode on or off for this viewer.
		     *
		     * @function
		     * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
		     */
		    setDebugMode: function(debugMode){

		        for (var i = 0; i < this.world.getItemCount(); i++) {
		            this.world.getItemAt(i).debugMode = debugMode;
		        }

		        this.debugMode = debugMode;
		        this.forceRedraw();
		    },

		    /**
		     * Update headers to include when making AJAX requests.
		     *
		     * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
		     * the updated headers are propagated to all tiled images, each of which will subsequently
		     * propagate the changed headers to all their tiles.
		     * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
		     *
		     * Note that the rules for merging headers still apply, i.e. headers returned by
		     * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
		     * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
		     *
		     * @function
		     * @param {Object} ajaxHeaders Updated AJAX headers.
		     * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
		     */
		    setAjaxHeaders: function(ajaxHeaders, propagate) {
		        if (ajaxHeaders === null) {
		            ajaxHeaders = {};
		        }
		        if (!$.isPlainObject(ajaxHeaders)) {
		            console.error('[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object');
		            return;
		        }
		        if (propagate === undefined) {
		            propagate = true;
		        }

		        this.ajaxHeaders = ajaxHeaders;

		        if (propagate) {
		            for (var i = 0; i < this.world.getItemCount(); i++) {
		                this.world.getItemAt(i)._updateAjaxHeaders(true);
		            }

		            if (this.navigator) {
		                this.navigator.setAjaxHeaders(this.ajaxHeaders, true);
		            }

		            if (this.referenceStrip && this.referenceStrip.miniViewers) {
		                for (var key in this.referenceStrip.miniViewers) {
		                    this.referenceStrip.miniViewers[key].setAjaxHeaders(this.ajaxHeaders, true);
		                }
		            }
		        }
		    },

		    /**
		     * Adds the given button to this viewer.
		     *
		     * @function
		     * @param {OpenSeadragon.Button} button
		     */
		    addButton: function( button ){
		        this.buttonGroup.addButton(button);
		    },

		    /**
		     * @function
		     * @returns {Boolean}
		     */
		    isFullPage: function () {
		        return THIS[this.hash] && THIS[ this.hash ].fullPage;
		    },


		    /**
		     * Toggle full page mode.
		     * @function
		     * @param {Boolean} fullPage
		     *      If true, enter full page mode.  If false, exit full page mode.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:pre-full-page
		     * @fires OpenSeadragon.Viewer.event:full-page
		     */
		    setFullPage: function( fullPage ) {

		        var body = document.body,
		            bodyStyle = body.style,
		            docStyle = document.documentElement.style,
		            _this = this,
		            nodes,
		            i;

		        //don't bother modifying the DOM if we are already in full page mode.
		        if ( fullPage === this.isFullPage() ) {
		            return this;
		        }

		        var fullPageEventArgs = {
		            fullPage: fullPage,
		            preventDefaultAction: false
		        };
		        /**
		         * Raised when the viewer is about to change to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
		         *
		         * @event pre-full-page
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} fullPage - True if entering full-page mode, false if exiting full-page mode.
		         * @property {Boolean} preventDefaultAction - Set to true to prevent full-page mode change. Default: false.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'pre-full-page', fullPageEventArgs );
		        if ( fullPageEventArgs.preventDefaultAction ) {
		            return this;
		        }

		        if ( fullPage && this.element ) {

		            this.elementSize = $.getElementSize( this.element );
		            this.pageScroll = $.getPageScroll();

		            this.elementMargin = this.element.style.margin;
		            this.element.style.margin = "0";
		            this.elementPadding = this.element.style.padding;
		            this.element.style.padding = "0";

		            this.bodyMargin = bodyStyle.margin;
		            this.docMargin = docStyle.margin;
		            bodyStyle.margin = "0";
		            docStyle.margin = "0";

		            this.bodyPadding = bodyStyle.padding;
		            this.docPadding = docStyle.padding;
		            bodyStyle.padding = "0";
		            docStyle.padding = "0";

		            this.bodyWidth = bodyStyle.width;
		            this.docWidth = docStyle.width;
		            bodyStyle.width = "100%";
		            docStyle.width = "100%";

		            this.bodyHeight = bodyStyle.height;
		            this.docHeight = docStyle.height;
		            bodyStyle.height = "100%";
		            docStyle.height = "100%";

		            this.bodyDisplay = bodyStyle.display;
		            bodyStyle.display = "block";

		            //when entering full screen on the ipad it wasn't sufficient to leave
		            //the body intact as only only the top half of the screen would
		            //respond to touch events on the canvas, while the bottom half treated
		            //them as touch events on the document body.  Thus we remove and store
		            //the bodies elements and replace them when we leave full screen.
		            this.previousBody = [];
		            THIS[ this.hash ].prevElementParent = this.element.parentNode;
		            THIS[ this.hash ].prevNextSibling = this.element.nextSibling;
		            THIS[ this.hash ].prevElementWidth = this.element.style.width;
		            THIS[ this.hash ].prevElementHeight = this.element.style.height;
		            nodes = body.childNodes.length;
		            for ( i = 0; i < nodes; i++ ) {
		                this.previousBody.push( body.childNodes[ 0 ] );
		                body.removeChild( body.childNodes[ 0 ] );
		            }

		            //If we've got a toolbar, we need to enable the user to use css to
		            //preserve it in fullpage mode
		            if ( this.toolbar && this.toolbar.element ) {
		                //save a reference to the parent so we can put it back
		                //in the long run we need a better strategy
		                this.toolbar.parentNode = this.toolbar.element.parentNode;
		                this.toolbar.nextSibling = this.toolbar.element.nextSibling;
		                body.appendChild( this.toolbar.element );

		                //Make sure the user has some ability to style the toolbar based
		                //on the mode
		                $.addClass( this.toolbar.element, 'fullpage' );
		            }

		            $.addClass( this.element, 'fullpage' );
		            body.appendChild( this.element );

		            this.element.style.height = '100vh';
		            this.element.style.width = '100vw';

		            if ( this.toolbar && this.toolbar.element ) {
		                this.element.style.height = (
		                    $.getElementSize( this.element ).y - $.getElementSize( this.toolbar.element ).y
		                ) + 'px';
		            }

		            THIS[ this.hash ].fullPage = true;

		            // mouse will be inside container now
		            $.delegate( this, onContainerEnter )( {} );

		        } else {

		            this.element.style.margin = this.elementMargin;
		            this.element.style.padding = this.elementPadding;

		            bodyStyle.margin = this.bodyMargin;
		            docStyle.margin = this.docMargin;

		            bodyStyle.padding = this.bodyPadding;
		            docStyle.padding = this.docPadding;

		            bodyStyle.width = this.bodyWidth;
		            docStyle.width = this.docWidth;

		            bodyStyle.height = this.bodyHeight;
		            docStyle.height = this.docHeight;

		            bodyStyle.display = this.bodyDisplay;

		            body.removeChild( this.element );
		            nodes = this.previousBody.length;
		            for ( i = 0; i < nodes; i++ ) {
		                body.appendChild( this.previousBody.shift() );
		            }

		            $.removeClass( this.element, 'fullpage' );
		            THIS[ this.hash ].prevElementParent.insertBefore(
		                this.element,
		                THIS[ this.hash ].prevNextSibling
		            );

		            //If we've got a toolbar, we need to enable the user to use css to
		            //reset it to its original state
		            if ( this.toolbar && this.toolbar.element ) {
		                body.removeChild( this.toolbar.element );

		                //Make sure the user has some ability to style the toolbar based
		                //on the mode
		                $.removeClass( this.toolbar.element, 'fullpage' );

		                this.toolbar.parentNode.insertBefore(
		                    this.toolbar.element,
		                    this.toolbar.nextSibling
		                );
		                delete this.toolbar.parentNode;
		                delete this.toolbar.nextSibling;
		            }

		            this.element.style.width = THIS[ this.hash ].prevElementWidth;
		            this.element.style.height = THIS[ this.hash ].prevElementHeight;

		            // After exiting fullPage or fullScreen, it can take some time
		            // before the browser can actually set the scroll.
		            var restoreScrollCounter = 0;
		            var restoreScroll = function() {
		                $.setPageScroll( _this.pageScroll );
		                var pageScroll = $.getPageScroll();
		                restoreScrollCounter++;
		                if (restoreScrollCounter < 10 &&
		                    (pageScroll.x !== _this.pageScroll.x ||
		                    pageScroll.y !== _this.pageScroll.y)) {
		                    $.requestAnimationFrame( restoreScroll );
		                }
		            };
		            $.requestAnimationFrame( restoreScroll );

		            THIS[ this.hash ].fullPage = false;

		            // mouse will likely be outside now
		            $.delegate( this, onContainerLeave )( { } );

		        }

		        if ( this.navigator && this.viewport ) {
		            this.navigator.update( this.viewport );
		        }

		        /**
		         * Raised when the viewer has changed to/from full-page mode (see {@link OpenSeadragon.Viewer#setFullPage}).
		         *
		         * @event full-page
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} fullPage - True if changed to full-page mode, false if exited full-page mode.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'full-page', { fullPage: fullPage } );

		        return this;
		    },

		    /**
		     * Toggle full screen mode if supported. Toggle full page mode otherwise.
		     * @function
		     * @param {Boolean} fullScreen
		     *      If true, enter full screen mode.  If false, exit full screen mode.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:pre-full-screen
		     * @fires OpenSeadragon.Viewer.event:full-screen
		     */
		    setFullScreen: function( fullScreen ) {
		        var _this = this;

		        if ( !$.supportsFullScreen ) {
		            return this.setFullPage( fullScreen );
		        }

		        if ( $.isFullScreen() === fullScreen ) {
		            return this;
		        }

		        var fullScreeEventArgs = {
		            fullScreen: fullScreen,
		            preventDefaultAction: false
		        };
		        /**
		         * Raised when the viewer is about to change to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
		         * Note: the pre-full-screen event is not raised when the user is exiting
		         * full-screen mode by pressing the Esc key. In that case, consider using
		         * the full-screen, pre-full-page or full-page events.
		         *
		         * @event pre-full-screen
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} fullScreen - True if entering full-screen mode, false if exiting full-screen mode.
		         * @property {Boolean} preventDefaultAction - Set to true to prevent full-screen mode change. Default: false.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'pre-full-screen', fullScreeEventArgs );
		        if ( fullScreeEventArgs.preventDefaultAction ) {
		            return this;
		        }

		        if ( fullScreen ) {

		            this.setFullPage( true );
		            // If the full page mode is not actually entered, we need to prevent
		            // the full screen mode.
		            if ( !this.isFullPage() ) {
		                return this;
		            }

		            this.fullPageStyleWidth = this.element.style.width;
		            this.fullPageStyleHeight = this.element.style.height;
		            this.element.style.width = '100%';
		            this.element.style.height = '100%';

		            var onFullScreenChange = function() {
		                var isFullScreen = $.isFullScreen();
		                if ( !isFullScreen ) {
		                    $.removeEvent( document, $.fullScreenEventName, onFullScreenChange );
		                    $.removeEvent( document, $.fullScreenErrorEventName, onFullScreenChange );

		                    _this.setFullPage( false );
		                    if ( _this.isFullPage() ) {
		                        _this.element.style.width = _this.fullPageStyleWidth;
		                        _this.element.style.height = _this.fullPageStyleHeight;
		                    }
		                }
		                if ( _this.navigator && _this.viewport ) {
		                    //09/08/2018 - Fabroh : Fix issue #1504 : Ensure to get the navigator updated on fullscreen out with custom location with a timeout
		                    setTimeout(function(){
		                        _this.navigator.update( _this.viewport );
		                    });
		                }
		                /**
		                 * Raised when the viewer has changed to/from full-screen mode (see {@link OpenSeadragon.Viewer#setFullScreen}).
		                 *
		                 * @event full-screen
		                 * @memberof OpenSeadragon.Viewer
		                 * @type {object}
		                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		                 * @property {Boolean} fullScreen - True if changed to full-screen mode, false if exited full-screen mode.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( 'full-screen', { fullScreen: isFullScreen } );
		            };
		            $.addEvent( document, $.fullScreenEventName, onFullScreenChange );
		            $.addEvent( document, $.fullScreenErrorEventName, onFullScreenChange );

		            $.requestFullScreen( document.body );

		        } else {
		            $.exitFullScreen();
		        }
		        return this;
		    },

		    /**
		     * @function
		     * @returns {Boolean}
		     */
		    isVisible: function () {
		        return this.container.style.visibility !== "hidden";
		    },


		    //
		    /**
		     * @function
		     * @returns {Boolean} returns true if the viewer is in fullscreen
		     */
		     isFullScreen: function () {
		        return $.isFullScreen() && this.isFullPage();
		    },

		    /**
		     * @function
		     * @param {Boolean} visible
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:visible
		     */
		    setVisible: function( visible ){
		        this.container.style.visibility = visible ? "" : "hidden";
		        /**
		         * Raised when the viewer is shown or hidden (see {@link OpenSeadragon.Viewer#setVisible}).
		         *
		         * @event visible
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Boolean} visible
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'visible', { visible: visible } );
		        return this;
		    },

		    /**
		     * Add a tiled image to the viewer.
		     * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
		     *  supports except arrays of images.
		     * Note that you can specify options.width or options.height, but not both.
		     * The other dimension will be calculated according to the item's aspect ratio.
		     * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
		     * automatically arranged with the others.
		     * @function
		     * @param {Object} options
		     * @param {String|Object|Function} options.tileSource - The TileSource specifier.
		     * A String implies a url used to determine the tileSource implementation
		     *      based on the file extension of url. JSONP is implied by *.js,
		     *      otherwise the url is retrieved as text and the resulting text is
		     *      introspected to determine if its json, xml, or text and parsed.
		     * An Object implies an inline configuration which has a single
		     *      property sufficient for being able to determine tileSource
		     *      implementation. If the object has a property which is a function
		     *      named 'getTileUrl', it is treated as a custom TileSource.
		     * @param {Number} [options.index] The index of the item. Added on top of
		     * all other items if not specified.
		     * @param {Boolean} [options.replace=false] If true, the item at options.index will be
		     * removed and the new item is added in its place. options.tileSource will be
		     * interpreted and fetched if necessary before the old item is removed to avoid leaving
		     * a gap in the world.
		     * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
		     * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
		     * @param {Number} [options.width=1] The width for the image in viewport coordinates.
		     * @param {Number} [options.height] The height for the image in viewport coordinates.
		     * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
		     * to fit the image into. If specified, x, y, width and height get ignored.
		     * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
		     * How to anchor the image in the bounds if options.fitBounds is set.
		     * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
		     * (portions of the image outside of this area will not be visible). Only works on
		     * browsers that support the HTML5 canvas.
		     * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
		     * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
		     * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
		     * its top left corner in degrees.
		     * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
		     * @param {String} [options.compositeOperation] How the image is composited onto other images.
		     * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
		     * overriding viewer.crossOriginPolicy.
		     * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
		     * @param {Boolean} [options.loadTilesWithAjax]
		     *      Whether to load tile data using AJAX requests.
		     *      Defaults to the setting in {@link OpenSeadragon.Options}.
		     * @param {Object} [options.ajaxHeaders]
		     *      A set of headers to include when making tile AJAX requests.
		     *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
		     *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
		     * @param {Function} [options.success] A function that gets called when the image is
		     * successfully added. It's passed the event object which contains a single property:
		     * "item", which is the resulting instance of TiledImage.
		     * @param {Function} [options.error] A function that gets called if the image is
		     * unable to be added. It's passed the error event object, which contains "message"
		     * and "source" properties.
		     * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
		     * specifies whether to snap to the new arrangement immediately or to animate to it.
		     * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
		     * @fires OpenSeadragon.World.event:add-item
		     * @fires OpenSeadragon.Viewer.event:add-item-failed
		     */
		    addTiledImage: function( options ) {
		        $.console.assert(options, "[Viewer.addTiledImage] options is required");
		        $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
		        $.console.assert(!options.replace || (options.index > -1 && options.index < this.world.getItemCount()),
		            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world");

		        var _this = this;

		        if (options.replace) {
		            options.replaceItem = _this.world.getItemAt(options.index);
		        }

		        this._hideMessage();

		        if (options.placeholderFillStyle === undefined) {
		            options.placeholderFillStyle = this.placeholderFillStyle;
		        }
		        if (options.opacity === undefined) {
		            options.opacity = this.opacity;
		        }
		        if (options.preload === undefined) {
		            options.preload = this.preload;
		        }
		        if (options.compositeOperation === undefined) {
		            options.compositeOperation = this.compositeOperation;
		        }
		        if (options.crossOriginPolicy === undefined) {
		            options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== undefined ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
		        }
		        if (options.ajaxWithCredentials === undefined) {
		            options.ajaxWithCredentials = this.ajaxWithCredentials;
		        }
		        if (options.loadTilesWithAjax === undefined) {
		            options.loadTilesWithAjax = this.loadTilesWithAjax;
		        }
		        if (!$.isPlainObject(options.ajaxHeaders)) {
		            options.ajaxHeaders = {};
		        }

		        var myQueueItem = {
		            options: options
		        };

		        function raiseAddItemFailed( event ) {
		            for (var i = 0; i < _this._loadQueue.length; i++) {
		                if (_this._loadQueue[i] === myQueueItem) {
		                    _this._loadQueue.splice(i, 1);
		                    break;
		                }
		            }

		            if (_this._loadQueue.length === 0) {
		                refreshWorld(myQueueItem);
		            }

		             /**
		             * Raised when an error occurs while adding a item.
		             * @event add-item-failed
		             * @memberOf OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		             * @property {String} message
		             * @property {String} source
		             * @property {Object} options The options passed to the addTiledImage method.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            _this.raiseEvent( 'add-item-failed', event );

		            if (options.error) {
		                options.error(event);
		            }
		        }

		        function refreshWorld(theItem) {
		            if (_this.collectionMode) {
		                _this.world.arrange({
		                    immediately: theItem.options.collectionImmediately,
		                    rows: _this.collectionRows,
		                    columns: _this.collectionColumns,
		                    layout: _this.collectionLayout,
		                    tileSize: _this.collectionTileSize,
		                    tileMargin: _this.collectionTileMargin
		                });
		                _this.world.setAutoRefigureSizes(true);
		            }
		        }

		        if ($.isArray(options.tileSource)) {
		            setTimeout(function() {
		                raiseAddItemFailed({
		                    message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
		                    source: options.tileSource,
		                    options: options
		                });
		            });
		            return;
		        }

		        this._loadQueue.push(myQueueItem);

		        function processReadyItems() {
		            var queueItem, tiledImage, optionsClone;
		            while (_this._loadQueue.length) {
		                queueItem = _this._loadQueue[0];
		                if (!queueItem.tileSource) {
		                    break;
		                }

		                _this._loadQueue.splice(0, 1);

		                if (queueItem.options.replace) {
		                    var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
		                    if (newIndex !== -1) {
		                        queueItem.options.index = newIndex;
		                    }
		                    _this.world.removeItem(queueItem.options.replaceItem);
		                }

		                tiledImage = new $.TiledImage({
		                    viewer: _this,
		                    source: queueItem.tileSource,
		                    viewport: _this.viewport,
		                    drawer: _this.drawer,
		                    tileCache: _this.tileCache,
		                    imageLoader: _this.imageLoader,
		                    x: queueItem.options.x,
		                    y: queueItem.options.y,
		                    width: queueItem.options.width,
		                    height: queueItem.options.height,
		                    fitBounds: queueItem.options.fitBounds,
		                    fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
		                    clip: queueItem.options.clip,
		                    placeholderFillStyle: queueItem.options.placeholderFillStyle,
		                    opacity: queueItem.options.opacity,
		                    preload: queueItem.options.preload,
		                    degrees: queueItem.options.degrees,
		                    flipped: queueItem.options.flipped,
		                    compositeOperation: queueItem.options.compositeOperation,
		                    springStiffness: _this.springStiffness,
		                    animationTime: _this.animationTime,
		                    minZoomImageRatio: _this.minZoomImageRatio,
		                    wrapHorizontal: _this.wrapHorizontal,
		                    wrapVertical: _this.wrapVertical,
		                    maxTilesPerFrame: _this.maxTilesPerFrame,
		                    immediateRender: _this.immediateRender,
		                    blendTime: _this.blendTime,
		                    alwaysBlend: _this.alwaysBlend,
		                    minPixelRatio: _this.minPixelRatio,
		                    smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
		                    iOSDevice: _this.iOSDevice,
		                    crossOriginPolicy: queueItem.options.crossOriginPolicy,
		                    ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
		                    loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
		                    ajaxHeaders: queueItem.options.ajaxHeaders,
		                    debugMode: _this.debugMode,
		                    subPixelRoundingForTransparency: _this.subPixelRoundingForTransparency
		                });

		                if (_this.collectionMode) {
		                    _this.world.setAutoRefigureSizes(false);
		                }

		                if (_this.navigator) {
		                    optionsClone = $.extend({}, queueItem.options, {
		                        replace: false, // navigator already removed the layer, nothing to replace
		                        originalTiledImage: tiledImage,
		                        tileSource: queueItem.tileSource
		                    });

		                    _this.navigator.addTiledImage(optionsClone);
		                }

		                _this.world.addItem( tiledImage, {
		                    index: queueItem.options.index
		                });

		                if (_this._loadQueue.length === 0) {
		                    //this restores the autoRefigureSizes flag to true.
		                    refreshWorld(queueItem);
		                }

		                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
		                    _this.viewport.goHome(true);
		                }

		                if (queueItem.options.success) {
		                    queueItem.options.success({
		                        item: tiledImage
		                    });
		                }
		            }
		        }

		        getTileSourceImplementation( this, options.tileSource, options, function( tileSource ) {

		            myQueueItem.tileSource = tileSource;

		            // add everybody at the front of the queue that's ready to go
		            processReadyItems();
		        }, function( event ) {
		            event.options = options;
		            raiseAddItemFailed(event);

		            // add everybody at the front of the queue that's ready to go
		            processReadyItems();
		        } );
		    },

		    /**
		     * Add a simple image to the viewer.
		     * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
		     * except for options.tileSource which is replaced by options.url.
		     * @function
		     * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
		     * for all the options
		     * @param {String} options.url - The URL of the image to add.
		     * @fires OpenSeadragon.World.event:add-item
		     * @fires OpenSeadragon.Viewer.event:add-item-failed
		     */
		    addSimpleImage: function(options) {
		        $.console.assert(options, "[Viewer.addSimpleImage] options is required");
		        $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");

		        var opts = $.extend({}, options, {
		            tileSource: {
		                type: 'image',
		                url:  options.url
		            }
		        });
		        delete opts.url;
		        this.addTiledImage(opts);
		    },

		    // deprecated
		    addLayer: function( options ) {
		        var _this = this;

		        $.console.error( "[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead." );

		        var optionsClone = $.extend({}, options, {
		            success: function(event) {
		                _this.raiseEvent("add-layer", {
		                    options: options,
		                    drawer: event.item
		                });
		            },
		            error: function(event) {
		                _this.raiseEvent("add-layer-failed", event);
		            }
		        });

		        this.addTiledImage(optionsClone);
		        return this;
		    },

		    // deprecated
		    getLayerAtLevel: function( level ) {
		        $.console.error( "[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead." );
		        return this.world.getItemAt(level);
		    },

		    // deprecated
		    getLevelOfLayer: function( drawer ) {
		        $.console.error( "[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead." );
		        return this.world.getIndexOfItem(drawer);
		    },

		    // deprecated
		    getLayersCount: function() {
		        $.console.error( "[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead." );
		        return this.world.getItemCount();
		    },

		    // deprecated
		    setLayerLevel: function( drawer, level ) {
		        $.console.error( "[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead." );
		        return this.world.setItemIndex(drawer, level);
		    },

		    // deprecated
		    removeLayer: function( drawer ) {
		        $.console.error( "[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead." );
		        return this.world.removeItem(drawer);
		    },

		    /**
		     * Force the viewer to redraw its contents.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     */
		    forceRedraw: function() {
		        THIS[ this.hash ].forceRedraw = true;
		        return this;
		    },

		    /**
		     * Force the viewer to reset its size to match its container.
		     */
		    forceResize: function() {
		        THIS[this.hash].needsResize = true;
		        THIS[this.hash].forceResize = true;
		    },

		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     */
		    bindSequenceControls: function(){

		        //////////////////////////////////////////////////////////////////////////
		        // Image Sequence Controls
		        //////////////////////////////////////////////////////////////////////////
		        var onFocusHandler          = $.delegate( this, onFocus ),
		            onBlurHandler           = $.delegate( this, onBlur ),
		            onNextHandler           = $.delegate( this, this.goToNextPage ),
		            onPreviousHandler       = $.delegate( this, this.goToPreviousPage ),
		            navImages               = this.navImages,
		            useGroup                = true;

		        if( this.showSequenceControl ){

		            if( this.previousButton || this.nextButton ){
		                //if we are binding to custom buttons then layout and
		                //grouping is the responsibility of the page author
		                useGroup = false;
		            }

		            this.previousButton = new $.Button({
		                element:    this.previousButton ? $.getElement( this.previousButton ) : null,
		                clickTimeThreshold: this.clickTimeThreshold,
		                clickDistThreshold: this.clickDistThreshold,
		                tooltip:    $.getString( "Tooltips.PreviousPage" ),
		                srcRest:    resolveUrl( this.prefixUrl, navImages.previous.REST ),
		                srcGroup:   resolveUrl( this.prefixUrl, navImages.previous.GROUP ),
		                srcHover:   resolveUrl( this.prefixUrl, navImages.previous.HOVER ),
		                srcDown:    resolveUrl( this.prefixUrl, navImages.previous.DOWN ),
		                onRelease:  onPreviousHandler,
		                onFocus:    onFocusHandler,
		                onBlur:     onBlurHandler
		            });

		            this.nextButton = new $.Button({
		                element:    this.nextButton ? $.getElement( this.nextButton ) : null,
		                clickTimeThreshold: this.clickTimeThreshold,
		                clickDistThreshold: this.clickDistThreshold,
		                tooltip:    $.getString( "Tooltips.NextPage" ),
		                srcRest:    resolveUrl( this.prefixUrl, navImages.next.REST ),
		                srcGroup:   resolveUrl( this.prefixUrl, navImages.next.GROUP ),
		                srcHover:   resolveUrl( this.prefixUrl, navImages.next.HOVER ),
		                srcDown:    resolveUrl( this.prefixUrl, navImages.next.DOWN ),
		                onRelease:  onNextHandler,
		                onFocus:    onFocusHandler,
		                onBlur:     onBlurHandler
		            });

		            if( !this.navPrevNextWrap ){
		                this.previousButton.disable();
		            }

		            if (!this.tileSources || !this.tileSources.length) {
		                this.nextButton.disable();
		            }

		            if( useGroup ){
		                this.paging = new $.ButtonGroup({
		                    buttons: [
		                        this.previousButton,
		                        this.nextButton
		                    ],
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold
		                });

		                this.pagingControl = this.paging.element;

		                if( this.toolbar ){
		                    this.toolbar.addControl(
		                        this.pagingControl,
		                        {anchor: $.ControlAnchor.BOTTOM_RIGHT}
		                    );
		                }else {
		                    this.addControl(
		                        this.pagingControl,
		                        {anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT}
		                    );
		                }
		            }
		        }
		        return this;
		    },


		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     */
		    bindStandardControls: function(){
		        //////////////////////////////////////////////////////////////////////////
		        // Navigation Controls
		        //////////////////////////////////////////////////////////////////////////
		        var beginZoomingInHandler   = $.delegate( this, beginZoomingIn ),
		            endZoomingHandler       = $.delegate( this, endZooming ),
		            doSingleZoomInHandler   = $.delegate( this, doSingleZoomIn ),
		            beginZoomingOutHandler  = $.delegate( this, beginZoomingOut ),
		            doSingleZoomOutHandler  = $.delegate( this, doSingleZoomOut ),
		            onHomeHandler           = $.delegate( this, onHome ),
		            onFullScreenHandler     = $.delegate( this, onFullScreen ),
		            onRotateLeftHandler     = $.delegate( this, onRotateLeft ),
		            onRotateRightHandler    = $.delegate( this, onRotateRight ),
		            onFlipHandler           = $.delegate( this, onFlip),
		            onFocusHandler          = $.delegate( this, onFocus ),
		            onBlurHandler           = $.delegate( this, onBlur ),
		            navImages               = this.navImages,
		            buttons                 = [],
		            useGroup                = true;


		        if ( this.showNavigationControl ) {

		            if( this.zoomInButton || this.zoomOutButton ||
		                this.homeButton || this.fullPageButton ||
		                this.rotateLeftButton || this.rotateRightButton ||
		                this.flipButton ) {
		                //if we are binding to custom buttons then layout and
		                //grouping is the responsibility of the page author
		                useGroup = false;
		            }

		            if ( this.showZoomControl ) {
		                buttons.push( this.zoomInButton = new $.Button({
		                    element:    this.zoomInButton ? $.getElement( this.zoomInButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.ZoomIn" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomIn.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomIn.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomIn.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomIn.DOWN ),
		                    onPress:    beginZoomingInHandler,
		                    onRelease:  endZoomingHandler,
		                    onClick:    doSingleZoomInHandler,
		                    onEnter:    beginZoomingInHandler,
		                    onExit:     endZoomingHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));

		                buttons.push( this.zoomOutButton = new $.Button({
		                    element:    this.zoomOutButton ? $.getElement( this.zoomOutButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.ZoomOut" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.zoomOut.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.zoomOut.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.zoomOut.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.zoomOut.DOWN ),
		                    onPress:    beginZoomingOutHandler,
		                    onRelease:  endZoomingHandler,
		                    onClick:    doSingleZoomOutHandler,
		                    onEnter:    beginZoomingOutHandler,
		                    onExit:     endZoomingHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));
		            }

		            if ( this.showHomeControl ) {
		                buttons.push( this.homeButton = new $.Button({
		                    element:    this.homeButton ? $.getElement( this.homeButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.Home" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.home.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.home.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.home.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.home.DOWN ),
		                    onRelease:  onHomeHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));
		            }

		            if ( this.showFullPageControl ) {
		                buttons.push( this.fullPageButton = new $.Button({
		                    element:    this.fullPageButton ? $.getElement( this.fullPageButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.FullPage" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.fullpage.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.fullpage.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.fullpage.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.fullpage.DOWN ),
		                    onRelease:  onFullScreenHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));
		            }

		            if ( this.showRotationControl ) {
		                buttons.push( this.rotateLeftButton = new $.Button({
		                    element:    this.rotateLeftButton ? $.getElement( this.rotateLeftButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.RotateLeft" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateleft.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateleft.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateleft.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateleft.DOWN ),
		                    onRelease:  onRotateLeftHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));

		                buttons.push( this.rotateRightButton = new $.Button({
		                    element:    this.rotateRightButton ? $.getElement( this.rotateRightButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.RotateRight" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.rotateright.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.rotateright.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.rotateright.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.rotateright.DOWN ),
		                    onRelease:  onRotateRightHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));
		            }

		            if ( this.showFlipControl ) {
		                buttons.push( this.flipButton = new $.Button({
		                    element:    this.flipButton ? $.getElement( this.flipButton ) : null,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold,
		                    tooltip:    $.getString( "Tooltips.Flip" ),
		                    srcRest:    resolveUrl( this.prefixUrl, navImages.flip.REST ),
		                    srcGroup:   resolveUrl( this.prefixUrl, navImages.flip.GROUP ),
		                    srcHover:   resolveUrl( this.prefixUrl, navImages.flip.HOVER ),
		                    srcDown:    resolveUrl( this.prefixUrl, navImages.flip.DOWN ),
		                    onRelease:  onFlipHandler,
		                    onFocus:    onFocusHandler,
		                    onBlur:     onBlurHandler
		                }));
		            }

		            if ( useGroup ) {
		                this.buttonGroup = new $.ButtonGroup({
		                    buttons:            buttons,
		                    clickTimeThreshold: this.clickTimeThreshold,
		                    clickDistThreshold: this.clickDistThreshold
		                });

		                this.navControl  = this.buttonGroup.element;
		                this.addHandler( 'open', $.delegate( this, lightUp ) );

		                if( this.toolbar ){
		                    this.toolbar.addControl(
		                        this.navControl,
		                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
		                    );
		                } else {
		                    this.addControl(
		                        this.navControl,
		                        {anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT}
		                    );
		                }
		            } else {
		                this.customButtons = buttons;
		            }

		        }
		        return this;
		    },

		    /**
		     * Gets the active page of a sequence
		     * @function
		     * @returns {Number}
		     */
		    currentPage: function() {
		        return this._sequenceIndex;
		    },

		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:page
		     */
		    goToPage: function( page ){
		        if( this.tileSources && page >= 0 && page < this.tileSources.length ){
		            this._sequenceIndex = page;

		            this._updateSequenceButtons( page );

		            this.open( this.tileSources[ page ] );

		            if( this.referenceStrip ){
		                this.referenceStrip.setFocus( page );
		            }

		            /**
		             * Raised when the page is changed on a viewer configured with multiple image sources (see {@link OpenSeadragon.Viewer#goToPage}).
		             *
		             * @event page
		             * @memberof OpenSeadragon.Viewer
		             * @type {Object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		             * @property {Number} page - The page index.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.raiseEvent( 'page', { page: page } );
		        }

		        return this;
		    },

		   /**
		     * Adds an html element as an overlay to the current viewport.  Useful for
		     * highlighting words or areas of interest on an image or other zoomable
		     * interface. The overlays added via this method are removed when the viewport
		     * is closed which include when changing page.
		     * @method
		     * @param {Element|String|Object} element - A reference to an element or an id for
		     *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
		     *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
		     *      all available options.
		     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
		     *      rectangle which will be overlaid. This is a viewport relative location.
		     * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
		     *      viewport which the location coordinates will be treated as relative
		     *      to.
		     * @param {function} [onDraw] - If supplied the callback is called when the overlay
		     *      needs to be drawn. It is the responsibility of the callback to do any drawing/positioning.
		     *      It is passed position, size and element.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:add-overlay
		     */
		    addOverlay: function( element, location, placement, onDraw ) {
		        var options;
		        if( $.isPlainObject( element ) ){
		            options = element;
		        } else {
		            options = {
		                element: element,
		                location: location,
		                placement: placement,
		                onDraw: onDraw
		            };
		        }

		        element = $.getElement( options.element );

		        if ( getOverlayIndex( this.currentOverlays, element ) >= 0 ) {
		            // they're trying to add a duplicate overlay
		            return this;
		        }

		        var overlay = getOverlayObject( this, options);
		        this.currentOverlays.push(overlay);
		        overlay.drawHTML( this.overlaysContainer, this.viewport );

		        /**
		         * Raised when an overlay is added to the viewer (see {@link OpenSeadragon.Viewer#addOverlay}).
		         *
		         * @event add-overlay
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Element} element - The overlay element.
		         * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
		         * @property {OpenSeadragon.Placement} placement
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'add-overlay', {
		            element: element,
		            location: options.location,
		            placement: options.placement
		        });
		        return this;
		    },

		    /**
		     * Updates the overlay represented by the reference to the element or
		     * element id moving it to the new location, relative to the new placement.
		     * @method
		     * @param {Element|String} element - A reference to an element or an id for
		     *      the element which is overlaid.
		     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
		     *      rectangle which will be overlaid. This is a viewport relative location.
		     * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
		     *      viewport which the location coordinates will be treated as relative
		     *      to.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:update-overlay
		     */
		    updateOverlay: function( element, location, placement ) {
		        var i;

		        element = $.getElement( element );
		        i = getOverlayIndex( this.currentOverlays, element );

		        if ( i >= 0 ) {
		            this.currentOverlays[ i ].update( location, placement );
		            THIS[ this.hash ].forceRedraw = true;
		            /**
		             * Raised when an overlay's location or placement changes
		             * (see {@link OpenSeadragon.Viewer#updateOverlay}).
		             *
		             * @event update-overlay
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the
		             * Viewer which raised the event.
		             * @property {Element} element
		             * @property {OpenSeadragon.Point|OpenSeadragon.Rect} location
		             * @property {OpenSeadragon.Placement} placement
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.raiseEvent( 'update-overlay', {
		                element: element,
		                location: location,
		                placement: placement
		            });
		        }
		        return this;
		    },

		    /**
		     * Removes an overlay identified by the reference element or element id
		     * and schedules an update.
		     * @method
		     * @param {Element|String} element - A reference to the element or an
		     *      element id which represent the ovelay content to be removed.
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:remove-overlay
		     */
		    removeOverlay: function( element ) {
		        var i;

		        element = $.getElement( element );
		        i = getOverlayIndex( this.currentOverlays, element );

		        if ( i >= 0 ) {
		            this.currentOverlays[ i ].destroy();
		            this.currentOverlays.splice( i, 1 );
		            THIS[ this.hash ].forceRedraw = true;
		            /**
		             * Raised when an overlay is removed from the viewer
		             * (see {@link OpenSeadragon.Viewer#removeOverlay}).
		             *
		             * @event remove-overlay
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the
		             * Viewer which raised the event.
		             * @property {Element} element - The overlay element.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.raiseEvent( 'remove-overlay', {
		                element: element
		            });
		        }
		        return this;
		    },

		    /**
		     * Removes all currently configured Overlays from this Viewer and schedules
		     * an update.
		     * @method
		     * @returns {OpenSeadragon.Viewer} Chainable.
		     * @fires OpenSeadragon.Viewer.event:clear-overlay
		     */
		    clearOverlays: function() {
		        while ( this.currentOverlays.length > 0 ) {
		            this.currentOverlays.pop().destroy();
		        }
		        THIS[ this.hash ].forceRedraw = true;
		        /**
		         * Raised when all overlays are removed from the viewer (see {@link OpenSeadragon.Drawer#clearOverlays}).
		         *
		         * @event clear-overlay
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'clear-overlay', {} );
		        return this;
		    },

		     /**
		     * Finds an overlay identified by the reference element or element id
		     * and returns it as an object, return null if not found.
		     * @method
		     * @param {Element|String} element - A reference to the element or an
		     *      element id which represents the overlay content.
		     * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
		     */
		    getOverlayById: function( element ) {
		        var i;

		        element = $.getElement( element );
		        i = getOverlayIndex( this.currentOverlays, element );

		        if (i >= 0) {
		            return this.currentOverlays[i];
		        } else {
		            return null;
		        }
		    },

		    /**
		     * Updates the sequence buttons.
		     * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
		     * @private
		     * @param {Number} Sequence Value
		     */
		    _updateSequenceButtons: function( page ) {

		            if ( this.nextButton ) {
		                if(!this.tileSources || this.tileSources.length - 1 === page) {
		                    //Disable next button
		                    if ( !this.navPrevNextWrap ) {
		                        this.nextButton.disable();
		                    }
		                } else {
		                    this.nextButton.enable();
		                }
		            }
		            if ( this.previousButton ) {
		                if ( page > 0 ) {
		                    //Enable previous button
		                    this.previousButton.enable();
		                } else {
		                    if ( !this.navPrevNextWrap ) {
		                        this.previousButton.disable();
		                    }
		                }
		            }
		      },

		    /**
		     * Display a message in the viewport
		     * @function OpenSeadragon.Viewer.prototype._showMessage
		     * @private
		     * @param {String} text message
		     */
		    _showMessage: function ( message ) {
		        this._hideMessage();

		        var div = $.makeNeutralElement( "div" );
		        div.appendChild( document.createTextNode( message ) );

		        this.messageDiv = $.makeCenteredNode( div );

		        $.addClass(this.messageDiv, "openseadragon-message");

		        this.container.appendChild( this.messageDiv );
		    },

		    /**
		     * Hide any currently displayed viewport message
		     * @function OpenSeadragon.Viewer.prototype._hideMessage
		     * @private
		     */
		    _hideMessage: function () {
		        var div = this.messageDiv;
		        if (div) {
		            div.parentNode.removeChild(div);
		            delete this.messageDiv;
		        }
		    },

		    /**
		     * Gets this viewer's gesture settings for the given pointer device type.
		     * @method
		     * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
		     * @returns {OpenSeadragon.GestureSettings}
		     */
		    gestureSettingsByDeviceType: function ( type ) {
		        switch ( type ) {
		            case 'mouse':
		                return this.gestureSettingsMouse;
		            case 'touch':
		                return this.gestureSettingsTouch;
		            case 'pen':
		                return this.gestureSettingsPen;
		            default:
		                return this.gestureSettingsUnknown;
		        }
		    },

		    // private
		    _drawOverlays: function() {
		        var i,
		            length = this.currentOverlays.length;
		        for ( i = 0; i < length; i++ ) {
		            this.currentOverlays[ i ].drawHTML( this.overlaysContainer, this.viewport );
		        }
		    },

		    /**
		     * Cancel the "in flight" images.
		     */
		    _cancelPendingImages: function() {
		        this._loadQueue = [];
		    },

		    /**
		     * Removes the reference strip and disables displaying it.
		     * @function
		     */
		    removeReferenceStrip: function() {
		        this.showReferenceStrip = false;

		        if (this.referenceStrip) {
		            this.referenceStrip.destroy();
		            this.referenceStrip = null;
		        }
		    },

		    /**
		     * Enables and displays the reference strip based on the currently set tileSources.
		     * Works only when the Viewer has sequenceMode set to true.
		     * @function
		     */
		    addReferenceStrip: function() {
		        this.showReferenceStrip = true;

		        if (this.sequenceMode) {
		            if (this.referenceStrip) {
		                return;
		            }

		            if (this.tileSources.length && this.tileSources.length > 1) {
		                this.referenceStrip = new $.ReferenceStrip({
		                    id:          this.referenceStripElement,
		                    position:    this.referenceStripPosition,
		                    sizeRatio:   this.referenceStripSizeRatio,
		                    scroll:      this.referenceStripScroll,
		                    height:      this.referenceStripHeight,
		                    width:       this.referenceStripWidth,
		                    tileSources: this.tileSources,
		                    prefixUrl:   this.prefixUrl,
		                    viewer:      this
		                });

		                this.referenceStrip.setFocus( this._sequenceIndex );
		            }
		        } else {
		            $.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
		        }
		    },

		    /**
		     * Adds _updatePixelDensityRatio to the window resize event.
		     * @private
		     */
		    _addUpdatePixelDensityRatioEvent: function() {
		        this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this);
		        $.addEvent( window, 'resize', this._updatePixelDensityRatioBind );
		    },

		    /**
		     * Removes _updatePixelDensityRatio from the window resize event.
		     * @private
		     */
		    _removeUpdatePixelDensityRatioEvent: function() {
		        $.removeEvent( window, 'resize', this._updatePixelDensityRatioBind );
		    },

		    /**
		     * Update pixel density ratio and forces a resize operation.
		     * @private
		     */
		     _updatePixelDensityRatio: function() {
		        var previusPixelDensityRatio = $.pixelDensityRatio;
		        var currentPixelDensityRatio = $.getCurrentPixelDensityRatio();
		        if (previusPixelDensityRatio !== currentPixelDensityRatio) {
		            $.pixelDensityRatio = currentPixelDensityRatio;
		            this.forceResize();
		        }
		    },

		    /**
		     * Sets the image source to the source with index equal to
		     * currentIndex - 1. Changes current image in sequence mode.
		     * If specified, wraps around (see navPrevNextWrap in
		     * {@link OpenSeadragon.Options})
		     *
		     * @method
		     */

		    goToPreviousPage: function () {
		        var previous = this._sequenceIndex - 1;
		        if(this.navPrevNextWrap && previous < 0){
		            previous += this.tileSources.length;
		        }
		        this.goToPage( previous );
		    },

		    /**
		     * Sets the image source to the source with index equal to
		     * currentIndex + 1. Changes current image in sequence mode.
		     * If specified, wraps around (see navPrevNextWrap in
		     * {@link OpenSeadragon.Options})
		     *
		     * @method
		     */
		    goToNextPage: function () {
		        var next = this._sequenceIndex + 1;
		        if(this.navPrevNextWrap && next >= this.tileSources.length){
		            next = 0;
		        }
		        this.goToPage( next );
		    },

		    isAnimating: function () {
		        return THIS[ this.hash ].animating;
		    },
		});


		/**
		 * _getSafeElemSize is like getElementSize(), but refuses to return 0 for x or y,
		 * which was causing some calling operations to return NaN.
		 * @returns {Point}
		 * @private
		 */
		function _getSafeElemSize (oElement) {
		    oElement = $.getElement( oElement );

		    return new $.Point(
		        (oElement.clientWidth === 0 ? 1 : oElement.clientWidth),
		        (oElement.clientHeight === 0 ? 1 : oElement.clientHeight)
		    );
		}


		/**
		 * @function
		 * @private
		 */
		function getTileSourceImplementation( viewer, tileSource, imgOptions, successCallback,
		    failCallback ) {
		    var _this = viewer;

		    //allow plain xml strings or json strings to be parsed here
		    if ( $.type( tileSource ) === 'string' ) {
		        //xml should start with "<" and end with ">"
		        if ( tileSource.match( /^\s*<.*>\s*$/ ) ) {
		            tileSource = $.parseXml( tileSource );
		        //json should start with "{" or "[" and end with "}" or "]"
		        } else if ( tileSource.match(/^\s*[{[].*[}\]]\s*$/ ) ) {
		            try {
		              var tileSourceJ = $.parseJSON(tileSource);
		              tileSource = tileSourceJ;
		            } catch (e) {
		              //tileSource = tileSource;
		            }
		        }
		    }

		    function waitUntilReady(tileSource, originalTileSource) {
		        if (tileSource.ready) {
		            successCallback(tileSource);
		        } else {
		            tileSource.addHandler('ready', function () {
		                successCallback(tileSource);
		            });
		            tileSource.addHandler('open-failed', function (event) {
		                failCallback({
		                    message: event.message,
		                    source: originalTileSource
		                });
		            });
		        }
		    }

		    setTimeout( function() {
		        if ( $.type( tileSource ) === 'string' ) {
		            //If its still a string it means it must be a url at this point
		            tileSource = new $.TileSource({
		                url: tileSource,
		                crossOriginPolicy: imgOptions.crossOriginPolicy !== undefined ?
		                    imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
		                ajaxWithCredentials: viewer.ajaxWithCredentials,
		                ajaxHeaders: imgOptions.ajaxHeaders ?
		                    imgOptions.ajaxHeaders : viewer.ajaxHeaders,
		                splitHashDataForPost: viewer.splitHashDataForPost,
		                success: function( event ) {
		                    successCallback( event.tileSource );
		                }
		            });
		            tileSource.addHandler( 'open-failed', function( event ) {
		                failCallback( event );
		            } );

		        } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {
		            if (tileSource.crossOriginPolicy === undefined &&
		                (imgOptions.crossOriginPolicy !== undefined || viewer.crossOriginPolicy !== undefined)) {
		                tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== undefined ?
		                    imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
		            }
		            if (tileSource.ajaxWithCredentials === undefined) {
		                tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
		            }

		            if ( $.isFunction( tileSource.getTileUrl ) ) {
		                //Custom tile source
		                var customTileSource = new $.TileSource( tileSource );
		                customTileSource.getTileUrl = tileSource.getTileUrl;
		                successCallback( customTileSource );
		            } else {
		                //inline configuration
		                var $TileSource = $.TileSource.determineType( _this, tileSource );
		                if ( !$TileSource ) {
		                    failCallback( {
		                        message: "Unable to load TileSource",
		                        source: tileSource
		                    });
		                    return;
		                }
		                var options = $TileSource.prototype.configure.apply( _this, [ tileSource ] );
		                waitUntilReady(new $TileSource(options), tileSource);
		            }
		        } else {
		            //can assume it's already a tile source implementation
		            waitUntilReady(tileSource, tileSource);
		        }
		    });
		}

		function getOverlayObject( viewer, overlay ) {
		    if ( overlay instanceof $.Overlay ) {
		        return overlay;
		    }

		    var element = null;
		    if ( overlay.element ) {
		        element = $.getElement( overlay.element );
		    } else {
		        var id = overlay.id ?
		            overlay.id :
		            "openseadragon-overlay-" + Math.floor( Math.random() * 10000000 );

		        element = $.getElement( overlay.id );
		        if ( !element ) {
		            element         = document.createElement( "a" );
		            element.href    = "#/overlay/" + id;
		        }
		        element.id = id;
		        $.addClass( element, overlay.className ?
		            overlay.className :
		            "openseadragon-overlay"
		        );
		    }

		    var location = overlay.location;
		    var width = overlay.width;
		    var height = overlay.height;
		    if (!location) {
		        var x = overlay.x;
		        var y = overlay.y;
		        if (overlay.px !== undefined) {
		            var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(
		                overlay.px,
		                overlay.py,
		                width || 0,
		                height || 0));
		            x = rect.x;
		            y = rect.y;
		            width = width !== undefined ? rect.width : undefined;
		            height = height !== undefined ? rect.height : undefined;
		        }
		        location = new $.Point(x, y);
		    }

		    var placement = overlay.placement;
		    if (placement && $.type(placement) === "string") {
		        placement = $.Placement[overlay.placement.toUpperCase()];
		    }

		    return new $.Overlay({
		        element: element,
		        location: location,
		        placement: placement,
		        onDraw: overlay.onDraw,
		        checkResize: overlay.checkResize,
		        width: width,
		        height: height,
		        rotationMode: overlay.rotationMode
		    });
		}

		/**
		 * @private
		 * @inner
		 * Determines the index of the given overlay in the given overlays array.
		 */
		function getOverlayIndex( overlays, element ) {
		    var i;
		    for ( i = overlays.length - 1; i >= 0; i-- ) {
		        if ( overlays[ i ].element === element ) {
		            return i;
		        }
		    }

		    return -1;
		}

		///////////////////////////////////////////////////////////////////////////////
		// Schedulers provide the general engine for animation
		///////////////////////////////////////////////////////////////////////////////
		function scheduleUpdate( viewer, updateFunc ){
		    return $.requestAnimationFrame( function(){
		        updateFunc( viewer );
		    } );
		}


		//provides a sequence in the fade animation
		function scheduleControlsFade( viewer ) {
		    $.requestAnimationFrame( function(){
		        updateControlsFade( viewer );
		    });
		}


		//initiates an animation to hide the controls
		function beginControlsAutoHide( viewer ) {
		    if ( !viewer.autoHideControls ) {
		        return;
		    }
		    viewer.controlsShouldFade = true;
		    viewer.controlsFadeBeginTime =
		        $.now() +
		        viewer.controlsFadeDelay;

		    window.setTimeout( function(){
		        scheduleControlsFade( viewer );
		    }, viewer.controlsFadeDelay );
		}


		//determines if fade animation is done or continues the animation
		function updateControlsFade( viewer ) {
		    var currentTime,
		        deltaTime,
		        opacity,
		        i;
		    if ( viewer.controlsShouldFade ) {
		        currentTime = $.now();
		        deltaTime = currentTime - viewer.controlsFadeBeginTime;
		        opacity = 1.0 - deltaTime / viewer.controlsFadeLength;

		        opacity = Math.min( 1.0, opacity );
		        opacity = Math.max( 0.0, opacity );

		        for ( i = viewer.controls.length - 1; i >= 0; i--) {
		            if (viewer.controls[ i ].autoFade) {
		                viewer.controls[ i ].setOpacity( opacity );
		            }
		        }

		        if ( opacity > 0 ) {
		            // fade again
		            scheduleControlsFade( viewer );
		        }
		    }
		}


		//stop the fade animation on the controls and show them
		function abortControlsAutoHide( viewer ) {
		    var i;
		    viewer.controlsShouldFade = false;
		    for ( i = viewer.controls.length - 1; i >= 0; i-- ) {
		        viewer.controls[ i ].setOpacity( 1.0 );
		    }
		}



		///////////////////////////////////////////////////////////////////////////////
		// Default view event handlers.
		///////////////////////////////////////////////////////////////////////////////
		function onFocus(){
		    abortControlsAutoHide( this );
		}

		function onBlur(){
		    beginControlsAutoHide( this );

		}

		function onCanvasContextMenu( event ) {
		    var eventArgs = {
		        tracker: event.eventSource,
		        position: event.position,
		        originalEvent: event.originalEvent,
		        preventDefault: event.preventDefault
		    };

		    /**
		     * Raised when a contextmenu event occurs in the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-contextmenu
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the contextmenu event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-contextmenu', eventArgs );

		    event.preventDefault = eventArgs.preventDefault;
		}

		function onCanvasKeyDown( event ) {
		    var canvasKeyDownEventArgs = {
		      originalEvent: event.originalEvent,
		      preventDefaultAction: false,
		      preventVerticalPan: event.preventVerticalPan || !this.panVertical,
		      preventHorizontalPan: event.preventHorizontalPan || !this.panHorizontal
		    };

		    /**
		     * Raised when a keyboard key is pressed and the focus is on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-key
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default keyboard behaviour. Default: false.
		     * @property {Boolean} preventVerticalPan - Set to true to prevent keyboard vertical panning. Default: false.
		     * @property {Boolean} preventHorizontalPan - Set to true to prevent keyboard horizontal panning. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */

		    this.raiseEvent('canvas-key', canvasKeyDownEventArgs);

		    if ( !canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta ) {
		        switch( event.keyCode ){
		            case 38://up arrow/shift uparrow
		                if (!canvasKeyDownEventArgs.preventVerticalPan) {
		                  if ( event.shift ) {
		                    this.viewport.zoomBy(1.1);
		                  } else {
		                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -this.pixelsPerArrowPress)));
		                  }
		                  this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 40://down arrow/shift downarrow
		                if (!canvasKeyDownEventArgs.preventVerticalPan) {
		                  if ( event.shift ) {
		                    this.viewport.zoomBy(0.9);
		                  } else {
		                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, this.pixelsPerArrowPress)));
		                  }
		                  this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 37://left arrow
		                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
		                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-this.pixelsPerArrowPress, 0)));
		                  this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 39://right arrow
		                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
		                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(this.pixelsPerArrowPress, 0)));
		                  this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 187://=|+
		                this.viewport.zoomBy(1.1);
		                this.viewport.applyConstraints();
		                event.preventDefault = true;
		                break;
		            case 189://-|_
		                this.viewport.zoomBy(0.9);
		                this.viewport.applyConstraints();
		                event.preventDefault = true;
		                break;
		            case 48://0|)
		                this.viewport.goHome();
		                this.viewport.applyConstraints();
		                event.preventDefault = true;
		                break;
		            case 87://W/w
		                if (!canvasKeyDownEventArgs.preventVerticalPan) {
		                    if ( event.shift ) {
		                        this.viewport.zoomBy(1.1);
		                    } else {
		                        this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
		                    }
		                    this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 83://S/s
		                if (!canvasKeyDownEventArgs.preventVerticalPan) {
		                    if ( event.shift ) {
		                        this.viewport.zoomBy(0.9);
		                    } else {
		                        this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
		                    }
		                    this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 65://a/A
		                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
		                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
		                    this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 68://d/D
		                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
		                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
		                    this.viewport.applyConstraints();
		                }
		                event.preventDefault = true;
		                break;
		            case 82: //r - clockwise rotation/R - counterclockwise rotation
		                if(event.shift){
		                    if(this.viewport.flipped){
		                        this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
		                    } else {
		                        this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
		                    }
		                }else {
		                    if(this.viewport.flipped){
		                        this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
		                    } else {
		                        this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
		                    }
		                }
		                this.viewport.applyConstraints();
		                event.preventDefault = true;
		                break;
		            case 70: //f/F
		                this.viewport.toggleFlip();
		                event.preventDefault = true;
		                break;
		            case 74: //j - previous image source
		                this.goToPreviousPage();
		                break;
		            case 75: //k - next image source
		                this.goToNextPage();
		                break;
		            default:
		                //console.log( 'navigator keycode %s', event.keyCode );
		                event.preventDefault = false;
		                break;
		        }
		    } else {
		        event.preventDefault = false;
		    }
		}

		function onCanvasKeyPress( event ) {
		    var canvasKeyPressEventArgs = {
		      originalEvent: event.originalEvent,
		    };

		    /**
		     * Raised when a keyboard key is pressed and the focus is on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-key-press
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */

		    this.raiseEvent('canvas-key-press', canvasKeyPressEventArgs);
		}

		function onCanvasClick( event ) {
		    var gestureSettings;

		    var haveKeyboardFocus = document.activeElement === this.canvas;

		    // If we don't have keyboard focus, request it.
		    if ( !haveKeyboardFocus ) {
		        this.canvas.focus();
		    }
		    if(this.viewport.flipped){
		        event.position.x = this.viewport.getContainerSize().x - event.position.x;
		    }

		    var canvasClickEventArgs = {
		        tracker: event.eventSource,
		        position: event.position,
		        quick: event.quick,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        originalTarget: event.originalTarget,
		        preventDefaultAction: false
		    };

		    /**
		     * Raised when a mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-click
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Element} originalTarget - The DOM element clicked on.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */

		    this.raiseEvent( 'canvas-click', canvasClickEventArgs);


		    if ( !canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick ) {
		        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );

		        if (gestureSettings.clickToZoom === true){
		            this.viewport.zoomBy(
		                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
		                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
		            );
		            this.viewport.applyConstraints();
		        }

		        if( gestureSettings.dblClickDragToZoom){
		            if(THIS[ this.hash ].draggingToZoom === true){
		                THIS[ this.hash ].lastClickTime = null;
		                THIS[ this.hash ].draggingToZoom = false;
		            }
		            else {
		                THIS[ this.hash ].lastClickTime = $.now();
		            }
		        }

		    }
		}

		function onCanvasDblClick( event ) {
		    var gestureSettings;

		    var canvasDblClickEventArgs = {
		        tracker: event.eventSource,
		        position: event.position,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        preventDefaultAction: false
		    };

		    /**
		     * Raised when a double mouse press/release or touch/remove occurs on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-double-click
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default double tap to zoom behaviour. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-double-click', canvasDblClickEventArgs);

		    if ( !canvasDblClickEventArgs.preventDefaultAction && this.viewport ) {
		        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
		        if ( gestureSettings.dblClickToZoom ) {
		            this.viewport.zoomBy(
		                event.shift ? 1.0 / this.zoomPerClick : this.zoomPerClick,
		                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
		            );
		            this.viewport.applyConstraints();
		        }
		    }
		}

		function onCanvasDrag( event ) {
		    var gestureSettings;

		    var canvasDragEventArgs = {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        delta: event.delta,
		        speed: event.speed,
		        direction: event.direction,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        preventDefaultAction: false
		    };

		    /**
		     * Raised when a mouse or touch drag operation occurs on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-drag
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
		     * @property {Number} speed - Current computed speed, in pixels per second.
		     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag to pan behaviour. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-drag', canvasDragEventArgs);

		    gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );

		    if(!canvasDragEventArgs.preventDefaultAction && this.viewport){

		        if (gestureSettings.dblClickDragToZoom && THIS[ this.hash ].draggingToZoom){
		            var factor = Math.pow( this.zoomPerDblClickDrag, event.delta.y / 50);
		            this.viewport.zoomBy(factor);
		        }
		        else if (gestureSettings.dragToPan && !THIS[ this.hash ].draggingToZoom) {
		            if( !this.panHorizontal ){
		                event.delta.x = 0;
		            }
		            if( !this.panVertical ){
		                event.delta.y = 0;
		            }
		            if(this.viewport.flipped){
		                event.delta.x = -event.delta.x;
		            }

		            if( this.constrainDuringPan ){
		                var delta = this.viewport.deltaPointsFromPixels( event.delta.negate() );

		                this.viewport.centerSpringX.target.value += delta.x;
		                this.viewport.centerSpringY.target.value += delta.y;

		                var constrainedBounds = this.viewport.getConstrainedBounds();

		                this.viewport.centerSpringX.target.value -= delta.x;
		                this.viewport.centerSpringY.target.value -= delta.y;

		                if (constrainedBounds.xConstrained) {
		                    event.delta.x = 0;
		                }

		                if (constrainedBounds.yConstrained) {
		                    event.delta.y = 0;
		                }
		            }
		            this.viewport.panBy( this.viewport.deltaPointsFromPixels( event.delta.negate() ), gestureSettings.flickEnabled && !this.constrainDuringPan);
		        }

		    }

		}

		function onCanvasDragEnd( event ) {
		    var gestureSettings;
		    var canvasDragEndEventArgs = {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        speed: event.speed,
		        direction: event.direction,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        preventDefaultAction: false
		    };

		    /**
		     * Raised when a mouse or touch drag operation ends on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-drag-end
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} speed - Speed at the end of a drag gesture, in pixels per second.
		     * @property {Number} direction - Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag-end flick behaviour. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		     this.raiseEvent('canvas-drag-end', canvasDragEndEventArgs);

		    gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );

		    if (!canvasDragEndEventArgs.preventDefaultAction && this.viewport) {
		        if ( !THIS[ this.hash ].draggingToZoom &&
		            gestureSettings.dragToPan &&
		            gestureSettings.flickEnabled &&
		            event.speed >= gestureSettings.flickMinSpeed) {
		            var amplitudeX = 0;
		            if (this.panHorizontal) {
		                amplitudeX = gestureSettings.flickMomentum * event.speed *
		                    Math.cos(event.direction);
		            }
		            var amplitudeY = 0;
		            if (this.panVertical) {
		                amplitudeY = gestureSettings.flickMomentum * event.speed *
		                    Math.sin(event.direction);
		            }
		            var center = this.viewport.pixelFromPoint(
		                this.viewport.getCenter(true));
		            var target = this.viewport.pointFromPixel(
		                new $.Point(center.x - amplitudeX, center.y - amplitudeY));
		            this.viewport.panTo(target, false);
		        }
		        this.viewport.applyConstraints();
		    }


		    if( gestureSettings.dblClickDragToZoom && THIS[ this.hash ].draggingToZoom === true ){
		        THIS[ this.hash ].draggingToZoom = false;
		    }


		}

		function onCanvasEnter( event ) {
		    /**
		     * Raised when a pointer enters the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-enter
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-enter', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        buttons: event.buttons,
		        pointers: event.pointers,
		        insideElementPressed: event.insideElementPressed,
		        buttonDownAny: event.buttonDownAny,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasLeave( event ) {
		    /**
		     * Raised when a pointer leaves the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-exit
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-exit', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        buttons: event.buttons,
		        pointers: event.pointers,
		        insideElementPressed: event.insideElementPressed,
		        buttonDownAny: event.buttonDownAny,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasPress( event ) {
		    var gestureSettings;

		    /**
		     * Raised when the primary mouse button is pressed or touch starts on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-press
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-press', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        insideElementPressed: event.insideElementPressed,
		        insideElementReleased: event.insideElementReleased,
		        originalEvent: event.originalEvent
		    });


		    gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
		    if ( gestureSettings.dblClickDragToZoom ){
		        var lastClickTime = THIS[ this.hash ].lastClickTime;
		        var currClickTime = $.now();

		        if ( lastClickTime === null) {
		            return;
		        }

		        if ((currClickTime - lastClickTime) < this.dblClickTimeThreshold) {
		            THIS[ this.hash ].draggingToZoom = true;
		        }

		        THIS[ this.hash ].lastClickTime = null;
		    }

		}

		function onCanvasRelease( event ) {
		    /**
		     * Raised when the primary mouse button is released or touch ends on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-release
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} insideElementReleased - True if the cursor still inside the tracked element when the button was released.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-release', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        insideElementPressed: event.insideElementPressed,
		        insideElementReleased: event.insideElementReleased,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasNonPrimaryPress( event ) {
		    /**
		     * Raised when any non-primary pointer button is pressed on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-nonprimary-press
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {Number} button - Button which caused the event.
		     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		     * @property {Number} buttons - Current buttons pressed.
		     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-nonprimary-press', {
		        tracker: event.eventSource,
		        position: event.position,
		        pointerType: event.pointerType,
		        button: event.button,
		        buttons: event.buttons,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasNonPrimaryRelease( event ) {
		    /**
		     * Raised when any non-primary pointer button is released on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-nonprimary-release
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {Number} button - Button which caused the event.
		     *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
		     * @property {Number} buttons - Current buttons pressed.
		     *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-nonprimary-release', {
		        tracker: event.eventSource,
		        position: event.position,
		        pointerType: event.pointerType,
		        button: event.button,
		        buttons: event.buttons,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasPinch( event ) {
		    var gestureSettings,
		        centerPt,
		        lastCenterPt,
		        panByPt;

		    var canvasPinchEventArgs = {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        gesturePoints: event.gesturePoints,
		        lastCenter: event.lastCenter,
		        center: event.center,
		        lastDistance: event.lastDistance,
		        distance: event.distance,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        preventDefaultPanAction: false,
		        preventDefaultZoomAction: false,
		        preventDefaultRotateAction: false
		    };

		    /**
		     * Raised when a pinch event occurs on the {@link OpenSeadragon.Viewer#canvas} element.
		     *
		     * @event canvas-pinch
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {Array.<OpenSeadragon.MouseTracker.GesturePoint>} gesturePoints - Gesture points associated with the gesture. Velocity data can be found here.
		     * @property {OpenSeadragon.Point} lastCenter - The previous center point of the two pinch contact points relative to the tracked element.
		     * @property {OpenSeadragon.Point} center - The center point of the two pinch contact points relative to the tracked element.
		     * @property {Number} lastDistance - The previous distance between the two pinch contact points in CSS pixels.
		     * @property {Number} distance - The distance between the two pinch contact points in CSS pixels.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefaultPanAction - Set to true to prevent default pinch to pan behaviour. Default: false.
		     * @property {Boolean} preventDefaultZoomAction - Set to true to prevent default pinch to zoom behaviour. Default: false.
		     * @property {Boolean} preventDefaultRotateAction - Set to true to prevent default pinch to rotate behaviour. Default: false.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		     this.raiseEvent('canvas-pinch', canvasPinchEventArgs);

		    if ( this.viewport ) {
		        gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
		        if ( gestureSettings.pinchToZoom &&
		                    (!canvasPinchEventArgs.preventDefaultPanAction || !canvasPinchEventArgs.preventDefaultZoomAction) ) {
		            centerPt = this.viewport.pointFromPixel( event.center, true );
		            if ( gestureSettings.zoomToRefPoint && !canvasPinchEventArgs.preventDefaultPanAction ) {
		                lastCenterPt = this.viewport.pointFromPixel( event.lastCenter, true );
		                panByPt = lastCenterPt.minus( centerPt );
		                if( !this.panHorizontal ) {
		                    panByPt.x = 0;
		                }
		                if( !this.panVertical ) {
		                    panByPt.y = 0;
		                }
		                this.viewport.panBy(panByPt, true);
		            }
		            if ( !canvasPinchEventArgs.preventDefaultZoomAction ) {
		                this.viewport.zoomBy( event.distance / event.lastDistance, centerPt, true );
		            }
		            this.viewport.applyConstraints();
		        }
		        if ( gestureSettings.pinchRotate && !canvasPinchEventArgs.preventDefaultRotateAction ) {
		            // Pinch rotate
		            var angle1 = Math.atan2(event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
		                event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x);
		            var angle2 = Math.atan2(event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
		                event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x);
		            centerPt = this.viewport.pointFromPixel( event.center, true );
		            this.viewport.rotateTo(this.viewport.getRotation(true) + ((angle1 - angle2) * (180 / Math.PI)), centerPt, true);
		        }
		    }
		}

		function onCanvasFocus( event ) {

		    /**
		     * Raised when the {@link OpenSeadragon.Viewer#canvas} element gets keyboard focus.
		     *
		     * @event canvas-focus
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-focus', {
		        tracker: event.eventSource,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasBlur( event ) {
		    /**
		     * Raised when the {@link OpenSeadragon.Viewer#canvas} element loses keyboard focus.
		     *
		     * @event canvas-blur
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'canvas-blur', {
		        tracker: event.eventSource,
		        originalEvent: event.originalEvent
		    });
		}

		function onCanvasScroll( event ) {
		    var canvasScrollEventArgs,
		        gestureSettings,
		        factor,
		        thisScrollTime,
		        deltaScrollTime;

		    /* Certain scroll devices fire the scroll event way too fast so we are injecting a simple adjustment to keep things
		     * partially normalized. If we have already fired an event within the last 'minScrollDelta' milliseconds we skip
		     * this one and wait for the next event. */
		    thisScrollTime = $.now();
		    deltaScrollTime = thisScrollTime - this._lastScrollTime;
		    if (deltaScrollTime > this.minScrollDeltaTime) {
		        this._lastScrollTime = thisScrollTime;

		        canvasScrollEventArgs = {
		            tracker: event.eventSource,
		            position: event.position,
		            scroll: event.scroll,
		            shift: event.shift,
		            originalEvent: event.originalEvent,
		            preventDefaultAction: false,
		            preventDefault: true
		        };

		        /**
		         * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#canvas} element (mouse wheel).
		         *
		         * @event canvas-scroll
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		         * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		         * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		         * @property {Number} scroll - The scroll delta for the event.
		         * @property {Boolean} shift - True if the shift key was pressed during this event.
		         * @property {Object} originalEvent - The original DOM event.
		         * @property {Boolean} preventDefaultAction - Set to true to prevent default scroll to zoom behaviour. Default: false.
		         * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the wheel event. Default: true.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		         this.raiseEvent('canvas-scroll', canvasScrollEventArgs );

		        if ( !canvasScrollEventArgs.preventDefaultAction && this.viewport ) {
		            if(this.viewport.flipped){
		                event.position.x = this.viewport.getContainerSize().x - event.position.x;
		            }

		            gestureSettings = this.gestureSettingsByDeviceType( event.pointerType );
		            if ( gestureSettings.scrollToZoom ) {
		                factor = Math.pow( this.zoomPerScroll, event.scroll );
		                this.viewport.zoomBy(
		                    factor,
		                    gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel( event.position, true ) : null
		                );
		                this.viewport.applyConstraints();
		            }
		        }

		        event.preventDefault = canvasScrollEventArgs.preventDefault;
		    } else {
		        event.preventDefault = true;
		    }
		}

		function onContainerEnter( event ) {
		    THIS[ this.hash ].mouseInside = true;
		    abortControlsAutoHide( this );
		    /**
		     * Raised when the cursor enters the {@link OpenSeadragon.Viewer#container} element.
		     *
		     * @event container-enter
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'container-enter', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        buttons: event.buttons,
		        pointers: event.pointers,
		        insideElementPressed: event.insideElementPressed,
		        buttonDownAny: event.buttonDownAny,
		        originalEvent: event.originalEvent
		    });
		}

		function onContainerLeave( event ) {
		    if ( event.pointers < 1 ) {
		        THIS[ this.hash ].mouseInside = false;
		        if ( !THIS[ this.hash ].animating ) {
		            beginControlsAutoHide( this );
		        }
		    }
		    /**
		     * Raised when the cursor leaves the {@link OpenSeadragon.Viewer#container} element.
		     *
		     * @event container-exit
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {String} pointerType - "mouse", "touch", "pen", etc.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} buttons - Current buttons pressed. A combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
		     * @property {Number} pointers - Number of pointers (all types) active in the tracked element.
		     * @property {Boolean} insideElementPressed - True if the left mouse button is currently being pressed and was initiated inside the tracked element, otherwise false.
		     * @property {Boolean} buttonDownAny - Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.raiseEvent( 'container-exit', {
		        tracker: event.eventSource,
		        pointerType: event.pointerType,
		        position: event.position,
		        buttons: event.buttons,
		        pointers: event.pointers,
		        insideElementPressed: event.insideElementPressed,
		        buttonDownAny: event.buttonDownAny,
		        originalEvent: event.originalEvent
		    });
		}


		///////////////////////////////////////////////////////////////////////////////
		// Page update routines ( aka Views - for future reference )
		///////////////////////////////////////////////////////////////////////////////

		function updateMulti( viewer ) {
		    updateOnce( viewer );

		    // Request the next frame, unless we've been closed
		    if ( viewer.isOpen() ) {
		        viewer._updateRequestId = scheduleUpdate( viewer, updateMulti );
		    } else {
		        viewer._updateRequestId = false;
		    }
		}

		function doViewerResize(viewer, containerSize){
		    var viewport = viewer.viewport;
		    var zoom = viewport.getZoom();
		    var center = viewport.getCenter();
		    viewport.resize(containerSize, viewer.preserveImageSizeOnResize);
		    viewport.panTo(center, true);
		    var resizeRatio;
		    if (viewer.preserveImageSizeOnResize) {
		        resizeRatio = THIS[viewer.hash].prevContainerSize.x / containerSize.x;
		    } else {
		        var origin = new $.Point(0, 0);
		        var prevDiag = new $.Point(THIS[viewer.hash].prevContainerSize.x, THIS[viewer.hash].prevContainerSize.y).distanceTo(origin);
		        var newDiag = new $.Point(containerSize.x, containerSize.y).distanceTo(origin);
		        resizeRatio = newDiag / prevDiag * THIS[viewer.hash].prevContainerSize.x / containerSize.x;
		    }
		    viewport.zoomTo(zoom * resizeRatio, null, true);
		    THIS[viewer.hash].prevContainerSize = containerSize;
		    THIS[viewer.hash].forceRedraw = true;
		    THIS[viewer.hash].needsResize = false;
		    THIS[viewer.hash].forceResize = false;
		}
		function updateOnce( viewer ) {

		    //viewer.profiler.beginUpdate();

		    if (viewer._opening || !THIS[viewer.hash]) {
		        return;
		    }
		    if (viewer.autoResize || THIS[viewer.hash].forceResize){
		        var containerSize;
		        if(viewer._autoResizePolling){
		            containerSize = _getSafeElemSize(viewer.container);
		            var prevContainerSize = THIS[viewer.hash].prevContainerSize;
		            if (!containerSize.equals(prevContainerSize)) {
		                THIS[viewer.hash].needsResize = true;
		            }
		        }
		        if(THIS[viewer.hash].needsResize){
		            doViewerResize(viewer, containerSize || _getSafeElemSize(viewer.container));
		        }

		    }



		    var viewportChange = viewer.viewport.update();
		    var animated = viewer.world.update(viewportChange) || viewportChange;

		    if (viewportChange) {
		        /**
		         * Raised when any spring animation update occurs (zoom, pan, etc.),
		         * before the viewer has drawn the new location.
		         *
		         * @event viewport-change
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        viewer.raiseEvent('viewport-change');
		    }

		    if( viewer.referenceStrip ){
		        animated = viewer.referenceStrip.update( viewer.viewport ) || animated;
		    }

		    var currentAnimating = THIS[ viewer.hash ].animating;

		    if ( !currentAnimating && animated ) {
		        /**
		         * Raised when any spring animation starts (zoom, pan, etc.).
		         *
		         * @event animation-start
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        viewer.raiseEvent( "animation-start" );
		        abortControlsAutoHide( viewer );
		    }

		    var isAnimationFinished = currentAnimating && !animated;

		    if ( isAnimationFinished ) {
		        THIS[ viewer.hash ].animating = false;
		    }

		    if ( animated || isAnimationFinished || THIS[ viewer.hash ].forceRedraw || viewer.world.needsDraw() ) {
		        drawWorld( viewer );
		        viewer._drawOverlays();
		        if( viewer.navigator ){
		          viewer.navigator.update( viewer.viewport );
		        }

		        THIS[ viewer.hash ].forceRedraw = false;

		        if (animated) {
		            /**
		             * Raised when any spring animation update occurs (zoom, pan, etc.),
		             * after the viewer has drawn the new location.
		             *
		             * @event animation
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            viewer.raiseEvent( "animation" );
		        }
		    }

		    if ( isAnimationFinished ) {
		        /**
		         * Raised when any spring animation ends (zoom, pan, etc.).
		         *
		         * @event animation-finish
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        viewer.raiseEvent( "animation-finish" );

		        if ( !THIS[ viewer.hash ].mouseInside ) {
		            beginControlsAutoHide( viewer );
		        }
		    }

		    THIS[ viewer.hash ].animating = animated;

		    //viewer.profiler.endUpdate();
		}

		function drawWorld( viewer ) {
		    viewer.imageLoader.clear();
		    viewer.world.draw();

		    /**
		     * <em>- Needs documentation -</em>
		     *
		     * @event update-viewport
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    viewer.raiseEvent( 'update-viewport', {} );
		}

		///////////////////////////////////////////////////////////////////////////////
		// Navigation Controls
		///////////////////////////////////////////////////////////////////////////////
		function resolveUrl( prefix, url ) {
		    return prefix ? prefix + url : url;
		}



		function beginZoomingIn() {
		    THIS[ this.hash ].lastZoomTime = $.now();
		    THIS[ this.hash ].zoomFactor = this.zoomPerSecond;
		    THIS[ this.hash ].zooming = true;
		    scheduleZoom( this );
		}


		function beginZoomingOut() {
		    THIS[ this.hash ].lastZoomTime = $.now();
		    THIS[ this.hash ].zoomFactor = 1.0 / this.zoomPerSecond;
		    THIS[ this.hash ].zooming = true;
		    scheduleZoom( this );
		}


		function endZooming() {
		    THIS[ this.hash ].zooming = false;
		}


		function scheduleZoom( viewer ) {
		    $.requestAnimationFrame( $.delegate( viewer, doZoom ) );
		}


		function doZoom() {
		    var currentTime,
		        deltaTime,
		        adjustedFactor;

		    if ( THIS[ this.hash ].zooming && this.viewport) {
		        currentTime     = $.now();
		        deltaTime       = currentTime - THIS[ this.hash ].lastZoomTime;
		        adjustedFactor  = Math.pow( THIS[ this.hash ].zoomFactor, deltaTime / 1000 );

		        this.viewport.zoomBy( adjustedFactor );
		        this.viewport.applyConstraints();
		        THIS[ this.hash ].lastZoomTime = currentTime;
		        scheduleZoom( this );
		    }
		}


		function doSingleZoomIn() {
		    if ( this.viewport ) {
		        THIS[ this.hash ].zooming = false;
		        this.viewport.zoomBy(
		            this.zoomPerClick / 1.0
		        );
		        this.viewport.applyConstraints();
		    }
		}


		function doSingleZoomOut() {
		    if ( this.viewport ) {
		        THIS[ this.hash ].zooming = false;
		        this.viewport.zoomBy(
		            1.0 / this.zoomPerClick
		        );
		        this.viewport.applyConstraints();
		    }
		}


		function lightUp() {
		    if (this.buttonGroup) {
		        this.buttonGroup.emulateEnter();
		        this.buttonGroup.emulateLeave();
		    }
		}


		function onHome() {
		    if ( this.viewport ) {
		        this.viewport.goHome();
		    }
		}


		function onFullScreen() {
		    if ( this.isFullPage() && !$.isFullScreen() ) {
		        // Is fullPage but not fullScreen
		        this.setFullPage( false );
		    } else {
		        this.setFullScreen( !this.isFullPage() );
		    }
		    // correct for no mouseout event on change
		    if ( this.buttonGroup ) {
		        this.buttonGroup.emulateLeave();
		    }
		    this.fullPageButton.element.focus();
		    if ( this.viewport ) {
		        this.viewport.applyConstraints();
		    }
		}

		function onRotateLeft() {
		    if ( this.viewport ) {
		        var currRotation = this.viewport.getRotation();

		        if ( this.viewport.flipped ){
		          currRotation += this.rotationIncrement;
		        } else {
		          currRotation -= this.rotationIncrement;
		        }
		        this.viewport.setRotation(currRotation);
		    }
		}

		function onRotateRight() {
		    if ( this.viewport ) {
		        var currRotation = this.viewport.getRotation();

		        if ( this.viewport.flipped ){
		          currRotation -= this.rotationIncrement;
		        } else {
		          currRotation += this.rotationIncrement;
		        }
		        this.viewport.setRotation(currRotation);
		    }
		}
		/**
		 * Note: When pressed flip control button
		 */
		function onFlip() {
		   this.viewport.toggleFlip();
		}

		/**
		 * Find drawer
		 */
		$.determineDrawer = function( id ){
		    for (let property in OpenSeadragon) {
		        const drawer = OpenSeadragon[ property ],
		            proto = drawer.prototype;
		        if( proto &&
		            proto instanceof OpenSeadragon.DrawerBase &&
		            $.isFunction( proto.getType ) &&
		            proto.getType.call( drawer ) === id
		        ){
		            return drawer;
		        }
		    }
		    return null;
		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Navigator
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class Navigator
		 * @classdesc The Navigator provides a small view of the current image as fixed
		 * while representing the viewport as a moving box serving as a frame
		 * of reference in the larger viewport as to which portion of the image
		 * is currently being examined.  The navigator's viewport can be interacted
		 * with using the keyboard or the mouse.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.Viewer
		 * @extends OpenSeadragon.EventSource
		 * @param {Object} options - Navigator options
		 * @param {Element} [options.element] - An element to use for the navigator.
		 * @param {String} [options.id] - Id of the element to use for the navigator. However, this is ignored if {@link options.element} is provided.
		 */
		$.Navigator = function( options ){

		    var viewer      = options.viewer,
		        _this = this,
		        viewerSize,
		        navigatorSize;

		    //We may need to create a new element and id if they did not
		    //provide the id for the existing element or the element itself
		    if( options.element || options.id ){
		        if ( options.element ) {
		            if ( options.id ){
		                $.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead.");
		            }

		            // Don't overwrite the element's id if it has one already
		            if ( options.element.id ) {
		                options.id = options.element.id;
		            } else {
		                options.id = 'navigator-' + $.now();
		            }

		            this.element = options.element;
		        } else {
		            this.element = document.getElementById( options.id );
		        }

		        options.controlOptions  = {
		            anchor:           $.ControlAnchor.NONE,
		            attachToViewer:   false,
		            autoFade:         false
		        };
		    } else {
		        options.id              = 'navigator-' + $.now();
		        this.element            = $.makeNeutralElement( "div" );
		        options.controlOptions  = {
		            anchor:           $.ControlAnchor.TOP_RIGHT,
		            attachToViewer:   true,
		            autoFade:         options.autoFade
		        };

		        if( options.position ){
		            if( 'BOTTOM_RIGHT' === options.position ){
		               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
		            } else if( 'BOTTOM_LEFT' === options.position ){
		               options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
		            } else if( 'TOP_RIGHT' === options.position ){
		               options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
		            } else if( 'TOP_LEFT' === options.position ){
		               options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
		            } else if( 'ABSOLUTE' === options.position ){
		               options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
		               options.controlOptions.top = options.top;
		               options.controlOptions.left = options.left;
		               options.controlOptions.height = options.height;
		               options.controlOptions.width = options.width;
		            }
		        }
		    }
		    this.element.id         = options.id;
		    this.element.className  += ' navigator';

		    options = $.extend( true, {
		        sizeRatio:     $.DEFAULT_SETTINGS.navigatorSizeRatio
		    }, options, {
		        element:                this.element,
		        tabIndex:               -1, // No keyboard navigation, omit from tab order
		        //These need to be overridden to prevent recursion since
		        //the navigator is a viewer and a viewer has a navigator
		        showNavigator:          false,
		        mouseNavEnabled:        false,
		        showNavigationControl:  false,
		        showSequenceControl:    false,
		        immediateRender:        true,
		        blendTime:              0,
		        animationTime:          options.animationTime,
		        // disable autoResize since resize behavior is implemented differently by the navigator
		        autoResize:             false,
		        // prevent resizing the navigator from adding unwanted space around the image
		        minZoomImageRatio:      1.0,
		        background:             options.background,
		        opacity:                options.opacity,
		        borderColor:            options.borderColor,
		        displayRegionColor:     options.displayRegionColor
		    });

		    options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;

		    $.setElementTouchActionNone( this.element );

		    this.borderWidth = 2;
		    //At some browser magnification levels the display regions lines up correctly, but at some there appears to
		    //be a one pixel gap.
		    this.fudge = new $.Point(1, 1);
		    this.totalBorderWidths = new $.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);


		    if ( options.controlOptions.anchor !== $.ControlAnchor.NONE ) {
		        (function( style, borderWidth ){
		            style.margin        = '0px';
		            style.border        = borderWidth + 'px solid ' + options.borderColor;
		            style.padding       = '0px';
		            style.background    = options.background;
		            style.opacity       = options.opacity;
		            style.overflow      = 'hidden';
		        }( this.element.style, this.borderWidth));
		    }

		    this.displayRegion           = $.makeNeutralElement( "div" );
		    this.displayRegion.id        = this.element.id + '-displayregion';
		    this.displayRegion.className = 'displayregion';

		    (function( style, borderWidth ){
		        style.position      = 'relative';
		        style.top           = '0px';
		        style.left          = '0px';
		        style.fontSize      = '0px';
		        style.overflow      = 'hidden';
		        style.border        = borderWidth + 'px solid ' + options.displayRegionColor;
		        style.margin        = '0px';
		        style.padding       = '0px';
		        style.background    = 'transparent';

		        // We use square bracket notation on the statement below, because float is a keyword.
		        // This is important for the Google Closure compiler, if nothing else.
		        /*jshint sub:true */
		        style['float']      = 'left'; //Webkit

		        style.cssFloat      = 'left'; //Firefox
		        style.zIndex        = 999999999;
		        style.cursor        = 'default';
		        style.boxSizing     = 'content-box';
		    }( this.displayRegion.style, this.borderWidth ));
		    $.setElementPointerEventsNone( this.displayRegion );
		    $.setElementTouchActionNone( this.displayRegion );

		    this.displayRegionContainer = $.makeNeutralElement("div");
		    this.displayRegionContainer.id = this.element.id + '-displayregioncontainer';
		    this.displayRegionContainer.className = "displayregioncontainer";
		    this.displayRegionContainer.style.width = "100%";
		    this.displayRegionContainer.style.height = "100%";
		    $.setElementPointerEventsNone( this.displayRegionContainer );
		    $.setElementTouchActionNone( this.displayRegionContainer );

		    viewer.addControl(
		        this.element,
		        options.controlOptions
		    );

		    this._resizeWithViewer = options.controlOptions.anchor !== $.ControlAnchor.ABSOLUTE &&
		        options.controlOptions.anchor !== $.ControlAnchor.NONE;

		    if (options.width && options.height) {
		        this.setWidth(options.width);
		        this.setHeight(options.height);
		    } else if ( this._resizeWithViewer ) {
		        viewerSize = $.getElementSize( viewer.element );
		        this.element.style.height = Math.round( viewerSize.y * options.sizeRatio ) + 'px';
		        this.element.style.width  = Math.round( viewerSize.x * options.sizeRatio ) + 'px';
		        this.oldViewerSize = viewerSize;
		        navigatorSize = $.getElementSize( this.element );
		        this.elementArea = navigatorSize.x * navigatorSize.y;
		    }

		    this.oldContainerSize = new $.Point( 0, 0 );

		    $.Viewer.apply( this, [ options ] );

		    this.displayRegionContainer.appendChild(this.displayRegion);
		    this.element.getElementsByTagName('div')[0].appendChild(this.displayRegionContainer);

		    function rotate(degrees, immediately) {
		        _setTransformRotate(_this.displayRegionContainer, degrees);
		        _setTransformRotate(_this.displayRegion, -degrees);
		        _this.viewport.setRotation(degrees, immediately);
		    }
		    if (options.navigatorRotate) {
		        var degrees = options.viewer.viewport ?
		            options.viewer.viewport.getRotation() :
		            options.viewer.degrees || 0;

		        rotate(degrees, true);
		        options.viewer.addHandler("rotate", function (args) {
		            rotate(args.degrees, args.immediately);
		        });
		    }


		    // Remove the base class' (Viewer's) innerTracker and replace it with our own
		    this.innerTracker.destroy();
		    this.innerTracker = new $.MouseTracker({
		        userData:        'Navigator.innerTracker',
		        element:         this.element, //this.canvas,
		        dragHandler:     $.delegate( this, onCanvasDrag ),
		        clickHandler:    $.delegate( this, onCanvasClick ),
		        releaseHandler:  $.delegate( this, onCanvasRelease ),
		        scrollHandler:   $.delegate( this, onCanvasScroll ),
		        preProcessEventHandler: function (eventInfo) {
		            if (eventInfo.eventType === 'wheel') {
		                //don't scroll the page up and down if the user is scrolling
		                //in the navigator
		                eventInfo.preventDefault = true;
		            }
		        }
		    });
		    this.outerTracker.userData = 'Navigator.outerTracker';

		    // this.innerTracker is attached to this.element...we need to allow pointer
		    //   events to pass through this Viewer's canvas/container elements so implicit
		    //   pointer capture works on touch devices
		    //TODO an alternative is to attach the new MouseTracker to this.canvas...not
		    //   sure why it isn't already (see MouseTracker constructor call above)
		    $.setElementPointerEventsNone( this.canvas );
		    $.setElementPointerEventsNone( this.container );

		    this.addHandler("reset-size", function() {
		        if (_this.viewport) {
		            _this.viewport.goHome(true);
		        }
		    });

		    viewer.world.addHandler("item-index-change", function(event) {
		        window.setTimeout(function(){
		            var item = _this.world.getItemAt(event.previousIndex);
		            _this.world.setItemIndex(item, event.newIndex);
		        }, 1);
		    });

		    viewer.world.addHandler("remove-item", function(event) {
		        var theirItem = event.item;
		        var myItem = _this._getMatchingItem(theirItem);
		        if (myItem) {
		            _this.world.removeItem(myItem);
		        }
		    });

		    this.update(viewer.viewport);
		};

		$.extend( $.Navigator.prototype, $.EventSource.prototype, $.Viewer.prototype, /** @lends OpenSeadragon.Navigator.prototype */{

		    /**
		     * Used to notify the navigator when its size has changed.
		     * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
		     * @function
		     */
		    updateSize: function () {
		        if ( this.viewport ) {
		            var containerSize = new $.Point(
		                    (this.container.clientWidth === 0 ? 1 : this.container.clientWidth),
		                    (this.container.clientHeight === 0 ? 1 : this.container.clientHeight)
		                );

		            if ( !containerSize.equals( this.oldContainerSize ) ) {
		                this.viewport.resize( containerSize, true );
		                this.viewport.goHome(true);
		                this.oldContainerSize = containerSize;
		                this.world.update();
		                this.world.draw();
		                this.update(this.viewer.viewport);
		            }
		        }
		    },

		    /**
		     * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
		     * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
		     */
		    setWidth: function(width) {
		        this.width = width;
		        this.element.style.width = typeof (width) === "number" ? (width + 'px') : width;
		        this._resizeWithViewer = false;
		        this.updateSize();
		    },

		    /**
		     * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
		     * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
		     */
		    setHeight: function(height) {
		        this.height = height;
		        this.element.style.height = typeof (height) === "number" ? (height + 'px') : height;
		        this._resizeWithViewer = false;
		        this.updateSize();
		    },

		    /**
		      * Flip navigator element
		      * @param {Boolean} state - Flip state to set.
		      */
		    setFlip: function(state) {
		      this.viewport.setFlip(state);

		      this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
		      return this;
		    },

		    setDisplayTransform: function(rule) {
		      setElementTransform(this.canvas, rule);
		      setElementTransform(this.element, rule);
		    },

		    /**
		     * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
		     * @function
		     * @param {OpenSeadragon.Viewport} [viewport] The viewport to display. Default: the viewport this navigator is tracking.
		     */
		    update: function( viewport ) {

		        var viewerSize,
		            newWidth,
		            newHeight,
		            bounds,
		            topleft,
		            bottomright;

		        if(!viewport){
		            viewport = this.viewer.viewport;
		        }

		        viewerSize = $.getElementSize( this.viewer.element );
		        if ( this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals( this.oldViewerSize ) ) {
		            this.oldViewerSize = viewerSize;

		            if ( this.maintainSizeRatio || !this.elementArea) {
		                newWidth  = viewerSize.x * this.sizeRatio;
		                newHeight = viewerSize.y * this.sizeRatio;
		            } else {
		                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
		                newHeight = this.elementArea / newWidth;
		            }

		            this.element.style.width  = Math.round( newWidth ) + 'px';
		            this.element.style.height = Math.round( newHeight ) + 'px';

		            if (!this.elementArea) {
		                this.elementArea = newWidth * newHeight;
		            }

		            this.updateSize();
		        }

		        if (viewport && this.viewport) {
		            bounds      = viewport.getBoundsNoRotate(true);
		            topleft     = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
		            bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false)
		                .minus( this.totalBorderWidths );

		            if (!this.navigatorRotate) {
		                var degrees = viewport.getRotation(true);
		                _setTransformRotate(this.displayRegion, -degrees);
		            }

		            //update style for navigator-box
		            var style = this.displayRegion.style;
		            style.display = this.world.getItemCount() ? 'block' : 'none';

		            style.top = topleft.y.toFixed(2) + "px";
		            style.left = topleft.x.toFixed(2) + "px";

		            var width = bottomright.x - topleft.x;
		            var height = bottomright.y - topleft.y;
		            // make sure width and height are non-negative so IE doesn't throw
		            style.width  = Math.round( Math.max( width, 0 ) ) + 'px';
		            style.height = Math.round( Math.max( height, 0 ) ) + 'px';
		        }

		    },

		    // overrides Viewer.addTiledImage
		    addTiledImage: function(options) {
		        var _this = this;

		        var original = options.originalTiledImage;
		        delete options.original;

		        var optionsClone = $.extend({}, options, {
		            success: function(event) {
		                var myItem = event.item;
		                myItem._originalForNavigator = original;
		                _this._matchBounds(myItem, original, true);
		                _this._matchOpacity(myItem, original);
		                _this._matchCompositeOperation(myItem, original);

		                function matchBounds() {
		                    _this._matchBounds(myItem, original);
		                }

		                function matchOpacity() {
		                    _this._matchOpacity(myItem, original);
		                }

		                function matchCompositeOperation() {
		                    _this._matchCompositeOperation(myItem, original);
		                }

		                original.addHandler('bounds-change', matchBounds);
		                original.addHandler('clip-change', matchBounds);
		                original.addHandler('opacity-change', matchOpacity);
		                original.addHandler('composite-operation-change', matchCompositeOperation);
		            }
		        });

		        return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
		    },

		    destroy: function() {
		        return $.Viewer.prototype.destroy.apply(this);
		    },

		    // private
		    _getMatchingItem: function(theirItem) {
		        var count = this.world.getItemCount();
		        var item;
		        for (var i = 0; i < count; i++) {
		            item = this.world.getItemAt(i);
		            if (item._originalForNavigator === theirItem) {
		                return item;
		            }
		        }

		        return null;
		    },

		    // private
		    _matchBounds: function(myItem, theirItem, immediately) {
		        var bounds = theirItem.getBoundsNoRotate();
		        myItem.setPosition(bounds.getTopLeft(), immediately);
		        myItem.setWidth(bounds.width, immediately);
		        myItem.setRotation(theirItem.getRotation(), immediately);
		        myItem.setClip(theirItem.getClip());
		        myItem.setFlip(theirItem.getFlip());
		    },

		    // private
		    _matchOpacity: function(myItem, theirItem) {
		        myItem.setOpacity(theirItem.opacity);
		    },

		    // private
		    _matchCompositeOperation: function(myItem, theirItem) {
		        myItem.setCompositeOperation(theirItem.compositeOperation);
		    }
		});


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onCanvasClick( event ) {
		  var canvasClickEventArgs = {
		    tracker: event.eventSource,
		    position: event.position,
		    quick: event.quick,
		    shift: event.shift,
		    originalEvent: event.originalEvent,
		    preventDefaultAction: false
		  };
		  /**
		   * Raised when a click event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
		   *
		   * @event navigator-click
		   * @memberof OpenSeadragon.Viewer
		   * @type {object}
		   * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		   * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		   * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		   * @property {Boolean} quick - True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for differentiating between clicks and drags.
		   * @property {Boolean} shift - True if the shift key was pressed during this event.
		   * @property {Object} originalEvent - The original DOM event.
		   * @property {?Object} userData - Arbitrary subscriber-defined object.
		   * @property {Boolean} preventDefaultAction - Set to true to prevent default click to zoom behaviour. Default: false.
		   */

		   this.viewer.raiseEvent('navigator-click', canvasClickEventArgs);

		   if ( !canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
		    if(this.viewer.viewport.flipped) {
		      event.position.x = this.viewport.getContainerSize().x - event.position.x;
		    }
		    var target = this.viewport.pointFromPixel(event.position);
		    if (!this.panVertical) {
		      // perform only horizonal pan
		      target.y = this.viewer.viewport.getCenter(true).y;
		    } else if (!this.panHorizontal) {
		      // perform only vertical pan
		      target.x = this.viewer.viewport.getCenter(true).x;
		    }
		    this.viewer.viewport.panTo(target);
		    this.viewer.viewport.applyConstraints();
		  }

		}

		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onCanvasDrag( event ) {
		    var canvasDragEventArgs = {
		      tracker: event.eventSource,
		      position: event.position,
		      delta: event.delta,
		      speed: event.speed,
		      direction: event.direction,
		      shift: event.shift,
		      originalEvent: event.originalEvent,
		      preventDefaultAction: false
		    };
		    /**
		     * Raised when a drag event occurs on the {@link OpenSeadragon.Viewer#navigator} element.
		     *
		     * @event navigator-drag
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {OpenSeadragon.Point} delta - The x,y components of the difference between start drag and end drag.
		     * @property {Number} speed - Current computed speed, in pixels per second.
		     * @property {Number} direction - Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     * @property {Boolean} preventDefaultAction - Set to true to prevent default drag to pan behaviour. Default: false.
		     */
		     this.viewer.raiseEvent('navigator-drag', canvasDragEventArgs);

		     if ( !canvasDragEventArgs.preventDefaultAction && this.viewer.viewport ) {
		       if( !this.panHorizontal ){
		            event.delta.x = 0;
		        }
		        if( !this.panVertical ){
		            event.delta.y = 0;
		        }

		        if(this.viewer.viewport.flipped){
		            event.delta.x = -event.delta.x;
		        }

		        this.viewer.viewport.panBy(
		            this.viewport.deltaPointsFromPixels(
		                event.delta
		            )
		        );
		        if( this.viewer.constrainDuringPan ){
		            this.viewer.viewport.applyConstraints();
		        }
		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onCanvasRelease( event ) {
		    if ( event.insideElementPressed && this.viewer.viewport ) {
		        this.viewer.viewport.applyConstraints();
		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onCanvasScroll( event ) {
		    var eventArgs = {
		        tracker: event.eventSource,
		        position: event.position,
		        scroll: event.scroll,
		        shift: event.shift,
		        originalEvent: event.originalEvent,
		        preventDefault: event.preventDefault
		    };

		    /**
		     * Raised when a scroll event occurs on the {@link OpenSeadragon.Viewer#navigator} element (mouse wheel, touch pinch, etc.).
		     *
		     * @event navigator-scroll
		     * @memberof OpenSeadragon.Viewer
		     * @type {object}
		     * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		     * @property {OpenSeadragon.MouseTracker} tracker - A reference to the MouseTracker which originated this event.
		     * @property {OpenSeadragon.Point} position - The position of the event relative to the tracked element.
		     * @property {Number} scroll - The scroll delta for the event.
		     * @property {Boolean} shift - True if the shift key was pressed during this event.
		     * @property {Object} originalEvent - The original DOM event.
		     * @property {Boolean} preventDefault - Set to true to prevent the default user-agent's handling of the wheel event.
		     * @property {?Object} userData - Arbitrary subscriber-defined object.
		     */
		    this.viewer.raiseEvent( 'navigator-scroll', eventArgs );

		    event.preventDefault = eventArgs.preventDefault;
		}

		/**
		    * @function
		    * @private
		    * @param {Object} element
		    * @param {Number} degrees
		    */
		function _setTransformRotate( element, degrees ) {
		  setElementTransform(element, "rotate(" + degrees + "deg)");
		}

		function setElementTransform( element, rule ) {
		  element.style.webkitTransform = rule;
		  element.style.mozTransform = rule;
		  element.style.msTransform = rule;
		  element.style.oTransform = rule;
		  element.style.transform = rule;
		}

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - getString/setString
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		//TODO: I guess this is where the i18n needs to be reimplemented.  I'll look
		//      into existing patterns for i18n in javascript but i think that mimicking
		//      pythons gettext might be a reasonable approach.
		var I18N = {
		    Errors: {
		        Dzc:            "Sorry, we don't support Deep Zoom Collections!",
		        Dzi:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
		        Xml:            "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
		        ImageFormat:    "Sorry, we don't support {0}-based Deep Zoom Images.",
		        Security:       "It looks like a security restriction stopped us from " +
		                        "loading this Deep Zoom Image.",
		        Status:         "This space unintentionally left blank ({0} {1}).",
		        OpenFailed:     "Unable to open {0}: {1}"
		    },

		    Tooltips: {
		        FullPage:       "Toggle full page",
		        Home:           "Go home",
		        ZoomIn:         "Zoom in",
		        ZoomOut:        "Zoom out",
		        NextPage:       "Next page",
		        PreviousPage:   "Previous page",
		        RotateLeft:     "Rotate left",
		        RotateRight:    "Rotate right",
		        Flip:           "Flip Horizontally"
		    }
		};

		$.extend( $, /** @lends OpenSeadragon */{

		    /**
		     * @function
		     * @param {String} property
		     */
		    getString: function( prop ) {

		        var props   = prop.split('.'),
		            string  = null,
		            args    = arguments,
		            container = I18N,
		            i;

		        for (i = 0; i < props.length - 1; i++) {
		            // in case not a subproperty
		            container = container[ props[ i ] ] || {};
		        }
		        string = container[ props[ i ] ];

		        if ( typeof ( string ) !== "string" ) {
		            $.console.error( "Untranslated source string:", prop );
		            string = ""; // FIXME: this breaks gettext()-style convention, which would return source
		        }

		        return string.replace(/\{\d+\}/g, function(capture) {
		            var i = parseInt( capture.match( /\d+/ ), 10 ) + 1;
		            return i < args.length ?
		                args[ i ] :
		                "";
		        });
		    },

		    /**
		     * @function
		     * @param {String} property
		     * @param {*} value
		     */
		    setString: function( prop, value ) {

		        var props     = prop.split('.'),
		            container = I18N,
		            i;

		        for ( i = 0; i < props.length - 1; i++ ) {
		            if ( !container[ props[ i ] ] ) {
		                container[ props[ i ] ] = {};
		            }
		            container = container[ props[ i ] ];
		        }

		        container[ props[ i ] ] = value;
		    }

		});

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Point
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class Point
		 * @classdesc A Point is really used as a 2-dimensional vector, equally useful for
		 * representing a point on a plane, or the height and width of a plane
		 * not requiring any other frame of reference.
		 *
		 * @memberof OpenSeadragon
		 * @param {Number} [x] The vector component 'x'. Defaults to the origin at 0.
		 * @param {Number} [y] The vector component 'y'. Defaults to the origin at 0.
		 */
		$.Point = function( x, y ) {
		    /**
		     * The vector component 'x'.
		     * @member {Number} x
		     * @memberof OpenSeadragon.Point#
		     */
		    this.x = typeof ( x ) === "number" ? x : 0;
		    /**
		     * The vector component 'y'.
		     * @member {Number} y
		     * @memberof OpenSeadragon.Point#
		     */
		    this.y = typeof ( y ) === "number" ? y : 0;
		};

		/** @lends OpenSeadragon.Point.prototype */
		$.Point.prototype = {
		    /**
		     * @function
		     * @returns {OpenSeadragon.Point} a duplicate of this Point
		     */
		    clone: function() {
		        return new $.Point(this.x, this.y);
		    },

		    /**
		     * Add another Point to this point and return a new Point.
		     * @function
		     * @param {OpenSeadragon.Point} point The point to add vector components.
		     * @returns {OpenSeadragon.Point} A new point representing the sum of the
		     *  vector components
		     */
		    plus: function( point ) {
		        return new $.Point(
		            this.x + point.x,
		            this.y + point.y
		        );
		    },

		    /**
		     * Subtract another Point to this point and return a new Point.
		     * @function
		     * @param {OpenSeadragon.Point} point The point to subtract vector components.
		     * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
		     *  vector components
		     */
		    minus: function( point ) {
		        return new $.Point(
		            this.x - point.x,
		            this.y - point.y
		        );
		    },

		    /**
		     * Multiply this point by a factor and return a new Point.
		     * @function
		     * @param {Number} factor The factor to multiply vector components.
		     * @returns {OpenSeadragon.Point} A new point representing the multiplication
		     *  of the vector components by the factor
		     */
		    times: function( factor ) {
		        return new $.Point(
		            this.x * factor,
		            this.y * factor
		        );
		    },

		    /**
		     * Divide this point by a factor and return a new Point.
		     * @function
		     * @param {Number} factor The factor to divide vector components.
		     * @returns {OpenSeadragon.Point} A new point representing the division of the
		     *  vector components by the factor
		     */
		    divide: function( factor ) {
		        return new $.Point(
		            this.x / factor,
		            this.y / factor
		        );
		    },

		    /**
		     * Compute the opposite of this point and return a new Point.
		     * @function
		     * @returns {OpenSeadragon.Point} A new point representing the opposite of the
		     *  vector components
		     */
		    negate: function() {
		        return new $.Point( -this.x, -this.y );
		    },

		    /**
		     * Compute the distance between this point and another point.
		     * @function
		     * @param {OpenSeadragon.Point} point The point to compute the distance with.
		     * @returns {Number} The distance between the 2 points
		     */
		    distanceTo: function( point ) {
		        return Math.sqrt(
		            Math.pow( this.x - point.x, 2 ) +
		            Math.pow( this.y - point.y, 2 )
		        );
		    },

		    /**
		     * Compute the squared distance between this point and another point.
		     * Useful for optimizing things like comparing distances.
		     * @function
		     * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
		     * @returns {Number} The squared distance between the 2 points
		     */
		    squaredDistanceTo: function( point ) {
		        return Math.pow( this.x - point.x, 2 ) +
		            Math.pow( this.y - point.y, 2 );
		    },

		    /**
		     * Apply a function to each coordinate of this point and return a new point.
		     * @function
		     * @param {function} func The function to apply to each coordinate.
		     * @returns {OpenSeadragon.Point} A new point with the coordinates computed
		     * by the specified function
		     */
		    apply: function( func ) {
		        return new $.Point( func( this.x ), func( this.y ) );
		    },

		    /**
		     * Check if this point is equal to another one.
		     * @function
		     * @param {OpenSeadragon.Point} point The point to compare this point with.
		     * @returns {Boolean} true if they are equal, false otherwise.
		     */
		    equals: function( point ) {
		        return (
		            point instanceof $.Point
		        ) && (
		            this.x === point.x
		        ) && (
		            this.y === point.y
		        );
		    },

		    /**
		     * Rotates the point around the specified pivot
		     * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
		     * @function
		     * @param {Number} degress to rotate around the pivot.
		     * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
		     * Defaults to the origin.
		     * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
		     */
		    rotate: function (degrees, pivot) {
		        pivot = pivot || new $.Point(0, 0);
		        var cos;
		        var sin;
		        // Avoid float computations when possible
		        if (degrees % 90 === 0) {
		            var d = $.positiveModulo(degrees, 360);
		            switch (d) {
		                case 0:
		                    cos = 1;
		                    sin = 0;
		                    break;
		                case 90:
		                    cos = 0;
		                    sin = 1;
		                    break;
		                case 180:
		                    cos = -1;
		                    sin = 0;
		                    break;
		                case 270:
		                    cos = 0;
		                    sin = -1;
		                    break;
		            }
		        } else {
		            var angle = degrees * Math.PI / 180.0;
		            cos = Math.cos(angle);
		            sin = Math.sin(angle);
		        }
		        var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
		        var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
		        return new $.Point(x, y);
		    },

		    /**
		     * Convert this point to a string in the format (x,y) where x and y are
		     * rounded to the nearest integer.
		     * @function
		     * @returns {String} A string representation of this point.
		     */
		    toString: function() {
		        return "(" + (Math.round(this.x * 100) / 100) + "," + (Math.round(this.y * 100) / 100) + ")";
		    }
		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - TileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){


		/**
		 * @class TileSource
		 * @classdesc The TileSource contains the most basic implementation required to create a
		 * smooth transition between layers in an image pyramid. It has only a single key
		 * interface that must be implemented to complete its key functionality:
		 * 'getTileUrl'.  It also has several optional interfaces that can be
		 * implemented if a new TileSource wishes to support configuration via a simple
		 * object or array ('configure') and if the tile source supports or requires
		 * configuration via retrieval of a document on the network ala AJAX or JSONP,
		 * ('getImageInfo').
		 * <br/>
		 * By default the image pyramid is split into N layers where the image's longest
		 * side in M (in pixels), where N is the smallest integer which satisfies
		 *      <strong>2^(N+1) >= M</strong>.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.EventSource
		 * @param {Object} options
		 *      You can either specify a URL, or literally define the TileSource (by specifying
		 *      width, height, tileSize, tileOverlap, minLevel, and maxLevel). For the former,
		 *      the extending class is expected to implement 'getImageInfo' and 'configure'.
		 *      For the latter, the construction is assumed to occur through
		 *      the extending classes implementation of 'configure'.
		 * @param {String} [options.url]
		 *      The URL for the data necessary for this TileSource.
		 * @param {String} [options.referenceStripThumbnailUrl]
		 *      The URL for a thumbnail image to be used by the reference strip
		 * @param {Function} [options.success]
		 *      A function to be called upon successful creation.
		 * @param {Boolean} [options.ajaxWithCredentials]
		 *      If this TileSource needs to make an AJAX call, this specifies whether to set
		 *      the XHR's withCredentials (for accessing secure data).
		 * @param {Object} [options.ajaxHeaders]
		 *      A set of headers to include in AJAX requests.
		 * @param {Boolean} [options.splitHashDataForPost]
		 *      First occurrence of '#' in the options.url is used to split URL
		 *      and the latter part is treated as POST data (applies to getImageInfo(...))
		 * @param {Number} [options.width]
		 *      Width of the source image at max resolution in pixels.
		 * @param {Number} [options.height]
		 *      Height of the source image at max resolution in pixels.
		 * @param {Number} [options.tileSize]
		 *      The size of the tiles to assumed to make up each pyramid layer in pixels.
		 *      Tile size determines the point at which the image pyramid must be
		 *      divided into a matrix of smaller images.
		 *      Use options.tileWidth and options.tileHeight to support non-square tiles.
		 * @param {Number} [options.tileWidth]
		 *      The width of the tiles to assumed to make up each pyramid layer in pixels.
		 * @param {Number} [options.tileHeight]
		 *      The height of the tiles to assumed to make up each pyramid layer in pixels.
		 * @param {Number} [options.tileOverlap]
		 *      The number of pixels each tile is expected to overlap touching tiles.
		 * @param {Number} [options.minLevel]
		 *      The minimum level to attempt to load.
		 * @param {Number} [options.maxLevel]
		 *      The maximum level to attempt to load.
		 */
		$.TileSource = function( width, height, tileSize, tileOverlap, minLevel, maxLevel ) {
		    var _this = this;

		    var args = arguments,
		        options,
		        i;

		    if( $.isPlainObject( width ) ){
		        options = width;
		    }else {
		        options = {
		            width: args[0],
		            height: args[1],
		            tileSize: args[2],
		            tileOverlap: args[3],
		            minLevel: args[4],
		            maxLevel: args[5]
		        };
		    }

		    //Tile sources supply some events, namely 'ready' when they must be configured
		    //by asynchronously fetching their configuration data.
		    $.EventSource.call( this );

		    //we allow options to override anything we don't treat as
		    //required via idiomatic options or which is functionally
		    //set depending on the state of the readiness of this tile
		    //source
		    $.extend( true, this, options );

		    if (!this.success) {
		        //Any functions that are passed as arguments are bound to the ready callback
		        for ( i = 0; i < arguments.length; i++ ) {
		            if ( $.isFunction( arguments[ i ] ) ) {
		                this.success = arguments[ i ];
		                //only one callback per constructor
		                break;
		            }
		        }
		    }

		    if (this.success) {
		        this.addHandler( 'ready', function ( event ) {
		            _this.success( event );
		        } );
		    }

		    /**
		     * Ratio of width to height
		     * @member {Number} aspectRatio
		     * @memberof OpenSeadragon.TileSource#
		     */
		    /**
		     * Vector storing x and y dimensions ( width and height respectively ).
		     * @member {OpenSeadragon.Point} dimensions
		     * @memberof OpenSeadragon.TileSource#
		     */
		    /**
		     * The overlap in pixels each tile shares with its adjacent neighbors.
		     * @member {Number} tileOverlap
		     * @memberof OpenSeadragon.TileSource#
		     */
		    /**
		     * The minimum pyramid level this tile source supports or should attempt to load.
		     * @member {Number} minLevel
		     * @memberof OpenSeadragon.TileSource#
		     */
		    /**
		     * The maximum pyramid level this tile source supports or should attempt to load.
		     * @member {Number} maxLevel
		     * @memberof OpenSeadragon.TileSource#
		     */
		    /**
		     *
		     * @member {Boolean} ready
		     * @memberof OpenSeadragon.TileSource#
		     */

		    if( 'string' === $.type( arguments[ 0 ] ) ){
		        this.url = arguments[0];
		    }

		    if (this.url) {
		        //in case the getImageInfo method is overridden and/or implies an
		        //async mechanism set some safe defaults first
		        this.aspectRatio = 1;
		        this.dimensions  = new $.Point( 10, 10 );
		        this._tileWidth  = 0;
		        this._tileHeight = 0;
		        this.tileOverlap = 0;
		        this.minLevel    = 0;
		        this.maxLevel    = 0;
		        this.ready       = false;
		        //configuration via url implies the extending class
		        //implements and 'configure'
		        this.getImageInfo( this.url );

		    } else {

		        //explicit configuration via positional args in constructor
		        //or the more idiomatic 'options' object
		        this.ready       = true;
		        this.aspectRatio = (options.width && options.height) ?
		            (options.width / options.height) : 1;
		        this.dimensions  = new $.Point( options.width, options.height );

		        if ( this.tileSize ){
		            this._tileWidth = this._tileHeight = this.tileSize;
		            delete this.tileSize;
		        } else {
		            if( this.tileWidth ){
		                // We were passed tileWidth in options, but we want to rename it
		                // with a leading underscore to make clear that it is not safe to directly modify it
		                this._tileWidth = this.tileWidth;
		                delete this.tileWidth;
		            } else {
		                this._tileWidth = 0;
		            }

		            if( this.tileHeight ){
		                // See note above about renaming this.tileWidth
		                this._tileHeight = this.tileHeight;
		                delete this.tileHeight;
		            } else {
		                this._tileHeight = 0;
		            }
		        }

		        this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
		        this.minLevel    = options.minLevel ? options.minLevel : 0;
		        this.maxLevel    = ( undefined !== options.maxLevel && null !== options.maxLevel ) ?
		            options.maxLevel : (
		                ( options.width && options.height ) ? Math.ceil(
		                    Math.log( Math.max( options.width, options.height ) ) /
		                    Math.log( 2 )
		                ) : 0
		            );
		        if( this.success && $.isFunction( this.success ) ){
		            this.success( this );
		        }
		    }


		};

		/** @lends OpenSeadragon.TileSource.prototype */
		$.TileSource.prototype = {

		    getTileSize: function( level ) {
		        $.console.error(
		            "[TileSource.getTileSize] is deprecated. " +
		            "Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
		        );
		        return this._tileWidth;
		    },

		    /**
		     * Return the tileWidth for a given level.
		     * Subclasses should override this if tileWidth can be different at different levels
		     *   such as in IIIFTileSource.  Code should use this function rather than reading
		     *   from ._tileWidth directly.
		     * @function
		     * @param {Number} level
		     */
		    getTileWidth: function( level ) {
		        if (!this._tileWidth) {
		            return this.getTileSize(level);
		        }
		        return this._tileWidth;
		    },

		    /**
		     * Return the tileHeight for a given level.
		     * Subclasses should override this if tileHeight can be different at different levels
		     *   such as in IIIFTileSource.  Code should use this function rather than reading
		     *   from ._tileHeight directly.
		     * @function
		     * @param {Number} level
		     */
		    getTileHeight: function( level ) {
		        if (!this._tileHeight) {
		            return this.getTileSize(level);
		        }
		        return this._tileHeight;
		    },

		    /**
		     * Set the maxLevel to the given level, and perform the memoization of
		     * getLevelScale with the new maxLevel. This function can be useful if the
		     * memoization is required before the first call of getLevelScale, or both
		     * memoized getLevelScale and maxLevel should be changed accordingly.
		     * @function
		     * @param {Number} level
		     */
		    setMaxLevel: function( level ) {
		        this.maxLevel = level;
		        this._memoizeLevelScale();
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getLevelScale: function( level ) {
		        // if getLevelScale is not memoized, we generate the memoized version
		        // at the first call and return the result
		        this._memoizeLevelScale();
		        return this.getLevelScale( level );
		    },

		    // private
		    _memoizeLevelScale: function() {
		        // see https://github.com/openseadragon/openseadragon/issues/22
		        // we use the tilesources implementation of getLevelScale to generate
		        // a memoized re-implementation
		        var levelScaleCache = {},
		            i;
		        for( i = 0; i <= this.maxLevel; i++ ){
		            levelScaleCache[ i ] = 1 / Math.pow(2, this.maxLevel - i);
		        }
		        this.getLevelScale = function( _level ){
		            return levelScaleCache[ _level ];
		        };
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getNumTiles: function( level ) {
		        var scale = this.getLevelScale( level ),
		            x = Math.ceil( scale * this.dimensions.x / this.getTileWidth(level) ),
		            y = Math.ceil( scale * this.dimensions.y / this.getTileHeight(level) );

		        return new $.Point( x, y );
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getPixelRatio: function( level ) {
		        var imageSizeScaled = this.dimensions.times( this.getLevelScale( level ) ),
		            rx = 1.0 / imageSizeScaled.x * $.pixelDensityRatio,
		            ry = 1.0 / imageSizeScaled.y * $.pixelDensityRatio;

		        return new $.Point(rx, ry);
		    },


		    /**
		     * @function
		     * @returns {Number} The highest level in this tile source that can be contained in a single tile.
		     */
		    getClosestLevel: function() {
		        var i,
		            tiles;

		        for (i = this.minLevel + 1; i <= this.maxLevel; i++){
		            tiles = this.getNumTiles(i);
		            if (tiles.x > 1 || tiles.y > 1) {
		                break;
		            }
		        }

		        return i - 1;
		    },

		    /**
		     * @function
		     * @param {Number} level
		     * @param {OpenSeadragon.Point} point
		     */
		    getTileAtPoint: function(level, point) {
		        var validPoint = point.x >= 0 && point.x <= 1 &&
		            point.y >= 0 && point.y <= 1 / this.aspectRatio;
		        $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");


		        var widthScaled = this.dimensions.x * this.getLevelScale(level);
		        var pixelX = point.x * widthScaled;
		        var pixelY = point.y * widthScaled;

		        var x = Math.floor(pixelX / this.getTileWidth(level));
		        var y = Math.floor(pixelY / this.getTileHeight(level));

		        // When point.x == 1 or point.y == 1 / this.aspectRatio we want to
		        // return the last tile of the row/column
		        if (point.x >= 1) {
		            x = this.getNumTiles(level).x - 1;
		        }
		        var EPSILON = 1e-15;
		        if (point.y >= 1 / this.aspectRatio - EPSILON) {
		            y = this.getNumTiles(level).y - 1;
		        }

		        return new $.Point(x, y);
		    },

		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
		     * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
		     * portion of the tile to use as the source of the drawing operation (in pixels), depending on
		     * the isSource parameter.
		     */
		    getTileBounds: function( level, x, y, isSource ) {
		        var dimensionsScaled = this.dimensions.times( this.getLevelScale( level ) ),
		            tileWidth = this.getTileWidth(level),
		            tileHeight = this.getTileHeight(level),
		            px = ( x === 0 ) ? 0 : tileWidth * x - this.tileOverlap,
		            py = ( y === 0 ) ? 0 : tileHeight * y - this.tileOverlap,
		            sx = tileWidth + ( x === 0 ? 1 : 2 ) * this.tileOverlap,
		            sy = tileHeight + ( y === 0 ? 1 : 2 ) * this.tileOverlap,
		            scale = 1.0 / dimensionsScaled.x;

		        sx = Math.min( sx, dimensionsScaled.x - px );
		        sy = Math.min( sy, dimensionsScaled.y - py );

		        if (isSource) {
		            return new $.Rect(0, 0, sx, sy);
		        }

		        return new $.Rect( px * scale, py * scale, sx * scale, sy * scale );
		    },


		    /**
		     * Responsible for retrieving, and caching the
		     * image metadata pertinent to this TileSources implementation.
		     * @function
		     * @param {String} url
		     * @throws {Error}
		     */
		    getImageInfo: function( url ) {
		        var _this = this,
		            callbackName,
		            callback,
		            readySource,
		            options,
		            urlParts,
		            filename,
		            lastDot;


		        if( url ) {
		            urlParts = url.split( '/' );
		            filename = urlParts[ urlParts.length - 1 ];
		            lastDot  = filename.lastIndexOf( '.' );
		            if ( lastDot > -1 ) {
		                urlParts[ urlParts.length - 1 ] = filename.slice( 0, lastDot );
		            }
		        }

		        var postData = null;
		        if (this.splitHashDataForPost) {
		            var hashIdx = url.indexOf("#");
		            if (hashIdx !== -1) {
		                postData = url.substring(hashIdx + 1);
		                url = url.substr(0, hashIdx);
		            }
		        }

		        callback = function( data ){
		            if( typeof (data) === "string" ) {
		                data = $.parseXml( data );
		            }
		            var $TileSource = $.TileSource.determineType( _this, data, url );
		            if ( !$TileSource ) {
		                /**
		                 * Raised when an error occurs loading a TileSource.
		                 *
		                 * @event open-failed
		                 * @memberof OpenSeadragon.TileSource
		                 * @type {object}
		                 * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
		                 * @property {String} message
		                 * @property {String} source
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( 'open-failed', { message: "Unable to load TileSource", source: url } );
		                return;
		            }

		            options = $TileSource.prototype.configure.apply( _this, [ data, url, postData ]);
		            if (options.ajaxWithCredentials === undefined) {
		                options.ajaxWithCredentials = _this.ajaxWithCredentials;
		            }

		            readySource = new $TileSource( options );
		            _this.ready = true;
		            /**
		             * Raised when a TileSource is opened and initialized.
		             *
		             * @event ready
		             * @memberof OpenSeadragon.TileSource
		             * @type {object}
		             * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
		             * @property {Object} tileSource
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            _this.raiseEvent( 'ready', { tileSource: readySource } );
		        };

		        if( url.match(/\.js$/) ){
		            //TODO: Its not very flexible to require tile sources to end jsonp
		            //      request for info  with a url that ends with '.js' but for
		            //      now it's the only way I see to distinguish uniformly.
		            callbackName = url.split('/').pop().replace('.js', '');
		            $.jsonp({
		                url: url,
		                async: false,
		                callbackName: callbackName,
		                callback: callback
		            });
		        } else {
		            // request info via xhr asynchronously.
		            $.makeAjaxRequest( {
		                url: url,
		                postData: postData,
		                withCredentials: this.ajaxWithCredentials,
		                headers: this.ajaxHeaders,
		                success: function( xhr ) {
		                    var data = processResponse( xhr );
		                    callback( data );
		                },
		                error: function ( xhr, exc ) {
		                    var msg;

		                    /*
		                        IE < 10 will block XHR requests to different origins. Any property access on the request
		                        object will raise an exception which we'll attempt to handle by formatting the original
		                        exception rather than the second one raised when we try to access xhr.status
		                     */
		                    try {
		                        msg = "HTTP " + xhr.status + " attempting to load TileSource: " + url;
		                    } catch ( e ) {
		                        var formattedExc;
		                        if ( typeof ( exc ) === "undefined" || !exc.toString ) {
		                            formattedExc = "Unknown error";
		                        } else {
		                            formattedExc = exc.toString();
		                        }

		                        msg = formattedExc + " attempting to load TileSource: " + url;
		                    }

		                    $.console.error(msg);

		                    /***
		                     * Raised when an error occurs loading a TileSource.
		                     *
		                     * @event open-failed
		                     * @memberof OpenSeadragon.TileSource
		                     * @type {object}
		                     * @property {OpenSeadragon.TileSource} eventSource - A reference to the TileSource which raised the event.
		                     * @property {String} message
		                     * @property {String} source
		                     * @property {String} postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		                     *      see TileSource::getPostData) or null
		                     * @property {?Object} userData - Arbitrary subscriber-defined object.
		                     */
		                    _this.raiseEvent( 'open-failed', {
		                        message: msg,
		                        source: url,
		                        postData: postData
		                    });
		                }
		            });
		        }

		    },

		    /**
		     * Responsible for determining if the particular TileSource supports the
		     * data format ( and allowed to apply logic against the url the data was
		     * loaded from, if any ). Overriding implementations are expected to do
		     * something smart with data and / or url to determine support.  Also
		     * understand that iteration order of TileSources is not guaranteed so
		     * please make sure your data or url is expressive enough to ensure a simple
		     * and sufficient mechanism for clear determination.
		     * @function
		     * @param {String|Object|Array|Document} data
		     * @param {String} url - the url the data was loaded
		     *      from if any.
		     * @returns {Boolean}
		     */
		    supports: function( data, url ) {
		        return false;
		    },

		    /**
		     * Responsible for parsing and configuring the
		     * image metadata pertinent to this TileSources implementation.
		     * This method is not implemented by this class other than to throw an Error
		     * announcing you have to implement it.  Because of the variety of tile
		     * server technologies, and various specifications for building image
		     * pyramids, this method is here to allow easy integration.
		     * @function
		     * @param {String|Object|Array|Document} data
		     * @param {String} url - the url the data was loaded
		     *      from if any.
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
		     *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
		     * @returns {Object} options - A dictionary of keyword arguments sufficient
		     *      to configure the tile source constructor (include all values you want to
		     *      instantiate the TileSource subclass with - what _options_ object should contain).
		     * @throws {Error}
		     */
		    configure: function( data, url, postData ) {
		        throw new Error( "Method not implemented." );
		    },

		    /**
		     * Responsible for retrieving the url which will return an image for the
		     * region specified by the given x, y, and level components.
		     * This method is not implemented by this class other than to throw an Error
		     * announcing you have to implement it.  Because of the variety of tile
		     * server technologies, and various specifications for building image
		     * pyramids, this method is here to allow easy integration.
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @returns {String|Function} url - A string for the url or a function that returns a url string.
		     * @throws {Error}
		     */
		    getTileUrl: function( level, x, y ) {
		        throw new Error( "Method not implemented." );
		    },

		    /**
		     * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
		     * If a value is returned, ajax issues POST request to the tile url.
		     * If null is returned, ajax issues GET request.
		     * The return value must comply to the header 'content type'.
		     *
		     * Examples (USED HEADER --> getTilePostData CODE):
		     * 'Content-type': 'application/x-www-form-urlencoded' -->
		     *   return "key1=value=1&key2=value2";
		     *
		     * 'Content-type': 'application/x-www-form-urlencoded' -->
		     *   return JSON.stringify({key: "value", number: 5});
		     *
		     * 'Content-type': 'multipart/form-data' -->
		     *   let result = new FormData();
		     *   result.append("data", myData);
		     *   return result;
		     *
		     * IMPORTANT: in case you move all the logic on image fetching
		     * to post data, you must re-define 'getTileHashKey(...)' to
		     * stay unique for different tile images.
		     *
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @returns {*|null} post data to send with tile configuration request
		     */
		    getTilePostData: function( level, x, y ) {
		        return null;
		    },

		    /**
		     * Responsible for retrieving the headers which will be attached to the image request for the
		     * region specified by the given x, y, and level components.
		     * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
		     * The headers returned here will override headers specified at the Viewer or TiledImage level.
		     * Specifying a falsy value for a header will clear its existing value set at the Viewer or
		     * TiledImage level (if any).
		     *
		     * Note that the headers of existing tiles don't automatically change when this function
		     * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
		     * and propagate the changes.
		     *
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @returns {Object}
		     */
		    getTileAjaxHeaders: function( level, x, y ) {
		        return {};
		    },

		    /**
		     * The tile cache object is uniquely determined by this key and used to lookup
		     * the image data in cache: keys should be different if images are different.
		     *
		     * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
		     * or its context2D is set manually; the cache is not used and this function
		     * is irrelevant.
		     * Note: default behaviour does not take into account post data.
		     * @param {Number} level tile level it was fetched with
		     * @param {Number} x x-coordinate in the pyramid level
		     * @param {Number} y y-coordinate in the pyramid level
		     * @param {String} url the tile was fetched with
		     * @param {Object} ajaxHeaders the tile was fetched with
		     * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
		     */
		    getTileHashKey: function(level, x, y, url, ajaxHeaders, postData) {
		        function withHeaders(hash) {
		            return ajaxHeaders ? hash + "+" + JSON.stringify(ajaxHeaders) : hash;
		        }

		        if (typeof url !== "string") {
		            return withHeaders(level + "/" + x + "_" + y);
		        }
		        return withHeaders(url);
		    },

		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     */
		    tileExists: function( level, x, y ) {
		        var numTiles = this.getNumTiles( level );
		        return level >= this.minLevel &&
		               level <= this.maxLevel &&
		               x >= 0 &&
		               y >= 0 &&
		               x < numTiles.x &&
		               y < numTiles.y;
		    },

		    /**
		     * Decide whether tiles have transparency: this is crucial for correct images blending.
		     * @returns {boolean} true if the image has transparency
		     */
		    hasTransparency: function(context2D, url, ajaxHeaders, post) {
		        return !!context2D || url.match('.png');
		    },

		    /**
		     * Download tile data.
		     * Note that if you override this function, you should override also downloadTileAbort().
		     * @param {ImageJob} context job context that you have to call finish(...) on.
		     * @param {String} [context.src] - URL of image to download.
		     * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
		     * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
		     * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
		     * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
		     * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		     *   see TileSource::getPostData) or null
		     * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
		     * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
		     *   be it successful or unsuccessful request.
		     *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
		     *   Add also reference to an ajax request if used. Provide error message in case of failure.
		     * @param {Function} [context.abort] - Called automatically when the job times out.
		     *   Usage: context.abort().
		     * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
		     *   (triggered by finish).
		     * @param {Number} [context.timeout] @private - The max number of milliseconds that
		     *   this image job may take to complete.
		     * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
		     */
		    downloadTileStart: function (context) {
		        var dataStore = context.userData,
		            image = new Image();

		        dataStore.image = image;
		        dataStore.request = null;

		        var finish = function(error) {
		            if (!image) {
		                context.finish(null, dataStore.request, "Image load failed: undefined Image instance.");
		                return;
		            }
		            image.onload = image.onerror = image.onabort = null;
		            context.finish(error ? null : image, dataStore.request, error);
		        };
		        image.onload = function () {
		            finish();
		        };
		        image.onabort = image.onerror = function() {
		            finish("Image load aborted.");
		        };

		        // Load the tile with an AJAX request if the loadWithAjax option is
		        // set. Otherwise load the image by setting the source property of the image object.
		        if (context.loadWithAjax) {
		            dataStore.request = $.makeAjaxRequest({
		                url: context.src,
		                withCredentials: context.ajaxWithCredentials,
		                headers: context.ajaxHeaders,
		                responseType: "arraybuffer",
		                postData: context.postData,
		                success: function(request) {
		                    var blb;
		                    // Make the raw data into a blob.
		                    // BlobBuilder fallback adapted from
		                    // http://stackoverflow.com/questions/15293694/blob-constructor-browser-compatibility
		                    try {
		                        blb = new window.Blob([request.response]);
		                    } catch (e) {
		                        var BlobBuilder = (
		                            window.BlobBuilder ||
		                            window.WebKitBlobBuilder ||
		                            window.MozBlobBuilder ||
		                            window.MSBlobBuilder
		                        );
		                        if (e.name === 'TypeError' && BlobBuilder) {
		                            var bb = new BlobBuilder();
		                            bb.append(request.response);
		                            blb = bb.getBlob();
		                        }
		                    }
		                    // If the blob is empty for some reason consider the image load a failure.
		                    if (blb.size === 0) {
		                        finish("Empty image response.");
		                    } else {
		                        // Create a URL for the blob data and make it the source of the image object.
		                        // This will still trigger Image.onload to indicate a successful tile load.
		                        image.src = (window.URL || window.webkitURL).createObjectURL(blb);
		                    }
		                },
		                error: function(request) {
		                    finish("Image load aborted - XHR error");
		                }
		            });
		        } else {
		            if (context.crossOriginPolicy !== false) {
		                image.crossOrigin = context.crossOriginPolicy;
		            }
		            image.src = context.src;
		        }
		    },

		    /**
		     * Provide means of aborting the execution.
		     * Note that if you override this function, you should override also downloadTileStart().
		     * @param {ImageJob} context job, the same object as with downloadTileStart(..)
		     * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
		     */
		    downloadTileAbort: function (context) {
		        if (context.userData.request) {
		            context.userData.request.abort();
		        }
		        var image = context.userData.image;
		        if (context.userData.image) {
		            image.onload = image.onerror = image.onabort = null;
		        }
		    },

		    /**
		     * Create cache object from the result of the download process. The
		     * cacheObject parameter should be used to attach the data to, there are no
		     * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
		     *
		     * Note that if you override any of *TileCache() functions, you should override all of them.
		     * @param {object} cacheObject context cache object
		     * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
		     * @param {Tile} tile instance the cache was created with
		     */
		    createTileCache: function(cacheObject, data, tile) {
		        cacheObject._data = data;
		    },

		    /**
		     * Cache object destructor, unset all properties you created to allow GC collection.
		     * Note that if you override any of *TileCache() functions, you should override all of them.
		     * @param {object} cacheObject context cache object
		     */
		    destroyTileCache: function (cacheObject) {
		        cacheObject._data = null;
		        cacheObject._renderedContext = null;
		    },

		    /**
		     * Raw data getter
		     * Note that if you override any of *TileCache() functions, you should override all of them.
		     * @param {object} cacheObject context cache object
		     * @returns {*} cache data
		     */
		    getTileCacheData: function(cacheObject) {
		        return cacheObject._data;
		    },

		    /**
		     * Compatibility image element getter
		     *  - plugins might need image representation of the data
		     *  - div HTML rendering relies on image element presence
		     * Note that if you override any of *TileCache() functions, you should override all of them.
		     *  @param {object} cacheObject context cache object
		     *  @returns {Image} cache data as an Image
		     */
		    getTileCacheDataAsImage: function(cacheObject) {
		        return cacheObject._data; //the data itself by default is Image
		    },

		    /**
		     * Compatibility context 2D getter
		     *  - most heavily used rendering method is a canvas-based approach,
		     *    convert the data to a canvas and return it's 2D context
		     * Note that if you override any of *TileCache() functions, you should override all of them.
		     * @param {object} cacheObject context cache object
		     * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
		     */
		    getTileCacheDataAsContext2D: function(cacheObject) {
		        if (!cacheObject._renderedContext) {
		            var canvas = document.createElement( 'canvas' );
		            canvas.width = cacheObject._data.width;
		            canvas.height = cacheObject._data.height;
		            cacheObject._renderedContext = canvas.getContext('2d');
		            cacheObject._renderedContext.drawImage( cacheObject._data, 0, 0 );
		            //since we are caching the prerendered image on a canvas
		            //allow the image to not be held in memory
		            cacheObject._data = null;
		        }
		        return cacheObject._renderedContext;
		    }
		};


		$.extend( true, $.TileSource.prototype, $.EventSource.prototype );


		/**
		 * Decides whether to try to process the response as xml, json, or hand back
		 * the text
		 * @private
		 * @inner
		 * @function
		 * @param {XMLHttpRequest} xhr - the completed network request
		 */
		function processResponse( xhr ){
		    var responseText = xhr.responseText,
		        status       = xhr.status,
		        statusText,
		        data;

		    if ( !xhr ) {
		        throw new Error( $.getString( "Errors.Security" ) );
		    } else if ( xhr.status !== 200 && xhr.status !== 0 ) {
		        status     = xhr.status;
		        statusText = ( status === 404 ) ?
		            "Not Found" :
		            xhr.statusText;
		        throw new Error( $.getString( "Errors.Status", status, statusText ) );
		    }

		    if( responseText.match(/^\s*<.*/) ){
		        try{
		        data = ( xhr.responseXML && xhr.responseXML.documentElement ) ?
		            xhr.responseXML :
		            $.parseXml( responseText );
		        } catch (e){
		            data = xhr.responseText;
		        }
		    }else if( responseText.match(/\s*[{[].*/) ){
		        try{
		          data = $.parseJSON(responseText);
		        } catch(e){
		          data =  responseText;
		        }
		    }else {
		        data = responseText;
		    }
		    return data;
		}


		/**
		 * Determines the TileSource Implementation by introspection of OpenSeadragon
		 * namespace, calling each TileSource implementation of 'isType'
		 * @private
		 * @inner
		 * @function
		 * @param {Object|Array|Document} data - the tile source configuration object
		 * @param {String} url - the url where the tile source configuration object was
		 *      loaded from, if any.
		 */
		$.TileSource.determineType = function( tileSource, data, url ){
		    var property;
		    for( property in OpenSeadragon ){
		        if( property.match(/.+TileSource$/) &&
		            $.isFunction( OpenSeadragon[ property ] ) &&
		            $.isFunction( OpenSeadragon[ property ].prototype.supports ) &&
		            OpenSeadragon[ property ].prototype.supports.call( tileSource, data, url )
		        ){
		            return OpenSeadragon[ property ];
		        }
		    }

		    $.console.error( "No TileSource was able to open %s %s", url, data );

		    return null;
		};


		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - DziTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class DziTileSource
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.TileSource
		 * @param {Number|Object} width - the pixel width of the image or the idiomatic
		 *      options object which is used instead of positional arguments.
		 * @param {Number} height
		 * @param {Number} tileSize
		 * @param {Number} tileOverlap
		 * @param {String} tilesUrl
		 * @param {String} fileFormat
		 * @param {OpenSeadragon.DisplayRect[]} displayRects
		 * @property {String} tilesUrl
		 * @property {String} fileFormat
		 * @property {OpenSeadragon.DisplayRect[]} displayRects
		 */
		$.DziTileSource = function( width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel ) {
		    var i,
		        rect,
		        level,
		        options;

		    if( $.isPlainObject( width ) ){
		        options = width;
		    }else {
		        options = {
		            width: arguments[ 0 ],
		            height: arguments[ 1 ],
		            tileSize: arguments[ 2 ],
		            tileOverlap: arguments[ 3 ],
		            tilesUrl: arguments[ 4 ],
		            fileFormat: arguments[ 5 ],
		            displayRects: arguments[ 6 ],
		            minLevel: arguments[ 7 ],
		            maxLevel: arguments[ 8 ]
		        };
		    }

		    this._levelRects  = {};
		    this.tilesUrl     = options.tilesUrl;
		    this.fileFormat   = options.fileFormat;
		    this.displayRects = options.displayRects;

		    if ( this.displayRects ) {
		        for ( i = this.displayRects.length - 1; i >= 0; i-- ) {
		            rect = this.displayRects[ i ];
		            for ( level = rect.minLevel; level <= rect.maxLevel; level++ ) {
		                if ( !this._levelRects[ level ] ) {
		                    this._levelRects[ level ] = [];
		                }
		                this._levelRects[ level ].push( rect );
		            }
		        }
		    }

		    $.TileSource.apply( this, [ options ] );

		};

		$.extend( $.DziTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.DziTileSource.prototype */{


		    /**
		     * Determine if the data and/or url imply the image service is supported by
		     * this tile source.
		     * @function
		     * @param {Object|Array} data
		     * @param {String} optional - url
		     */
		    supports: function( data, url ){
		        var ns;
		        if ( data.Image ) {
		            ns = data.Image.xmlns;
		        } else if ( data.documentElement) {
		            if ("Image" === data.documentElement.localName || "Image" === data.documentElement.tagName) {
		                ns = data.documentElement.namespaceURI;
		            }
		        }

		        ns = (ns || '').toLowerCase();

		        return (ns.indexOf('schemas.microsoft.com/deepzoom/2008') !== -1 ||
		            ns.indexOf('schemas.microsoft.com/deepzoom/2009') !== -1);
		    },

		    /**
		     *
		     * @function
		     * @param {Object|XMLDocument} data - the raw configuration
		     * @param {String} url - the url the data was retrieved from if any.
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		     * @returns {Object} options - A dictionary of keyword arguments sufficient
		     *      to configure this tile sources constructor.
		     */
		    configure: function( data, url, postData ){

		        var options;

		        if( !$.isPlainObject(data) ){

		            options = configureFromXML( this, data );

		        }else {

		            options = configureFromObject( this, data );
		        }

		        if (url && !options.tilesUrl) {
		            options.tilesUrl = url.replace(
		                    /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/, '$1_files/');

		            if (url.search(/\.(dzi|xml|js)\?/) !== -1) {
		                options.queryParams = url.match(/\?.*/);
		            }else {
		                options.queryParams = '';
		            }
		        }

		        return options;
		    },


		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     */
		    getTileUrl: function( level, x, y ) {
		        return [ this.tilesUrl, level, '/', x, '_', y, '.', this.fileFormat, this.queryParams ].join( '' );
		    },


		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     */
		    tileExists: function( level, x, y ) {
		        var rects = this._levelRects[ level ],
		            rect,
		            scale,
		            xMin,
		            yMin,
		            xMax,
		            yMax,
		            i;

		        if ((this.minLevel && level < this.minLevel) || (this.maxLevel && level > this.maxLevel)) {
		            return false;
		        }

		        if ( !rects || !rects.length ) {
		            return true;
		        }

		        for ( i = rects.length - 1; i >= 0; i-- ) {
		            rect = rects[ i ];

		            if ( level < rect.minLevel || level > rect.maxLevel ) {
		                continue;
		            }

		            scale = this.getLevelScale( level );
		            xMin = rect.x * scale;
		            yMin = rect.y * scale;
		            xMax = xMin + rect.width * scale;
		            yMax = yMin + rect.height * scale;

		            xMin = Math.floor( xMin / this._tileWidth );
		            yMin = Math.floor( yMin / this._tileWidth ); // DZI tiles are square, so we just use _tileWidth
		            xMax = Math.ceil( xMax / this._tileWidth );
		            yMax = Math.ceil( yMax / this._tileWidth );

		            if ( xMin <= x && x < xMax && yMin <= y && y < yMax ) {
		                return true;
		            }
		        }

		        return false;
		    }
		});


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function configureFromXML( tileSource, xmlDoc ){

		    if ( !xmlDoc || !xmlDoc.documentElement ) {
		        throw new Error( $.getString( "Errors.Xml" ) );
		    }

		    var root           = xmlDoc.documentElement,
		        rootName       = root.localName || root.tagName,
		        ns             = xmlDoc.documentElement.namespaceURI,
		        configuration  = null,
		        displayRects   = [],
		        dispRectNodes,
		        dispRectNode,
		        rectNode,
		        sizeNode,
		        i;

		    if ( rootName === "Image" ) {

		        try {
		            sizeNode = root.getElementsByTagName("Size" )[ 0 ];
		            if (sizeNode === undefined) {
		                sizeNode = root.getElementsByTagNameNS(ns, "Size" )[ 0 ];
		            }

		            configuration = {
		                Image: {
		                    xmlns:       "http://schemas.microsoft.com/deepzoom/2008",
		                    Url:         root.getAttribute( "Url" ),
		                    Format:      root.getAttribute( "Format" ),
		                    DisplayRect: null,
		                    Overlap:     parseInt( root.getAttribute( "Overlap" ), 10 ),
		                    TileSize:    parseInt( root.getAttribute( "TileSize" ), 10 ),
		                    Size: {
		                        Height: parseInt( sizeNode.getAttribute( "Height" ), 10 ),
		                        Width:  parseInt( sizeNode.getAttribute( "Width" ), 10 )
		                    }
		                }
		            };

		            if ( !$.imageFormatSupported( configuration.Image.Format ) ) {
		                throw new Error(
		                    $.getString( "Errors.ImageFormat", configuration.Image.Format.toUpperCase() )
		                );
		            }

		            dispRectNodes = root.getElementsByTagName("DisplayRect" );
		            if (dispRectNodes === undefined) {
		                dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect" )[ 0 ];
		            }

		            for ( i = 0; i < dispRectNodes.length; i++ ) {
		                dispRectNode = dispRectNodes[ i ];
		                rectNode     = dispRectNode.getElementsByTagName("Rect" )[ 0 ];
		                if (rectNode === undefined) {
		                    rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect" )[ 0 ];
		                }

		                displayRects.push({
		                    Rect: {
		                        X: parseInt( rectNode.getAttribute( "X" ), 10 ),
		                        Y: parseInt( rectNode.getAttribute( "Y" ), 10 ),
		                        Width: parseInt( rectNode.getAttribute( "Width" ), 10 ),
		                        Height: parseInt( rectNode.getAttribute( "Height" ), 10 ),
		                        MinLevel: parseInt( dispRectNode.getAttribute( "MinLevel" ), 10 ),
		                        MaxLevel: parseInt( dispRectNode.getAttribute( "MaxLevel" ), 10 )
		                    }
		                });
		            }

		            if( displayRects.length ){
		                configuration.Image.DisplayRect = displayRects;
		            }

		            return configureFromObject( tileSource, configuration );

		        } catch ( e ) {
		            throw (e instanceof Error) ?
		                e :
		                new Error( $.getString("Errors.Dzi") );
		        }
		    } else if ( rootName === "Collection" ) {
		        throw new Error( $.getString( "Errors.Dzc" ) );
		    } else if ( rootName === "Error" ) {
		        var messageNode = root.getElementsByTagName("Message")[0];
		        var message = messageNode.firstChild.nodeValue;
		        throw new Error(message);
		    }

		    throw new Error( $.getString( "Errors.Dzi" ) );
		}

		/**
		 * @private
		 * @inner
		 * @function
		 */
		function configureFromObject( tileSource, configuration ){
		    var imageData     = configuration.Image,
		        tilesUrl      = imageData.Url,
		        fileFormat    = imageData.Format,
		        sizeData      = imageData.Size,
		        dispRectData  = imageData.DisplayRect || [],
		        width         = parseInt( sizeData.Width, 10 ),
		        height        = parseInt( sizeData.Height, 10 ),
		        tileSize      = parseInt( imageData.TileSize, 10 ),
		        tileOverlap   = parseInt( imageData.Overlap, 10 ),
		        displayRects  = [],
		        rectData,
		        i;

		    //TODO: need to figure out out to better handle image format compatibility
		    //      which actually includes additional file formats like xml and pdf
		    //      and plain text for various tilesource implementations to avoid low
		    //      level errors.
		    //
		    //      For now, just don't perform the check.
		    //
		    /*if ( !imageFormatSupported( fileFormat ) ) {
		        throw new Error(
		            $.getString( "Errors.ImageFormat", fileFormat.toUpperCase() )
		        );
		    }*/

		    for ( i = 0; i < dispRectData.length; i++ ) {
		        rectData = dispRectData[ i ].Rect;

		        displayRects.push( new $.DisplayRect(
		            parseInt( rectData.X, 10 ),
		            parseInt( rectData.Y, 10 ),
		            parseInt( rectData.Width, 10 ),
		            parseInt( rectData.Height, 10 ),
		            parseInt( rectData.MinLevel, 10 ),
		            parseInt( rectData.MaxLevel, 10 )
		        ));
		    }

		    return $.extend(true, {
		        width: width, /* width *required */
		        height: height, /* height *required */
		        tileSize: tileSize, /* tileSize *required */
		        tileOverlap: tileOverlap, /* tileOverlap *required */
		        minLevel: null, /* minLevel */
		        maxLevel: null, /* maxLevel */
		        tilesUrl: tilesUrl, /* tilesUrl */
		        fileFormat: fileFormat, /* fileFormat */
		        displayRects: displayRects /* displayRects */
		    }, configuration );

		}

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - IIIFTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class IIIFTileSource
		 * @classdesc A client implementation of the International Image Interoperability Framework
		 * Format: Image API 1.0 - 2.1
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.TileSource
		 * @see http://iiif.io/api/image/
		 * @param {String} [options.tileFormat='jpg']
		 *      The extension that will be used when requiring tiles.
		 */
		$.IIIFTileSource = function( options ){

		    /* eslint-disable camelcase */

		    $.extend( true, this, options );

		    /* Normalizes v3-style 'id' keys to an "_id" internal property */
		    this._id = this["@id"] || this["id"] || this['identifier'] || null;

		    if ( !( this.height && this.width && this._id) ) {
		        throw new Error( 'IIIF required parameters (width, height, or id) not provided.' );
		    }

		    options.tileSizePerScaleFactor = {};

		    this.tileFormat = this.tileFormat || 'jpg';

		    this.version = options.version;

		    // N.B. 2.0 renamed scale_factors to scaleFactors
		    if ( this.tile_width && this.tile_height ) {
		        options.tileWidth = this.tile_width;
		        options.tileHeight = this.tile_height;
		    } else if ( this.tile_width ) {
		        options.tileSize = this.tile_width;
		    } else if ( this.tile_height ) {
		        options.tileSize = this.tile_height;
		    } else if ( this.tiles ) {
		        // Version 2.0 forwards
		        if ( this.tiles.length === 1 ) {
		            options.tileWidth  = this.tiles[0].width;
		            // Use height if provided, otherwise assume square tiles and use width.
		            options.tileHeight = this.tiles[0].height || this.tiles[0].width;
		            this.scale_factors = this.tiles[0].scaleFactors;
		        } else {
		            // Multiple tile sizes at different levels
		            this.scale_factors = [];
		            for (var t = 0; t < this.tiles.length; t++ ) {
		                for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
		                    var scaleFactor = this.tiles[t].scaleFactors[sf];
		                    this.scale_factors.push(scaleFactor);
		                    options.tileSizePerScaleFactor[scaleFactor] = {
		                        width: this.tiles[t].width,
		                        height: this.tiles[t].height || this.tiles[t].width
		                    };
		                }
		            }
		        }
		    } else if ( canBeTiled(options) ) {
		        // use the largest of tileOptions that is smaller than the short dimension
		        var shortDim = Math.min( this.height, this.width ),
		            tileOptions = [256, 512, 1024],
		            smallerTiles = [];

		        for ( var c = 0; c < tileOptions.length; c++ ) {
		            if ( tileOptions[c] <= shortDim ) {
		                smallerTiles.push( tileOptions[c] );
		            }
		        }

		        if ( smallerTiles.length > 0 ) {
		            options.tileSize = Math.max.apply( null, smallerTiles );
		        } else {
		            // If we're smaller than 256, just use the short side.
		            options.tileSize = shortDim;
		        }
		    } else if (this.sizes && this.sizes.length > 0) {
		        // This info.json can't be tiled, but we can still construct a legacy pyramid from the sizes array.
		        // In this mode, IIIFTileSource will call functions from the abstract baseTileSource or the
		        // LegacyTileSource instead of performing IIIF tiling.
		        this.emulateLegacyImagePyramid = true;

		        options.levels = constructLevels( this );
		        // use the largest available size to define tiles
		        $.extend( true, options, {
		            width: options.levels[ options.levels.length - 1 ].width,
		            height: options.levels[ options.levels.length - 1 ].height,
		            tileSize: Math.max( options.height, options.width ),
		            tileOverlap: 0,
		            minLevel: 0,
		            maxLevel: options.levels.length - 1
		        });
		        this.levels = options.levels;
		    } else {
		        $.console.error("Nothing in the info.json to construct image pyramids from");
		    }

		    if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
		        if (!this.scale_factors) {
		            options.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
		        } else {
		            var maxScaleFactor = Math.max.apply(null, this.scale_factors);
		            options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
		        }
		    }

		    // Create an array with our exact resolution sizes if these have been supplied
		    if( this.sizes ) {
		        var sizeLength = this.sizes.length;
		        if ( (sizeLength === options.maxLevel) || (sizeLength === options.maxLevel + 1) ) {
		            this.levelSizes = this.sizes.slice().sort(( size1, size2 ) => size1.width - size2.width);
		            // Need to take into account that the list may or may not include the full resolution size
		            if( sizeLength === options.maxLevel ) {
		                this.levelSizes.push( {width: this.width, height: this.height} );
		            }
		        }
		    }

		    $.TileSource.apply( this, [ options ] );
		};

		$.extend( $.IIIFTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.IIIFTileSource.prototype */{
		    /**
		     * Determine if the data and/or url imply the image service is supported by
		     * this tile source.
		     * @function
		     * @param {Object|Array} data
		     * @param {String} [url] - url
		     */

		    supports: function( data, url ) {
		        // Version 2.0 and forwards
		        if (data.protocol && data.protocol === 'http://iiif.io/api/image') {
		            return true;
		        // Version 1.1
		        } else if ( data['@context'] && (
		            data['@context'] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" ||
		            data['@context'] === "http://iiif.io/api/image/1/context.json") ) {
		            // N.B. the iiif.io context is wrong, but where the representation lives so likely to be used
		            return true;

		        // Version 1.0
		        } else if ( data.profile &&
		            data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
		            return true;
		        } else if ( data.identifier && data.width && data.height ) {
		            return true;
		        } else if ( data.documentElement &&
		            "info" === data.documentElement.tagName &&
		            "http://library.stanford.edu/iiif/image-api/ns/" ===
		                data.documentElement.namespaceURI) {
		            return true;

		        // Not IIIF
		        } else {
		            return false;
		        }
		    },

		    /**
		     * A static function used to prepare an incoming IIIF Image API info.json
		     * response for processing by the tile handler. Normalizes data for all
		     * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
		     * may be passed to the IIIFTileSource.
		     *
		     * @function
		     * @static
		     * @param {Object} data - the raw configuration
		     * @param {String} url - the url configuration was retrieved from
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		     * @returns {Object} A normalized IIIF data object
		     * @example <caption>IIIF 2.x Info Looks like this</caption>
		     * {
		     * "@context": "http://iiif.io/api/image/2/context.json",
		     * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
		     * "protocol": "http://iiif.io/api/image",
		     * "height": 1024,
		     * "width": 775,
		     * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
		     *  "profile": ["http://iiif.io/api/image/2/level1.json", {
		     *    "qualities": [ "native", "bitonal", "grey", "color" ],
		     *    "formats": [ "jpg", "png", "gif" ]
		     *   }]
		     * }
		     */
		    configure: function( data, url, postData ){
		        // Try to deduce our version and fake it upwards if needed
		        if ( !$.isPlainObject(data) ) {
		            var options = configureFromXml10( data );
		            options['@context'] = "http://iiif.io/api/image/1.0/context.json";
		            options["@id"] = url.replace('/info.xml', '');
		            options.version = 1;
		            return options;
		        } else {
		            if ( !data['@context'] ) {
		                data['@context'] = 'http://iiif.io/api/image/1.0/context.json';
		                data["@id"] = url.replace('/info.json', '');
		                data.version = 1;
		            } else {
		                var context = data['@context'];
		                if (Array.isArray(context)) {
		                    for (var i = 0; i < context.length; i++) {
		                        if (typeof context[i] === 'string' &&
		                            ( /^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) ||
		                            context[i] === 'http://library.stanford.edu/iiif/image-api/1.1/context.json' ) ) {
		                            context = context[i];
		                            break;
		                        }
		                    }
		                }
		                switch (context) {
		                    case 'http://iiif.io/api/image/1/context.json':
		                    case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
		                        data.version = 1;
		                        break;
		                    case 'http://iiif.io/api/image/2/context.json':
		                        data.version = 2;
		                        break;
		                    case 'http://iiif.io/api/image/3/context.json':
		                        data.version = 3;
		                        break;
		                    default:
		                        $.console.error('Data has a @context property which contains no known IIIF context URI.');
		                }
		            }

		            if (data.preferredFormats) {
		                for (var f = 0; f < data.preferredFormats.length; f++ ) {
		                    if ( OpenSeadragon.imageFormatSupported(data.preferredFormats[f]) ) {
		                        data.tileFormat = data.preferredFormats[f];
		                        break;
		                    }
		                }
		            }
		            return data;
		        }
		    },

		    /**
		     * Return the tileWidth for the given level.
		     * @function
		     * @param {Number} level
		     */
		    getTileWidth: function( level ) {

		        if(this.emulateLegacyImagePyramid) {
		            return $.TileSource.prototype.getTileWidth.call(this, level);
		        }

		        var scaleFactor = Math.pow(2, this.maxLevel - level);

		        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
		            return this.tileSizePerScaleFactor[scaleFactor].width;
		        }
		        return this._tileWidth;
		    },

		    /**
		     * Return the tileHeight for the given level.
		     * @function
		     * @param {Number} level
		     */
		    getTileHeight: function( level ) {

		        if(this.emulateLegacyImagePyramid) {
		            return $.TileSource.prototype.getTileHeight.call(this, level);
		        }

		        var scaleFactor = Math.pow(2, this.maxLevel - level);

		        if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
		            return this.tileSizePerScaleFactor[scaleFactor].height;
		        }
		        return this._tileHeight;
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getLevelScale: function ( level ) {

		        if(this.emulateLegacyImagePyramid) {
		            var levelScale = NaN;
		            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
		                levelScale =
		                    this.levels[level].width /
		                    this.levels[this.maxLevel].width;
		            }
		            return levelScale;
		        }

		        return $.TileSource.prototype.getLevelScale.call(this, level);
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getNumTiles: function( level ) {

		        if(this.emulateLegacyImagePyramid) {
		            var scale = this.getLevelScale(level);
		            if (scale) {
		                return new $.Point(1, 1);
		            } else {
		                return new $.Point(0, 0);
		            }
		        }

		        // Use supplied list of scaled resolution sizes if these exist
		        if( this.levelSizes ) {
		            var levelSize = this.levelSizes[level];
		            var x = Math.ceil( levelSize.width / this.getTileWidth(level) ),
		                y = Math.ceil( levelSize.height / this.getTileHeight(level) );
		            return new $.Point( x, y );
		        }
		        // Otherwise call default TileSource->getNumTiles() function
		        else {
		            return $.TileSource.prototype.getNumTiles.call(this, level);
		        }
		    },


		    /**
		     * @function
		     * @param {Number} level
		     * @param {OpenSeadragon.Point} point
		     */
		    getTileAtPoint: function( level, point ) {

		        if(this.emulateLegacyImagePyramid) {
		            return new $.Point(0, 0);
		        }

		        // Use supplied list of scaled resolution sizes if these exist
		        if( this.levelSizes ) {

		            var validPoint = point.x >= 0 && point.x <= 1 &&
		                             point.y >= 0 && point.y <= 1 / this.aspectRatio;
		            $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");

		            var widthScaled = this.levelSizes[level].width;
		            var pixelX = point.x * widthScaled;
		            var pixelY = point.y * widthScaled;

		            var x = Math.floor(pixelX / this.getTileWidth(level));
		            var y = Math.floor(pixelY / this.getTileHeight(level));

		            // When point.x == 1 or point.y == 1 / this.aspectRatio we want to
		            // return the last tile of the row/column
		            if (point.x >= 1) {
		                x = this.getNumTiles(level).x - 1;
		            }
		            var EPSILON = 1e-15;
		            if (point.y >= 1 / this.aspectRatio - EPSILON) {
		                y = this.getNumTiles(level).y - 1;
		            }

		            return new $.Point(x, y);
		        }

		        // Otherwise call default TileSource->getTileAtPoint() function
		        return $.TileSource.prototype.getTileAtPoint.call(this, level, point);
		    },


		    /**
		     * Responsible for retrieving the url which will return an image for the
		     * region specified by the given x, y, and level components.
		     * @function
		     * @param {Number} level - z index
		     * @param {Number} x
		     * @param {Number} y
		     * @throws {Error}
		     */
		    getTileUrl: function( level, x, y ){

		        if(this.emulateLegacyImagePyramid) {
		            var url = null;
		            if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
		                url = this.levels[ level ].url;
		            }
		            return url;
		        }

		        //# constants
		        var IIIF_ROTATION = '0',
		            //## get the scale (level as a decimal)
		            scale = Math.pow( 0.5, this.maxLevel - level ),
		            //# image dimensions at this level
		            levelWidth,
		            levelHeight,

		            //## iiif region
		            tileWidth,
		            tileHeight,
		            iiifTileSizeWidth,
		            iiifTileSizeHeight,
		            iiifRegion,
		            iiifTileX,
		            iiifTileY,
		            iiifTileW,
		            iiifTileH,
		            iiifSize,
		            iiifSizeW,
		            iiifSizeH,
		            iiifQuality,
		            uri;

		        // Use supplied list of scaled resolution sizes if these exist
		        if( this.levelSizes ) {
		            levelWidth = this.levelSizes[level].width;
		            levelHeight = this.levelSizes[level].height;
		        }
		        // Otherwise calculate the sizes ourselves
		        else {
		            levelWidth = Math.ceil( this.width * scale );
		            levelHeight = Math.ceil( this.height * scale );
		        }

		        tileWidth = this.getTileWidth(level);
		        tileHeight = this.getTileHeight(level);
		        iiifTileSizeWidth = Math.round( tileWidth / scale );
		        iiifTileSizeHeight = Math.round( tileHeight / scale );
		        if (this.version === 1) {
		            iiifQuality = "native." + this.tileFormat;
		        } else {
		            iiifQuality = "default." + this.tileFormat;
		        }
		        if ( levelWidth < tileWidth && levelHeight < tileHeight ){
		            if ( this.version === 2 && levelWidth === this.width ) {
		                iiifSize = "full";
		            } else if ( this.version === 3 && levelWidth === this.width && levelHeight === this.height ) {
		                iiifSize = "max";
		            } else if ( this.version === 3 ) {
		                iiifSize = levelWidth + "," + levelHeight;
		            } else {
		                iiifSize = levelWidth + ",";
		            }
		            iiifRegion = 'full';
		        } else {
		            iiifTileX = x * iiifTileSizeWidth;
		            iiifTileY = y * iiifTileSizeHeight;
		            iiifTileW = Math.min( iiifTileSizeWidth, this.width - iiifTileX );
		            iiifTileH = Math.min( iiifTileSizeHeight, this.height - iiifTileY );
		            if ( x === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height ) {
		                iiifRegion = "full";
		            } else {
		                iiifRegion = [ iiifTileX, iiifTileY, iiifTileW, iiifTileH ].join( ',' );
		            }
		            iiifSizeW = Math.min( tileWidth, levelWidth - (x * tileWidth) );
		            iiifSizeH = Math.min( tileHeight, levelHeight - (y * tileHeight) );
		            if ( this.version === 2 && iiifSizeW === this.width ) {
		                iiifSize = "full";
		            } else if ( this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height ) {
		                iiifSize = "max";
		            } else if (this.version === 3) {
		                iiifSize = iiifSizeW + "," + iiifSizeH;
		            } else {
		                iiifSize = iiifSizeW + ",";
		            }
		        }
		        uri = [ this._id, iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality ].join( '/' );

		        return uri;
		    },

		    __testonly__: {
		        canBeTiled: canBeTiled,
		        constructLevels: constructLevels
		    }

		  });

		    /**
		     * Determine whether arbitrary tile requests can be made against a service with the given profile
		     * @function
		     * @param {Object} options
		     * @param {Array|String} options.profile
		     * @param {Number} options.version
		     * @param {String[]} options.extraFeatures
		     * @returns {Boolean}
		     */
		    function canBeTiled ( options ) {
		        var level0Profiles = [
		            "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
		            "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
		            "http://iiif.io/api/image/2/level0.json",
		            "level0",
		            "https://iiif.io/api/image/3/level0.json"
		        ];
		        var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
		        var isLevel0 = (level0Profiles.indexOf(profileLevel) !== -1);
		        var hasCanoncicalSizeFeature = false;
		        if ( options.version === 2 && options.profile.length > 1 && options.profile[1].supports ) {
		            hasCanoncicalSizeFeature = options.profile[1].supports.indexOf( "sizeByW" ) !== -1;
		        }
		        if ( options.version === 3 && options.extraFeatures ) {
		            hasCanoncicalSizeFeature = options.extraFeatures.indexOf( "sizeByWh" ) !== -1;
		        }
		        return !isLevel0 || hasCanoncicalSizeFeature;
		    }

		    /**
		     * Build the legacy pyramid URLs (one tile per level)
		     * @function
		     * @param {object} options - infoJson
		     * @throws {Error}
		     */
		    function constructLevels(options) {
		        var levels = [];
		        for(var i = 0; i < options.sizes.length; i++) {
		            levels.push({
		                url: options._id + '/full/' + options.sizes[i].width + ',' +
		                    (options.version === 3 ? options.sizes[i].height : '') +
		                    '/0/default.' + options.tileFormat,
		                width: options.sizes[i].width,
		                height: options.sizes[i].height
		            });
		        }
		        return levels.sort(function(a, b) {
		            return a.width - b.width;
		        });
		    }


		    function configureFromXml10(xmlDoc) {
		        //parse the xml
		        if ( !xmlDoc || !xmlDoc.documentElement ) {
		            throw new Error( $.getString( "Errors.Xml" ) );
		        }

		        var root            = xmlDoc.documentElement,
		            rootName        = root.tagName,
		            configuration   = null;

		        if ( rootName === "info" ) {
		            try {
		                configuration = {};
		                parseXML10( root, configuration );
		                return configuration;

		            } catch ( e ) {
		                throw (e instanceof Error) ?
		                    e :
		                    new Error( $.getString("Errors.IIIF") );
		            }
		        }
		        throw new Error( $.getString( "Errors.IIIF" ) );
		    }

		    function parseXML10( node, configuration, property ) {
		        var i,
		            value;
		        if ( node.nodeType === 3 && property ) {//text node
		            value = node.nodeValue.trim();
		            if( value.match(/^\d*$/)){
		                value = Number( value );
		            }
		            if( !configuration[ property ] ){
		                configuration[ property ] = value;
		            }else {
		                if( !$.isArray( configuration[ property ] ) ){
		                    configuration[ property ] = [ configuration[ property ] ];
		                }
		                configuration[ property ].push( value );
		            }
		        } else if( node.nodeType === 1 ){
		            for( i = 0; i < node.childNodes.length; i++ ){
		                parseXML10( node.childNodes[ i ], configuration, node.nodeName );
		            }
		        }
		    }



		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - OsmTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		/*
		 * Derived from the OSM tile source in Rainer Simon's seajax-utils project
		 * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed
		 * the included code to the OpenSeadragon project under the New BSD license;
		 * see <https://github.com/openseadragon/openseadragon/issues/58>.
		 */


		(function( $ ){

		/**
		 * @class OsmTileSource
		 * @classdesc A tilesource implementation for OpenStreetMap.<br><br>
		 *
		 * Note 1. Zoomlevels. Deep Zoom and OSM define zoom levels differently. In  Deep
		 * Zoom, level 0 equals an image of 1x1 pixels. In OSM, level 0 equals an image of
		 * 256x256 levels (see http://gasi.ch/blog/inside-deep-zoom-2). I.e. there is a
		 * difference of log2(256)=8 levels.<br><br>
		 *
		 * Note 2. Image dimension. According to the OSM Wiki
		 * (http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Zoom_levels)
		 * the highest Mapnik zoom level has 256.144x256.144 tiles, with a 256x256
		 * pixel size. I.e. the Deep Zoom image dimension is 65.572.864x65.572.864
		 * pixels.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.TileSource
		 * @param {Number|Object} width - the pixel width of the image or the idiomatic
		 *      options object which is used instead of positional arguments.
		 * @param {Number} height
		 * @param {Number} tileSize
		 * @param {Number} tileOverlap
		 * @param {String} tilesUrl
		 */
		$.OsmTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
		    var options;

		    if( $.isPlainObject( width ) ){
		        options = width;
		    }else {
		        options = {
		            width: arguments[0],
		            height: arguments[1],
		            tileSize: arguments[2],
		            tileOverlap: arguments[3],
		            tilesUrl: arguments[4]
		        };
		    }
		    //apply default setting for standard public OpenStreatMaps service
		    //but allow them to be specified so fliks can host there own instance
		    //or apply against other services supportting the same standard
		    if( !options.width || !options.height ){
		        options.width = 65572864;
		        options.height = 65572864;
		    }
		    if( !options.tileSize ){
		        options.tileSize = 256;
		        options.tileOverlap = 0;
		    }
		    if( !options.tilesUrl ){
		        options.tilesUrl = "http://tile.openstreetmap.org/";
		    }
		    options.minLevel = 8;

		    $.TileSource.apply( this, [ options ] );

		};

		$.extend( $.OsmTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.OsmTileSource.prototype */{


		    /**
		     * Determine if the data and/or url imply the image service is supported by
		     * this tile source.
		     * @function
		     * @param {Object|Array} data
		     * @param {String} optional - url
		     */
		    supports: function( data, url ){
		        return (
		            data.type &&
		            "openstreetmaps" === data.type
		        );
		    },

		    /**
		     *
		     * @function
		     * @param {Object} data - the raw configuration
		     * @param {String} url - the url the data was retrieved from if any.
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		     * @returns {Object} options - A dictionary of keyword arguments sufficient
		     *      to configure this tile sources constructor.
		     */
		    configure: function( data, url, postData ){
		        return data;
		    },


		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     */
		    getTileUrl: function( level, x, y ) {
		        return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
		    }
		});


		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - TmsTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		/*
		 * Derived from the TMS tile source in Rainer Simon's seajax-utils project
		 * <http://github.com/rsimon/seajax-utils>.  Rainer Simon has contributed
		 * the included code to the OpenSeadragon project under the New BSD license;
		 * see <https://github.com/openseadragon/openseadragon/issues/58>.
		 */


		(function( $ ){

		/**
		 * @class TmsTileSource
		 * @classdesc A tilesource implementation for Tiled Map Services (TMS).
		 * TMS tile scheme ( [ as supported by OpenLayers ] is described here
		 * ( http://openlayers.org/dev/examples/tms.html ).
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.TileSource
		 * @param {Number|Object} width - the pixel width of the image or the idiomatic
		 *      options object which is used instead of positional arguments.
		 * @param {Number} height
		 * @param {Number} tileSize
		 * @param {Number} tileOverlap
		 * @param {String} tilesUrl
		 */
		$.TmsTileSource = function( width, height, tileSize, tileOverlap, tilesUrl ) {
		    var options;

		    if( $.isPlainObject( width ) ){
		        options = width;
		    }else {
		        options = {
		            width: arguments[0],
		            height: arguments[1],
		            tileSize: arguments[2],
		            tileOverlap: arguments[3],
		            tilesUrl: arguments[4]
		        };
		    }
		    // TMS has integer multiples of 256 for width/height and adds buffer
		    // if necessary -> account for this!
		    var bufferedWidth = Math.ceil(options.width / 256) * 256,
		        bufferedHeight = Math.ceil(options.height / 256) * 256,
		        max;

		    // Compute number of zoomlevels in this tileset
		    if (bufferedWidth > bufferedHeight) {
		        max = bufferedWidth / 256;
		    } else {
		        max = bufferedHeight / 256;
		    }
		    options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
		    options.tileSize = 256;
		    options.width = bufferedWidth;
		    options.height = bufferedHeight;

		    $.TileSource.apply( this, [ options ] );

		};

		$.extend( $.TmsTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.TmsTileSource.prototype */{


		    /**
		     * Determine if the data and/or url imply the image service is supported by
		     * this tile source.
		     * @function
		     * @param {Object|Array} data
		     * @param {String} optional - url
		     */
		    supports: function( data, url ){
		        return ( data.type && "tiledmapservice" === data.type );
		    },

		    /**
		     *
		     * @function
		     * @param {Object} data - the raw configuration
		     * @param {String} url - the url the data was retrieved from if any.
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		     * @returns {Object} options - A dictionary of keyword arguments sufficient
		     *      to configure this tile sources constructor.
		     */
		    configure: function( data, url, postData ){
		        return data;
		    },


		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     */
		    getTileUrl: function( level, x, y ) {
		        // Convert from Deep Zoom definition to TMS zoom definition
		        var yTiles = this.getNumTiles( level ).y - 1;

		        return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
		    }
		});


		}( OpenSeadragon ));

		(function($) {

		    /**
		     * @class ZoomifyTileSource
		     * @classdesc A tilesource implementation for the zoomify format.
		     *
		     * A description of the format can be found here:
		     * https://ecommons.cornell.edu/bitstream/handle/1813/5410/Introducing_Zoomify_Image.pdf
		     *
		     * There are two ways of creating a zoomify tilesource for openseadragon
		     *
		     * 1) Supplying all necessary information in the tilesource object. A minimal example object for this method looks like this:
		     *
		     * {
		     *      type: "zoomifytileservice",
		     *      width: 1000,
		     *      height: 1000,
		     *      tilesUrl: "/test/data/zoomify/"
		     * }
		     *
		     * The tileSize is set to 256 (the usual Zoomify default) when it is not defined. The tileUrl must the path to the image _directory_.
		     *
		     * 2) Loading image metadata from xml file: (CURRENTLY NOT SUPPORTED)
		     *
		     * When creating zoomify formatted images one "xml" like file with name ImageProperties.xml
		     * will be created as well. Here is an example of such a file:
		     *
		     * <IMAGE_PROPERTIES WIDTH="1000" HEIGHT="1000" NUMTILES="21" NUMIMAGES="1" VERSION="1.8" TILESIZE="256" />
		     *
		     * To use this xml file as metadata source you must supply the path to the ImageProperties.xml file and leave out all other parameters:
		     * As stated above, this method of loading a zoomify tilesource is currently not supported
		     *
		     * {
		     *      type: "zoomifytileservice",
		     *      tilesUrl: "/test/data/zoomify/ImageProperties.xml"
		     * }

		    *
		    * @memberof OpenSeadragon
		     * @extends OpenSeadragon.TileSource
		     * @param {Number} width - the pixel width of the image.
		     * @param {Number} height
		     * @param {Number} tileSize
		     * @param {String} tilesUrl
		     */
		    $.ZoomifyTileSource = function(options) {
		        if(typeof options.tileSize === 'undefined'){
		            options.tileSize = 256;
		        }

		        if(typeof options.fileFormat === 'undefined'){
		            options.fileFormat = 'jpg';
		            this.fileFormat = options.fileFormat;
		        }

		        var currentImageSize = {
		            x: options.width,
		            y: options.height
		        };
		        options.imageSizes = [{
		            x: options.width,
		            y: options.height
		        }];
		        options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];

		        while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
		            currentImageSize.x = Math.floor(currentImageSize.x / 2);
		            currentImageSize.y = Math.floor(currentImageSize.y / 2);
		            options.imageSizes.push({
		                x: currentImageSize.x,
		                y: currentImageSize.y
		            });
		            options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
		        }
		        options.imageSizes.reverse();
		        options.gridSize.reverse();
		        options.minLevel = 0;
		        options.maxLevel = options.gridSize.length - 1;

		        OpenSeadragon.TileSource.apply(this, [options]);
		    };

		    $.extend($.ZoomifyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ZoomifyTileSource.prototype */ {

		        //private
		        _getGridSize: function(width, height, tileSize) {
		            return {
		                x: Math.ceil(width / tileSize),
		                y: Math.ceil(height / tileSize)
		            };
		        },

		        //private
		        _calculateAbsoluteTileNumber: function(level, x, y) {
		            var num = 0;
		            var size = {};

		            //Sum up all tiles below the level we want the number of tiles
		            for (var z = 0; z < level; z++) {
		                size = this.gridSize[z];
		                num += size.x * size.y;
		            }
		            //Add the tiles of the level
		            size = this.gridSize[level];
		            num += size.x * y + x;
		            return num;
		        },

		        /**
		         * Determine if the data and/or url imply the image service is supported by
		         * this tile source.
		         * @function
		         * @param {Object|Array} data
		         * @param {String} optional - url
		         */
		        supports: function(data, url) {
		            return (data.type && "zoomifytileservice" === data.type);
		        },

		        /**
		         *
		         * @function
		         * @param {Object} data - the raw configuration
		         * @param {String} url - the url the data was retrieved from if any.
		         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		         * @returns {Object} options - A dictionary of keyword arguments sufficient
		         *      to configure this tile sources constructor.
		         */
		        configure: function(data, url, postData) {
		            return data;
		        },

		        /**
		         * @function
		         * @param {Number} level
		         * @param {Number} x
		         * @param {Number} y
		         */
		        getTileUrl: function(level, x, y) {
		            //console.log(level);
		            var result = 0;
		            var num = this._calculateAbsoluteTileNumber(level, x, y);
		            result = Math.floor(num / 256);
		            return this.tilesUrl + 'TileGroup' + result + '/' + level + '-' + x + '-' + y + '.' + this.fileFormat;

		        }
		    });

		}(OpenSeadragon));


		/*
		 * OpenSeadragon - LegacyTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class LegacyTileSource
		 * @classdesc The LegacyTileSource allows simple, traditional image pyramids to be loaded
		 * into an OpenSeadragon Viewer.  Basically, this translates to the historically
		 * common practice of starting with a 'master' image, maybe a tiff for example,
		 * and generating a set of 'service' images like one or more thumbnails, a medium
		 * resolution image and a high resolution image in standard web formats like
		 * png or jpg.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.TileSource
		 * @param {Array} levels An array of file descriptions, each is an object with
		 *      a 'url', a 'width', and a 'height'.  Overriding classes can expect more
		 *      properties but these properties are sufficient for this implementation.
		 *      Additionally, the levels are required to be listed in order from
		 *      smallest to largest.
		 * @property {Number} aspectRatio
		 * @property {Number} dimensions
		 * @property {Number} tileSize
		 * @property {Number} tileOverlap
		 * @property {Number} minLevel
		 * @property {Number} maxLevel
		 * @property {Array}  levels
		 */
		$.LegacyTileSource = function( levels ) {

		    var options,
		        width,
		        height;

		    if( $.isArray( levels ) ){
		        options = {
		            type: 'legacy-image-pyramid',
		            levels: levels
		        };
		    }

		    //clean up the levels to make sure we support all formats
		    options.levels = filterFiles( options.levels );

		    if ( options.levels.length > 0 ) {
		        width = options.levels[ options.levels.length - 1 ].width;
		        height = options.levels[ options.levels.length - 1 ].height;
		    }
		    else {
		        width = 0;
		        height = 0;
		        $.console.error( "No supported image formats found" );
		    }

		    $.extend( true, options, {
		        width: width,
		        height: height,
		        tileSize: Math.max( height, width ),
		        tileOverlap: 0,
		        minLevel: 0,
		        maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
		    } );

		    $.TileSource.apply( this, [ options ] );

		    this.levels = options.levels;
		};

		$.extend( $.LegacyTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.LegacyTileSource.prototype */{
		    /**
		     * Determine if the data and/or url imply the image service is supported by
		     * this tile source.
		     * @function
		     * @param {Object|Array} data
		     * @param {String} optional - url
		     */
		    supports: function( data, url ){
		        return (
		            data.type &&
		            "legacy-image-pyramid" === data.type
		        ) || (
		            data.documentElement &&
		            "legacy-image-pyramid" === data.documentElement.getAttribute('type')
		        );
		    },


		    /**
		     *
		     * @function
		     * @param {Object|XMLDocument} configuration - the raw configuration
		     * @param {String} dataUrl - the url the data was retrieved from if any.
		     * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		     * @returns {Object} options - A dictionary of keyword arguments sufficient
		     *      to configure this tile sources constructor.
		     */
		    configure: function( configuration, dataUrl, postData ){

		        var options;

		        if( !$.isPlainObject(configuration) ){

		            options = configureFromXML( this, configuration );

		        }else {

		            options = configureFromObject( this, configuration );
		        }

		        return options;

		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getLevelScale: function ( level ) {
		        var levelScale = NaN;
		        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
		            levelScale =
		                this.levels[ level ].width /
		                this.levels[ this.maxLevel ].width;
		        }
		        return levelScale;
		    },

		    /**
		     * @function
		     * @param {Number} level
		     */
		    getNumTiles: function( level ) {
		        var scale = this.getLevelScale( level );
		        if ( scale ){
		            return new $.Point( 1, 1 );
		        } else {
		            return new $.Point( 0, 0 );
		        }
		    },

		    /**
		     * This method is not implemented by this class other than to throw an Error
		     * announcing you have to implement it.  Because of the variety of tile
		     * server technologies, and various specifications for building image
		     * pyramids, this method is here to allow easy integration.
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @throws {Error}
		     */
		    getTileUrl: function ( level, x, y ) {
		        var url = null;
		        if ( this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel ) {
		            url = this.levels[ level ].url;
		        }
		        return url;
		    }
		} );

		/**
		 * This method removes any files from the Array which don't conform to our
		 * basic requirements for a 'level' in the LegacyTileSource.
		 * @private
		 * @inner
		 * @function
		 */
		function filterFiles( files ){
		    var filtered = [],
		        file,
		        i;
		    for( i = 0; i < files.length; i++ ){
		        file = files[ i ];
		        if( file.height &&
		            file.width &&
		            file.url ){
		            //This is sufficient to serve as a level
		            filtered.push({
		                url: file.url,
		                width: Number( file.width ),
		                height: Number( file.height )
		            });
		        }
		        else {
		            $.console.error( 'Unsupported image format: %s', file.url ? file.url : '<no URL>' );
		        }
		    }

		    return filtered.sort(function(a, b) {
		        return a.height - b.height;
		    });

		}

		/**
		 * @private
		 * @inner
		 * @function
		 */
		function configureFromXML( tileSource, xmlDoc ){

		    if ( !xmlDoc || !xmlDoc.documentElement ) {
		        throw new Error( $.getString( "Errors.Xml" ) );
		    }

		    var root         = xmlDoc.documentElement,
		        rootName     = root.tagName,
		        conf         = null,
		        levels       = [],
		        level,
		        i;

		    if ( rootName === "image" ) {

		        try {
		            conf = {
		                type:        root.getAttribute( "type" ),
		                levels:      []
		            };

		            levels = root.getElementsByTagName( "level" );
		            for ( i = 0; i < levels.length; i++ ) {
		                level = levels[ i ];

		                conf.levels.push({
		                    url:    level.getAttribute( "url" ),
		                    width:  parseInt( level.getAttribute( "width" ), 10 ),
		                    height: parseInt( level.getAttribute( "height" ), 10 )
		                });
		            }

		            return configureFromObject( tileSource, conf );

		        } catch ( e ) {
		            throw (e instanceof Error) ?
		                e :
		                new Error( 'Unknown error parsing Legacy Image Pyramid XML.' );
		        }
		    } else if ( rootName === "collection" ) {
		        throw new Error( 'Legacy Image Pyramid Collections not yet supported.' );
		    } else if ( rootName === "error" ) {
		        throw new Error( 'Error: ' + xmlDoc );
		    }

		    throw new Error( 'Unknown element ' + rootName );
		}

		/**
		 * @private
		 * @inner
		 * @function
		 */
		function configureFromObject( tileSource, configuration ){

		    return configuration.levels;

		}

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - ImageTileSource
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function ($) {

		    /**
		     * @class ImageTileSource
		     * @classdesc The ImageTileSource allows a simple image to be loaded
		     * into an OpenSeadragon Viewer.
		     * There are 2 ways to open an ImageTileSource:
		     * 1. viewer.open({type: 'image', url: fooUrl});
		     * 2. viewer.open(new OpenSeadragon.ImageTileSource({url: fooUrl}));
		     *
		     * With the first syntax, the crossOriginPolicy and ajaxWithCredentials
		     * options are inherited from the viewer if they are not
		     * specified directly in the options object.
		     *
		     * @memberof OpenSeadragon
		     * @extends OpenSeadragon.TileSource
		     * @param {Object} options Options object.
		     * @param {String} options.url URL of the image
		     * @param {Boolean} [options.buildPyramid=true] If set to true (default), a
		     * pyramid will be built internally to provide a better downsampling.
		     * @param {String|Boolean} [options.crossOriginPolicy=false] Valid values are
		     * 'Anonymous', 'use-credentials', and false. If false, image requests will
		     * not use CORS preventing internal pyramid building for images from other
		     * domains.
		     * @param {String|Boolean} [options.ajaxWithCredentials=false] Whether to set
		     * the withCredentials XHR flag for AJAX requests (when loading tile sources).
		     */
		    $.ImageTileSource = function (options) {

		        options = $.extend({
		            buildPyramid: true,
		            crossOriginPolicy: false,
		            ajaxWithCredentials: false
		        }, options);
		        $.TileSource.apply(this, [options]);

		    };

		    $.extend($.ImageTileSource.prototype, $.TileSource.prototype, /** @lends OpenSeadragon.ImageTileSource.prototype */{
		        /**
		         * Determine if the data and/or url imply the image service is supported by
		         * this tile source.
		         * @function
		         * @param {Object|Array} data
		         * @param {String} optional - url
		         */
		        supports: function (data, url) {
		            return data.type && data.type === "image";
		        },
		        /**
		         *
		         * @function
		         * @param {Object} options - the options
		         * @param {String} dataUrl - the url the image was retrieved from, if any.
		         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
		         * @returns {Object} options - A dictionary of keyword arguments sufficient
		         *      to configure this tile sources constructor.
		         */
		        configure: function (options, dataUrl, postData) {
		            return options;
		        },
		        /**
		         * Responsible for retrieving, and caching the
		         * image metadata pertinent to this TileSources implementation.
		         * @function
		         * @param {String} url
		         * @throws {Error}
		         */
		        getImageInfo: function (url) {
		            var image = this._image = new Image();
		            var _this = this;

		            if (this.crossOriginPolicy) {
		                image.crossOrigin = this.crossOriginPolicy;
		            }
		            if (this.ajaxWithCredentials) {
		                image.useCredentials = this.ajaxWithCredentials;
		            }

		            $.addEvent(image, 'load', function () {
		                _this.width = image.naturalWidth;
		                _this.height = image.naturalHeight;
		                _this.aspectRatio = _this.width / _this.height;
		                _this.dimensions = new $.Point(_this.width, _this.height);
		                _this._tileWidth = _this.width;
		                _this._tileHeight = _this.height;
		                _this.tileOverlap = 0;
		                _this.minLevel = 0;
		                _this.levels = _this._buildLevels();
		                _this.maxLevel = _this.levels.length - 1;

		                _this.ready = true;

		                // Note: this event is documented elsewhere, in TileSource
		                _this.raiseEvent('ready', {tileSource: _this});
		            });

		            $.addEvent(image, 'error', function () {
		                // Note: this event is documented elsewhere, in TileSource
		                _this.raiseEvent('open-failed', {
		                    message: "Error loading image at " + url,
		                    source: url
		                });
		            });

		            image.src = url;
		        },
		        /**
		         * @function
		         * @param {Number} level
		         */
		        getLevelScale: function (level) {
		            var levelScale = NaN;
		            if (level >= this.minLevel && level <= this.maxLevel) {
		                levelScale =
		                        this.levels[level].width /
		                        this.levels[this.maxLevel].width;
		            }
		            return levelScale;
		        },
		        /**
		         * @function
		         * @param {Number} level
		         */
		        getNumTiles: function (level) {
		            var scale = this.getLevelScale(level);
		            if (scale) {
		                return new $.Point(1, 1);
		            } else {
		                return new $.Point(0, 0);
		            }
		        },
		        /**
		         * Retrieves a tile url
		         * @function
		         * @param {Number} level Level of the tile
		         * @param {Number} x x coordinate of the tile
		         * @param {Number} y y coordinate of the tile
		         */
		        getTileUrl: function (level, x, y) {
		            var url = null;
		            if (level >= this.minLevel && level <= this.maxLevel) {
		                url = this.levels[level].url;
		            }
		            return url;
		        },
		        /**
		         * Retrieves a tile context 2D
		         * @function
		         * @param {Number} level Level of the tile
		         * @param {Number} x x coordinate of the tile
		         * @param {Number} y y coordinate of the tile
		         */
		        getContext2D: function (level, x, y) {
		            var context = null;
		            if (level >= this.minLevel && level <= this.maxLevel) {
		                context = this.levels[level].context2D;
		            }
		            return context;
		        },
		        /**
		         * Destroys ImageTileSource
		         * @function
		         * @param {OpenSeadragon.Viewer} viewer the viewer that is calling
		         * destroy on the ImageTileSource
		         */
		        destroy: function (viewer) {
		            this._freeupCanvasMemory(viewer);
		        },

		        // private
		        //
		        // Builds the different levels of the pyramid if possible
		        // (i.e. if canvas API enabled and no canvas tainting issue).
		        _buildLevels: function () {
		            var levels = [{
		                    url: this._image.src,
		                    width: this._image.naturalWidth,
		                    height:  this._image.naturalHeight
		                }];

		            if (!this.buildPyramid || !$.supportsCanvas) {
		                // We don't need the image anymore. Allows it to be GC.
		                delete this._image;
		                return levels;
		            }

		            var currentWidth = this._image.naturalWidth;
		            var currentHeight = this._image.naturalHeight;


		            var bigCanvas = document.createElement("canvas");
		            var bigContext = bigCanvas.getContext("2d");

		            bigCanvas.width = currentWidth;
		            bigCanvas.height = currentHeight;
		            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
		            // We cache the context of the highest level because the browser
		            // is a lot faster at downsampling something it already has
		            // downsampled before.
		            levels[0].context2D = bigContext;
		            // We don't need the image anymore. Allows it to be GC.
		            delete this._image;

		            if ($.isCanvasTainted(bigCanvas)) {
		                // If the canvas is tainted, we can't compute the pyramid.
		                return levels;
		            }

		            // We build smaller levels until either width or height becomes
		            // 1 pixel wide.
		            while (currentWidth >= 2 && currentHeight >= 2) {
		                currentWidth = Math.floor(currentWidth / 2);
		                currentHeight = Math.floor(currentHeight / 2);
		                var smallCanvas = document.createElement("canvas");
		                var smallContext = smallCanvas.getContext("2d");
		                smallCanvas.width = currentWidth;
		                smallCanvas.height = currentHeight;
		                smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);

		                levels.splice(0, 0, {
		                    context2D: smallContext,
		                    width: currentWidth,
		                    height: currentHeight
		                });

		                bigCanvas = smallCanvas;
		                bigContext = smallContext;
		            }
		            return levels;
		        },
		        /**
		         * Free up canvas memory
		         * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
		         * and Safari keeps canvas until its height and width will be set to 0).
		         * @function
		         */
		        _freeupCanvasMemory: function (viewer) {
		            for (var i = 0; i < this.levels.length; i++) {
		                if(this.levels[i].context2D){
		                    this.levels[i].context2D.canvas.height = 0;
		                    this.levels[i].context2D.canvas.width = 0;

		                    if(viewer){
		                        /**
		                        * Triggered when an image has just been unloaded
		                        *
		                        * @event image-unloaded
		                        * @memberof OpenSeadragon.Viewer
		                        * @type {object}
		                        * @property {CanvasRenderingContext2D} context2D - The context that is being unloaded
		                        * @private
		                        */
		                        viewer.raiseEvent("image-unloaded", {
		                            context2D: this.levels[i].context2D
		                        });
		                    }

		                }
		            }
		        },
		    });

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - TileSourceCollection
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($) {

		// deprecated
		$.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
		    $.console.error('TileSourceCollection is deprecated; use World instead');
		};

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - Button
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * An enumeration of button states
		 * @member ButtonState
		 * @memberof OpenSeadragon
		 * @static
		 * @type {Object}
		 * @property {Number} REST
		 * @property {Number} GROUP
		 * @property {Number} HOVER
		 * @property {Number} DOWN
		 */
		$.ButtonState = {
		    REST:   0,
		    GROUP:  1,
		    HOVER:  2,
		    DOWN:   3
		};

		/**
		 * @class Button
		 * @classdesc Manages events, hover states for individual buttons, tool-tips, as well
		 * as fading the buttons out when the user has not interacted with them
		 * for a specified period.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.EventSource
		 * @param {Object} options
		 * @param {Element} [options.element=null] Element to use as the button. If not specified, an HTML &lt;div&gt; element is created.
		 * @param {String} [options.tooltip=null] Provides context help for the button when the
		 *  user hovers over it.
		 * @param {String} [options.srcRest=null] URL of image to use in 'rest' state.
		 * @param {String} [options.srcGroup=null] URL of image to use in 'up' state.
		 * @param {String} [options.srcHover=null] URL of image to use in 'hover' state.
		 * @param {String} [options.srcDown=null] URL of image to use in 'down' state.
		 * @param {Number} [options.fadeDelay=0] How long to wait before fading.
		 * @param {Number} [options.fadeLength=2000] How long should it take to fade the button.
		 * @param {OpenSeadragon.EventHandler} [options.onPress=null] Event handler callback for {@link OpenSeadragon.Button.event:press}.
		 * @param {OpenSeadragon.EventHandler} [options.onRelease=null] Event handler callback for {@link OpenSeadragon.Button.event:release}.
		 * @param {OpenSeadragon.EventHandler} [options.onClick=null] Event handler callback for {@link OpenSeadragon.Button.event:click}.
		 * @param {OpenSeadragon.EventHandler} [options.onEnter=null] Event handler callback for {@link OpenSeadragon.Button.event:enter}.
		 * @param {OpenSeadragon.EventHandler} [options.onExit=null] Event handler callback for {@link OpenSeadragon.Button.event:exit}.
		 * @param {OpenSeadragon.EventHandler} [options.onFocus=null] Event handler callback for {@link OpenSeadragon.Button.event:focus}.
		 * @param {OpenSeadragon.EventHandler} [options.onBlur=null] Event handler callback for {@link OpenSeadragon.Button.event:blur}.
		 * @param {Object} [options.userData=null] Arbitrary object to be passed unchanged to any attached handler methods.
		 */
		$.Button = function( options ) {

		    var _this = this;

		    $.EventSource.call( this );

		    $.extend( true, this, {

		        tooltip:            null,
		        srcRest:            null,
		        srcGroup:           null,
		        srcHover:           null,
		        srcDown:            null,
		        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
		        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
		        /**
		         * How long to wait before fading.
		         * @member {Number} fadeDelay
		         * @memberof OpenSeadragon.Button#
		         */
		        fadeDelay:          0,
		        /**
		         * How long should it take to fade the button.
		         * @member {Number} fadeLength
		         * @memberof OpenSeadragon.Button#
		         */
		        fadeLength:         2000,
		        onPress:            null,
		        onRelease:          null,
		        onClick:            null,
		        onEnter:            null,
		        onExit:             null,
		        onFocus:            null,
		        onBlur:             null,
		        userData:           null

		    }, options );

		    /**
		     * The button element.
		     * @member {Element} element
		     * @memberof OpenSeadragon.Button#
		     */
		    this.element = options.element || $.makeNeutralElement("div");

		    //if the user has specified the element to bind the control to explicitly
		    //then do not add the default control images
		    if ( !options.element ) {
		        this.imgRest      = $.makeTransparentImage( this.srcRest );
		        this.imgGroup     = $.makeTransparentImage( this.srcGroup );
		        this.imgHover     = $.makeTransparentImage( this.srcHover );
		        this.imgDown      = $.makeTransparentImage( this.srcDown );

		        this.imgRest.alt  =
		        this.imgGroup.alt =
		        this.imgHover.alt =
		        this.imgDown.alt  =
		            this.tooltip;

		        // Allow pointer events to pass through the img elements so implicit
		        //   pointer capture works on touch devices
		        $.setElementPointerEventsNone( this.imgRest );
		        $.setElementPointerEventsNone( this.imgGroup );
		        $.setElementPointerEventsNone( this.imgHover );
		        $.setElementPointerEventsNone( this.imgDown );

		        this.element.style.position = "relative";
		        $.setElementTouchActionNone( this.element );

		        this.imgGroup.style.position =
		        this.imgHover.style.position =
		        this.imgDown.style.position  =
		            "absolute";

		        this.imgGroup.style.top =
		        this.imgHover.style.top =
		        this.imgDown.style.top  =
		            "0px";

		        this.imgGroup.style.left =
		        this.imgHover.style.left =
		        this.imgDown.style.left  =
		            "0px";

		        this.imgHover.style.visibility =
		        this.imgDown.style.visibility  =
		            "hidden";

		        this.element.appendChild( this.imgRest );
		        this.element.appendChild( this.imgGroup );
		        this.element.appendChild( this.imgHover );
		        this.element.appendChild( this.imgDown );
		    }


		    this.addHandler("press", this.onPress);
		    this.addHandler("release", this.onRelease);
		    this.addHandler("click", this.onClick);
		    this.addHandler("enter", this.onEnter);
		    this.addHandler("exit", this.onExit);
		    this.addHandler("focus", this.onFocus);
		    this.addHandler("blur", this.onBlur);

		    /**
		     * The button's current state.
		     * @member {OpenSeadragon.ButtonState} currentState
		     * @memberof OpenSeadragon.Button#
		     */
		    this.currentState = $.ButtonState.GROUP;

		    // When the button last began to fade.
		    this.fadeBeginTime  = null;
		    // Whether this button should fade after user stops interacting with the viewport.
		    this.shouldFade     = false;

		    this.element.style.display  = "inline-block";
		    this.element.style.position = "relative";
		    this.element.title          = this.tooltip;

		    /**
		     * Tracks mouse/touch/key events on the button.
		     * @member {OpenSeadragon.MouseTracker} tracker
		     * @memberof OpenSeadragon.Button#
		     */
		    this.tracker = new $.MouseTracker({

		        userData:           'Button.tracker',
		        element:            this.element,
		        clickTimeThreshold: this.clickTimeThreshold,
		        clickDistThreshold: this.clickDistThreshold,

		        enterHandler: function( event ) {
		            if ( event.insideElementPressed ) {
		                inTo( _this, $.ButtonState.DOWN );
		                /**
		                 * Raised when the cursor enters the Button element.
		                 *
		                 * @event enter
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( "enter", { originalEvent: event.originalEvent } );
		            } else if ( !event.buttonDownAny ) {
		                inTo( _this, $.ButtonState.HOVER );
		            }
		        },

		        focusHandler: function ( event ) {
		            _this.tracker.enterHandler( event );
		            /**
		             * Raised when the Button element receives focus.
		             *
		             * @event focus
		             * @memberof OpenSeadragon.Button
		             * @type {object}
		             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		             * @property {Object} originalEvent - The original DOM event.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            _this.raiseEvent( "focus", { originalEvent: event.originalEvent } );
		        },

		        leaveHandler: function( event ) {
		            outTo( _this, $.ButtonState.GROUP );
		            if ( event.insideElementPressed ) {
		                /**
		                 * Raised when the cursor leaves the Button element.
		                 *
		                 * @event exit
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( "exit", { originalEvent: event.originalEvent } );
		            }
		        },

		        blurHandler: function ( event ) {
		            _this.tracker.leaveHandler( event );
		            /**
		             * Raised when the Button element loses focus.
		             *
		             * @event blur
		             * @memberof OpenSeadragon.Button
		             * @type {object}
		             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		             * @property {Object} originalEvent - The original DOM event.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            _this.raiseEvent( "blur", { originalEvent: event.originalEvent } );
		        },

		        pressHandler: function ( event ) {
		            inTo( _this, $.ButtonState.DOWN );
		            /**
		             * Raised when a mouse button is pressed or touch occurs in the Button element.
		             *
		             * @event press
		             * @memberof OpenSeadragon.Button
		             * @type {object}
		             * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		             * @property {Object} originalEvent - The original DOM event.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            _this.raiseEvent( "press", { originalEvent: event.originalEvent } );
		        },

		        releaseHandler: function( event ) {
		            if ( event.insideElementPressed && event.insideElementReleased ) {
		                outTo( _this, $.ButtonState.HOVER );
		                /**
		                 * Raised when the mouse button is released or touch ends in the Button element.
		                 *
		                 * @event release
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );
		            } else if ( event.insideElementPressed ) {
		                outTo( _this, $.ButtonState.GROUP );
		            } else {
		                inTo( _this, $.ButtonState.HOVER );
		            }
		        },

		        clickHandler: function( event ) {
		            if ( event.quick ) {
		                /**
		                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
		                 *
		                 * @event click
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent("click", { originalEvent: event.originalEvent });
		            }
		        },

		        keyHandler: function( event ){
		            //console.log( "%s : handling key %s!", _this.tooltip, event.keyCode);
		            if( 13 === event.keyCode ){
		                /***
		                 * Raised when a mouse button is pressed and released or touch is initiated and ended in the Button element within the time and distance threshold.
		                 *
		                 * @event click
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( "click", { originalEvent: event.originalEvent } );
		                /***
		                 * Raised when the mouse button is released or touch ends in the Button element.
		                 *
		                 * @event release
		                 * @memberof OpenSeadragon.Button
		                 * @type {object}
		                 * @property {OpenSeadragon.Button} eventSource - A reference to the Button which raised the event.
		                 * @property {Object} originalEvent - The original DOM event.
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                _this.raiseEvent( "release", { originalEvent: event.originalEvent } );

		                event.preventDefault = true;
		            } else {
		                event.preventDefault = false;
		            }
		        }

		    });

		    outTo( this, $.ButtonState.REST );
		};

		$.extend( $.Button.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.Button.prototype */{

		    /**
		     * Used by a button container element (e.g. a ButtonGroup) to transition the button state
		     * to ButtonState.GROUP.
		     * @function
		     */
		    notifyGroupEnter: function() {
		        inTo( this, $.ButtonState.GROUP );
		    },

		    /**
		     * Used by a button container element (e.g. a ButtonGroup) to transition the button state
		     * to ButtonState.REST.
		     * @function
		     */
		    notifyGroupExit: function() {
		        outTo( this, $.ButtonState.REST );
		    },

		    /**
		     * @function
		     */
		    disable: function(){
		        this.notifyGroupExit();
		        this.element.disabled = true;
		        this.tracker.setTracking(false);
		        $.setElementOpacity( this.element, 0.2, true );
		    },

		    /**
		     * @function
		     */
		    enable: function(){
		        this.element.disabled = false;
		        this.tracker.setTracking(true);
		        $.setElementOpacity( this.element, 1.0, true );
		        this.notifyGroupEnter();
		    },

		    destroy: function() {
		        if (this.imgRest) {
		            this.element.removeChild(this.imgRest);
		            this.imgRest = null;
		        }
		        if (this.imgGroup) {
		            this.element.removeChild(this.imgGroup);
		            this.imgGroup = null;
		        }
		        if (this.imgHover) {
		            this.element.removeChild(this.imgHover);
		            this.imgHover = null;
		        }
		        if (this.imgDown) {
		            this.element.removeChild(this.imgDown);
		            this.imgDown = null;
		        }
		        this.removeAllHandlers();
		        this.tracker.destroy();
		        this.element = null;
		    }

		});


		function scheduleFade( button ) {
		    $.requestAnimationFrame(function(){
		        updateFade( button );
		    });
		}

		function updateFade( button ) {
		    var currentTime,
		        deltaTime,
		        opacity;

		    if ( button.shouldFade ) {
		        currentTime = $.now();
		        deltaTime   = currentTime - button.fadeBeginTime;
		        opacity     = 1.0 - deltaTime / button.fadeLength;
		        opacity     = Math.min( 1.0, opacity );
		        opacity     = Math.max( 0.0, opacity );

		        if( button.imgGroup ){
		            $.setElementOpacity( button.imgGroup, opacity, true );
		        }
		        if ( opacity > 0 ) {
		            // fade again
		            scheduleFade( button );
		        }
		    }
		}

		function beginFading( button ) {
		    button.shouldFade = true;
		    button.fadeBeginTime = $.now() + button.fadeDelay;
		    window.setTimeout( function(){
		        scheduleFade( button );
		    }, button.fadeDelay );
		}

		function stopFading( button ) {
		    button.shouldFade = false;
		    if( button.imgGroup ){
		        $.setElementOpacity( button.imgGroup, 1.0, true );
		    }
		}

		function inTo( button, newState ) {

		    if( button.element.disabled ){
		        return;
		    }

		    if ( newState >= $.ButtonState.GROUP &&
		         button.currentState === $.ButtonState.REST ) {
		        stopFading( button );
		        button.currentState = $.ButtonState.GROUP;
		    }

		    if ( newState >= $.ButtonState.HOVER &&
		         button.currentState === $.ButtonState.GROUP ) {
		        if( button.imgHover ){
		            button.imgHover.style.visibility = "";
		        }
		        button.currentState = $.ButtonState.HOVER;
		    }

		    if ( newState >= $.ButtonState.DOWN &&
		         button.currentState === $.ButtonState.HOVER ) {
		        if( button.imgDown ){
		            button.imgDown.style.visibility = "";
		        }
		        button.currentState = $.ButtonState.DOWN;
		    }
		}


		function outTo( button, newState ) {

		    if( button.element.disabled ){
		        return;
		    }

		    if ( newState <= $.ButtonState.HOVER &&
		         button.currentState === $.ButtonState.DOWN ) {
		        if( button.imgDown ){
		            button.imgDown.style.visibility = "hidden";
		        }
		        button.currentState = $.ButtonState.HOVER;
		    }

		    if ( newState <= $.ButtonState.GROUP &&
		         button.currentState === $.ButtonState.HOVER ) {
		        if( button.imgHover ){
		            button.imgHover.style.visibility = "hidden";
		        }
		        button.currentState = $.ButtonState.GROUP;
		    }

		    if ( newState <= $.ButtonState.REST &&
		         button.currentState === $.ButtonState.GROUP ) {
		        beginFading( button );
		        button.currentState = $.ButtonState.REST;
		    }
		}



		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - ButtonGroup
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){
		/**
		 * @class ButtonGroup
		 * @classdesc Manages events on groups of buttons.
		 *
		 * @memberof OpenSeadragon
		 * @param {Object} options - A dictionary of settings applied against the entire group of buttons.
		 * @param {Array} options.buttons Array of buttons
		 * @param {Element} [options.element] Element to use as the container
		 **/
		$.ButtonGroup = function( options ) {

		    $.extend( true, this, {
		        /**
		         * An array containing the buttons themselves.
		         * @member {Array} buttons
		         * @memberof OpenSeadragon.ButtonGroup#
		         */
		        buttons:            [],
		        clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
		        clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
		        labelText:          ""
		    }, options );

		    // copy the button elements  TODO: Why?
		    var buttons = this.buttons.concat([]),
		        _this = this,
		        i;

		    /**
		     * The shared container for the buttons.
		     * @member {Element} element
		     * @memberof OpenSeadragon.ButtonGroup#
		     */
		    this.element = options.element || $.makeNeutralElement( "div" );

		    // TODO What if there IS an options.group specified?
		    if( !options.group ){
		        this.element.style.display = "inline-block";
		        //this.label   = $.makeNeutralElement( "label" );
		        //TODO: support labels for ButtonGroups
		        //this.label.innerHTML = this.labelText;
		        //this.element.appendChild( this.label );
		        for ( i = 0; i < buttons.length; i++ ) {
		            this.element.appendChild( buttons[ i ].element );
		        }
		    }

		    $.setElementTouchActionNone( this.element );

		    /**
		     * Tracks mouse/touch/key events across the group of buttons.
		     * @member {OpenSeadragon.MouseTracker} tracker
		     * @memberof OpenSeadragon.ButtonGroup#
		     */
		    this.tracker = new $.MouseTracker({
		        userData:           'ButtonGroup.tracker',
		        element:            this.element,
		        clickTimeThreshold: this.clickTimeThreshold,
		        clickDistThreshold: this.clickDistThreshold,
		        enterHandler: function ( event ) {
		            var i;
		            for ( i = 0; i < _this.buttons.length; i++ ) {
		                _this.buttons[ i ].notifyGroupEnter();
		            }
		        },
		        leaveHandler: function ( event ) {
		            var i;
		            if ( !event.insideElementPressed ) {
		                for ( i = 0; i < _this.buttons.length; i++ ) {
		                    _this.buttons[ i ].notifyGroupExit();
		                }
		            }
		        },
		    });
		};

		/** @lends OpenSeadragon.ButtonGroup.prototype */
		$.ButtonGroup.prototype = {

		    /**
		     * Adds the given button to this button group.
		     *
		     * @function
		     * @param {OpenSeadragon.Button} button
		     */
		    addButton: function( button ){
		        this.buttons.push(button);
		        this.element.appendChild(button.element);
		    },

		    /**
		     * TODO: Figure out why this is used on the public API and if a more useful
		     * api can be created.
		     * @function
		     * @private
		     */
		    emulateEnter: function() {
		        this.tracker.enterHandler( { eventSource: this.tracker } );
		    },

		    /**
		     * TODO: Figure out why this is used on the public API and if a more useful
		     * api can be created.
		     * @function
		     * @private
		     */
		    emulateLeave: function() {
		        this.tracker.leaveHandler( { eventSource: this.tracker } );
		    },

		    destroy: function() {
		        while (this.buttons.length) {
		            var button = this.buttons.pop();
		            this.element.removeChild(button.element);
		            button.destroy();
		        }
		        this.tracker.destroy();
		        this.element = null;
		    }
		};


		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Rect
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($) {

		/**
		 * @class Rect
		 * @classdesc A Rectangle is described by it top left coordinates (x, y), width,
		 * height and degrees of rotation around (x, y).
		 * Note that the coordinate system used is the one commonly used with images:
		 * x increases when going to the right
		 * y increases when going to the bottom
		 * degrees increases clockwise with 0 being the horizontal
		 *
		 * The constructor normalizes the rectangle to always have 0 <= degrees < 90
		 *
		 * @memberof OpenSeadragon
		 * @param {Number} [x=0] The vector component 'x'.
		 * @param {Number} [y=0] The vector component 'y'.
		 * @param {Number} [width=0] The vector component 'width'.
		 * @param {Number} [height=0] The vector component 'height'.
		 * @param {Number} [degrees=0] Rotation of the rectangle around (x,y) in degrees.
		 */
		$.Rect = function(x, y, width, height, degrees) {
		    /**
		     * The vector component 'x'.
		     * @member {Number} x
		     * @memberof OpenSeadragon.Rect#
		     */
		    this.x = typeof (x) === "number" ? x : 0;
		    /**
		     * The vector component 'y'.
		     * @member {Number} y
		     * @memberof OpenSeadragon.Rect#
		     */
		    this.y = typeof (y) === "number" ? y : 0;
		    /**
		     * The vector component 'width'.
		     * @member {Number} width
		     * @memberof OpenSeadragon.Rect#
		     */
		    this.width  = typeof (width) === "number" ? width : 0;
		    /**
		     * The vector component 'height'.
		     * @member {Number} height
		     * @memberof OpenSeadragon.Rect#
		     */
		    this.height = typeof (height) === "number" ? height : 0;

		    /**
		     * The rotation of the rectangle, in degrees.
		     * @member {Number} degrees
		     * @memberof OpenSeadragon.Rect#
		     */
		    this.degrees = typeof (degrees) === "number" ? degrees : 0;

		    // Normalizes the rectangle.
		    this.degrees = $.positiveModulo(this.degrees, 360);
		    var newTopLeft, newWidth;
		    if (this.degrees >= 270) {
		        newTopLeft = this.getTopRight();
		        this.x = newTopLeft.x;
		        this.y = newTopLeft.y;
		        newWidth = this.height;
		        this.height = this.width;
		        this.width = newWidth;
		        this.degrees -= 270;
		    } else if (this.degrees >= 180) {
		        newTopLeft = this.getBottomRight();
		        this.x = newTopLeft.x;
		        this.y = newTopLeft.y;
		        this.degrees -= 180;
		    } else if (this.degrees >= 90) {
		        newTopLeft = this.getBottomLeft();
		        this.x = newTopLeft.x;
		        this.y = newTopLeft.y;
		        newWidth = this.height;
		        this.height = this.width;
		        this.width = newWidth;
		        this.degrees -= 90;
		    }
		};

		/**
		 * Builds a rectangle having the 3 specified points as summits.
		 * @static
		 * @memberof OpenSeadragon.Rect
		 * @param {OpenSeadragon.Point} topLeft
		 * @param {OpenSeadragon.Point} topRight
		 * @param {OpenSeadragon.Point} bottomLeft
		 * @returns {OpenSeadragon.Rect}
		 */
		$.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
		    var width = topLeft.distanceTo(topRight);
		    var height = topLeft.distanceTo(bottomLeft);
		    var diff = topRight.minus(topLeft);
		    var radians = Math.atan(diff.y / diff.x);
		    if (diff.x < 0) {
		        radians += Math.PI;
		    } else if (diff.y < 0) {
		        radians += 2 * Math.PI;
		    }
		    return new $.Rect(
		        topLeft.x,
		        topLeft.y,
		        width,
		        height,
		        radians / Math.PI * 180);
		};

		/** @lends OpenSeadragon.Rect.prototype */
		$.Rect.prototype = {
		    /**
		     * @function
		     * @returns {OpenSeadragon.Rect} a duplicate of this Rect
		     */
		    clone: function() {
		        return new $.Rect(
		            this.x,
		            this.y,
		            this.width,
		            this.height,
		            this.degrees);
		    },

		    /**
		     * The aspect ratio is simply the ratio of width to height.
		     * @function
		     * @returns {Number} The ratio of width to height.
		     */
		    getAspectRatio: function() {
		        return this.width / this.height;
		    },

		    /**
		     * Provides the coordinates of the upper-left corner of the rectangle as a
		     * point.
		     * @function
		     * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
		     *  the rectangle.
		     */
		    getTopLeft: function() {
		        return new $.Point(
		            this.x,
		            this.y
		        );
		    },

		    /**
		     * Provides the coordinates of the bottom-right corner of the rectangle as a
		     * point.
		     * @function
		     * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
		     *  the rectangle.
		     */
		    getBottomRight: function() {
		        return new $.Point(this.x + this.width, this.y + this.height)
		            .rotate(this.degrees, this.getTopLeft());
		    },

		    /**
		     * Provides the coordinates of the top-right corner of the rectangle as a
		     * point.
		     * @function
		     * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
		     *  the rectangle.
		     */
		    getTopRight: function() {
		        return new $.Point(this.x + this.width, this.y)
		            .rotate(this.degrees, this.getTopLeft());
		    },

		    /**
		     * Provides the coordinates of the bottom-left corner of the rectangle as a
		     * point.
		     * @function
		     * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
		     *  the rectangle.
		     */
		    getBottomLeft: function() {
		        return new $.Point(this.x, this.y + this.height)
		            .rotate(this.degrees, this.getTopLeft());
		    },

		    /**
		     * Computes the center of the rectangle.
		     * @function
		     * @returns {OpenSeadragon.Point} The center of the rectangle as represented
		     *  as represented by a 2-dimensional vector (x,y)
		     */
		    getCenter: function() {
		        return new $.Point(
		            this.x + this.width / 2.0,
		            this.y + this.height / 2.0
		        ).rotate(this.degrees, this.getTopLeft());
		    },

		    /**
		     * Returns the width and height component as a vector OpenSeadragon.Point
		     * @function
		     * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
		     *  width and height of the rectangle.
		     */
		    getSize: function() {
		        return new $.Point(this.width, this.height);
		    },

		    /**
		     * Determines if two Rectangles have equivalent components.
		     * @function
		     * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
		     * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
		     */
		    equals: function(other) {
		        return (other instanceof $.Rect) &&
		            this.x === other.x &&
		            this.y === other.y &&
		            this.width === other.width &&
		            this.height === other.height &&
		            this.degrees === other.degrees;
		    },

		    /**
		    * Multiply all dimensions (except degrees) in this Rect by a factor and
		    * return a new Rect.
		    * @function
		    * @param {Number} factor The factor to multiply vector components.
		    * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
		    *  of the vector components by the factor
		    */
		    times: function(factor) {
		        return new $.Rect(
		            this.x * factor,
		            this.y * factor,
		            this.width * factor,
		            this.height * factor,
		            this.degrees);
		    },

		    /**
		    * Translate/move this Rect by a vector and return new Rect.
		    * @function
		    * @param {OpenSeadragon.Point} delta The translation vector.
		    * @returns {OpenSeadragon.Rect} A new rect with altered position
		    */
		    translate: function(delta) {
		        return new $.Rect(
		            this.x + delta.x,
		            this.y + delta.y,
		            this.width,
		            this.height,
		            this.degrees);
		    },

		    /**
		     * Returns the smallest rectangle that will contain this and the given
		     * rectangle bounding boxes.
		     * @param {OpenSeadragon.Rect} rect
		     * @returns {OpenSeadragon.Rect} The new rectangle.
		     */
		    union: function(rect) {
		        var thisBoundingBox = this.getBoundingBox();
		        var otherBoundingBox = rect.getBoundingBox();

		        var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
		        var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
		        var right = Math.max(
		            thisBoundingBox.x + thisBoundingBox.width,
		            otherBoundingBox.x + otherBoundingBox.width);
		        var bottom = Math.max(
		            thisBoundingBox.y + thisBoundingBox.height,
		            otherBoundingBox.y + otherBoundingBox.height);

		        return new $.Rect(
		            left,
		            top,
		            right - left,
		            bottom - top);
		    },

		    /**
		     * Returns the bounding box of the intersection of this rectangle with the
		     * given rectangle.
		     * @param {OpenSeadragon.Rect} rect
		     * @returns {OpenSeadragon.Rect} the bounding box of the intersection
		     * or null if the rectangles don't intersect.
		     */
		    intersection: function(rect) {
		        // Simplified version of Weiler Atherton clipping algorithm
		        // https://en.wikipedia.org/wiki/Weiler%E2%80%93Atherton_clipping_algorithm
		        // Because we just want the bounding box of the intersection,
		        // we can just compute the bounding box of:
		        // 1. all the summits of this which are inside rect
		        // 2. all the summits of rect which are inside this
		        // 3. all the intersections of rect and this
		        var EPSILON = 0.0000000001;

		        var intersectionPoints = [];

		        var thisTopLeft = this.getTopLeft();
		        if (rect.containsPoint(thisTopLeft, EPSILON)) {
		            intersectionPoints.push(thisTopLeft);
		        }
		        var thisTopRight = this.getTopRight();
		        if (rect.containsPoint(thisTopRight, EPSILON)) {
		            intersectionPoints.push(thisTopRight);
		        }
		        var thisBottomLeft = this.getBottomLeft();
		        if (rect.containsPoint(thisBottomLeft, EPSILON)) {
		            intersectionPoints.push(thisBottomLeft);
		        }
		        var thisBottomRight = this.getBottomRight();
		        if (rect.containsPoint(thisBottomRight, EPSILON)) {
		            intersectionPoints.push(thisBottomRight);
		        }

		        var rectTopLeft = rect.getTopLeft();
		        if (this.containsPoint(rectTopLeft, EPSILON)) {
		            intersectionPoints.push(rectTopLeft);
		        }
		        var rectTopRight = rect.getTopRight();
		        if (this.containsPoint(rectTopRight, EPSILON)) {
		            intersectionPoints.push(rectTopRight);
		        }
		        var rectBottomLeft = rect.getBottomLeft();
		        if (this.containsPoint(rectBottomLeft, EPSILON)) {
		            intersectionPoints.push(rectBottomLeft);
		        }
		        var rectBottomRight = rect.getBottomRight();
		        if (this.containsPoint(rectBottomRight, EPSILON)) {
		            intersectionPoints.push(rectBottomRight);
		        }

		        var thisSegments = this._getSegments();
		        var rectSegments = rect._getSegments();
		        for (var i = 0; i < thisSegments.length; i++) {
		            var thisSegment = thisSegments[i];
		            for (var j = 0; j < rectSegments.length; j++) {
		                var rectSegment = rectSegments[j];
		                var intersect = getIntersection(thisSegment[0], thisSegment[1],
		                    rectSegment[0], rectSegment[1]);
		                if (intersect) {
		                    intersectionPoints.push(intersect);
		                }
		            }
		        }

		        // Get intersection point of segments [a,b] and [c,d]
		        function getIntersection(a, b, c, d) {
		            // http://stackoverflow.com/a/1968345/1440403
		            var abVector = b.minus(a);
		            var cdVector = d.minus(c);

		            var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
		            if (denom === 0) {
		                return null;
		            }

		            var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
		            var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;

		            if (-EPSILON <= s && s <= 1 - EPSILON &&
		                -EPSILON <= t && t <= 1 - EPSILON) {
		                return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);
		            }
		            return null;
		        }

		        if (intersectionPoints.length === 0) {
		            return null;
		        }

		        var minX = intersectionPoints[0].x;
		        var maxX = intersectionPoints[0].x;
		        var minY = intersectionPoints[0].y;
		        var maxY = intersectionPoints[0].y;
		        for (var k = 1; k < intersectionPoints.length; k++) {
		            var point = intersectionPoints[k];
		            if (point.x < minX) {
		                minX = point.x;
		            }
		            if (point.x > maxX) {
		                maxX = point.x;
		            }
		            if (point.y < minY) {
		                minY = point.y;
		            }
		            if (point.y > maxY) {
		                maxY = point.y;
		            }
		        }
		        return new $.Rect(minX, minY, maxX - minX, maxY - minY);
		    },

		    // private
		    _getSegments: function() {
		        var topLeft = this.getTopLeft();
		        var topRight = this.getTopRight();
		        var bottomLeft = this.getBottomLeft();
		        var bottomRight = this.getBottomRight();
		        return [[topLeft, topRight],
		            [topRight, bottomRight],
		            [bottomRight, bottomLeft],
		            [bottomLeft, topLeft]];
		    },

		    /**
		     * Rotates a rectangle around a point.
		     * @function
		     * @param {Number} degrees The angle in degrees to rotate.
		     * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
		     * Defaults to the center of the rectangle.
		     * @returns {OpenSeadragon.Rect}
		     */
		    rotate: function(degrees, pivot) {
		        degrees = $.positiveModulo(degrees, 360);
		        if (degrees === 0) {
		            return this.clone();
		        }

		        pivot = pivot || this.getCenter();
		        var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
		        var newTopRight = this.getTopRight().rotate(degrees, pivot);

		        var diff = newTopRight.minus(newTopLeft);
		        // Handle floating point error
		        diff = diff.apply(function(x) {
		            var EPSILON = 1e-15;
		            return Math.abs(x) < EPSILON ? 0 : x;
		        });
		        var radians = Math.atan(diff.y / diff.x);
		        if (diff.x < 0) {
		            radians += Math.PI;
		        } else if (diff.y < 0) {
		            radians += 2 * Math.PI;
		        }
		        return new $.Rect(
		            newTopLeft.x,
		            newTopLeft.y,
		            this.width,
		            this.height,
		            radians / Math.PI * 180);
		    },

		    /**
		     * Retrieves the smallest horizontal (degrees=0) rectangle which contains
		     * this rectangle.
		     * @returns {OpenSeadragon.Rect}
		     */
		    getBoundingBox: function() {
		        if (this.degrees === 0) {
		            return this.clone();
		        }
		        var topLeft = this.getTopLeft();
		        var topRight = this.getTopRight();
		        var bottomLeft = this.getBottomLeft();
		        var bottomRight = this.getBottomRight();
		        var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
		        var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
		        var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
		        var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
		        return new $.Rect(
		            minX,
		            minY,
		            maxX - minX,
		            maxY - minY);
		    },

		    /**
		     * Retrieves the smallest horizontal (degrees=0) rectangle which contains
		     * this rectangle and has integers x, y, width and height
		     * @returns {OpenSeadragon.Rect}
		     */
		    getIntegerBoundingBox: function() {
		        var boundingBox = this.getBoundingBox();
		        var x = Math.floor(boundingBox.x);
		        var y = Math.floor(boundingBox.y);
		        var width = Math.ceil(boundingBox.width + boundingBox.x - x);
		        var height = Math.ceil(boundingBox.height + boundingBox.y - y);
		        return new $.Rect(x, y, width, height);
		    },

		    /**
		     * Determines whether a point is inside this rectangle (edge included).
		     * @function
		     * @param {OpenSeadragon.Point} point
		     * @param {Number} [epsilon=0] the margin of error allowed
		     * @returns {Boolean} true if the point is inside this rectangle, false
		     * otherwise.
		     */
		    containsPoint: function(point, epsilon) {
		        epsilon = epsilon || 0;

		        // See http://stackoverflow.com/a/2752754/1440403 for explanation
		        var topLeft = this.getTopLeft();
		        var topRight = this.getTopRight();
		        var bottomLeft = this.getBottomLeft();
		        var topDiff = topRight.minus(topLeft);
		        var leftDiff = bottomLeft.minus(topLeft);

		        return ((point.x - topLeft.x) * topDiff.x +
		            (point.y - topLeft.y) * topDiff.y >= -epsilon) &&

		            ((point.x - topRight.x) * topDiff.x +
		            (point.y - topRight.y) * topDiff.y <= epsilon) &&

		            ((point.x - topLeft.x) * leftDiff.x +
		            (point.y - topLeft.y) * leftDiff.y >= -epsilon) &&

		            ((point.x - bottomLeft.x) * leftDiff.x +
		            (point.y - bottomLeft.y) * leftDiff.y <= epsilon);
		    },

		    /**
		     * Provides a string representation of the rectangle which is useful for
		     * debugging.
		     * @function
		     * @returns {String} A string representation of the rectangle.
		     */
		    toString: function() {
		        return "[" +
		            (Math.round(this.x * 100) / 100) + ", " +
		            (Math.round(this.y * 100) / 100) + ", " +
		            (Math.round(this.width * 100) / 100) + "x" +
		            (Math.round(this.height * 100) / 100) + ", " +
		            (Math.round(this.degrees * 100) / 100) + "deg" +
		            "]";
		    }
		};


		}(OpenSeadragon));

		/*
		 * OpenSeadragon - ReferenceStrip
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function ( $ ) {

		// dictionary from id to private properties
		var THIS = {};

		/**
		 *  The CollectionDrawer is a reimplementation if the Drawer API that
		 *  focuses on allowing a viewport to be redefined as a collection
		 *  of smaller viewports, defined by a clear number of rows and / or
		 *  columns of which each item in the matrix of viewports has its own
		 *  source.
		 *
		 *  This idea is a reexpression of the idea of dzi collections
		 *  which allows a clearer algorithm to reuse the tile sources already
		 *  supported by OpenSeadragon, in heterogeneous or homogeneous
		 *  sequences just like mixed groups already supported by the viewer
		 *  for the purpose of image sequnces.
		 *
		 *  TODO:   The difficult part of this feature is figuring out how to express
		 *          this functionality as a combination of the functionality already
		 *          provided by Drawer, Viewport, TileSource, and Navigator.  It may
		 *          require better abstraction at those points in order to efficiently
		 *          reuse those paradigms.
		 */
		/**
		 * @class ReferenceStrip
		 * @memberof OpenSeadragon
		 * @param {Object} options
		 */
		$.ReferenceStrip = function ( options ) {

		    var _this       = this,
		        viewer      = options.viewer,
		        viewerSize  = $.getElementSize( viewer.element ),
		        element,
		        style,
		        i;

		    //We may need to create a new element and id if they did not
		    //provide the id for the existing element
		    if ( !options.id ) {
		        options.id              = 'referencestrip-' + $.now();
		        this.element            = $.makeNeutralElement( "div" );
		        this.element.id         = options.id;
		        this.element.className  = 'referencestrip';
		    }

		    options = $.extend( true, {
		        sizeRatio:  $.DEFAULT_SETTINGS.referenceStripSizeRatio,
		        position:   $.DEFAULT_SETTINGS.referenceStripPosition,
		        scroll:     $.DEFAULT_SETTINGS.referenceStripScroll,
		        clickTimeThreshold:  $.DEFAULT_SETTINGS.clickTimeThreshold
		    }, options, {
		        element:                this.element
		    } );

		    $.extend( this, options );
		    //Private state properties
		    THIS[this.id] = {
		        animating:           false
		    };

		    this.minPixelRatio = this.viewer.minPixelRatio;

		    this.element.tabIndex = 0;

		    style = this.element.style;
		    style.marginTop     = '0px';
		    style.marginRight   = '0px';
		    style.marginBottom  = '0px';
		    style.marginLeft    = '0px';
		    style.left          = '0px';
		    style.bottom        = '0px';
		    style.border        = '0px';
		    style.background    = '#000';
		    style.position      = 'relative';

		    $.setElementTouchActionNone( this.element );

		    $.setElementOpacity( this.element, 0.8 );

		    this.viewer = viewer;
		    this.tracker = new $.MouseTracker( {
		        userData:       'ReferenceStrip.tracker',
		        element:        this.element,
		        clickHandler:   $.delegate( this, onStripClick ),
		        dragHandler:    $.delegate( this, onStripDrag ),
		        scrollHandler:  $.delegate( this, onStripScroll ),
		        enterHandler:   $.delegate( this, onStripEnter ),
		        leaveHandler:   $.delegate( this, onStripLeave ),
		        keyDownHandler: $.delegate( this, onKeyDown ),
		        keyHandler:     $.delegate( this, onKeyPress ),
		        preProcessEventHandler: function (eventInfo) {
		            if (eventInfo.eventType === 'wheel') {
		                eventInfo.preventDefault = true;
		            }
		        }
		    } );

		    //Controls the position and orientation of the reference strip and sets the
		    //appropriate width and height
		    if ( options.width && options.height ) {
		        this.element.style.width  = options.width + 'px';
		        this.element.style.height = options.height + 'px';
		        viewer.addControl(
		            this.element,
		            { anchor: $.ControlAnchor.BOTTOM_LEFT }
		        );
		    } else {
		        if ( "horizontal" === options.scroll ) {
		            this.element.style.width = (
		                viewerSize.x *
		                options.sizeRatio *
		                viewer.tileSources.length
		            ) + ( 12 * viewer.tileSources.length ) + 'px';

		            this.element.style.height = (
		                viewerSize.y *
		                options.sizeRatio
		            ) + 'px';

		            viewer.addControl(
		                this.element,
		                { anchor: $.ControlAnchor.BOTTOM_LEFT }
		            );
		        } else {
		            this.element.style.height = (
		                viewerSize.y *
		                options.sizeRatio *
		                viewer.tileSources.length
		            ) + ( 12 * viewer.tileSources.length ) + 'px';

		            this.element.style.width = (
		                viewerSize.x *
		                options.sizeRatio
		            ) + 'px';

		            viewer.addControl(
		                this.element,
		                { anchor: $.ControlAnchor.TOP_LEFT }
		            );

		        }
		    }

		    this.panelWidth = ( viewerSize.x * this.sizeRatio ) + 8;
		    this.panelHeight = ( viewerSize.y * this.sizeRatio ) + 8;
		    this.panels = [];
		    this.miniViewers = {};

		    /*jshint loopfunc:true*/
		    for ( i = 0; i < viewer.tileSources.length; i++ ) {

		        element = $.makeNeutralElement( 'div' );
		        element.id = this.element.id + "-" + i;

		        element.style.width         = _this.panelWidth + 'px';
		        element.style.height        = _this.panelHeight + 'px';
		        element.style.display       = 'inline';
		        element.style['float']      = 'left'; //Webkit
		        element.style.cssFloat      = 'left'; //Firefox
		        element.style.padding       = '2px';
		        $.setElementTouchActionNone( element );
		        $.setElementPointerEventsNone( element );

		        this.element.appendChild( element );

		        element.activePanel = false;

		        this.panels.push( element );

		    }
		    loadPanels( this, this.scroll === 'vertical' ? viewerSize.y : viewerSize.x, 0 );
		    this.setFocus( 0 );

		};

		/** @lends OpenSeadragon.ReferenceStrip.prototype */
		$.ReferenceStrip.prototype = {

		    /**
		     * @function
		     */
		    setFocus: function ( page ) {
		        var element      = this.element.querySelector('#' + this.element.id + '-' + page ),
		            viewerSize   = $.getElementSize( this.viewer.canvas ),
		            scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
		            scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
		            offsetLeft   = -Number( this.element.style.marginLeft.replace( 'px', '' ) ),
		            offsetTop    = -Number( this.element.style.marginTop.replace( 'px', '' ) ),
		            offset;

		        if ( this.currentSelected !== element ) {
		            if ( this.currentSelected ) {
		                this.currentSelected.style.background = '#000';
		            }
		            this.currentSelected = element;
		            this.currentSelected.style.background = '#999';

		            if ( 'horizontal' === this.scroll ) {
		                //right left
		                offset = ( Number( page ) ) * ( this.panelWidth + 3 );
		                if ( offset > offsetLeft + viewerSize.x - this.panelWidth ) {
		                    offset = Math.min( offset, ( scrollWidth - viewerSize.x ) );
		                    this.element.style.marginLeft = -offset + 'px';
		                    loadPanels( this, viewerSize.x, -offset );
		                } else if ( offset < offsetLeft ) {
		                    offset = Math.max( 0, offset - viewerSize.x / 2 );
		                    this.element.style.marginLeft = -offset + 'px';
		                    loadPanels( this, viewerSize.x, -offset );
		                }
		            } else {
		                offset = ( Number( page ) ) * ( this.panelHeight + 3 );
		                if ( offset > offsetTop + viewerSize.y - this.panelHeight ) {
		                    offset = Math.min( offset, ( scrollHeight - viewerSize.y ) );
		                    this.element.style.marginTop = -offset + 'px';
		                    loadPanels( this, viewerSize.y, -offset );
		                } else if ( offset < offsetTop ) {
		                    offset = Math.max( 0, offset - viewerSize.y / 2 );
		                    this.element.style.marginTop = -offset + 'px';
		                    loadPanels( this, viewerSize.y, -offset );
		                }
		            }

		            this.currentPage = page;
		            onStripEnter.call( this, { eventSource: this.tracker } );
		        }
		    },

		    /**
		     * @function
		     */
		    update: function () {
		        if ( THIS[this.id].animating ) {
		            // $.console.log( 'image reference strip update' );
		            return true;
		        }
		        return false;
		    },

		    destroy: function() {
		        if (this.miniViewers) {
		          for (var key in this.miniViewers) {
		            this.miniViewers[key].destroy();
		          }
		        }

		        this.tracker.destroy();

		        if (this.element) {
		            this.viewer.removeControl( this.element );
		        }
		    }

		};


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onStripClick( event ) {
		    if ( event.quick ) {
		        var page;

		        if ( 'horizontal' === this.scroll ) {
		            // +4px fix to solve problem with precision on thumbnail selection if there is a lot of them
		            page = Math.floor(event.position.x / (this.panelWidth + 4));
		        } else {
		            page = Math.floor(event.position.y / this.panelHeight);
		        }

		        this.viewer.goToPage( page );
		    }

		    this.element.focus();
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onStripDrag( event ) {

		    this.dragging = true;
		    if ( this.element ) {
		        var offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) ),
		        offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) ),
		        scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
		        scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
		        viewerSize   = $.getElementSize( this.viewer.canvas );

		        if ( 'horizontal' === this.scroll ) {
		            if ( -event.delta.x > 0 ) {
		                //forward
		                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {
		                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
		                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
		                }
		            } else if ( -event.delta.x < 0 ) {
		                //reverse
		                if ( offsetLeft < 0 ) {
		                    this.element.style.marginLeft = ( offsetLeft + ( event.delta.x * 2 ) ) + 'px';
		                    loadPanels( this, viewerSize.x, offsetLeft + ( event.delta.x * 2 ) );
		                }
		            }
		        } else {
		            if ( -event.delta.y > 0 ) {
		                //forward
		                if ( offsetTop > -( scrollHeight - viewerSize.y ) ) {
		                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
		                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
		                }
		            } else if ( -event.delta.y < 0 ) {
		                //reverse
		                if ( offsetTop < 0 ) {
		                    this.element.style.marginTop = ( offsetTop + ( event.delta.y * 2 ) ) + 'px';
		                    loadPanels( this, viewerSize.y, offsetTop + ( event.delta.y * 2 ) );
		                }
		            }
		        }
		    }

		}



		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onStripScroll( event ) {
		    if ( this.element ) {
		        var offsetLeft   = Number( this.element.style.marginLeft.replace( 'px', '' ) ),
		        offsetTop    = Number( this.element.style.marginTop.replace( 'px', '' ) ),
		        scrollWidth  = Number( this.element.style.width.replace( 'px', '' ) ),
		        scrollHeight = Number( this.element.style.height.replace( 'px', '' ) ),
		        viewerSize   = $.getElementSize( this.viewer.canvas );

		        if ( 'horizontal' === this.scroll ) {
		            if ( event.scroll > 0 ) {
		                //forward
		                if ( offsetLeft > -( scrollWidth - viewerSize.x ) ) {
		                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
		                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
		                }
		            } else if ( event.scroll < 0 ) {
		                //reverse
		                if ( offsetLeft < 0 ) {
		                    this.element.style.marginLeft = ( offsetLeft - ( event.scroll * 60 ) ) + 'px';
		                    loadPanels( this, viewerSize.x, offsetLeft - ( event.scroll * 60 ) );
		                }
		            }
		        } else {
		            if ( event.scroll < 0 ) {
		                //scroll up
		                if ( offsetTop > viewerSize.y - scrollHeight ) {
		                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
		                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
		                }
		            } else if ( event.scroll > 0 ) {
		                //scroll dowm
		                if ( offsetTop < 0 ) {
		                    this.element.style.marginTop = ( offsetTop + ( event.scroll * 60 ) ) + 'px';
		                    loadPanels( this, viewerSize.y, offsetTop + ( event.scroll * 60 ) );
		                }
		            }
		        }

		        event.preventDefault = true;
		    }
		}


		function loadPanels( strip, viewerSize, scroll ) {
		    var panelSize,
		        activePanelsStart,
		        activePanelsEnd,
		        miniViewer,
		        i,
		        element;
		    if ( 'horizontal' === strip.scroll ) {
		        panelSize = strip.panelWidth;
		    } else {
		        panelSize = strip.panelHeight;
		    }
		    activePanelsStart = Math.ceil( viewerSize / panelSize ) + 5;
		    activePanelsEnd = Math.ceil( ( Math.abs( scroll ) + viewerSize ) / panelSize ) + 1;
		    activePanelsStart = activePanelsEnd - activePanelsStart;
		    activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;

		    for ( i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++ ) {
		        element = strip.panels[i];
		        if ( !element.activePanel ) {
		            var miniTileSource;
		            var originalTileSource = strip.viewer.tileSources[i];
		            if (originalTileSource.referenceStripThumbnailUrl) {
		                miniTileSource = {
		                    type: 'image',
		                    url: originalTileSource.referenceStripThumbnailUrl
		                };
		            } else {
		                miniTileSource = originalTileSource;
		            }
		            miniViewer = new $.Viewer( {
		                id:                     element.id,
		                tileSources:            [miniTileSource],
		                element:                element,
		                navigatorSizeRatio:     strip.sizeRatio,
		                showNavigator:          false,
		                mouseNavEnabled:        false,
		                showNavigationControl:  false,
		                showSequenceControl:    false,
		                immediateRender:        true,
		                blendTime:              0,
		                animationTime:          0,
		                loadTilesWithAjax:      strip.viewer.loadTilesWithAjax,
		                ajaxHeaders:            strip.viewer.ajaxHeaders,
		                drawer:                 'canvas', //always use canvas for the reference strip
		            } );
		            // Allow pointer events to pass through miniViewer's canvas/container
		            //   elements so implicit pointer capture works on touch devices
		            $.setElementPointerEventsNone( miniViewer.canvas );
		            $.setElementPointerEventsNone( miniViewer.container );
		            // We'll use event delegation from the reference strip element instead of
		            //   handling events on every miniViewer
		            miniViewer.innerTracker.setTracking( false );
		            miniViewer.outerTracker.setTracking( false );

		            strip.miniViewers[element.id] = miniViewer;

		            element.activePanel = true;
		        }
		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onStripEnter( event ) {
		    var element = event.eventSource.element;

		    //$.setElementOpacity(element, 0.8);

		    //element.style.border = '1px solid #555';
		    //element.style.background = '#000';

		    if ( 'horizontal' === this.scroll ) {

		        //element.style.paddingTop = "0px";
		        element.style.marginBottom = "0px";

		    } else {

		        //element.style.paddingRight = "0px";
		        element.style.marginLeft = "0px";

		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onStripLeave( event ) {
		    var element = event.eventSource.element;

		    if ( 'horizontal' === this.scroll ) {

		        //element.style.paddingTop = "10px";
		        element.style.marginBottom = "-" + ( $.getElementSize( element ).y / 2 ) + "px";

		    } else {

		        //element.style.paddingRight = "10px";
		        element.style.marginLeft = "-" + ( $.getElementSize( element ).x / 2 ) + "px";

		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onKeyDown( event ) {
		    //console.log( event.keyCode );

		    if ( !event.ctrl && !event.alt && !event.meta ) {
		        switch ( event.keyCode ) {
		            case 38: //up arrow
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 40: //down arrow
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 37: //left arrow
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 39: //right arrow
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
		                event.preventDefault = true;
		                break;
		            default:
		                //console.log( 'navigator keycode %s', event.keyCode );
		                event.preventDefault = false;
		                break;
		        }
		    } else {
		        event.preventDefault = false;
		    }
		}


		/**
		 * @private
		 * @inner
		 * @function
		 */
		function onKeyPress( event ) {
		    //console.log( event.keyCode );

		    if ( !event.ctrl && !event.alt && !event.meta ) {
		        switch ( event.keyCode ) {
		            case 61: //=|+
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 45: //-|_
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 48: //0|)
		            case 119: //w
		            case 87: //W
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 115: //s
		            case 83: //S
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 97: //a
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: -1, shift: null } );
		                event.preventDefault = true;
		                break;
		            case 100: //d
		                onStripScroll.call( this, { eventSource: this.tracker, position: null, scroll: 1, shift: null } );
		                event.preventDefault = true;
		                break;
		            default:
		                //console.log( 'navigator keycode %s', event.keyCode );
		                event.preventDefault = false;
		                break;
		        }
		    } else {
		        event.preventDefault = false;
		    }
		}

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - DisplayRect
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class DisplayRect
		 * @classdesc A display rectangle is very similar to {@link OpenSeadragon.Rect} but adds two
		 * fields, 'minLevel' and 'maxLevel' which denote the supported zoom levels
		 * for this rectangle.
		 *
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.Rect
		 * @param {Number} x The vector component 'x'.
		 * @param {Number} y The vector component 'y'.
		 * @param {Number} width The vector component 'height'.
		 * @param {Number} height The vector component 'width'.
		 * @param {Number} minLevel The lowest zoom level supported.
		 * @param {Number} maxLevel The highest zoom level supported.
		 */
		$.DisplayRect = function( x, y, width, height, minLevel, maxLevel ) {
		    $.Rect.apply( this, [ x, y, width, height ] );

		    /**
		     * The lowest zoom level supported.
		     * @member {Number} minLevel
		     * @memberof OpenSeadragon.DisplayRect#
		     */
		    this.minLevel = minLevel;
		    /**
		     * The highest zoom level supported.
		     * @member {Number} maxLevel
		     * @memberof OpenSeadragon.DisplayRect#
		     */
		    this.maxLevel = maxLevel;
		};

		$.extend( $.DisplayRect.prototype, $.Rect.prototype );

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Spring
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class Spring
		 * @memberof OpenSeadragon
		 * @param {Object} options - Spring configuration settings.
		 * @param {Number} options.springStiffness - Spring stiffness. Must be greater than zero.
		 * The closer to zero, the closer to linear animation.
		 * @param {Number} options.animationTime - Animation duration per spring, in seconds.
		 * Must be zero or greater.
		 * @param {Number} [options.initial=0] - Initial value of spring.
		 * @param {Boolean} [options.exponential=false] - Whether this spring represents
		 * an exponential scale (such as zoom) and should be animated accordingly. Note that
		 * exponential springs must have non-zero values.
		 */
		$.Spring = function( options ) {
		    var args = arguments;

		    if( typeof ( options ) !== 'object' ){
		        //allows backward compatible use of ( initialValue, config ) as
		        //constructor parameters
		        options = {
		            initial: args.length && typeof ( args[ 0 ] ) === "number" ?
		                args[ 0 ] :
		                undefined,
		            /**
		             * Spring stiffness.
		             * @member {Number} springStiffness
		             * @memberof OpenSeadragon.Spring#
		             */
		            springStiffness: args.length > 1 ?
		                args[ 1 ].springStiffness :
		                5.0,
		            /**
		             * Animation duration per spring.
		             * @member {Number} animationTime
		             * @memberof OpenSeadragon.Spring#
		             */
		            animationTime: args.length > 1 ?
		                args[ 1 ].animationTime :
		                1.5
		        };
		    }

		    $.console.assert(typeof options.springStiffness === "number" && options.springStiffness !== 0,
		        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number");

		    $.console.assert(typeof options.animationTime === "number" && options.animationTime >= 0,
		        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0");

		    if (options.exponential) {
		        this._exponential = true;
		        delete options.exponential;
		    }

		    $.extend( true, this, options);

		    /**
		     * @member {Object} current
		     * @memberof OpenSeadragon.Spring#
		     * @property {Number} value
		     * @property {Number} time
		     */
		    this.current = {
		        value: typeof ( this.initial ) === "number" ?
		            this.initial :
		            (this._exponential ? 0 : 1),
		        time:  $.now() // always work in milliseconds
		    };

		    $.console.assert(!this._exponential || this.current.value !== 0,
		        "[OpenSeadragon.Spring] value must be non-zero for exponential springs");

		    /**
		     * @member {Object} start
		     * @memberof OpenSeadragon.Spring#
		     * @property {Number} value
		     * @property {Number} time
		     */
		    this.start = {
		        value: this.current.value,
		        time:  this.current.time
		    };

		    /**
		     * @member {Object} target
		     * @memberof OpenSeadragon.Spring#
		     * @property {Number} value
		     * @property {Number} time
		     */
		    this.target = {
		        value: this.current.value,
		        time:  this.current.time
		    };

		    if (this._exponential) {
		        this.start._logValue = Math.log(this.start.value);
		        this.target._logValue = Math.log(this.target.value);
		        this.current._logValue = Math.log(this.current.value);
		    }
		};

		/** @lends OpenSeadragon.Spring.prototype */
		$.Spring.prototype = {

		    /**
		     * @function
		     * @param {Number} target
		     */
		    resetTo: function( target ) {
		        $.console.assert(!this._exponential || target !== 0,
		            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs");

		        this.start.value = this.target.value = this.current.value = target;
		        this.start.time = this.target.time = this.current.time = $.now();

		        if (this._exponential) {
		            this.start._logValue = Math.log(this.start.value);
		            this.target._logValue = Math.log(this.target.value);
		            this.current._logValue = Math.log(this.current.value);
		        }
		    },

		    /**
		     * @function
		     * @param {Number} target
		     */
		    springTo: function( target ) {
		        $.console.assert(!this._exponential || target !== 0,
		            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs");

		        this.start.value  = this.current.value;
		        this.start.time   = this.current.time;
		        this.target.value = target;
		        this.target.time  = this.start.time + 1000 * this.animationTime;

		        if (this._exponential) {
		            this.start._logValue = Math.log(this.start.value);
		            this.target._logValue = Math.log(this.target.value);
		        }
		    },

		    /**
		     * @function
		     * @param {Number} delta
		     */
		    shiftBy: function( delta ) {
		        this.start.value  += delta;
		        this.target.value += delta;

		        if (this._exponential) {
		            $.console.assert(this.target.value !== 0 && this.start.value !== 0,
		                "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs");

		            this.start._logValue = Math.log(this.start.value);
		            this.target._logValue = Math.log(this.target.value);
		        }
		    },

		    setExponential: function(value) {
		        this._exponential = value;

		        if (this._exponential) {
		            $.console.assert(this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
		                "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs");

		            this.start._logValue = Math.log(this.start.value);
		            this.target._logValue = Math.log(this.target.value);
		            this.current._logValue = Math.log(this.current.value);
		        }
		    },

		    /**
		     * @function
		     * @returns true if the spring is still updating its value, false if it is
		     * already at the target value.
		     */
		    update: function() {
		        this.current.time  = $.now();

		        let startValue, targetValue;
		        if (this._exponential) {
		            startValue = this.start._logValue;
		            targetValue = this.target._logValue;
		        } else {
		            startValue = this.start.value;
		            targetValue = this.target.value;
		        }

		        if(this.current.time >= this.target.time){
		            this.current.value = this.target.value;
		        } else {
		            let currentValue = startValue +
		                    ( targetValue - startValue ) *
		                    transform(
		                        this.springStiffness,
		                        ( this.current.time - this.start.time ) /
		                        ( this.target.time - this.start.time )
		                    );

		            if (this._exponential) {
		                this.current.value = Math.exp(currentValue);
		            } else {
		                this.current.value = currentValue;
		            }
		        }

		        return this.current.value !== this.target.value;
		    },

		    /**
		     * Returns whether the spring is at the target value
		     * @function
		     * @returns {Boolean} True if at target value, false otherwise
		     */
		    isAtTargetValue: function() {
		        return this.current.value === this.target.value;
		    }
		};

		/**
		 * @private
		 */
		function transform( stiffness, x ) {
		    return ( 1.0 - Math.exp( stiffness * -x ) ) /
		        ( 1.0 - Math.exp( -stiffness ) );
		}

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - ImageLoader
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors

		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($){

		/**
		 * @class ImageJob
		 * @classdesc Handles downloading of a single image.
		 *
		 * @memberof OpenSeadragon
		 * @param {Object} options - Options for this ImageJob.
		 * @param {String} [options.src] - URL of image to download.
		 * @param {Tile} [options.tile] - Tile that belongs the data to.
		 * @param {TileSource} [options.source] - Image loading strategy
		 * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
		 * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
		 * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
		 * @param {String} [options.crossOriginPolicy] - CORS policy to use for downloads
		 * @param {String} [options.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		 *      see TileSource::getPostData) or null
		 * @param {Function} [options.callback] - Called once image has been downloaded.
		 * @param {Function} [options.abort] - Called when this image job is aborted.
		 * @param {Number} [options.timeout] - The max number of milliseconds that this image job may take to complete.
		 * @param {Number} [options.tries] - Actual number of the current try.
		 */
		$.ImageJob = function(options) {

		    $.extend(true, this, {
		        timeout: $.DEFAULT_SETTINGS.timeout,
		        jobId: null,
		        tries: 0
		    }, options);

		    /**
		     * Data object which will contain downloaded image data.
		     * @member {Image|*} data data object, by default an Image object (depends on TileSource)
		     * @memberof OpenSeadragon.ImageJob#
		     */
		    this.data = null;

		    /**
		     * User workspace to populate with helper variables
		     * @member {*} userData to append custom data and avoid namespace collision
		     * @memberof OpenSeadragon.ImageJob#
		     */
		    this.userData = {};

		    /**
		     * Error message holder
		     * @member {string} error message
		     * @memberof OpenSeadragon.ImageJob#
		     * @private
		     */
		    this.errorMsg = null;
		};

		$.ImageJob.prototype = {
		    /**
		     * Starts the image job.
		     * @method
		     * @memberof OpenSeadragon.ImageJob#
		     */
		    start: function() {
		        this.tries++;

		        var self = this;
		        var selfAbort = this.abort;

		        this.jobId = window.setTimeout(function () {
		            self.finish(null, null, "Image load exceeded timeout (" + self.timeout + " ms)");
		        }, this.timeout);

		        this.abort = function() {
		            self.source.downloadTileAbort(self);
		            if (typeof selfAbort === "function") {
		                selfAbort();
		            }
		        };

		        this.source.downloadTileStart(this);
		    },

		    /**
		     * Finish this job.
		     * @param {*} data data that has been downloaded
		     * @param {XMLHttpRequest} request reference to the request if used
		     * @param {string} errorMessage description upon failure
		     * @memberof OpenSeadragon.ImageJob#
		     */
		    finish: function(data, request, errorMessage ) {
		        this.data = data;
		        this.request = request;
		        this.errorMsg = errorMessage;

		        if (this.jobId) {
		            window.clearTimeout(this.jobId);
		        }

		        this.callback(this);
		    }
		};

		/**
		 * @class ImageLoader
		 * @memberof OpenSeadragon
		 * @classdesc Handles downloading of a set of images using asynchronous queue pattern.
		 * You generally won't have to interact with the ImageLoader directly.
		 * @param {Object} options - Options for this ImageLoader.
		 * @param {Number} [options.jobLimit] - The number of concurrent image requests. See imageLoaderLimit in {@link OpenSeadragon.Options} for details.
		 * @param {Number} [options.timeout] - The max number of milliseconds that an image job may take to complete.
		 */
		$.ImageLoader = function(options) {

		    $.extend(true, this, {
		        jobLimit:       $.DEFAULT_SETTINGS.imageLoaderLimit,
		        timeout:        $.DEFAULT_SETTINGS.timeout,
		        jobQueue:       [],
		        failedTiles:    [],
		        jobsInProgress: 0
		    }, options);

		};

		/** @lends OpenSeadragon.ImageLoader.prototype */
		$.ImageLoader.prototype = {

		    /**
		     * Add an unloaded image to the loader queue.
		     * @method
		     * @param {Object} options - Options for this job.
		     * @param {String} [options.src] - URL of image to download.
		     * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
		     *      is not internally used and serves for custom TileSources implementations.
		     * @param {TileSource} [options.source] - Image loading strategy
		     * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
		     * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
		     * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
		     * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
		     *      see TileSource::getPostData) or null
		     * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
		     *      requests.
		     * @param {Function} [options.callback] - Called once image has been downloaded.
		     * @param {Function} [options.abort] - Called when this image job is aborted.
		     */
		    addJob: function(options) {
		        if (!options.source) {
		            $.console.error('ImageLoader.prototype.addJob() requires [options.source]. ' +
		                'TileSource since new API defines how images are fetched. Creating a dummy TileSource.');
		            var implementation = $.TileSource.prototype;
		            options.source = {
		                downloadTileStart: implementation.downloadTileStart,
		                downloadTileAbort: implementation.downloadTileAbort
		            };
		        }

		        var _this = this,
		            complete = function(job) {
		                completeJob(_this, job, options.callback);
		            },
		            jobOptions = {
		                src: options.src,
		                tile: options.tile || {},
		                source: options.source,
		                loadWithAjax: options.loadWithAjax,
		                ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
		                crossOriginPolicy: options.crossOriginPolicy,
		                ajaxWithCredentials: options.ajaxWithCredentials,
		                postData: options.postData,
		                callback: complete,
		                abort: options.abort,
		                timeout: this.timeout
		            },
		            newJob = new $.ImageJob(jobOptions);

		        if ( !this.jobLimit || this.jobsInProgress < this.jobLimit ) {
		            newJob.start();
		            this.jobsInProgress++;
		        }
		        else {
		            this.jobQueue.push( newJob );
		        }
		    },

		    /**
		     * Clear any unstarted image loading jobs from the queue.
		     * @method
		     */
		    clear: function() {
		        for( var i = 0; i < this.jobQueue.length; i++ ) {
		            var job = this.jobQueue[i];
		            if ( typeof job.abort === "function" ) {
		                job.abort();
		            }
		        }

		        this.jobQueue = [];
		    }
		};

		/**
		 * Cleans up ImageJob once completed. Restarts job after tileRetryDelay seconds if failed
		 * but max tileRetryMax times
		 * @method
		 * @private
		 * @param loader - ImageLoader used to start job.
		 * @param job - The ImageJob that has completed.
		 * @param callback - Called once cleanup is finished.
		 */
		function completeJob(loader, job, callback) {
		    if (job.errorMsg !== '' && (job.data === null || job.data === undefined) && job.tries < 1 + loader.tileRetryMax) {
		        loader.failedTiles.push(job);
		    }
		    var nextJob;

		    loader.jobsInProgress--;

		    if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
		        nextJob = loader.jobQueue.shift();
		        nextJob.start();
		        loader.jobsInProgress++;
		    }

		    if (loader.tileRetryMax > 0 && loader.jobQueue.length === 0) {
		        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.failedTiles.length > 0) {
		             nextJob = loader.failedTiles.shift();
		             setTimeout(function () {
		                 nextJob.start();
		             }, loader.tileRetryDelay);
		             loader.jobsInProgress++;
		         }
		     }

		    callback(job.data, job.errorMsg, job.request);
		}

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - Tile
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class Tile
		 * @memberof OpenSeadragon
		 * @param {Number} level The zoom level this tile belongs to.
		 * @param {Number} x The vector component 'x'.
		 * @param {Number} y The vector component 'y'.
		 * @param {OpenSeadragon.Rect} bounds Where this tile fits, in normalized
		 *      coordinates.
		 * @param {Boolean} exists Is this tile a part of a sparse image? ( Also has
		 *      this tile failed to load? )
		 * @param {String|Function} url The URL of this tile's image or a function that returns a url.
		 * @param {CanvasRenderingContext2D} context2D The context2D of this tile if it
		 *      is provided directly by the tile source.
		 * @param {Boolean} loadWithAjax Whether this tile image should be loaded with an AJAX request .
		 * @param {Object} ajaxHeaders The headers to send with this tile's AJAX request (if applicable).
		 * @param {OpenSeadragon.Rect} sourceBounds The portion of the tile to use as the source of the
		 *      drawing operation, in pixels. Note that this only works when drawing with canvas; when drawing
		 *      with HTML the entire tile is always used.
		 * @param {String} postData HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		 *      see TileSource::getPostData) or null
		 * @param {String} cacheKey key to act as a tile cache, must be unique for tiles with unique image data
		 */
		$.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds, postData, cacheKey) {
		    /**
		     * The zoom level this tile belongs to.
		     * @member {Number} level
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.level   = level;
		    /**
		     * The vector component 'x'.
		     * @member {Number} x
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.x       = x;
		    /**
		     * The vector component 'y'.
		     * @member {Number} y
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.y       = y;
		    /**
		     * Where this tile fits, in normalized coordinates
		     * @member {OpenSeadragon.Rect} bounds
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.bounds  = bounds;
		    /**
		     * Where this tile fits, in normalized coordinates, after positioning
		     * @member {OpenSeadragon.Rect} positionedBounds
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.positionedBounds  = new OpenSeadragon.Rect(bounds.x, bounds.y, bounds.width, bounds.height);
		    /**
		     * The portion of the tile to use as the source of the drawing operation, in pixels. Note that
		     * this only works when drawing with canvas; when drawing with HTML the entire tile is always used.
		     * @member {OpenSeadragon.Rect} sourceBounds
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.sourceBounds = sourceBounds;
		    /**
		     * Is this tile a part of a sparse image? Also has this tile failed to load?
		     * @member {Boolean} exists
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.exists  = exists;
		    /**
		     * Private property to hold string url or url retriever function.
		     * Consumers should access via Tile.getUrl()
		     * @private
		     * @member {String|Function} url
		     * @memberof OpenSeadragon.Tile#
		     */
		    this._url     = url;
		    /**
		     * Post parameters for this tile. For example, it can be an URL-encoded string
		     * in k1=v1&k2=v2... format, or a JSON, or a FormData instance... or null if no POST request used
		     * @member {String} postData HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
		     *      see TileSource::getPostData) or null
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.postData  = postData;
		    /**
		     * The context2D of this tile if it is provided directly by the tile source.
		     * @member {CanvasRenderingContext2D} context2D
		     * @memberOf OpenSeadragon.Tile#
		     */
		    this.context2D = context2D;
		    /**
		     * Whether to load this tile's image with an AJAX request.
		     * @member {Boolean} loadWithAjax
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.loadWithAjax = loadWithAjax;
		    /**
		     * The headers to be used in requesting this tile's image.
		     * Only used if loadWithAjax is set to true.
		     * @member {Object} ajaxHeaders
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.ajaxHeaders = ajaxHeaders;

		    if (cacheKey === undefined) {
		        $.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache" +
		            " in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used.");
		        cacheKey = $.TileSource.prototype.getTileHashKey(level, x, y, url, ajaxHeaders, postData);
		    }
		    /**
		     * The unique cache key for this tile.
		     * @member {String} cacheKey
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.cacheKey = cacheKey;
		    /**
		     * Is this tile loaded?
		     * @member {Boolean} loaded
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.loaded  = false;
		    /**
		     * Is this tile loading?
		     * @member {Boolean} loading
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.loading = false;

		    /**
		     * The HTML div element for this tile
		     * @member {Element} element
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.element    = null;
		    /**
		     * The HTML img element for this tile.
		     * @member {Element} imgElement
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.imgElement = null;

		    /**
		     * The alias of this.element.style.
		     * @member {String} style
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.style      = null;
		    /**
		     * This tile's position on screen, in pixels.
		     * @member {OpenSeadragon.Point} position
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.position   = null;
		    /**
		     * This tile's size on screen, in pixels.
		     * @member {OpenSeadragon.Point} size
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.size       = null;
		    /**
		     * Whether to flip the tile when rendering.
		     * @member {Boolean} flipped
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.flipped    = false;
		    /**
		     * The start time of this tile's blending.
		     * @member {Number} blendStart
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.blendStart = null;
		    /**
		     * The current opacity this tile should be.
		     * @member {Number} opacity
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.opacity    = null;
		    /**
		     * The squared distance of this tile to the viewport center.
		     * Use for comparing tiles.
		     * @private
		     * @member {Number} squaredDistance
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.squaredDistance   = null;
		    /**
		     * The visibility score of this tile.
		     * @member {Number} visibility
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.visibility = null;

		    /**
		     * The transparency indicator of this tile.
		     * @member {Boolean} hasTransparency true if tile contains transparency for correct rendering
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.hasTransparency = false;

		    /**
		     * Whether this tile is currently being drawn.
		     * @member {Boolean} beingDrawn
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.beingDrawn     = false;

		    /**
		     * Timestamp the tile was last touched.
		     * @member {Number} lastTouchTime
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.lastTouchTime  = 0;

		    /**
		     * Whether this tile is in the right-most column for its level.
		     * @member {Boolean} isRightMost
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.isRightMost = false;

		    /**
		     * Whether this tile is in the bottom-most row for its level.
		     * @member {Boolean} isBottomMost
		     * @memberof OpenSeadragon.Tile#
		     */
		    this.isBottomMost = false;
		};

		/** @lends OpenSeadragon.Tile.prototype */
		$.Tile.prototype = {

		    /**
		     * Provides a string representation of this tiles level and (x,y)
		     * components.
		     * @function
		     * @returns {String}
		     */
		    toString: function() {
		        return this.level + "/" + this.x + "_" + this.y;
		    },

		    // private
		    _hasTransparencyChannel: function() {
		        console.warn("Tile.prototype._hasTransparencyChannel() has been " +
		            "deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead.");
		        return !!this.context2D || this.getUrl().match('.png');
		    },

		    /**
		     * The Image object for this tile.
		     * @member {Object} image
		     * @memberof OpenSeadragon.Tile#
		     * @deprecated
		     * @returns {Image}
		     */
		    get image() {
		        $.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead.");
		        return this.getImage();
		    },

		    /**
		     * The URL of this tile's image.
		     * @member {String} url
		     * @memberof OpenSeadragon.Tile#
		     * @deprecated
		     * @returns {String}
		     */
		    get url() {
		        $.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead.");
		        return this.getUrl();
		    },

		    /**
		     * Get the Image object for this tile.
		     * @returns {Image}
		     */
		    getImage: function() {
		        return this.cacheImageRecord.getImage();
		    },

		    /**
		     * Get the url string for this tile.
		     * @returns {String}
		     */
		    getUrl: function() {
		        if (typeof this._url === 'function') {
		            return this._url();
		        }

		        return this._url;
		    },

		    /**
		     * Get the CanvasRenderingContext2D instance for tile image data drawn
		     * onto Canvas if enabled and available
		     * @returns {CanvasRenderingContext2D}
		     */
		    getCanvasContext: function() {
		        return this.context2D || (this.cacheImageRecord && this.cacheImageRecord.getRenderedContext());
		    },

		    /**
		     * Get the ratio between current and original size.
		     * @function
		     * @returns {Float}
		     */
		    getScaleForEdgeSmoothing: function() {
		        var context;
		        if (this.cacheImageRecord) {
		            context = this.cacheImageRecord.getRenderedContext();
		        } else if (this.context2D) {
		            context = this.context2D;
		        } else {
		            $.console.warn(
		                '[Tile.drawCanvas] attempting to get tile scale %s when tile\'s not cached',
		                this.toString());
		            return 1;
		        }
		        return context.canvas.width / (this.size.x * $.pixelDensityRatio);
		    },

		    /**
		     * Get a translation vector that when applied to the tile position produces integer coordinates.
		     * Needed to avoid swimming and twitching.
		     * @function
		     * @param {Number} [scale=1] - Scale to be applied to position.
		     * @returns {OpenSeadragon.Point}
		     */
		    getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
		        // The translation vector must have positive values, otherwise the image goes a bit off
		        // the sketch canvas to the top and left and we must use negative coordinates to repaint it
		        // to the main canvas. In that case, some browsers throw:
		        // INDEX_SIZE_ERR: DOM Exception 1: Index or size was negative, or greater than the allowed value.
		        var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
		        var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
		        return new $.Point(x, y).minus(
		            this.position
		                .times($.pixelDensityRatio)
		                .times(scale || 1)
		                .apply(function(x) {
		                    return x % 1;
		                })
		        );
		    },

		    /**
		     * Removes tile from its container.
		     * @function
		     */
		    unload: function() {
		        if ( this.imgElement && this.imgElement.parentNode ) {
		            this.imgElement.parentNode.removeChild( this.imgElement );
		        }
		        if ( this.element && this.element.parentNode ) {
		            this.element.parentNode.removeChild( this.element );
		        }

		        this.element    = null;
		        this.imgElement = null;
		        this.loaded     = false;
		        this.loading    = false;
		    }
		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Overlay
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function($) {

		    /**
		     * An enumeration of positions that an overlay may be assigned relative to
		     * the viewport.
		     * It is identical to OpenSeadragon.Placement but is kept for backward
		     * compatibility.
		     * @member OverlayPlacement
		     * @memberof OpenSeadragon
		     * @see OpenSeadragon.Placement
		     * @static
		     * @readonly
		     * @type {Object}
		     * @property {Number} CENTER
		     * @property {Number} TOP_LEFT
		     * @property {Number} TOP
		     * @property {Number} TOP_RIGHT
		     * @property {Number} RIGHT
		     * @property {Number} BOTTOM_RIGHT
		     * @property {Number} BOTTOM
		     * @property {Number} BOTTOM_LEFT
		     * @property {Number} LEFT
		     */
		    $.OverlayPlacement = $.Placement;

		    /**
		     * An enumeration of possible ways to handle overlays rotation
		     * @member OverlayRotationMode
		     * @memberOf OpenSeadragon
		     * @static
		     * @readonly
		     * @property {Number} NO_ROTATION The overlay ignore the viewport rotation.
		     * @property {Number} EXACT The overlay use CSS 3 transforms to rotate with
		     * the viewport. If the overlay contains text, it will get rotated as well.
		     * @property {Number} BOUNDING_BOX The overlay adjusts for rotation by
		     * taking the size of the bounding box of the rotated bounds.
		     * Only valid for overlays with Rect location and scalable in both directions.
		     */
		    $.OverlayRotationMode = $.freezeObject({
		        NO_ROTATION: 1,
		        EXACT: 2,
		        BOUNDING_BOX: 3
		    });

		    /**
		     * @class Overlay
		     * @classdesc Provides a way to float an HTML element on top of the viewer element.
		     *
		     * @memberof OpenSeadragon
		     * @param {Object} options
		     * @param {Element} options.element
		     * @param {OpenSeadragon.Point|OpenSeadragon.Rect} options.location - The
		     * location of the overlay on the image. If a {@link OpenSeadragon.Point}
		     * is specified, the overlay will be located at this location with respect
		     * to the placement option. If a {@link OpenSeadragon.Rect} is specified,
		     * the overlay will be placed at this location with the corresponding width
		     * and height and placement TOP_LEFT.
		     * @param {OpenSeadragon.Placement} [options.placement=OpenSeadragon.Placement.TOP_LEFT]
		     * Defines what part of the overlay should be at the specified options.location
		     * @param {OpenSeadragon.Overlay.OnDrawCallback} [options.onDraw]
		     * @param {Boolean} [options.checkResize=true] Set to false to avoid to
		     * check the size of the overlay every time it is drawn in the directions
		     * which are not scaled. It will improve performances but will cause a
		     * misalignment if the overlay size changes.
		     * @param {Number} [options.width] The width of the overlay in viewport
		     * coordinates. If specified, the width of the overlay will be adjusted when
		     * the zoom changes.
		     * @param {Number} [options.height] The height of the overlay in viewport
		     * coordinates. If specified, the height of the overlay will be adjusted when
		     * the zoom changes.
		     * @param {Boolean} [options.rotationMode=OpenSeadragon.OverlayRotationMode.EXACT]
		     * How to handle the rotation of the viewport.
		     */
		    $.Overlay = function(element, location, placement) {

		        /**
		         * onDraw callback signature used by {@link OpenSeadragon.Overlay}.
		         *
		         * @callback OnDrawCallback
		         * @memberof OpenSeadragon.Overlay
		         * @param {OpenSeadragon.Point} position
		         * @param {OpenSeadragon.Point} size
		         * @param {Element} element
		         */

		        var options;
		        if ($.isPlainObject(element)) {
		            options = element;
		        } else {
		            options = {
		                element: element,
		                location: location,
		                placement: placement
		            };
		        }

		        this.elementWrapper = document.createElement('div');
		        this.element = options.element;
		        this.elementWrapper.appendChild(this.element);

		        if (this.element.id) {
		            this.elementWrapper.id = "overlay-wrapper-" + this.element.id;
		        } else {
		            this.elementWrapper.id = "overlay-wrapper";
		        }

		        this.style = this.elementWrapper.style;
		        this._init(options);
		    };

		    /** @lends OpenSeadragon.Overlay.prototype */
		    $.Overlay.prototype = {

		        // private
		        _init: function(options) {
		            this.location = options.location;
		            this.placement = options.placement === undefined ?
		                $.Placement.TOP_LEFT : options.placement;
		            this.onDraw = options.onDraw;
		            this.checkResize = options.checkResize === undefined ?
		                true : options.checkResize;

		            // When this.width is not null, the overlay get scaled horizontally
		            this.width = options.width === undefined ? null : options.width;

		            // When this.height is not null, the overlay get scaled vertically
		            this.height = options.height === undefined ? null : options.height;

		            this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;

		            // Having a rect as location is a syntactic sugar
		            if (this.location instanceof $.Rect) {
		                this.width = this.location.width;
		                this.height = this.location.height;
		                this.location = this.location.getTopLeft();
		                this.placement = $.Placement.TOP_LEFT;
		            }

		            // Deprecated properties kept for backward compatibility.
		            this.scales = this.width !== null && this.height !== null;
		            this.bounds = new $.Rect(
		                this.location.x, this.location.y, this.width, this.height);
		            this.position = this.location;
		        },

		        /**
		         * Internal function to adjust the position of an overlay
		         * depending on it size and placement.
		         * @function
		         * @param {OpenSeadragon.Point} position
		         * @param {OpenSeadragon.Point} size
		         */
		        adjust: function(position, size) {
		            var properties = $.Placement.properties[this.placement];
		            if (!properties) {
		                return;
		            }
		            if (properties.isHorizontallyCentered) {
		                position.x -= size.x / 2;
		            } else if (properties.isRight) {
		                position.x -= size.x;
		            }
		            if (properties.isVerticallyCentered) {
		                position.y -= size.y / 2;
		            } else if (properties.isBottom) {
		                position.y -= size.y;
		            }
		        },

		        /**
		         * @function
		         */
		        destroy: function() {
		            var element = this.elementWrapper;
		            var style = this.style;

		            if (element.parentNode) {
		                element.parentNode.removeChild(element);
		                //this should allow us to preserve overlays when required between
		                //pages
		                if (element.prevElementParent) {
		                    style.display = 'none';
		                    //element.prevElementParent.insertBefore(
		                    //    element,
		                    //    element.prevNextSibling
		                    //);
		                    document.body.appendChild(element);
		                }
		            }

		            // clear the onDraw callback
		            this.onDraw = null;

		            style.top = "";
		            style.left = "";
		            style.position = "";

		            if (this.width !== null) {
		                style.width = "";
		            }
		            if (this.height !== null) {
		                style.height = "";
		            }
		            var transformOriginProp = $.getCssPropertyWithVendorPrefix(
		                'transformOrigin');
		            var transformProp = $.getCssPropertyWithVendorPrefix(
		                'transform');
		            if (transformOriginProp && transformProp) {
		                style[transformOriginProp] = "";
		                style[transformProp] = "";
		            }
		        },

		        /**
		         * @function
		         * @param {Element} container
		         */
		        drawHTML: function(container, viewport) {
		            var element = this.elementWrapper;
		            if (element.parentNode !== container) {
		                //save the source parent for later if we need it
		                element.prevElementParent = element.parentNode;
		                element.prevNextSibling = element.nextSibling;
		                container.appendChild(element);

		                // have to set position before calculating size, fix #1116
		                this.style.position = "absolute";
		                // this.size is used by overlays which don't get scaled in at
		                // least one direction when this.checkResize is set to false.
		                this.size = $.getElementSize(this.elementWrapper);
		            }
		            var positionAndSize = this._getOverlayPositionAndSize(viewport);
		            var position = positionAndSize.position;
		            var size = this.size = positionAndSize.size;
		            var outerScale = "";
		            if (viewport.overlayPreserveContentDirection) {
		                outerScale = viewport.flipped ? " scaleX(-1)" : " scaleX(1)";
		            }
		            var rotate = viewport.flipped ? -positionAndSize.rotate : positionAndSize.rotate;
		            var scale = viewport.flipped ? " scaleX(-1)" : "";
		            // call the onDraw callback if it exists to allow one to overwrite
		            // the drawing/positioning/sizing of the overlay
		            if (this.onDraw) {
		                this.onDraw(position, size, this.element);
		            } else {
		                var style = this.style;
		                var innerStyle = this.element.style;
		                innerStyle.display = "block";
		                style.left = position.x + "px";
		                style.top = position.y + "px";
		                if (this.width !== null) {
		                    innerStyle.width = size.x + "px";
		                }
		                if (this.height !== null) {
		                    innerStyle.height = size.y + "px";
		                }
		                var transformOriginProp = $.getCssPropertyWithVendorPrefix(
		                    'transformOrigin');
		                var transformProp = $.getCssPropertyWithVendorPrefix(
		                    'transform');
		                if (transformOriginProp && transformProp) {
		                    if (rotate && !viewport.flipped) {
		                        innerStyle[transformProp] = "";
		                        style[transformOriginProp] = this._getTransformOrigin();
		                        style[transformProp] = "rotate(" + rotate + "deg)";
		                    } else if (!rotate && viewport.flipped) {
		                        innerStyle[transformProp] = outerScale;
		                        style[transformOriginProp] = this._getTransformOrigin();
		                        style[transformProp] = scale;
		                    } else if (rotate && viewport.flipped){
		                        innerStyle[transformProp] = outerScale;
		                        style[transformOriginProp] = this._getTransformOrigin();
		                        style[transformProp] = "rotate(" + rotate + "deg)" + scale;
		                    } else {
		                        innerStyle[transformProp] = "";
		                        style[transformOriginProp] = "";
		                        style[transformProp] = "";
		                    }
		                }
		                style.display = 'flex';
		            }
		        },

		        // private
		        _getOverlayPositionAndSize: function(viewport) {
		            var position = viewport.pixelFromPoint(this.location, true);
		            var size = this._getSizeInPixels(viewport);
		            this.adjust(position, size);

		            var rotate = 0;
		            if (viewport.getRotation(true) &&
		                this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {
		                // BOUNDING_BOX is only valid if both directions get scaled.
		                // Get replaced by EXACT otherwise.
		                if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX &&
		                    this.width !== null && this.height !== null) {
		                    var rect = new $.Rect(position.x, position.y, size.x, size.y);
		                    var boundingBox = this._getBoundingBox(rect, viewport.getRotation(true));
		                    position = boundingBox.getTopLeft();
		                    size = boundingBox.getSize();
		                } else {
		                    rotate = viewport.getRotation(true);
		                }
		            }

		            if (viewport.flipped) {
		                position.x = (viewport.getContainerSize().x - position.x);
		            }
		            return {
		                position: position,
		                size: size,
		                rotate: rotate
		            };
		        },

		        // private
		        _getSizeInPixels: function(viewport) {
		            var width = this.size.x;
		            var height = this.size.y;
		            if (this.width !== null || this.height !== null) {
		                var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
		                    new $.Point(this.width || 0, this.height || 0), true);
		                if (this.width !== null) {
		                    width = scaledSize.x;
		                }
		                if (this.height !== null) {
		                    height = scaledSize.y;
		                }
		            }
		            if (this.checkResize &&
		                (this.width === null || this.height === null)) {
		                var eltSize = this.size = $.getElementSize(this.elementWrapper);
		                if (this.width === null) {
		                    width = eltSize.x;
		                }
		                if (this.height === null) {
		                    height = eltSize.y;
		                }
		            }
		            return new $.Point(width, height);
		        },

		        // private
		        _getBoundingBox: function(rect, degrees) {
		            var refPoint = this._getPlacementPoint(rect);
		            return rect.rotate(degrees, refPoint).getBoundingBox();
		        },

		        // private
		        _getPlacementPoint: function(rect) {
		            var result = new $.Point(rect.x, rect.y);
		            var properties = $.Placement.properties[this.placement];
		            if (properties) {
		                if (properties.isHorizontallyCentered) {
		                    result.x += rect.width / 2;
		                } else if (properties.isRight) {
		                    result.x += rect.width;
		                }
		                if (properties.isVerticallyCentered) {
		                    result.y += rect.height / 2;
		                } else if (properties.isBottom) {
		                    result.y += rect.height;
		                }
		            }
		            return result;
		        },

		        // private
		        _getTransformOrigin: function() {
		            var result = "";
		            var properties = $.Placement.properties[this.placement];
		            if (!properties) {
		                return result;
		            }
		            if (properties.isLeft) {
		                result = "left";
		            } else if (properties.isRight) {
		                result = "right";
		            }
		            if (properties.isTop) {
		                result += " top";
		            } else if (properties.isBottom) {
		                result += " bottom";
		            }
		            return result;
		        },

		        /**
		         * Changes the overlay settings.
		         * @function
		         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
		         * If an object is specified, the options are the same than the constructor
		         * except for the element which can not be changed.
		         * @param {OpenSeadragon.Placement} placement
		         */
		        update: function(location, placement) {
		            var options = $.isPlainObject(location) ? location : {
		                location: location,
		                placement: placement
		            };
		            this._init({
		                location: options.location || this.location,
		                placement: options.placement !== undefined ?
		                    options.placement : this.placement,
		                onDraw: options.onDraw || this.onDraw,
		                checkResize: options.checkResize || this.checkResize,
		                width: options.width !== undefined ? options.width : this.width,
		                height: options.height !== undefined ? options.height : this.height,
		                rotationMode: options.rotationMode || this.rotationMode
		            });
		        },

		        /**
		         * Returns the current bounds of the overlay in viewport coordinates
		         * @function
		         * @param {OpenSeadragon.Viewport} viewport the viewport
		         * @returns {OpenSeadragon.Rect} overlay bounds
		         */
		        getBounds: function(viewport) {
		            $.console.assert(viewport,
		                'A viewport must now be passed to Overlay.getBounds.');
		            var width = this.width;
		            var height = this.height;
		            if (width === null || height === null) {
		                var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
		                if (width === null) {
		                    width = size.x;
		                }
		                if (height === null) {
		                    height = size.y;
		                }
		            }
		            var location = this.location.clone();
		            this.adjust(location, new $.Point(width, height));
		            return this._adjustBoundsForRotation(
		                viewport, new $.Rect(location.x, location.y, width, height));
		        },

		        // private
		        _adjustBoundsForRotation: function(viewport, bounds) {
		            if (!viewport ||
		                viewport.getRotation(true) === 0 ||
		                this.rotationMode === $.OverlayRotationMode.EXACT) {
		                return bounds;
		            }
		            if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {
		                // If overlay not fully scalable, BOUNDING_BOX falls back to EXACT
		                if (this.width === null || this.height === null) {
		                    return bounds;
		                }
		                // It is easier to just compute the position and size and
		                // convert to viewport coordinates.
		                var positionAndSize = this._getOverlayPositionAndSize(viewport);
		                return viewport.viewerElementToViewportRectangle(new $.Rect(
		                    positionAndSize.position.x,
		                    positionAndSize.position.y,
		                    positionAndSize.size.x,
		                    positionAndSize.size.y));
		            }

		            // NO_ROTATION case
		            return bounds.rotate(-viewport.getRotation(true),
		                this._getPlacementPoint(bounds));
		        }
		    };

		}(OpenSeadragon));

		/*
		 * OpenSeadragon - DrawerBase
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		    const OpenSeadragon = $; // (re)alias back to OpenSeadragon for JSDoc
		/**
		 * @class OpenSeadragon.DrawerBase
		 * @classdesc Base class for Drawers that handle rendering of tiles for an {@link OpenSeadragon.Viewer}.
		 * @param {Object} options - Options for this Drawer.
		 * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
		 * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
		 * @param {HTMLElement} options.element - Parent element.
		 * @abstract
		 */

		OpenSeadragon.DrawerBase = class DrawerBase{
		    constructor(options){
		        $.console.assert( options.viewer, "[Drawer] options.viewer is required" );
		        $.console.assert( options.viewport, "[Drawer] options.viewport is required" );
		        $.console.assert( options.element, "[Drawer] options.element is required" );

		        this.viewer = options.viewer;
		        this.viewport = options.viewport;
		        this.debugGridColor = typeof options.debugGridColor === 'string' ? [options.debugGridColor] : options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
		        this.options = options.options || {};

		        this.container  = $.getElement( options.element );

		        this._renderingTarget = this._createDrawingElement();


		        this.canvas.style.width     = "100%";
		        this.canvas.style.height    = "100%";
		        this.canvas.style.position  = "absolute";
		        // set canvas.style.left = 0 so the canvas is positioned properly in ltr and rtl html
		        this.canvas.style.left = "0";
		        $.setElementOpacity( this.canvas, this.viewer.opacity, true );

		        // Allow pointer events to pass through the canvas element so implicit
		        //   pointer capture works on touch devices
		        $.setElementPointerEventsNone( this.canvas );
		        $.setElementTouchActionNone( this.canvas );

		        // explicit left-align
		        this.container.style.textAlign = "left";
		        this.container.appendChild( this.canvas );

		        this._checkForAPIOverrides();
		    }

		    // protect the canvas member with a getter
		    get canvas(){
		        return this._renderingTarget;
		    }
		    get element(){
		        $.console.error('Drawer.element is deprecated. Use Drawer.container instead.');
		        return this.container;
		    }

		    /**
		     * @abstract
		     * @returns {String | undefined} What type of drawer this is. Must be overridden by extending classes.
		     */
		    getType(){
		        $.console.error('Drawer.getType must be implemented by child class');
		        return undefined;
		    }

		    /**
		     * @abstract
		     * @returns {Boolean} Whether the drawer implementation is supported by the browser. Must be overridden by extending classes.
		     */
		    static isSupported() {
		        $.console.error('Drawer.isSupported must be implemented by child class');
		    }

		    /**
		     * @abstract
		     * @returns {Element} the element to draw into
		     * @private
		     */
		    _createDrawingElement() {
		        $.console.error('Drawer._createDrawingElement must be implemented by child class');
		        return null;
		    }

		    /**
		     * @abstract
		     * @param {Array} tiledImages - An array of TiledImages that are ready to be drawn.
		     * @private
		     */
		    draw(tiledImages) {
		        $.console.error('Drawer.draw must be implemented by child class');
		    }

		    /**
		     * @abstract
		     * @returns {Boolean} True if rotation is supported.
		     */
		    canRotate() {
		        $.console.error('Drawer.canRotate must be implemented by child class');
		    }

		    /**
		     * @abstract
		     */
		    destroy() {
		        $.console.error('Drawer.destroy must be implemented by child class');
		    }

		    /**
		     * @param {TiledImage} tiledImage the tiled image that is calling the function
		     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
		     * @private
		     */
		    minimumOverlapRequired(tiledImage) {
		        return false;
		    }


		    /**
		     * @abstract
		     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
		     * drawn smoothly on the canvas; see imageSmoothingEnabled in
		     * {@link OpenSeadragon.Options} for more explanation.
		     */
		    setImageSmoothingEnabled(imageSmoothingEnabled){
		        $.console.error('Drawer.setImageSmoothingEnabled must be implemented by child class');
		    }

		    /**
		     * Optional public API to draw a rectangle (e.g. for debugging purposes)
		     * Child classes can override this method if they wish to support this
		     * @param {OpenSeadragon.Rect} rect
		     */
		    drawDebuggingRect(rect) {
		        $.console.warn('[drawer].drawDebuggingRect is not implemented by this drawer');
		    }

		    // Deprecated functions
		    clear(){
		        $.console.warn('[drawer].clear() is deprecated. The drawer is responsible for clearing itself as needed before drawing tiles.');
		    }

		    // Private functions

		    /**
		     * Ensures that child classes have provided implementations for public API methods
		     * draw, canRotate, destroy, and setImageSmoothinEnabled. Throws an exception if the original
		     * placeholder methods are still in place.
		     * @private
		     *
		     */
		    _checkForAPIOverrides(){
		        if(this._createDrawingElement === $.DrawerBase.prototype._createDrawingElement){
		            throw(new Error("[drawer]._createDrawingElement must be implemented by child class"));
		        }
		        if(this.draw === $.DrawerBase.prototype.draw){
		            throw(new Error("[drawer].draw must be implemented by child class"));
		        }
		        if(this.canRotate === $.DrawerBase.prototype.canRotate){
		            throw(new Error("[drawer].canRotate must be implemented by child class"));
		        }
		        if(this.destroy === $.DrawerBase.prototype.destroy){
		            throw(new Error("[drawer].destroy must be implemented by child class"));
		        }
		        if(this.setImageSmoothingEnabled === $.DrawerBase.prototype.setImageSmoothingEnabled){
		            throw(new Error("[drawer].setImageSmoothingEnabled must be implemented by child class"));
		        }
		    }


		    // Utility functions

		    /**
		     * Scale from OpenSeadragon viewer rectangle to drawer rectangle
		     * (ignoring rotation)
		     * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
		     * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
		     */
		    viewportToDrawerRectangle(rectangle) {
		        var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
		        var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);

		        return new $.Rect(
		            topLeft.x * $.pixelDensityRatio,
		            topLeft.y * $.pixelDensityRatio,
		            size.x * $.pixelDensityRatio,
		            size.y * $.pixelDensityRatio
		        );
		    }

		    /**
		     * This function converts the given point from to the drawer coordinate by
		     * multiplying it with the pixel density.
		     * This function does not take rotation into account, thus assuming provided
		     * point is at 0 degree.
		     * @param {OpenSeadragon.Point} point - the pixel point to convert
		     * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
		     */
		    viewportCoordToDrawerCoord(point) {
		        var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
		        return new $.Point(
		            vpPoint.x * $.pixelDensityRatio,
		            vpPoint.y * $.pixelDensityRatio
		        );
		    }


		    // Internal utility functions

		    /**
		     * Calculate width and height of the canvas based on viewport dimensions
		     * and pixelDensityRatio
		     * @private
		     * @returns {OpenSeadragon.Point} {x, y} size of the canvas
		     */
		    _calculateCanvasSize() {
		        var pixelDensityRatio = $.pixelDensityRatio;
		        var viewportSize = this.viewport.getContainerSize();
		        return new OpenSeadragon.Point( Math.round(viewportSize.x * pixelDensityRatio), Math.round(viewportSize.y * pixelDensityRatio));
		    }

		    /**
		     * Called by implementations to fire the tiled-image-drawn event (used by tests)
		     * @private
		     */
		    _raiseTiledImageDrawnEvent(tiledImage, tiles){
		        if(!this.viewer) {
		            return;
		        }

		        /**
		        *  Raised when a tiled image is drawn to the canvas. Used internally for testing.
		        *  The update-viewport event is preferred if you want to know when a frame has been drawn.
		        *
		        * @event tiled-image-drawn
		        * @memberof OpenSeadragon.Viewer
		        * @type {object}
		        * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		        * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		        * @property {Array} tiles - An array of Tile objects that were drawn.
		        * @property {?Object} userData - Arbitrary subscriber-defined object.
		        * @private
		        */
		        this.viewer.raiseEvent( 'tiled-image-drawn', {
		            tiledImage: tiledImage,
		            tiles: tiles,
		        });
		    }

		    /**
		     * Called by implementations to fire the drawer-error event
		     * @private
		     */
		    _raiseDrawerErrorEvent(tiledImage, errorMessage){
		        if(!this.viewer) {
		            return;
		        }

		        /**
		        *  Raised when a tiled image is drawn to the canvas. Used internally for testing.
		        *  The update-viewport event is preferred if you want to know when a frame has been drawn.
		        *
		        * @event drawer-error
		        * @memberof OpenSeadragon.Viewer
		        * @type {object}
		        * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		        * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		        * @property {OpenSeadragon.DrawerBase} drawer - The drawer that raised the error.
		        * @property {String} error - A message describing the error.
		        * @property {?Object} userData - Arbitrary subscriber-defined object.
		        * @private
		        */
		        this.viewer.raiseEvent( 'drawer-error', {
		            tiledImage: tiledImage,
		            drawer: this,
		            error: errorMessage,
		        });
		    }


		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - HTMLDrawer
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		    const OpenSeadragon = $; // alias back for JSDoc

		/**
		 * @class OpenSeadragon.HTMLDrawer
		 * @extends OpenSeadragon.DrawerBase
		 * @classdesc HTML-based implementation of DrawerBase for an {@link OpenSeadragon.Viewer}.
		 * @param {Object} options - Options for this Drawer.
		 * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
		 * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
		 * @param {Element} options.element - Parent element.
		 * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
		 */

		class HTMLDrawer extends OpenSeadragon.DrawerBase{
		    constructor(options){
		        super(options);

		        /**
		         * The HTML element (div) that this drawer uses for drawing
		         * @member {Element} canvas
		         * @memberof OpenSeadragon.HTMLDrawer#
		         */

		        /**
		         * The parent element of this Drawer instance, passed in when the Drawer was created.
		         * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
		         * @member {Element} container
		         * @memberof OpenSeadragon.HTMLDrawer#
		         */

		        // Reject listening for the tile-drawing event, which this drawer does not fire
		        this.viewer.rejectEventHandler("tile-drawing", "The HTMLDrawer does not raise the tile-drawing event");
		        // Since the tile-drawn event is fired by this drawer, make sure handlers can be added for it
		        this.viewer.allowEventHandler("tile-drawn");
		    }

		    /**
		     * @returns {Boolean} always true
		     */
		    static isSupported(){
		        return true;
		    }

		    /**
		     *
		     * @returns 'html'
		     */
		    getType(){
		        return 'html';
		    }

		    /**
		     * @param {TiledImage} tiledImage the tiled image that is calling the function
		     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
		     * @private
		     */
		    minimumOverlapRequired(tiledImage) {
		        return true;
		    }

		    /**
		     * create the HTML element (e.g. canvas, div) that the image will be drawn into
		     * @returns {Element} the div to draw into
		     */
		    _createDrawingElement(){
		        let canvas = $.makeNeutralElement("div");
		        return canvas;
		    }

		    /**
		     * Draws the TiledImages
		     */
		    draw(tiledImages) {
		        var _this = this;
		        this._prepareNewFrame(); // prepare to draw a new frame
		        tiledImages.forEach(function(tiledImage){
		            if (tiledImage.opacity !== 0) {
		                _this._drawTiles(tiledImage);
		            }
		        });

		    }

		    /**
		     * @returns {Boolean} False - rotation is not supported.
		     */
		    canRotate() {
		        return false;
		    }

		    /**
		     * Destroy the drawer (unload current loaded tiles)
		     */
		    destroy() {
		        this.container.removeChild(this.canvas);
		    }

		    /**
		     * This function is ignored by the HTML Drawer. Implementing it is required by DrawerBase.
		     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
		     * drawn smoothly on the canvas; see imageSmoothingEnabled in
		     * {@link OpenSeadragon.Options} for more explanation.
		     */
		    setImageSmoothingEnabled(){
		        // noop - HTML Drawer does not deal with this property
		    }

		    /**
		     * Clears the Drawer so it's ready to draw another frame.
		     * @private
		     *
		     */
		    _prepareNewFrame() {
		        this.canvas.innerHTML = "";
		    }

		    /**
		     * Draws a TiledImage.
		     * @private
		     *
		     */
		    _drawTiles( tiledImage ) {
		        var lastDrawn = tiledImage.getTilesToDraw().map(info => info.tile);
		        if (tiledImage.opacity === 0 || (lastDrawn.length === 0 && !tiledImage.placeholderFillStyle)) {
		            return;
		        }

		        // Iterate over the tiles to draw, and draw them
		        for (var i = lastDrawn.length - 1; i >= 0; i--) {
		            var tile = lastDrawn[ i ];
		            this._drawTile( tile );

		            if( this.viewer ){
		                /**
		                 * Raised when a tile is drawn to the canvas. Only valid for
		                 * context2d and html drawers.
		                 *
		                 * @event tile-drawn
		                 * @memberof OpenSeadragon.Viewer
		                 * @type {object}
		                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		                 * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		                 * @property {OpenSeadragon.Tile} tile
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                this.viewer.raiseEvent( 'tile-drawn', {
		                    tiledImage: tiledImage,
		                    tile: tile
		                });
		            }
		        }

		    }

		    /**
		     * Draws the given tile.
		     * @private
		     * @param {OpenSeadragon.Tile} tile - The tile to draw.
		     * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
		     * drawingHandler({context, tile, rendered})
		     */
		    _drawTile( tile ) {
		        $.console.assert(tile, '[Drawer._drawTile] tile is required');

		        let container = this.canvas;

		        if (!tile.cacheImageRecord) {
		            $.console.warn(
		                '[Drawer._drawTileToHTML] attempting to draw tile %s when it\'s not cached',
		                tile.toString());
		            return;
		        }

		        if ( !tile.loaded ) {
		            $.console.warn(
		                "Attempting to draw tile %s when it's not yet loaded.",
		                tile.toString()
		            );
		            return;
		        }

		        //EXPERIMENTAL - trying to figure out how to scale the container
		        //               content during animation of the container size.

		        if ( !tile.element ) {
		            var image = tile.getImage();
		            if (!image) {
		                return;
		            }

		            tile.element                              = $.makeNeutralElement( "div" );
		            tile.imgElement                           = image.cloneNode();
		            tile.imgElement.style.msInterpolationMode = "nearest-neighbor";
		            tile.imgElement.style.width               = "100%";
		            tile.imgElement.style.height              = "100%";

		            tile.style                     = tile.element.style;
		            tile.style.position            = "absolute";
		        }

		        if ( tile.element.parentNode !== container ) {
		            container.appendChild( tile.element );
		        }
		        if ( tile.imgElement.parentNode !== tile.element ) {
		            tile.element.appendChild( tile.imgElement );
		        }

		        tile.style.top     = tile.position.y + "px";
		        tile.style.left    = tile.position.x + "px";
		        tile.style.height  = tile.size.y + "px";
		        tile.style.width   = tile.size.x + "px";

		        if (tile.flipped) {
		            tile.style.transform = "scaleX(-1)";
		        }

		        $.setElementOpacity( tile.element, tile.opacity );
		    }

		}

		$.HTMLDrawer = HTMLDrawer;


		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - CanvasDrawer
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		    const OpenSeadragon = $; // (re)alias back to OpenSeadragon for JSDoc
		/**
		 * @class OpenSeadragon.CanvasDrawer
		 * @extends OpenSeadragon.DrawerBase
		 * @classdesc Default implementation of CanvasDrawer for an {@link OpenSeadragon.Viewer}.
		 * @param {Object} options - Options for this Drawer.
		 * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
		 * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
		 * @param {Element} options.element - Parent element.
		 * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
		 */

		class CanvasDrawer extends OpenSeadragon.DrawerBase{
		    constructor(options){
		        super(options);

		        /**
		         * The HTML element (canvas) that this drawer uses for drawing
		         * @member {Element} canvas
		         * @memberof OpenSeadragon.CanvasDrawer#
		         */

		        /**
		         * The parent element of this Drawer instance, passed in when the Drawer was created.
		         * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
		         * @member {Element} container
		         * @memberof OpenSeadragon.CanvasDrawer#
		         */

		        /**
		         * 2d drawing context for {@link OpenSeadragon.CanvasDrawer#canvas}.
		         * @member {Object} context
		         * @memberof OpenSeadragon.CanvasDrawer#
		         * @private
		         */
		        this.context = this.canvas.getContext( '2d' );

		        // Sketch canvas used to temporarily draw tiles which cannot be drawn directly
		        // to the main canvas due to opacity. Lazily initialized.
		        this.sketchCanvas = null;
		        this.sketchContext = null;

		        // Image smoothing for canvas rendering (only if canvas is used).
		        // Canvas default is "true", so this will only be changed if user specifies "false" in the options or via setImageSmoothinEnabled.
		        this._imageSmoothingEnabled = true;

		        // Since the tile-drawn and tile-drawing events are fired by this drawer, make sure handlers can be added for them
		        this.viewer.allowEventHandler("tile-drawn");
		        this.viewer.allowEventHandler("tile-drawing");

		    }

		    /**
		     * @returns {Boolean} true if canvas is supported by the browser, otherwise false
		     */
		    static isSupported(){
		        return $.supportsCanvas;
		    }

		    getType(){
		        return 'canvas';
		    }

		    /**
		     * create the HTML element (e.g. canvas, div) that the image will be drawn into
		     * @returns {Element} the canvas to draw into
		     */
		    _createDrawingElement(){
		        let canvas = $.makeNeutralElement("canvas");
		        let viewportSize = this._calculateCanvasSize();
		        canvas.width = viewportSize.x;
		        canvas.height = viewportSize.y;
		        return canvas;
		    }

		    /**
		     * Draws the TiledImages
		     */
		    draw(tiledImages) {
		        this._prepareNewFrame(); // prepare to draw a new frame
		        if(this.viewer.viewport.getFlip() !== this._viewportFlipped){
		            this._flip();
		        }
		        for(const tiledImage of tiledImages){
		            if (tiledImage.opacity !== 0) {
		                this._drawTiles(tiledImage);
		            }
		        }
		    }

		    /**
		     * @returns {Boolean} True - rotation is supported.
		     */
		    canRotate() {
		        return true;
		    }

		    /**
		     * Destroy the drawer (unload current loaded tiles)
		     */
		    destroy() {
		        //force unloading of current canvas (1x1 will be gc later, trick not necessarily needed)
		        this.canvas.width  = 1;
		        this.canvas.height = 1;
		        this.sketchCanvas = null;
		        this.sketchContext = null;
		        this.container.removeChild(this.canvas);
		    }

		    /**
		     * @param {TiledImage} tiledImage the tiled image that is calling the function
		     * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
		     * @private
		     */
		    minimumOverlapRequired(tiledImage) {
		        return true;
		    }


		    /**
		     * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
		     *
		     * @function
		     * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
		     * drawn smoothly on the canvas; see imageSmoothingEnabled in
		     * {@link OpenSeadragon.Options} for more explanation.
		     */
		    setImageSmoothingEnabled(imageSmoothingEnabled){
		        this._imageSmoothingEnabled = !!imageSmoothingEnabled;
		        this._updateImageSmoothingEnabled(this.context);
		        this.viewer.forceRedraw();
		    }

		    /**
		     * Draw a rectangle onto the canvas
		     * @param {OpenSeadragon.Rect} rect
		     */
		    drawDebuggingRect(rect) {
		        var context = this.context;
		        context.save();
		        context.lineWidth = 2 * $.pixelDensityRatio;
		        context.strokeStyle = this.debugGridColor[0];
		        context.fillStyle = this.debugGridColor[0];

		        context.strokeRect(
		            rect.x * $.pixelDensityRatio,
		            rect.y * $.pixelDensityRatio,
		            rect.width * $.pixelDensityRatio,
		            rect.height * $.pixelDensityRatio
		        );

		        context.restore();
		    }

		    /**
		     * Test whether the current context is flipped or not
		     * @private
		     */
		    get _viewportFlipped(){
		        return this.context.getTransform().a < 0;
		    }

		    /**
		     * Fires the tile-drawing event.
		     * @private
		     */
		    _raiseTileDrawingEvent(tiledImage, context, tile, rendered){
		        /**
		         * This event is fired just before the tile is drawn giving the application a chance to alter the image.
		         *
		         * NOTE: This event is only fired when the 'canvas' drawer is being used
		         *
		         * @event tile-drawing
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {OpenSeadragon.Tile} tile - The Tile being drawn.
		         * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		         * @property {CanvasRenderingContext2D} context - The HTML canvas context being drawn into.
		         * @property {CanvasRenderingContext2D} rendered - The HTML canvas context containing the tile imagery.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.viewer.raiseEvent('tile-drawing', {
		            tiledImage: tiledImage,
		            context: context,
		            tile: tile,
		            rendered: rendered
		        });
		    }

		    /**
		     * Clears the Drawer so it's ready to draw another frame.
		     * @private
		     *
		     */
		    _prepareNewFrame() {
		        var viewportSize = this._calculateCanvasSize();
		        if( this.canvas.width !== viewportSize.x ||
		            this.canvas.height !== viewportSize.y ) {
		            this.canvas.width = viewportSize.x;
		            this.canvas.height = viewportSize.y;
		            this._updateImageSmoothingEnabled(this.context);
		            if ( this.sketchCanvas !== null ) {
		                var sketchCanvasSize = this._calculateSketchCanvasSize();
		                this.sketchCanvas.width = sketchCanvasSize.x;
		                this.sketchCanvas.height = sketchCanvasSize.y;
		                this._updateImageSmoothingEnabled(this.sketchContext);
		            }
		        }
		        this._clear();
		    }

		    /**
		     * @private
		     * @param {Boolean} useSketch Whether to clear sketch canvas or main canvas
		     * @param {OpenSeadragon.Rect} [bounds] The rectangle to clear
		     */
		    _clear(useSketch, bounds){
		        var context = this._getContext(useSketch);
		        if (bounds) {
		            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
		        } else {
		            var canvas = context.canvas;
		            context.clearRect(0, 0, canvas.width, canvas.height);
		        }
		    }

		    /**
		     * Draws a TiledImage.
		     * @private
		     *
		     */
		    _drawTiles( tiledImage ) {
		        var lastDrawn =  tiledImage.getTilesToDraw().map(info => info.tile);
		        if (tiledImage.opacity === 0 || (lastDrawn.length === 0 && !tiledImage.placeholderFillStyle)) {
		            return;
		        }

		        var tile = lastDrawn[0];
		        var useSketch;

		        if (tile) {
		            useSketch = tiledImage.opacity < 1 ||
		                (tiledImage.compositeOperation && tiledImage.compositeOperation !== 'source-over') ||
		                (!tiledImage._isBottomItem() &&
		                tiledImage.source.hasTransparency(tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData));
		        }

		        var sketchScale;
		        var sketchTranslate;

		        var zoom = this.viewport.getZoom(true);
		        var imageZoom = tiledImage.viewportToImageZoom(zoom);

		        if (lastDrawn.length > 1 &&
		            imageZoom > tiledImage.smoothTileEdgesMinZoom &&
		            !tiledImage.iOSDevice &&
		            tiledImage.getRotation(true) % 360 === 0 ){ // TODO: support tile edge smoothing with tiled image rotation.
		            // When zoomed in a lot (>100%) the tile edges are visible.
		            // So we have to composite them at ~100% and scale them up together.
		            // Note: Disabled on iOS devices per default as it causes a native crash
		            useSketch = true;
		            sketchScale = tile.getScaleForEdgeSmoothing();
		            sketchTranslate = tile.getTranslationForEdgeSmoothing(sketchScale,
		                this._getCanvasSize(false),
		                this._getCanvasSize(true));
		        }

		        var bounds;
		        if (useSketch) {
		            if (!sketchScale) {
		                // Except when edge smoothing, we only clean the part of the
		                // sketch canvas we are going to use for performance reasons.
		                bounds = this.viewport.viewportToViewerElementRectangle(
		                    tiledImage.getClippedBounds(true))
		                    .getIntegerBoundingBox();

		                bounds = bounds.times($.pixelDensityRatio);
		            }
		            this._clear(true, bounds);
		        }

		        // When scaling, we must rotate only when blending the sketch canvas to
		        // avoid interpolation
		        if (!sketchScale) {
		            this._setRotations(tiledImage, useSketch);
		        }

		        var usedClip = false;
		        if ( tiledImage._clip ) {
		            this._saveContext(useSketch);

		            var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
		            box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
		            var clipRect = this.viewportToDrawerRectangle(box);
		            if (sketchScale) {
		                clipRect = clipRect.times(sketchScale);
		            }
		            if (sketchTranslate) {
		                clipRect = clipRect.translate(sketchTranslate);
		            }
		            this._setClip(clipRect, useSketch);

		            usedClip = true;
		        }

		        if (tiledImage._croppingPolygons) {
		            var self = this;
		            if(!usedClip){
		                this._saveContext(useSketch);
		            }
		            try {
		                var polygons = tiledImage._croppingPolygons.map(function (polygon) {
		                    return polygon.map(function (coord) {
		                        var point = tiledImage
		                            .imageToViewportCoordinates(coord.x, coord.y, true)
		                            .rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
		                        var clipPoint = self.viewportCoordToDrawerCoord(point);
		                        if (sketchScale) {
		                            clipPoint = clipPoint.times(sketchScale);
		                        }
		                        if (sketchTranslate) { // mostly fixes #2312
		                            clipPoint = clipPoint.plus(sketchTranslate);
		                        }
		                        return clipPoint;
		                    });
		                });
		                this._clipWithPolygons(polygons, useSketch);
		            } catch (e) {
		                $.console.error(e);
		            }
		            usedClip = true;
		        }
		        tiledImage._hasOpaqueTile = false;
		        if ( tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false ) {
		            let placeholderRect = this.viewportToDrawerRectangle(tiledImage.getBoundsNoRotate(true));
		            if (sketchScale) {
		                placeholderRect = placeholderRect.times(sketchScale);
		            }
		            if (sketchTranslate) {
		                placeholderRect = placeholderRect.translate(sketchTranslate);
		            }

		            let fillStyle = null;
		            if ( typeof tiledImage.placeholderFillStyle === "function" ) {
		                fillStyle = tiledImage.placeholderFillStyle(tiledImage, this.context);
		            }
		            else {
		                fillStyle = tiledImage.placeholderFillStyle;
		            }

		            this._drawRectangle(placeholderRect, fillStyle, useSketch);
		        }

		        var subPixelRoundingRule = determineSubPixelRoundingRule(tiledImage.subPixelRoundingForTransparency);

		        var shouldRoundPositionAndSize = false;

		        if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS) {
		            shouldRoundPositionAndSize = true;
		        } else if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
		            var isAnimating = this.viewer && this.viewer.isAnimating();
		            shouldRoundPositionAndSize = !isAnimating;
		        }

		        // Iterate over the tiles to draw, and draw them
		        for (var i = 0; i < lastDrawn.length; i++) {
		            tile = lastDrawn[ i ];
		            this._drawTile( tile, tiledImage, useSketch, sketchScale,
		                sketchTranslate, shouldRoundPositionAndSize, tiledImage.source );

		            if( this.viewer ){
		                /**
		                 * Raised when a tile is drawn to the canvas. Only valid for
		                 * context2d and html drawers.
		                 *
		                 * @event tile-drawn
		                 * @memberof OpenSeadragon.Viewer
		                 * @type {object}
		                 * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		                 * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		                 * @property {OpenSeadragon.Tile} tile
		                 * @property {?Object} userData - Arbitrary subscriber-defined object.
		                 */
		                this.viewer.raiseEvent( 'tile-drawn', {
		                    tiledImage: tiledImage,
		                    tile: tile
		                });
		            }
		        }

		        if ( usedClip ) {
		            this._restoreContext( useSketch );
		        }

		        if (!sketchScale) {
		            if (tiledImage.getRotation(true) % 360 !== 0) {
		                this._restoreRotationChanges(useSketch);
		            }
		            if (this.viewport.getRotation(true) % 360 !== 0) {
		                this._restoreRotationChanges(useSketch);
		            }
		        }

		        if (useSketch) {
		            if (sketchScale) {
		                this._setRotations(tiledImage);
		            }
		            this.blendSketch({
		                opacity: tiledImage.opacity,
		                scale: sketchScale,
		                translate: sketchTranslate,
		                compositeOperation: tiledImage.compositeOperation,
		                bounds: bounds
		            });
		            if (sketchScale) {
		                if (tiledImage.getRotation(true) % 360 !== 0) {
		                    this._restoreRotationChanges(false);
		                }
		                if (this.viewport.getRotation(true) % 360 !== 0) {
		                    this._restoreRotationChanges(false);
		                }
		            }
		        }

		        this._drawDebugInfo( tiledImage, lastDrawn );

		        // Fire tiled-image-drawn event.

		        this._raiseTiledImageDrawnEvent(tiledImage, lastDrawn);

		    }

		    /**
		     * Draws special debug information for a TiledImage if in debug mode.
		     * @private
		     * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
		     */
		    _drawDebugInfo( tiledImage, lastDrawn ) {
		        if( tiledImage.debugMode ) {
		            for ( var i = lastDrawn.length - 1; i >= 0; i-- ) {
		                var tile = lastDrawn[ i ];
		                try {
		                    this._drawDebugInfoOnTile(tile, lastDrawn.length, i, tiledImage);
		                } catch(e) {
		                    $.console.error(e);
		                }
		            }
		        }
		    }

		    /**
		     * This function will create multiple polygon paths on the drawing context by provided polygons,
		     * then clip the context to the paths.
		     * @private
		     * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
		     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
		     */
		    _clipWithPolygons (polygons, useSketch) {
		        var context = this._getContext(useSketch);
		        context.beginPath();
		        for(const polygon of polygons){
		            for(const [i, coord] of polygon.entries() ){
		                context[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
		            }
		        }

		        context.clip();
		    }

		    /**
		     * Draws the given tile.
		     * @private
		     * @param {OpenSeadragon.Tile} tile - The tile to draw.
		     * @param {OpenSeadragon.TiledImage} tiledImage - The tiled image being drawn.
		     * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
		     * where <code>rendered</code> is the context with the pre-drawn image.
		     * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
		     * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
		     * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
		     * position and size of tiles supporting alpha channel in non-transparency
		     * context.
		     * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
		     */
		    _drawTile( tile, tiledImage, useSketch, scale, translate, shouldRoundPositionAndSize, source) {
		        $.console.assert(tile, '[Drawer._drawTile] tile is required');
		        $.console.assert(tiledImage, '[Drawer._drawTile] drawingHandler is required');

		        var context = this._getContext(useSketch);
		        scale = scale || 1;
		        this._drawTileToCanvas(tile, context, tiledImage, scale, translate, shouldRoundPositionAndSize, source);

		    }

		    /**
		     * Renders the tile in a canvas-based context.
		     * @private
		     * @function
		     * @param {OpenSeadragon.Tile} tile - the tile to draw to the canvas
		     * @param {Canvas} context
		     * @param {OpenSeadragon.TiledImage} tiledImage - Method for firing the drawing event.
		     * drawingHandler({context, tile, rendered})
		     * where <code>rendered</code> is the context with the pre-drawn image.
		     * @param {Number} [scale=1] - Apply a scale to position and size
		     * @param {OpenSeadragon.Point} [translate] - A translation vector
		     * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
		     * position and size of tiles supporting alpha channel in non-transparency
		     * context.
		     * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
		     */
		    _drawTileToCanvas( tile, context, tiledImage, scale, translate, shouldRoundPositionAndSize, source) {

		        var position = tile.position.times($.pixelDensityRatio),
		            size     = tile.size.times($.pixelDensityRatio),
		            rendered;

		        if (!tile.context2D && !tile.cacheImageRecord) {
		            $.console.warn(
		                '[Drawer._drawTileToCanvas] attempting to draw tile %s when it\'s not cached',
		                tile.toString());
		            return;
		        }

		        rendered = tile.getCanvasContext();

		        if ( !tile.loaded || !rendered ){
		            $.console.warn(
		                "Attempting to draw tile %s when it's not yet loaded.",
		                tile.toString()
		            );

		            return;
		        }

		        context.save();

		        if (typeof scale === 'number' && scale !== 1) {
		            // draw tile at a different scale
		            position = position.times(scale);
		            size = size.times(scale);
		        }

		        if (translate instanceof $.Point) {
		            // shift tile position slightly
		            position = position.plus(translate);
		        }

		        //if we are supposed to be rendering fully opaque rectangle,
		        //ie its done fading or fading is turned off, and if we are drawing
		        //an image with an alpha channel, then the only way
		        //to avoid seeing the tile underneath is to clear the rectangle
		        if (context.globalAlpha === 1 && tile.hasTransparency) {
		            if (shouldRoundPositionAndSize) {
		                // Round to the nearest whole pixel so we don't get seams from overlap.
		                position.x = Math.round(position.x);
		                position.y = Math.round(position.y);
		                size.x = Math.round(size.x);
		                size.y = Math.round(size.y);
		            }

		            //clearing only the inside of the rectangle occupied
		            //by the png prevents edge flikering
		            context.clearRect(
		                position.x,
		                position.y,
		                size.x,
		                size.y
		            );
		        }

		        this._raiseTileDrawingEvent(tiledImage, context, tile, rendered);

		        var sourceWidth, sourceHeight;
		        if (tile.sourceBounds) {
		            sourceWidth = Math.min(tile.sourceBounds.width, rendered.canvas.width);
		            sourceHeight = Math.min(tile.sourceBounds.height, rendered.canvas.height);
		        } else {
		            sourceWidth = rendered.canvas.width;
		            sourceHeight = rendered.canvas.height;
		        }

		        context.translate(position.x + size.x / 2, 0);
		        if (tile.flipped) {
		            context.scale(-1, 1);
		        }
		        context.drawImage(
		            rendered.canvas,
		            0,
		            0,
		            sourceWidth,
		            sourceHeight,
		            -size.x / 2,
		            position.y,
		            size.x,
		            size.y
		        );

		        context.restore();
		    }

		    /**
		     * Get the context of the main or sketch canvas
		     * @private
		     * @param {Boolean} useSketch
		     * @returns {CanvasRenderingContext2D}
		     */
		    _getContext( useSketch ) {
		        var context = this.context;
		        if ( useSketch ) {
		            if (this.sketchCanvas === null) {
		                this.sketchCanvas = document.createElement( "canvas" );
		                var sketchCanvasSize = this._calculateSketchCanvasSize();
		                this.sketchCanvas.width = sketchCanvasSize.x;
		                this.sketchCanvas.height = sketchCanvasSize.y;
		                this.sketchContext = this.sketchCanvas.getContext( "2d" );

		                // If the viewport is not currently rotated, the sketchCanvas
		                // will have the same size as the main canvas. However, if
		                // the viewport get rotated later on, we will need to resize it.
		                if (this.viewport.getRotation() === 0) {
		                    var self = this;
		                    this.viewer.addHandler('rotate', function resizeSketchCanvas() {
		                        if (self.viewport.getRotation() === 0) {
		                            return;
		                        }
		                        self.viewer.removeHandler('rotate', resizeSketchCanvas);
		                        var sketchCanvasSize = self._calculateSketchCanvasSize();
		                        self.sketchCanvas.width = sketchCanvasSize.x;
		                        self.sketchCanvas.height = sketchCanvasSize.y;
		                    });
		                }
		                this._updateImageSmoothingEnabled(this.sketchContext);
		            }
		            context = this.sketchContext;
		        }
		        return context;
		    }

		    /**
		     * Save the context of the main or sketch canvas
		     * @private
		     * @param {Boolean} useSketch
		     */
		    _saveContext( useSketch ) {
		        this._getContext( useSketch ).save();
		    }

		    /**
		     * Restore the context of the main or sketch canvas
		     * @private
		     * @param {Boolean} useSketch
		     */
		    _restoreContext( useSketch ) {
		        this._getContext( useSketch ).restore();
		    }

		    // private
		    _setClip(rect, useSketch) {
		        var context = this._getContext( useSketch );
		        context.beginPath();
		        context.rect(rect.x, rect.y, rect.width, rect.height);
		        context.clip();
		    }

		    // private
		    // used to draw a placeholder rectangle
		    _drawRectangle(rect, fillStyle, useSketch) {
		        var context = this._getContext( useSketch );
		        context.save();
		        context.fillStyle = fillStyle;
		        context.fillRect(rect.x, rect.y, rect.width, rect.height);
		        context.restore();
		    }

		    /**
		     * Blends the sketch canvas in the main canvas.
		     * @param {Object} options The options
		     * @param {Float} options.opacity The opacity of the blending.
		     * @param {Float} [options.scale=1] The scale at which tiles were drawn on
		     * the sketch. Default is 1.
		     * Use scale to draw at a lower scale and then enlarge onto the main canvas.
		     * @param {OpenSeadragon.Point} [options.translate] A translation vector
		     * that was used to draw the tiles
		     * @param {String} [options.compositeOperation] - How the image is
		     * composited onto other images; see compositeOperation in
		     * {@link OpenSeadragon.Options} for possible values.
		     * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
		     * canvas to blend in the main canvas. If specified, options.scale and
		     * options.translate get ignored.
		     */
		    blendSketch(opacity, scale, translate, compositeOperation) {
		        var options = opacity;
		        if (!$.isPlainObject(options)) {
		            options = {
		                opacity: opacity,
		                scale: scale,
		                translate: translate,
		                compositeOperation: compositeOperation
		            };
		        }

		        opacity = options.opacity;
		        compositeOperation = options.compositeOperation;
		        var bounds = options.bounds;

		        this.context.save();
		        this.context.globalAlpha = opacity;
		        if (compositeOperation) {
		            this.context.globalCompositeOperation = compositeOperation;
		        }
		        if (bounds) {
		            // Internet Explorer, Microsoft Edge, and Safari have problems
		            // when you call context.drawImage with negative x or y
		            // or x + width or y + height greater than the canvas width or height respectively.
		            if (bounds.x < 0) {
		                bounds.width += bounds.x;
		                bounds.x = 0;
		            }
		            if (bounds.x + bounds.width > this.canvas.width) {
		                bounds.width = this.canvas.width - bounds.x;
		            }
		            if (bounds.y < 0) {
		                bounds.height += bounds.y;
		                bounds.y = 0;
		            }
		            if (bounds.y + bounds.height > this.canvas.height) {
		                bounds.height = this.canvas.height - bounds.y;
		            }

		            this.context.drawImage(
		                this.sketchCanvas,
		                bounds.x,
		                bounds.y,
		                bounds.width,
		                bounds.height,
		                bounds.x,
		                bounds.y,
		                bounds.width,
		                bounds.height
		            );
		        } else {
		            scale = options.scale || 1;
		            translate = options.translate;
		            var position = translate instanceof $.Point ?
		                translate : new $.Point(0, 0);

		            var widthExt = 0;
		            var heightExt = 0;
		            if (translate) {
		                var widthDiff = this.sketchCanvas.width - this.canvas.width;
		                var heightDiff = this.sketchCanvas.height - this.canvas.height;
		                widthExt = Math.round(widthDiff / 2);
		                heightExt = Math.round(heightDiff / 2);
		            }
		            this.context.drawImage(
		                this.sketchCanvas,
		                position.x - widthExt * scale,
		                position.y - heightExt * scale,
		                (this.canvas.width + 2 * widthExt) * scale,
		                (this.canvas.height + 2 * heightExt) * scale,
		                -widthExt,
		                -heightExt,
		                this.canvas.width + 2 * widthExt,
		                this.canvas.height + 2 * heightExt
		            );
		        }
		        this.context.restore();
		    }

		    // private
		    _drawDebugInfoOnTile(tile, count, i, tiledImage) {

		        var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
		        var context = this.context;
		        context.save();
		        context.lineWidth = 2 * $.pixelDensityRatio;
		        context.font = 'small-caps bold ' + (13 * $.pixelDensityRatio) + 'px arial';
		        context.strokeStyle = this.debugGridColor[colorIndex];
		        context.fillStyle = this.debugGridColor[colorIndex];

		        this._setRotations(tiledImage);

		        if(this._viewportFlipped){
		            this._flip({point: tile.position.plus(tile.size.divide(2))});
		        }

		        context.strokeRect(
		            tile.position.x * $.pixelDensityRatio,
		            tile.position.y * $.pixelDensityRatio,
		            tile.size.x * $.pixelDensityRatio,
		            tile.size.y * $.pixelDensityRatio
		        );

		        var tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;
		        var tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;

		        // Rotate the text the right way around.
		        context.translate( tileCenterX, tileCenterY );
		        const angleInDegrees = this.viewport.getRotation(true);
		        context.rotate( Math.PI / 180 * -angleInDegrees );
		        context.translate( -tileCenterX, -tileCenterY );

		        if( tile.x === 0 && tile.y === 0 ){
		            context.fillText(
		                "Zoom: " + this.viewport.getZoom(),
		                tile.position.x * $.pixelDensityRatio,
		                (tile.position.y - 30) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Pan: " + this.viewport.getBounds().toString(),
		                tile.position.x * $.pixelDensityRatio,
		                (tile.position.y - 20) * $.pixelDensityRatio
		            );
		        }
		        context.fillText(
		            "Level: " + tile.level,
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 20) * $.pixelDensityRatio
		        );
		        context.fillText(
		            "Column: " + tile.x,
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 30) * $.pixelDensityRatio
		        );
		        context.fillText(
		            "Row: " + tile.y,
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 40) * $.pixelDensityRatio
		        );
		        context.fillText(
		            "Order: " + i + " of " + count,
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 50) * $.pixelDensityRatio
		        );
		        context.fillText(
		            "Size: " + tile.size.toString(),
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 60) * $.pixelDensityRatio
		        );
		        context.fillText(
		            "Position: " + tile.position.toString(),
		            (tile.position.x + 10) * $.pixelDensityRatio,
		            (tile.position.y + 70) * $.pixelDensityRatio
		        );

		        if (this.viewport.getRotation(true) % 360 !== 0 ) {
		            this._restoreRotationChanges();
		        }
		        if (tiledImage.getRotation(true) % 360 !== 0) {
		            this._restoreRotationChanges();
		        }

		        context.restore();
		    }

		    // private
		    _updateImageSmoothingEnabled(context){
		        context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
		        context.imageSmoothingEnabled = this._imageSmoothingEnabled;
		    }

		    /**
		     * Get the canvas size
		     * @private
		     * @param {Boolean} sketch If set to true return the size of the sketch canvas
		     * @returns {OpenSeadragon.Point} The size of the canvas
		     */
		    _getCanvasSize(sketch) {
		        var canvas = this._getContext(sketch).canvas;
		        return new $.Point(canvas.width, canvas.height);
		    }

		    /**
		     * Get the canvas center
		     * @private
		     * @param {Boolean} sketch If set to true return the center point of the sketch canvas
		     * @returns {OpenSeadragon.Point} The center point of the canvas
		     */
		    _getCanvasCenter() {
		        return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
		    }

		    /**
		     * Set rotations for viewport & tiledImage
		     * @private
		     * @param {OpenSeadragon.TiledImage} tiledImage
		     * @param {Boolean} [useSketch=false]
		     */
		    _setRotations(tiledImage, useSketch = false) {
		        var saveContext = false;
		        if (this.viewport.getRotation(true) % 360 !== 0) {
		            this._offsetForRotation({
		                degrees: this.viewport.getRotation(true),
		                useSketch: useSketch,
		                saveContext: saveContext
		            });
		            saveContext = false;
		        }
		        if (tiledImage.getRotation(true) % 360 !== 0) {
		            this._offsetForRotation({
		                degrees: tiledImage.getRotation(true),
		                point: this.viewport.pixelFromPointNoRotate(
		                    tiledImage._getRotationPoint(true), true),
		                useSketch: useSketch,
		                saveContext: saveContext
		            });
		        }
		    }

		    // private
		    _offsetForRotation(options) {
		        var point = options.point ?
		            options.point.times($.pixelDensityRatio) :
		            this._getCanvasCenter();

		        var context = this._getContext(options.useSketch);
		        context.save();

		        context.translate(point.x, point.y);
		        context.rotate(Math.PI / 180 * options.degrees);
		        context.translate(-point.x, -point.y);
		    }

		    // private
		    _flip(options) {
		        options = options || {};
		        var point = options.point ?
		        options.point.times($.pixelDensityRatio) :
		        this._getCanvasCenter();
		        var context = this._getContext(options.useSketch);

		        context.translate(point.x, 0);
		        context.scale(-1, 1);
		        context.translate(-point.x, 0);
		    }

		    // private
		    _restoreRotationChanges(useSketch) {
		        var context = this._getContext(useSketch);
		        context.restore();
		    }

		    // private
		    _calculateCanvasSize() {
		        var pixelDensityRatio = $.pixelDensityRatio;
		        var viewportSize = this.viewport.getContainerSize();
		        return {
		            // canvas width and height are integers
		            x: Math.round(viewportSize.x * pixelDensityRatio),
		            y: Math.round(viewportSize.y * pixelDensityRatio)
		        };
		    }

		    // private
		    _calculateSketchCanvasSize() {
		        var canvasSize = this._calculateCanvasSize();
		        if (this.viewport.getRotation() === 0) {
		            return canvasSize;
		        }
		        // If the viewport is rotated, we need a larger sketch canvas in order
		        // to support edge smoothing.
		        var sketchCanvasSize = Math.ceil(Math.sqrt(
		            canvasSize.x * canvasSize.x +
		            canvasSize.y * canvasSize.y));
		        return {
		            x: sketchCanvasSize,
		            y: sketchCanvasSize
		        };
		    }
		}
		$.CanvasDrawer = CanvasDrawer;


		/**
		 * Defines the value for subpixel rounding to fallback to in case of missing or
		 * invalid value.
		 * @private
		 */
		var DEFAULT_SUBPIXEL_ROUNDING_RULE = $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;

		/**
		 * Checks whether the input value is an invalid subpixel rounding enum value.
		 * @private
		 *
		 * @param {SUBPIXEL_ROUNDING_OCCURRENCES} value - The subpixel rounding enum value to check.
		 * @returns {Boolean} Returns true if the input value is none of the expected
		 * {@link SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS}, {@link SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST} or {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} value.
		 */
		function isSubPixelRoundingRuleUnknown(value) {
		    return value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS &&
		        value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST &&
		        value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
		}

		/**
		 * Ensures the returned value is always a valid subpixel rounding enum value,
		 * defaulting to {@link SUBPIXEL_ROUNDING_OCCURRENCES.NEVER} if input is missing or invalid.
		 * @private
		 * @param {SUBPIXEL_ROUNDING_OCCURRENCES} value - The subpixel rounding enum value to normalize.
		 * @returns {SUBPIXEL_ROUNDING_OCCURRENCES} Returns a valid subpixel rounding enum value.
		 */
		function normalizeSubPixelRoundingRule(value) {
		    if (isSubPixelRoundingRuleUnknown(value)) {
		        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
		    }
		    return value;
		}

		/**
		 * Ensures the returned value is always a valid subpixel rounding enum value,
		 * defaulting to 'NEVER' if input is missing or invalid.
		 * @private
		 *
		 * @param {Object} subPixelRoundingRules - A subpixel rounding enum values dictionary [{@link BROWSERS}] --> {@link SUBPIXEL_ROUNDING_OCCURRENCES}.
		 * @returns {SUBPIXEL_ROUNDING_OCCURRENCES} Returns the determined subpixel rounding enum value for the
		 * current browser.
		 */
		function determineSubPixelRoundingRule(subPixelRoundingRules) {
		    if (typeof subPixelRoundingRules === 'number') {
		        return normalizeSubPixelRoundingRule(subPixelRoundingRules);
		    }

		    if (!subPixelRoundingRules || !$.Browser) {
		        return DEFAULT_SUBPIXEL_ROUNDING_RULE;
		    }

		    var subPixelRoundingRule = subPixelRoundingRules[$.Browser.vendor];

		    if (isSubPixelRoundingRuleUnknown(subPixelRoundingRule)) {
		        subPixelRoundingRule = subPixelRoundingRules['*'];
		    }

		    return normalizeSubPixelRoundingRule(subPixelRoundingRule);
		}

		}( OpenSeadragon ));


		/*
		 * OpenSeadragon - WebGLDrawer
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		    const OpenSeadragon = $; // alias for JSDoc

		   /**
		    * @class OpenSeadragon.WebGLDrawer
		    * @classdesc Default implementation of WebGLDrawer for an {@link OpenSeadragon.Viewer}. The WebGLDrawer
		    * loads tile data as textures to the graphics card as soon as it is available (via the tile-ready event),
		    * and unloads the data (via the image-unloaded event). The drawer utilizes a context-dependent two pass drawing pipeline.
		    * For the first pass, tile composition for a given TiledImage is always done using a canvas with a WebGL context.
		    * This allows tiles to be stitched together without seams or artifacts, without requiring a tile source with overlap. If overlap is present,
		    * overlapping pixels are discarded. The second pass copies all pixel data from the WebGL context onto an output canvas
		    * with a Context2d context. This allows applications to have access to pixel data and other functionality provided by
		    * Context2d, regardless of whether the CanvasDrawer or the WebGLDrawer is used. Certain options, including compositeOperation,
		    * clip, croppingPolygons, and debugMode are implemented using Context2d operations; in these scenarios, each TiledImage is
		    * drawn onto the output canvas immediately after the tile composition step (pass 1). Otherwise, for efficiency, all TiledImages
		    * are copied over to the output canvas at once, after all tiles have been composited for all images.
		    * @param {Object} options - Options for this Drawer.
		    * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this Drawer.
		    * @param {OpenSeadragon.Viewport} options.viewport - Reference to Viewer viewport.
		    * @param {Element} options.element - Parent element.
		    * @param {Number} [options.debugGridColor] - See debugGridColor in {@link OpenSeadragon.Options} for details.
		    */

		    OpenSeadragon.WebGLDrawer = class WebGLDrawer extends OpenSeadragon.DrawerBase{
		        constructor(options){
		           super(options);

		            /**
		             * The HTML element (canvas) that this drawer uses for drawing
		             * @member {Element} canvas
		             * @memberof OpenSeadragon.WebGLDrawer#
		             */

		            /**
		             * The parent element of this Drawer instance, passed in when the Drawer was created.
		             * The parent of {@link OpenSeadragon.WebGLDrawer#canvas}.
		             * @member {Element} container
		             * @memberof OpenSeadragon.WebGLDrawer#
		             */

		            // private members
		            this._destroyed = false;
		            this._TextureMap = new Map();
		            this._TileMap = new Map();

		            this._gl = null;
		            this._firstPass = null;
		            this._secondPass = null;
		            this._glFrameBuffer = null;
		            this._renderToTexture = null;
		            this._glFramebufferToCanvasTransform = null;
		            this._outputCanvas = null;
		            this._outputContext = null;
		            this._clippingCanvas = null;
		            this._clippingContext = null;
		            this._renderingCanvas = null;
		            this._backupCanvasDrawer = null;

		            this._imageSmoothingEnabled = true; // will be updated by setImageSmoothingEnabled

		            // Add listeners for events that require modifying the scene or camera
		            this._boundToTileReady = ev => this._tileReadyHandler(ev);
		            this._boundToImageUnloaded = ev => this._imageUnloadedHandler(ev);
		            this.viewer.addHandler("tile-ready", this._boundToTileReady);
		            this.viewer.addHandler("image-unloaded", this._boundToImageUnloaded);

		            // Reject listening for the tile-drawing and tile-drawn events, which this drawer does not fire
		            this.viewer.rejectEventHandler("tile-drawn", "The WebGLDrawer does not raise the tile-drawn event");
		            this.viewer.rejectEventHandler("tile-drawing", "The WebGLDrawer does not raise the tile-drawing event");

		            // this.viewer and this.canvas are part of the public DrawerBase API
		            // and are defined by the parent DrawerBase class. Additional setup is done by
		            // the private _setupCanvases and _setupRenderer functions.
		            this._setupCanvases();
		            this._setupRenderer();

		            this.context = this._outputContext; // API required by tests

		       }

		        // Public API required by all Drawer implementations
		        /**
		        * Clean up the renderer, removing all resources
		        */
		        destroy(){
		            if(this._destroyed){
		                return;
		            }
		            // clear all resources used by the renderer, geometries, textures etc
		            let gl = this._gl;

		            // adapted from https://stackoverflow.com/a/23606581/1214731
		            var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		            for (let unit = 0; unit < numTextureUnits; ++unit) {
		                gl.activeTexture(gl.TEXTURE0 + unit);
		                gl.bindTexture(gl.TEXTURE_2D, null);
		                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
		            }
		            gl.bindBuffer(gl.ARRAY_BUFFER, null);
		            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
		            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
		            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		            this._unloadTextures();

		            // Delete all our created resources
		            gl.deleteBuffer(this._secondPass.bufferOutputPosition);
		            gl.deleteFramebuffer(this._glFrameBuffer);

		            // make canvases 1 x 1 px and delete references
		            this._renderingCanvas.width = this._renderingCanvas.height = 1;
		            this._clippingCanvas.width = this._clippingCanvas.height = 1;
		            this._outputCanvas.width = this._outputCanvas.height = 1;
		            this._renderingCanvas = null;
		            this._clippingCanvas = this._clippingContext = null;
		            this._outputCanvas = this._outputContext = null;

		            let ext = gl.getExtension('WEBGL_lose_context');
		            if(ext){
		                ext.loseContext();
		            }

		            // unbind our event listeners from the viewer
		            this.viewer.removeHandler("tile-ready", this._boundToTileReady);
		            this.viewer.removeHandler("image-unloaded", this._boundToImageUnloaded);
		            this.viewer.removeHandler("resize", this._resizeHandler);

		            // set our webgl context reference to null to enable garbage collection
		            this._gl = null;

		            if(this._backupCanvasDrawer){
		                this._backupCanvasDrawer.destroy();
		                this._backupCanvasDrawer = null;
		            }

		            this.container.removeChild(this.canvas);
		            if(this.viewer.drawer === this){
		                this.viewer.drawer = null;
		            }

		            // set our destroyed flag to true
		            this._destroyed = true;
		        }

		        // Public API required by all Drawer implementations
		        /**
		        *
		        * @returns {Boolean} true
		        */
		        canRotate(){
		            return true;
		        }

		        // Public API required by all Drawer implementations
		        /**
		        * @returns {Boolean} true if canvas and webgl are supported
		        */
		        static isSupported(){
		            let canvasElement = document.createElement( 'canvas' );
		            let webglContext = $.isFunction( canvasElement.getContext ) &&
		                        canvasElement.getContext( 'webgl' );
		            let ext = webglContext && webglContext.getExtension('WEBGL_lose_context');
		            if(ext){
		                ext.loseContext();
		            }
		            return !!( webglContext );
		        }

		        /**
		         *
		         * @returns 'webgl'
		         */
		        getType(){
		            return 'webgl';
		        }

		        /**
		         * @param {TiledImage} tiledImage the tiled image that is calling the function
		         * @returns {Boolean} Whether this drawer requires enforcing minimum tile overlap to avoid showing seams.
		         * @private
		         */
		        minimumOverlapRequired(tiledImage) {
		            // return true if the tiled image is tainted, since the backup canvas drawer will be used.
		            return tiledImage.isTainted();
		        }

		        /**
		        * create the HTML element (canvas in this case) that the image will be drawn into
		        * @private
		        * @returns {Element} the canvas to draw into
		        */
		        _createDrawingElement(){
		            let canvas = $.makeNeutralElement("canvas");
		            let viewportSize = this._calculateCanvasSize();
		            canvas.width = viewportSize.x;
		            canvas.height = viewportSize.y;
		            return canvas;
		        }

		        /**
		         * Get the backup renderer (CanvasDrawer) to use if data cannot be used by webgl
		         * Lazy loaded
		         * @private
		         * @returns {CanvasDrawer}
		         */
		        _getBackupCanvasDrawer(){
		            if(!this._backupCanvasDrawer){
		                this._backupCanvasDrawer = this.viewer.requestDrawer('canvas', {mainDrawer: false});
		                this._backupCanvasDrawer.canvas.style.setProperty('visibility', 'hidden');
		            }

		            return this._backupCanvasDrawer;
		        }

		        /**
		        *
		        * @param {Array} tiledImages Array of TiledImage objects to draw
		        */
		        draw(tiledImages){
		            let gl = this._gl;
		            const bounds = this.viewport.getBoundsNoRotateWithMargins(true);
		            let view = {
		                bounds: bounds,
		                center: new OpenSeadragon.Point(bounds.x + bounds.width / 2, bounds.y + bounds.height / 2),
		                rotation: this.viewport.getRotation(true) * Math.PI / 180
		            };

		            let flipMultiplier = this.viewport.flipped ? -1 : 1;
		            // calculate view matrix for viewer
		            let posMatrix = $.Mat3.makeTranslation(-view.center.x, -view.center.y);
		            let scaleMatrix = $.Mat3.makeScaling(2 / view.bounds.width * flipMultiplier, -2 / view.bounds.height);
		            let rotMatrix = $.Mat3.makeRotation(-view.rotation);
		            let viewMatrix = scaleMatrix.multiply(rotMatrix).multiply(posMatrix);

		            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		            gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer

		            // clear the output canvas
		            this._outputContext.clearRect(0, 0, this._outputCanvas.width, this._outputCanvas.height);


		            let renderingBufferHasImageData = false;

		            //iterate over tiled images and draw each one using a two-pass rendering pipeline if needed
		            tiledImages.forEach( (tiledImage, tiledImageIndex) => {

		                if(tiledImage.isTainted()){
		                    // first, draw any data left in the rendering buffer onto the output canvas
		                    if(renderingBufferHasImageData){
		                        this._outputContext.drawImage(this._renderingCanvas, 0, 0);
		                        // clear the buffer
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		                        gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
		                        renderingBufferHasImageData = false;
		                    }

		                    // next, use the backup canvas drawer to draw this tainted image
		                    const canvasDrawer = this._getBackupCanvasDrawer();
		                    canvasDrawer.draw([tiledImage]);
		                    this._outputContext.drawImage(canvasDrawer.canvas, 0, 0);

		                } else {
		                    let tilesToDraw = tiledImage.getTilesToDraw();

		                    if ( tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false ) {
		                        this._drawPlaceholder(tiledImage);
		                    }

		                    if(tilesToDraw.length === 0 || tiledImage.getOpacity() === 0){
		                        return;
		                    }
		                    let firstTile = tilesToDraw[0];

		                    let useContext2dPipeline = ( tiledImage.compositeOperation ||
		                        this.viewer.compositeOperation ||
		                        tiledImage._clip ||
		                        tiledImage._croppingPolygons ||
		                        tiledImage.debugMode
		                    );

		                    let useTwoPassRendering = useContext2dPipeline || (tiledImage.opacity < 1) || firstTile.hasTransparency;

		                    // using the context2d pipeline requires a clean rendering (back) buffer to start
		                    if(useContext2dPipeline){
		                        // if the rendering buffer has image data currently, write it to the output canvas now and clear it

		                        if(renderingBufferHasImageData){
		                            this._outputContext.drawImage(this._renderingCanvas, 0, 0);
		                        }

		                        // clear the buffer
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		                        gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
		                    }

		                    // First rendering pass: compose tiles that make up this tiledImage
		                    gl.useProgram(this._firstPass.shaderProgram);

		                    // bind to the framebuffer for render-to-texture if using two-pass rendering, otherwise back buffer (null)
		                    if(useTwoPassRendering){
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		                        // clear the buffer to draw a new image
		                        gl.clear(gl.COLOR_BUFFER_BIT);
		                    } else {
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		                        // no need to clear, just draw on top of the existing pixels
		                    }

		                    let overallMatrix = viewMatrix;

		                    let imageRotation = tiledImage.getRotation(true);
		                    // if needed, handle the tiledImage being rotated
		                    if( imageRotation % 360 !== 0){
		                        let imageRotationMatrix = $.Mat3.makeRotation(-imageRotation * Math.PI / 180);
		                        let imageCenter = tiledImage.getBoundsNoRotate(true).getCenter();
		                        let t1 = $.Mat3.makeTranslation(imageCenter.x, imageCenter.y);
		                        let t2 = $.Mat3.makeTranslation(-imageCenter.x, -imageCenter.y);

		                        // update the view matrix to account for this image's rotation
		                        let localMatrix = t1.multiply(imageRotationMatrix).multiply(t2);
		                        overallMatrix = viewMatrix.multiply(localMatrix);
		                    }

		                    let maxTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
		                    if(maxTextures <= 0){
		                        // This can apparently happen on some systems if too many WebGL contexts have been created
		                        // in which case maxTextures can be null, leading to out of bounds errors with the array.
		                        // For example, when viewers were created and not destroyed in the test suite, this error
		                        // occurred in the TravisCI tests, though it did not happen when testing locally either in
		                        // a browser or on the command line via grunt test.

		                        throw(new Error(`WegGL error: bad value for gl parameter MAX_TEXTURE_IMAGE_UNITS (${maxTextures}). This could happen
                        if too many contexts have been created and not released, or there is another problem with the graphics card.`));
		                    }

		                    let texturePositionArray = new Float32Array(maxTextures * 12); // 6 vertices (2 triangles) x 2 coordinates per vertex
		                    let textureDataArray = new Array(maxTextures);
		                    let matrixArray = new Array(maxTextures);
		                    let opacityArray = new Array(maxTextures);

		                    // iterate over tiles and add data for each one to the buffers
		                    for(let tileIndex = 0; tileIndex < tilesToDraw.length; tileIndex++){
		                        let tile = tilesToDraw[tileIndex].tile;
		                        let indexInDrawArray = tileIndex % maxTextures;
		                        let numTilesToDraw =  indexInDrawArray + 1;
		                        let tileContext = tile.getCanvasContext();

		                        let textureInfo = tileContext ? this._TextureMap.get(tileContext.canvas) : null;
		                        if(!textureInfo){
		                            // tile was not processed in the tile-ready event (this can happen
		                            // if this drawer was created after the tile was downloaded)
		                            this._tileReadyHandler({tile: tile, tiledImage: tiledImage});

		                            // retry getting textureInfo
		                            textureInfo = tileContext ? this._TextureMap.get(tileContext.canvas) : null;
		                        }

		                        if(textureInfo){
		                            this._getTileData(tile, tiledImage, textureInfo, overallMatrix, indexInDrawArray, texturePositionArray, textureDataArray, matrixArray, opacityArray);
		                        }
		                        if( (numTilesToDraw === maxTextures) || (tileIndex === tilesToDraw.length - 1)){
		                            // We've filled up the buffers: time to draw this set of tiles

		                            // bind each tile's texture to the appropriate gl.TEXTURE#
		                            for(let i = 0; i <= numTilesToDraw; i++){
		                                gl.activeTexture(gl.TEXTURE0 + i);
		                                gl.bindTexture(gl.TEXTURE_2D, textureDataArray[i]);
		                            }

		                            // set the buffer data for the texture coordinates to use for each tile
		                            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
		                            gl.bufferData(gl.ARRAY_BUFFER, texturePositionArray, gl.DYNAMIC_DRAW);

		                            // set the transform matrix uniform for each tile
		                            matrixArray.forEach( (matrix, index) => {
		                                gl.uniformMatrix3fv(this._firstPass.uTransformMatrices[index], false, matrix);
		                            });
		                            // set the opacity uniform for each tile
		                            gl.uniform1fv(this._firstPass.uOpacities, new Float32Array(opacityArray));

		                            // bind vertex buffers and (re)set attributes before calling gl.drawArrays()
		                            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferOutputPosition);
		                            gl.vertexAttribPointer(this._firstPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);

		                            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
		                            gl.vertexAttribPointer(this._firstPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);

		                            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferIndex);
		                            gl.vertexAttribPointer(this._firstPass.aIndex, 1, gl.FLOAT, false, 0, 0);

		                            // Draw! 6 vertices per tile (2 triangles per rectangle)
		                            gl.drawArrays(gl.TRIANGLES, 0, 6 * numTilesToDraw );
		                        }
		                    }

		                    if(useTwoPassRendering){
		                        // Second rendering pass: Render the tiled image from the framebuffer into the back buffer
		                        gl.useProgram(this._secondPass.shaderProgram);

		                        // set the rendering target to the back buffer (null)
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

		                        // bind the rendered texture from the first pass to use during this second pass
		                        gl.activeTexture(gl.TEXTURE0);
		                        gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);

		                        // set opacity to the value for the current tiledImage
		                        this._gl.uniform1f(this._secondPass.uOpacityMultiplier, tiledImage.opacity);

		                        // bind buffers and set attributes before calling gl.drawArrays
		                        gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferTexturePosition);
		                        gl.vertexAttribPointer(this._secondPass.aTexturePosition, 2, gl.FLOAT, false, 0, 0);
		                        gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferOutputPosition);
		                        gl.vertexAttribPointer(this._secondPass.aOutputPosition, 2, gl.FLOAT, false, 0, 0);

		                        // Draw the quad (two triangles)
		                        gl.drawArrays(gl.TRIANGLES, 0, 6);

		                    }

		                    renderingBufferHasImageData = true;

		                    if(useContext2dPipeline){
		                        // draw from the rendering canvas onto the output canvas, clipping/cropping if needed.
		                        this._applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex);
		                        renderingBufferHasImageData = false;
		                        // clear the buffer
		                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		                        gl.clear(gl.COLOR_BUFFER_BIT); // clear the back buffer
		                    }

		                    // after drawing the first TiledImage, fire the tiled-image-drawn event (for testing)
		                    if(tiledImageIndex === 0){
		                        this._raiseTiledImageDrawnEvent(tiledImage, tilesToDraw.map(info=>info.tile));
		                    }
		                }



		            });

		            if(renderingBufferHasImageData){
		                this._outputContext.drawImage(this._renderingCanvas, 0, 0);
		            }

		        }

		        // Public API required by all Drawer implementations
		        /**
		        * Sets whether image smoothing is enabled or disabled
		        * @param {Boolean} enabled If true, uses gl.LINEAR as the TEXTURE_MIN_FILTER and TEXTURE_MAX_FILTER, otherwise gl.NEAREST.
		        */
		        setImageSmoothingEnabled(enabled){
		            if( this._imageSmoothingEnabled !== enabled ){
		                this._imageSmoothingEnabled = enabled;
		                this._unloadTextures();
		                this.viewer.world.draw();
		            }
		        }

		        /**
		        * Draw a rect onto the output canvas for debugging purposes
		        * @param {OpenSeadragon.Rect} rect
		        */
		        drawDebuggingRect(rect){
		            let context = this._outputContext;
		            context.save();
		            context.lineWidth = 2 * $.pixelDensityRatio;
		            context.strokeStyle = this.debugGridColor[0];
		            context.fillStyle = this.debugGridColor[0];

		            context.strokeRect(
		                rect.x * $.pixelDensityRatio,
		                rect.y * $.pixelDensityRatio,
		                rect.width * $.pixelDensityRatio,
		                rect.height * $.pixelDensityRatio
		            );

		            context.restore();
		        }

		        // private
		        _getTextureDataFromTile(tile){
		            return tile.getCanvasContext().canvas;
		        }

		        /**
		        * Draw data from the rendering canvas onto the output canvas, with clipping,
		        * cropping and/or debug info as requested.
		        * @private
		        * @param {OpenSeadragon.TiledImage} tiledImage - the tiledImage to draw
		        * @param {Array} tilesToDraw - array of objects containing tiles that were drawn
		        */
		        _applyContext2dPipeline(tiledImage, tilesToDraw, tiledImageIndex){
		            // composite onto the output canvas, clipping if necessary
		            this._outputContext.save();

		            // set composite operation; ignore for first image drawn
		            this._outputContext.globalCompositeOperation = tiledImageIndex === 0 ? null : tiledImage.compositeOperation || this.viewer.compositeOperation;
		            if(tiledImage._croppingPolygons || tiledImage._clip){
		                this._renderToClippingCanvas(tiledImage);
		                this._outputContext.drawImage(this._clippingCanvas, 0, 0);

		            } else {
		                this._outputContext.drawImage(this._renderingCanvas, 0, 0);
		            }
		            this._outputContext.restore();
		            if(tiledImage.debugMode){
		                const flipped = this.viewer.viewport.getFlip();
		                if(flipped){
		                    this._flip();
		                }
		                this._drawDebugInfo(tilesToDraw, tiledImage, flipped);
		                if(flipped){
		                    this._flip();
		                }
		            }


		        }

		        // private
		        _getTileData(tile, tiledImage, textureInfo, viewMatrix, index, texturePositionArray, textureDataArray, matrixArray, opacityArray){

		            let texture = textureInfo.texture;
		            let textureQuad = textureInfo.position;

		            // set the position of this texture
		            texturePositionArray.set(textureQuad, index * 12);

		            // compute offsets that account for tile overlap; needed for calculating the transform matrix appropriately
		            let overlapFraction = this._calculateOverlapFraction(tile, tiledImage);
		            let xOffset = tile.positionedBounds.width * overlapFraction.x;
		            let yOffset = tile.positionedBounds.height * overlapFraction.y;

		            // x, y, w, h in viewport coords
		            let x = tile.positionedBounds.x + (tile.x === 0 ? 0 : xOffset);
		            let y = tile.positionedBounds.y + (tile.y === 0 ? 0 : yOffset);
		            let right = tile.positionedBounds.x + tile.positionedBounds.width - (tile.isRightMost ? 0 : xOffset);
		            let bottom = tile.positionedBounds.y + tile.positionedBounds.height - (tile.isBottomMost ? 0 : yOffset);
		            let w = right - x;
		            let h = bottom - y;

		            let matrix = new $.Mat3([
		                w, 0, 0,
		                0, h, 0,
		                x, y, 1,
		            ]);

		            if(tile.flipped){
		                // flip the tile around the center of the unit quad
		                let t1 = $.Mat3.makeTranslation(0.5, 0);
		                let t2 = $.Mat3.makeTranslation(-0.5, 0);

		                // update the view matrix to account for this image's rotation
		                let localMatrix = t1.multiply($.Mat3.makeScaling(-1, 1)).multiply(t2);
		                matrix = matrix.multiply(localMatrix);
		            }

		            let overallMatrix = viewMatrix.multiply(matrix);

		            opacityArray[index] = tile.opacity;
		            textureDataArray[index] = texture;
		            matrixArray[index] = overallMatrix.values;

		        }

		        // private
		        _textureFilter(){
		            return this._imageSmoothingEnabled ? this._gl.LINEAR : this._gl.NEAREST;
		        }

		        // private
		        _setupRenderer(){
		            let gl = this._gl;
		            if(!gl){
		                $.console.error('_setupCanvases must be called before _setupRenderer');
		            }
		            this._unitQuad = this._makeQuadVertexBuffer(0, 1, 0, 1); // used a few places; create once and store the result

		            this._makeFirstPassShaderProgram();
		            this._makeSecondPassShaderProgram();

		            // set up the texture to render to in the first pass, and which will be used for rendering the second pass
		            this._renderToTexture = gl.createTexture();
		            gl.activeTexture(gl.TEXTURE0);
		            gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
		            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._renderingCanvas.width, this._renderingCanvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		            // set up the framebuffer for render-to-texture
		            this._glFrameBuffer = gl.createFramebuffer();
		            gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		            gl.framebufferTexture2D(
		                gl.FRAMEBUFFER,
		                gl.COLOR_ATTACHMENT0,       // attach texture as COLOR_ATTACHMENT0
		                gl.TEXTURE_2D,              // attach a 2D texture
		                this._renderToTexture,  // the texture to attach
		                0
		            );

		            gl.enable(gl.BLEND);
		            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

		        }

		        //private
		        _makeFirstPassShaderProgram(){
		            let numTextures = this._glNumTextures = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);
		            let makeMatrixUniforms = () => {
		                return [...Array(numTextures).keys()].map(index => `uniform mat3 u_matrix_${index};`).join('\n');
		            };
		            let makeConditionals = () => {
		                return [...Array(numTextures).keys()].map(index => `${index > 0 ? 'else ' : ''}if(int(a_index) == ${index}) { transform_matrix = u_matrix_${index}; }`).join('\n');
		            };

		            const vertexShaderProgram = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;
            attribute float a_index;

            ${makeMatrixUniforms()} // create a uniform mat3 for each potential tile to draw

            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {

                mat3 transform_matrix; // value will be set by the if/elses in makeConditional()

                ${makeConditionals()}

                gl_Position = vec4(transform_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
                v_image_index = a_index;
            }
            `;

		            const fragmentShaderProgram = `
            precision mediump float;

            // our textures
            uniform sampler2D u_images[${numTextures}];
            // our opacities
            uniform float u_opacities[${numTextures}];

            // the varyings passed in from the vertex shader.
            varying vec2 v_texture_position;
            varying float v_image_index;

            void main() {
                // can't index directly with a variable, need to use a loop iterator hack
                for(int i = 0; i < ${numTextures}; ++i){
                    if(i == int(v_image_index)){
                        gl_FragColor = texture2D(u_images[i], v_texture_position) * u_opacities[i];
                    }
                }
            }
            `;

		            let gl = this._gl;

		            let program = this.constructor.initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
		            gl.useProgram(program);

		            // get locations of attributes and uniforms, and create buffers for each attribute
		            this._firstPass = {
		                shaderProgram: program,
		                aOutputPosition: gl.getAttribLocation(program, 'a_output_position'),
		                aTexturePosition: gl.getAttribLocation(program, 'a_texture_position'),
		                aIndex: gl.getAttribLocation(program, 'a_index'),
		                uTransformMatrices: [...Array(this._glNumTextures).keys()].map(i=>gl.getUniformLocation(program, `u_matrix_${i}`)),
		                uImages: gl.getUniformLocation(program, 'u_images'),
		                uOpacities: gl.getUniformLocation(program, 'u_opacities'),
		                bufferOutputPosition: gl.createBuffer(),
		                bufferTexturePosition: gl.createBuffer(),
		                bufferIndex: gl.createBuffer(),
		            };

		            gl.uniform1iv(this._firstPass.uImages, [...Array(numTextures).keys()]);

		            // provide coordinates for the rectangle in output space, i.e. a unit quad for each one.
		            let outputQuads = new Float32Array(numTextures * 12);
		            for(let i = 0; i < numTextures; ++i){
		                outputQuads.set(Float32Array.from(this._unitQuad), i * 12);
		            }
		            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferOutputPosition);
		            gl.bufferData(gl.ARRAY_BUFFER, outputQuads, gl.STATIC_DRAW); // bind data statically here, since it's unchanging
		            gl.enableVertexAttribArray(this._firstPass.aOutputPosition);

		            // provide texture coordinates for the rectangle in image (texture) space. Data will be set later.
		            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferTexturePosition);
		            gl.enableVertexAttribArray(this._firstPass.aTexturePosition);

		            // for each vertex, provide an index into the array of textures/matrices to use for the correct tile
		            gl.bindBuffer(gl.ARRAY_BUFFER, this._firstPass.bufferIndex);
		            let indices = [...Array(this._glNumTextures).keys()].map(i => Array(6).fill(i)).flat(); // repeat each index 6 times, for the 6 vertices per tile (2 triangles)
		            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(indices), gl.STATIC_DRAW); // bind data statically here, since it's unchanging
		            gl.enableVertexAttribArray(this._firstPass.aIndex);

		        }

		        // private
		        _makeSecondPassShaderProgram(){
		            const vertexShaderProgram = `
            attribute vec2 a_output_position;
            attribute vec2 a_texture_position;

            uniform mat3 u_matrix;

            varying vec2 v_texture_position;

            void main() {
                gl_Position = vec4(u_matrix * vec3(a_output_position, 1), 1);

                v_texture_position = a_texture_position;
            }
            `;

		            const fragmentShaderProgram = `
            precision mediump float;

            // our texture
            uniform sampler2D u_image;

            // the texCoords passed in from the vertex shader.
            varying vec2 v_texture_position;

            // the opacity multiplier for the image
            uniform float u_opacity_multiplier;

            void main() {
                gl_FragColor = texture2D(u_image, v_texture_position);
                gl_FragColor *= u_opacity_multiplier;
            }
            `;

		            let gl = this._gl;

		            let program = this.constructor.initShaderProgram(gl, vertexShaderProgram, fragmentShaderProgram);
		            gl.useProgram(program);

		            // get locations of attributes and uniforms, and create buffers for each attribute
		            this._secondPass = {
		                shaderProgram: program,
		                aOutputPosition: gl.getAttribLocation(program, 'a_output_position'),
		                aTexturePosition: gl.getAttribLocation(program, 'a_texture_position'),
		                uMatrix: gl.getUniformLocation(program, 'u_matrix'),
		                uImage: gl.getUniformLocation(program, 'u_image'),
		                uOpacityMultiplier: gl.getUniformLocation(program, 'u_opacity_multiplier'),
		                bufferOutputPosition: gl.createBuffer(),
		                bufferTexturePosition: gl.createBuffer(),
		            };


		            // provide coordinates for the rectangle in output space, i.e. a unit quad for each one.
		            gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferOutputPosition);
		            gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.STATIC_DRAW); // bind data statically here since it's unchanging
		            gl.enableVertexAttribArray(this._secondPass.aOutputPosition);

		            // provide texture coordinates for the rectangle in image (texture) space.
		            gl.bindBuffer(gl.ARRAY_BUFFER, this._secondPass.bufferTexturePosition);
		            gl.bufferData(gl.ARRAY_BUFFER, this._unitQuad, gl.DYNAMIC_DRAW); // bind data statically here since it's unchanging
		            gl.enableVertexAttribArray(this._secondPass.aTexturePosition);

		            // set the matrix that transforms the framebuffer to clip space
		            let matrix = $.Mat3.makeScaling(2, 2).multiply($.Mat3.makeTranslation(-0.5, -0.5));
		            gl.uniformMatrix3fv(this._secondPass.uMatrix, false, matrix.values);
		        }

		        // private
		        _resizeRenderer(){
		            let gl = this._gl;
		            let w = this._renderingCanvas.width;
		            let h = this._renderingCanvas.height;
		            gl.viewport(0, 0, w, h);

		            //release the old texture
		            gl.deleteTexture(this._renderToTexture);
		            //create a new texture and set it up
		            this._renderToTexture = gl.createTexture();
		            gl.activeTexture(gl.TEXTURE0);
		            gl.bindTexture(gl.TEXTURE_2D, this._renderToTexture);
		            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		            //bind the frame buffer to the new texture
		            gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
		            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderToTexture, 0);

		        }

		        // private
		        _setupCanvases(){
		            let _this = this;

		            this._outputCanvas = this.canvas; //output canvas
		            this._outputContext = this._outputCanvas.getContext('2d');

		            this._renderingCanvas = document.createElement('canvas');

		            this._clippingCanvas = document.createElement('canvas');
		            this._clippingContext = this._clippingCanvas.getContext('2d');
		            this._renderingCanvas.width = this._clippingCanvas.width = this._outputCanvas.width;
		            this._renderingCanvas.height = this._clippingCanvas.height = this._outputCanvas.height;

		            this._gl = this._renderingCanvas.getContext('webgl');

		            this._resizeHandler = function(){

		                if(_this._outputCanvas !== _this.viewer.drawer.canvas){
		                    _this._outputCanvas.style.width = _this.viewer.drawer.canvas.clientWidth + 'px';
		                    _this._outputCanvas.style.height = _this.viewer.drawer.canvas.clientHeight + 'px';
		                }

		                let viewportSize = _this._calculateCanvasSize();
		                if( _this._outputCanvas.width !== viewportSize.x ||
		                    _this._outputCanvas.height !== viewportSize.y ) {
		                    _this._outputCanvas.width = viewportSize.x;
		                    _this._outputCanvas.height = viewportSize.y;
		                }

		                _this._renderingCanvas.style.width = _this._outputCanvas.clientWidth + 'px';
		                _this._renderingCanvas.style.height = _this._outputCanvas.clientHeight + 'px';
		                _this._renderingCanvas.width = _this._clippingCanvas.width = _this._outputCanvas.width;
		                _this._renderingCanvas.height = _this._clippingCanvas.height = _this._outputCanvas.height;

		                // important - update the size of the rendering viewport!
		                _this._resizeRenderer();
		            };

		            //make the additional canvas elements mirror size changes to the output canvas
		            this.viewer.addHandler("resize", this._resizeHandler);
		        }

		        // private
		        _makeQuadVertexBuffer(left, right, top, bottom){
		            return new Float32Array([
		                left, bottom,
		                right, bottom,
		                left, top,
		                left, top,
		                right, bottom,
		                right, top]);
		        }

		        // private
		        _tileReadyHandler(event){
		            let tile = event.tile;
		            let tiledImage = event.tiledImage;

		            // If a tiledImage is already known to be tainted, don't try to upload any
		            // textures to webgl, because they won't be used even if it succeeds
		            if(tiledImage.isTainted()){
		                return;
		            }

		            let tileContext = tile.getCanvasContext();
		            let canvas = tileContext && tileContext.canvas;
		            // if the tile doesn't provide a canvas, or is tainted by cross-origin
		            // data, marked the TiledImage as tainted so the canvas drawer can be
		            // used instead, and return immediately - tainted data cannot be uploaded to webgl
		            if(!canvas || $.isCanvasTainted(canvas)){
		                const wasTainted = tiledImage.isTainted();
		                if(!wasTainted){
		                    tiledImage.setTainted(true);
		                    $.console.warn('WebGL cannot be used to draw this TiledImage because it has tainted data. Does crossOriginPolicy need to be set?');
		                    this._raiseDrawerErrorEvent(tiledImage, 'Tainted data cannot be used by the WebGLDrawer. Falling back to CanvasDrawer for this TiledImage.');
		                }
		                return;
		            }

		            let textureInfo = this._TextureMap.get(canvas);

		            // if this is a new image for us, create a texture
		            if(!textureInfo){
		                let gl = this._gl;

		                // create a gl Texture for this tile and bind the canvas with the image data
		                let texture = gl.createTexture();
		                let position;
		                let overlap = tiledImage.source.tileOverlap;

		                // deal with tiles where there is padding, i.e. the pixel data doesn't take up the entire provided canvas
		                let sourceWidthFraction, sourceHeightFraction;
		                if (tile.sourceBounds) {
		                    sourceWidthFraction = Math.min(tile.sourceBounds.width, canvas.width) / canvas.width;
		                    sourceHeightFraction = Math.min(tile.sourceBounds.height, canvas.height) / canvas.height;
		                } else {
		                    sourceWidthFraction = 1;
		                    sourceHeightFraction = 1;
		                }

		                if( overlap > 0){
		                    // calculate the normalized position of the rect to actually draw
		                    // discarding overlap.
		                    let overlapFraction = this._calculateOverlapFraction(tile, tiledImage);

		                    let left = (tile.x === 0 ? 0 : overlapFraction.x) * sourceWidthFraction;
		                    let top = (tile.y === 0 ? 0 : overlapFraction.y) * sourceHeightFraction;
		                    let right = (tile.isRightMost ? 1 : 1 - overlapFraction.x) * sourceWidthFraction;
		                    let bottom = (tile.isBottomMost ? 1 : 1 - overlapFraction.y) * sourceHeightFraction;
		                    position = this._makeQuadVertexBuffer(left, right, top, bottom);
		                } else if (sourceWidthFraction === 1 && sourceHeightFraction === 1) {
		                    // no overlap and no padding: this texture can use the unit quad as its position data
		                    position = this._unitQuad;
		                } else {
		                    position = this._makeQuadVertexBuffer(0, sourceWidthFraction, 0, sourceHeightFraction);
		                }

		                let textureInfo = {
		                    texture: texture,
		                    position: position,
		                };

		                // add it to our _TextureMap
		                this._TextureMap.set(canvas, textureInfo);
		                gl.activeTexture(gl.TEXTURE0);
		                gl.bindTexture(gl.TEXTURE_2D, texture);
		                // Set the parameters so we can render any size image.
		                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this._textureFilter());
		                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this._textureFilter());

		                // Upload the image into the texture.
		                this._uploadImageData(tileContext);

		            }

		        }

		        // private
		        _calculateOverlapFraction(tile, tiledImage){
		            let overlap = tiledImage.source.tileOverlap;
		            let nativeWidth = tile.sourceBounds.width; // in pixels
		            let nativeHeight = tile.sourceBounds.height; // in pixels
		            let overlapWidth  = (tile.x === 0 ? 0 : overlap) + (tile.isRightMost ? 0 : overlap); // in pixels
		            let overlapHeight = (tile.y === 0 ? 0 : overlap) + (tile.isBottomMost ? 0 : overlap); // in pixels
		            let widthOverlapFraction = overlap / (nativeWidth + overlapWidth); // as a fraction of image including overlap
		            let heightOverlapFraction = overlap / (nativeHeight + overlapHeight); // as a fraction of image including overlap
		            return {
		                x: widthOverlapFraction,
		                y: heightOverlapFraction
		            };
		        }

		        // private
		        _unloadTextures(){
		            let canvases = Array.from(this._TextureMap.keys());
		            canvases.forEach(canvas => {
		                this._cleanupImageData(canvas); // deletes texture, removes from _TextureMap
		            });
		        }

		        // private
		        _uploadImageData(tileContext){

		            let gl = this._gl;
		            let canvas = tileContext.canvas;

		            try{
		                if(!canvas){
		                    throw('Tile context does not have a canvas', tileContext);
		                }
		                // This depends on gl.TEXTURE_2D being bound to the texture
		                // associated with this canvas before calling this function
		                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
		            } catch (e){
		                $.console.error('Error uploading image data to WebGL', e);
		            }
		        }

		        // private
		        _imageUnloadedHandler(event){
		            let canvas = event.context2D.canvas;
		            this._cleanupImageData(canvas);
		        }

		        // private
		        _cleanupImageData(tileCanvas){
		            let textureInfo = this._TextureMap.get(tileCanvas);
		            //remove from the map
		            this._TextureMap.delete(tileCanvas);

		            //release the texture from the GPU
		            if(textureInfo){
		                this._gl.deleteTexture(textureInfo.texture);
		            }

		        }

		        // private
		        _setClip(){
		            // no-op: called by _renderToClippingCanvas when tiledImage._clip is truthy
		            // so that tests will pass.
		        }

		        // private
		        _renderToClippingCanvas(item){

		            this._clippingContext.clearRect(0, 0, this._clippingCanvas.width, this._clippingCanvas.height);
		            this._clippingContext.save();
		            if(this.viewer.viewport.getFlip()){
		                const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
		                this._clippingContext.translate(point.x, 0);
		                this._clippingContext.scale(-1, 1);
		                this._clippingContext.translate(-point.x, 0);
		            }

		            if(item._clip){
		                const polygon = [
		                    {x: item._clip.x, y: item._clip.y},
		                    {x: item._clip.x + item._clip.width, y: item._clip.y},
		                    {x: item._clip.x + item._clip.width, y: item._clip.y + item._clip.height},
		                    {x: item._clip.x, y: item._clip.y + item._clip.height},
		                ];
		                let clipPoints = polygon.map(coord => {
		                    let point = item.imageToViewportCoordinates(coord.x, coord.y, true)
		                        .rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
		                    let clipPoint = this.viewportCoordToDrawerCoord(point);
		                    return clipPoint;
		                });
		                this._clippingContext.beginPath();
		                clipPoints.forEach( (coord, i) => {
		                    this._clippingContext[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
		                });
		                this._clippingContext.clip();
		                this._setClip();
		            }
		            if(item._croppingPolygons){
		                let polygons = item._croppingPolygons.map(polygon => {
		                    return polygon.map(coord => {
		                        let point = item.imageToViewportCoordinates(coord.x, coord.y, true)
		                            .rotate(this.viewer.viewport.getRotation(true), this.viewer.viewport.getCenter(true));
		                        let clipPoint = this.viewportCoordToDrawerCoord(point);
		                        return clipPoint;
		                    });
		                });
		                this._clippingContext.beginPath();
		                polygons.forEach((polygon) => {
		                    polygon.forEach( (coord, i) => {
		                        this._clippingContext[i === 0 ? 'moveTo' : 'lineTo'](coord.x, coord.y);
		                    });
		                });
		                this._clippingContext.clip();
		            }

		            if(this.viewer.viewport.getFlip()){
		                const point = new $.Point(this.canvas.width / 2, this.canvas.height / 2);
		                this._clippingContext.translate(point.x, 0);
		                this._clippingContext.scale(-1, 1);
		                this._clippingContext.translate(-point.x, 0);
		            }

		            this._clippingContext.drawImage(this._renderingCanvas, 0, 0);

		            this._clippingContext.restore();
		        }

		        /**
		         * Set rotations for viewport & tiledImage
		         * @private
		         * @param {OpenSeadragon.TiledImage} tiledImage
		         */
		        _setRotations(tiledImage) {
		            var saveContext = false;
		            if (this.viewport.getRotation(true) % 360 !== 0) {
		                this._offsetForRotation({
		                    degrees: this.viewport.getRotation(true),
		                    saveContext: saveContext
		                });
		                saveContext = false;
		            }
		            if (tiledImage.getRotation(true) % 360 !== 0) {
		                this._offsetForRotation({
		                    degrees: tiledImage.getRotation(true),
		                    point: this.viewport.pixelFromPointNoRotate(
		                        tiledImage._getRotationPoint(true), true),
		                    saveContext: saveContext
		                });
		            }
		        }

		        // private
		        _offsetForRotation(options) {
		            var point = options.point ?
		                options.point.times($.pixelDensityRatio) :
		                this._getCanvasCenter();

		            var context = this._outputContext;
		            context.save();

		            context.translate(point.x, point.y);
		            context.rotate(Math.PI / 180 * options.degrees);
		            context.translate(-point.x, -point.y);
		        }

		        // private
		        _flip(options) {
		            options = options || {};
		            var point = options.point ?
		            options.point.times($.pixelDensityRatio) :
		            this._getCanvasCenter();
		            var context = this._outputContext;

		            context.translate(point.x, 0);
		            context.scale(-1, 1);
		            context.translate(-point.x, 0);
		        }

		        // private
		        _drawDebugInfo( tilesToDraw, tiledImage, flipped ) {

		            for ( var i = tilesToDraw.length - 1; i >= 0; i-- ) {
		                var tile = tilesToDraw[ i ].tile;
		                try {
		                    this._drawDebugInfoOnTile(tile, tilesToDraw.length, i, tiledImage, flipped);
		                } catch(e) {
		                    $.console.error(e);
		                }
		            }
		        }

		        // private
		        _drawDebugInfoOnTile(tile, count, i, tiledImage, flipped) {

		            var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
		            var context = this.context;
		            context.save();
		            context.lineWidth = 2 * $.pixelDensityRatio;
		            context.font = 'small-caps bold ' + (13 * $.pixelDensityRatio) + 'px arial';
		            context.strokeStyle = this.debugGridColor[colorIndex];
		            context.fillStyle = this.debugGridColor[colorIndex];

		            this._setRotations(tiledImage);

		            if(flipped){
		                this._flip({point: tile.position.plus(tile.size.divide(2))});
		            }

		            context.strokeRect(
		                tile.position.x * $.pixelDensityRatio,
		                tile.position.y * $.pixelDensityRatio,
		                tile.size.x * $.pixelDensityRatio,
		                tile.size.y * $.pixelDensityRatio
		            );

		            var tileCenterX = (tile.position.x + (tile.size.x / 2)) * $.pixelDensityRatio;
		            var tileCenterY = (tile.position.y + (tile.size.y / 2)) * $.pixelDensityRatio;

		            // Rotate the text the right way around.
		            context.translate( tileCenterX, tileCenterY );
		            const angleInDegrees = this.viewport.getRotation(true);
		            context.rotate( Math.PI / 180 * -angleInDegrees );
		            context.translate( -tileCenterX, -tileCenterY );

		            if( tile.x === 0 && tile.y === 0 ){
		                context.fillText(
		                    "Zoom: " + this.viewport.getZoom(),
		                    tile.position.x * $.pixelDensityRatio,
		                    (tile.position.y - 30) * $.pixelDensityRatio
		                );
		                context.fillText(
		                    "Pan: " + this.viewport.getBounds().toString(),
		                    tile.position.x * $.pixelDensityRatio,
		                    (tile.position.y - 20) * $.pixelDensityRatio
		                );
		            }
		            context.fillText(
		                "Level: " + tile.level,
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 20) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Column: " + tile.x,
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 30) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Row: " + tile.y,
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 40) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Order: " + i + " of " + count,
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 50) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Size: " + tile.size.toString(),
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 60) * $.pixelDensityRatio
		            );
		            context.fillText(
		                "Position: " + tile.position.toString(),
		                (tile.position.x + 10) * $.pixelDensityRatio,
		                (tile.position.y + 70) * $.pixelDensityRatio
		            );

		            if (this.viewport.getRotation(true) % 360 !== 0 ) {
		                this._restoreRotationChanges();
		            }
		            if (tiledImage.getRotation(true) % 360 !== 0) {
		                this._restoreRotationChanges();
		            }

		            context.restore();
		        }

		        _drawPlaceholder(tiledImage){

		            const bounds = tiledImage.getBounds(true);
		            const rect = this.viewportToDrawerRectangle(tiledImage.getBounds(true));
		            const context = this._outputContext;

		            let fillStyle;
		            if ( typeof tiledImage.placeholderFillStyle === "function" ) {
		                fillStyle = tiledImage.placeholderFillStyle(tiledImage, context);
		            }
		            else {
		                fillStyle = tiledImage.placeholderFillStyle;
		            }

		            this._offsetForRotation({degrees: this.viewer.viewport.getRotation(true)});
		            context.fillStyle = fillStyle;
		            context.translate(rect.x, rect.y);
		            context.rotate(Math.PI / 180 * bounds.degrees);
		            context.translate(-rect.x, -rect.y);
		            context.fillRect(rect.x, rect.y, rect.width, rect.height);
		            this._restoreRotationChanges();

		        }

		        /**
		         * Get the canvas center
		         * @private
		         * @returns {OpenSeadragon.Point} The center point of the canvas
		         */
		        _getCanvasCenter() {
		            return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
		        }

		        // private
		        _restoreRotationChanges() {
		            var context = this._outputContext;
		            context.restore();
		        }

		        // modified from https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
		        static initShaderProgram(gl, vsSource, fsSource) {

		            function loadShader(gl, type, source) {
		                const shader = gl.createShader(type);

		                // Send the source to the shader object

		                gl.shaderSource(shader, source);

		                // Compile the shader program

		                gl.compileShader(shader);

		                // See if it compiled successfully

		                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		                    $.console.error(
		                        `An error occurred compiling the shaders: ${gl.getShaderInfoLog(shader)}`
		                    );
		                    gl.deleteShader(shader);
		                    return null;
		                }

		                return shader;
		            }

		            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
		            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

		            // Create the shader program

		            const shaderProgram = gl.createProgram();
		            gl.attachShader(shaderProgram, vertexShader);
		            gl.attachShader(shaderProgram, fragmentShader);
		            gl.linkProgram(shaderProgram);

		            // If creating the shader program failed, alert

		            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		            $.console.error(
		                `Unable to initialize the shader program: ${gl.getProgramInfoLog(
		                shaderProgram
		                )}`
		            );
		            return null;
		            }

		            return shaderProgram;
		        }

		    };



		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - Viewport
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){


		/**
		 * @class Viewport
		 * @memberof OpenSeadragon
		 * @classdesc Handles coordinate-related functionality (zoom, pan, rotation, etc.)
		 * for an {@link OpenSeadragon.Viewer}.
		 * @param {Object} options - Options for this Viewport.
		 * @param {Object} [options.margins] - See viewportMargins in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.springStiffness] - See springStiffness in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.animationTime] - See animationTime in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.minZoomImageRatio] - See minZoomImageRatio in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.maxZoomPixelRatio] - See maxZoomPixelRatio in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.visibilityRatio] - See visibilityRatio in {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.wrapHorizontal] - See wrapHorizontal in {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.wrapVertical] - See wrapVertical in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.defaultZoomLevel] - See defaultZoomLevel in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.minZoomLevel] - See minZoomLevel in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.maxZoomLevel] - See maxZoomLevel in {@link OpenSeadragon.Options}.
		 * @param {Number} [options.degrees] - See degrees in {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.homeFillsViewer] - See homeFillsViewer in {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.silenceMultiImageWarnings] - See silenceMultiImageWarnings in {@link OpenSeadragon.Options}.
		 */
		$.Viewport = function( options ) {

		    //backward compatibility for positional args while preferring more
		    //idiomatic javascript options object as the only argument
		    var args = arguments;
		    if (args.length && args[0] instanceof $.Point) {
		        options = {
		            containerSize:  args[0],
		            contentSize:    args[1],
		            config:         args[2]
		        };
		    }

		    //options.config and the general config argument are deprecated
		    //in favor of the more direct specification of optional settings
		    //being passed directly on the options object
		    if ( options.config ){
		        $.extend( true, options, options.config );
		        delete options.config;
		    }

		    this._margins = $.extend({
		        left: 0,
		        top: 0,
		        right: 0,
		        bottom: 0
		    }, options.margins || {});

		    delete options.margins;

		    options.initialDegrees = options.degrees;
		    delete options.degrees;

		    $.extend( true, this, {

		        //required settings
		        containerSize:      null,
		        contentSize:        null,

		        //internal state properties
		        zoomPoint:          null,
		        rotationPivot:      null,
		        viewer:             null,

		        //configurable options
		        springStiffness:            $.DEFAULT_SETTINGS.springStiffness,
		        animationTime:              $.DEFAULT_SETTINGS.animationTime,
		        minZoomImageRatio:          $.DEFAULT_SETTINGS.minZoomImageRatio,
		        maxZoomPixelRatio:          $.DEFAULT_SETTINGS.maxZoomPixelRatio,
		        visibilityRatio:            $.DEFAULT_SETTINGS.visibilityRatio,
		        wrapHorizontal:             $.DEFAULT_SETTINGS.wrapHorizontal,
		        wrapVertical:               $.DEFAULT_SETTINGS.wrapVertical,
		        defaultZoomLevel:           $.DEFAULT_SETTINGS.defaultZoomLevel,
		        minZoomLevel:               $.DEFAULT_SETTINGS.minZoomLevel,
		        maxZoomLevel:               $.DEFAULT_SETTINGS.maxZoomLevel,
		        initialDegrees:             $.DEFAULT_SETTINGS.degrees,
		        flipped:                    $.DEFAULT_SETTINGS.flipped,
		        homeFillsViewer:            $.DEFAULT_SETTINGS.homeFillsViewer,
		        silenceMultiImageWarnings:  $.DEFAULT_SETTINGS.silenceMultiImageWarnings

		    }, options );

		    this._updateContainerInnerSize();

		    this.centerSpringX = new $.Spring({
		        initial: 0,
		        springStiffness: this.springStiffness,
		        animationTime:   this.animationTime
		    });
		    this.centerSpringY = new $.Spring({
		        initial: 0,
		        springStiffness: this.springStiffness,
		        animationTime:   this.animationTime
		    });
		    this.zoomSpring    = new $.Spring({
		        exponential: true,
		        initial: 1,
		        springStiffness: this.springStiffness,
		        animationTime:   this.animationTime
		    });

		    this.degreesSpring = new $.Spring({
		        initial: options.initialDegrees,
		        springStiffness: this.springStiffness,
		        animationTime: this.animationTime
		    });

		    this._oldCenterX = this.centerSpringX.current.value;
		    this._oldCenterY = this.centerSpringY.current.value;
		    this._oldZoom    = this.zoomSpring.current.value;
		    this._oldDegrees = this.degreesSpring.current.value;

		    this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);

		    this.goHome(true);
		    this.update();
		};

		/** @lends OpenSeadragon.Viewport.prototype */
		$.Viewport.prototype = {

		    // deprecated
		    get degrees () {
		        $.console.warn('Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead.');
		        return this.getRotation();
		    },

		    // deprecated
		    set degrees (degrees) {
		        $.console.warn('Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead.');
		        this.rotateTo(degrees);
		    },

		    /**
		     * Updates the viewport's home bounds and constraints for the given content size.
		     * @function
		     * @param {OpenSeadragon.Point} contentSize - size of the content in content units
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:reset-size
		     */
		    resetContentSize: function(contentSize) {
		        $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
		        $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
		        $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
		        $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");

		        this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
		        return this;
		    },

		    // deprecated
		    setHomeBounds: function(bounds, contentFactor) {
		        $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
		        this._setContentBounds(bounds, contentFactor);
		    },

		    // Set the viewport's content bounds
		    // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
		    // without rotation
		    // @param {Number} contentFactor - how many content units per viewport unit
		    // @fires OpenSeadragon.Viewer.event:reset-size
		    // @private
		    _setContentBounds: function(bounds, contentFactor) {
		        $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
		        $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
		        $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
		        $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");

		        this._contentBoundsNoRotate = bounds.clone();
		        this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
		            contentFactor);

		        this._contentBounds = bounds.rotate(this.getRotation()).getBoundingBox();
		        this._contentSize = this._contentBounds.getSize().times(contentFactor);
		        this._contentAspectRatio = this._contentSize.x / this._contentSize.y;

		        if (this.viewer) {
		            /**
		             * Raised when the viewer's content size or home bounds are reset
		             * (see {@link OpenSeadragon.Viewport#resetContentSize}).
		             *
		             * @event reset-size
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {OpenSeadragon.Point} contentSize
		             * @property {OpenSeadragon.Rect} contentBounds - Content bounds.
		             * @property {OpenSeadragon.Rect} homeBounds - Content bounds.
		             * Deprecated use contentBounds instead.
		             * @property {Number} contentFactor
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent('reset-size', {
		                contentSize: this._contentSizeNoRotate.clone(),
		                contentFactor: contentFactor,
		                homeBounds: this._contentBoundsNoRotate.clone(),
		                contentBounds: this._contentBounds.clone()
		            });
		        }
		    },

		    /**
		     * Returns the home zoom in "viewport zoom" value.
		     * @function
		     * @returns {Number} The home zoom in "viewport zoom".
		     */
		    getHomeZoom: function() {
		        if (this.defaultZoomLevel) {
		            return this.defaultZoomLevel;
		        }

		        var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
		        var output;
		        if (this.homeFillsViewer) { // fill the viewer and clip the image
		            output = aspectFactor >= 1 ? aspectFactor : 1;
		        } else {
		            output = aspectFactor >= 1 ? 1 : aspectFactor;
		        }

		        return output / this._contentBounds.width;
		    },

		    /**
		     * Returns the home bounds in viewport coordinates.
		     * @function
		     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
		     */
		    getHomeBounds: function() {
		        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
		    },

		    /**
		     * Returns the home bounds in viewport coordinates.
		     * This method ignores the viewport rotation. Use
		     * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
		     * @function
		     * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
		     */
		    getHomeBoundsNoRotate: function() {
		        var center = this._contentBounds.getCenter();
		        var width  = 1.0 / this.getHomeZoom();
		        var height = width / this.getAspectRatio();

		        return new $.Rect(
		            center.x - (width / 2.0),
		            center.y - (height / 2.0),
		            width,
		            height
		        );
		    },

		    /**
		     * @function
		     * @param {Boolean} immediately
		     * @fires OpenSeadragon.Viewer.event:home
		     */
		    goHome: function(immediately) {
		        if (this.viewer) {
		            /**
		             * Raised when the "home" operation occurs (see {@link OpenSeadragon.Viewport#goHome}).
		             *
		             * @event home
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {Boolean} immediately
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent('home', {
		                immediately: immediately
		            });
		        }
		        return this.fitBounds(this.getHomeBounds(), immediately);
		    },

		    /**
		     * @function
		     */
		    getMinZoom: function() {
		        var homeZoom = this.getHomeZoom(),
		            zoom = this.minZoomLevel ?
		            this.minZoomLevel :
		                this.minZoomImageRatio * homeZoom;

		        return zoom;
		    },

		    /**
		     * @function
		     */
		    getMaxZoom: function() {
		        var zoom = this.maxZoomLevel;
		        if (!zoom) {
		            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
		            zoom /= this._contentBounds.width;
		        }

		        return Math.max( zoom, this.getHomeZoom() );
		    },

		    /**
		     * @function
		     */
		    getAspectRatio: function() {
		        return this._containerInnerSize.x / this._containerInnerSize.y;
		    },

		    /**
		     * @function
		     * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
		     */
		    getContainerSize: function() {
		        return new $.Point(
		            this.containerSize.x,
		            this.containerSize.y
		        );
		    },

		    /**
		     * The margins push the "home" region in from the sides by the specified amounts.
		     * @function
		     * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
		     */
		    getMargins: function() {
		        return $.extend({}, this._margins); // Make a copy so we are not returning our original
		    },

		    /**
		     * The margins push the "home" region in from the sides by the specified amounts.
		     * @function
		     * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
		     */
		    setMargins: function(margins) {
		        $.console.assert($.type(margins) === 'object', '[Viewport.setMargins] margins must be an object');

		        this._margins = $.extend({
		            left: 0,
		            top: 0,
		            right: 0,
		            bottom: 0
		        }, margins);

		        this._updateContainerInnerSize();
		        if (this.viewer) {
		            this.viewer.forceRedraw();
		        }
		    },

		    /**
		     * Returns the bounds of the visible area in viewport coordinates.
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
		     */
		    getBounds: function(current) {
		        return this.getBoundsNoRotate(current).rotate(-this.getRotation(current));
		    },

		    /**
		     * Returns the bounds of the visible area in viewport coordinates.
		     * This method ignores the viewport rotation. Use
		     * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
		     */
		    getBoundsNoRotate: function(current) {
		        var center = this.getCenter(current);
		        var width  = 1.0 / this.getZoom(current);
		        var height = width / this.getAspectRatio();

		        return new $.Rect(
		            center.x - (width / 2.0),
		            center.y - (height / 2.0),
		            width,
		            height
		        );
		    },

		    /**
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
		     * including the space taken by margins, in viewport coordinates.
		     */
		    getBoundsWithMargins: function(current) {
		        return this.getBoundsNoRotateWithMargins(current).rotate(
		            -this.getRotation(current), this.getCenter(current));
		    },

		    /**
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
		     * including the space taken by margins, in viewport coordinates.
		     */
		    getBoundsNoRotateWithMargins: function(current) {
		        var bounds = this.getBoundsNoRotate(current);
		        var factor = this._containerInnerSize.x * this.getZoom(current);
		        bounds.x -= this._margins.left / factor;
		        bounds.y -= this._margins.top / factor;
		        bounds.width += (this._margins.left + this._margins.right) / factor;
		        bounds.height += (this._margins.top + this._margins.bottom) / factor;
		        return bounds;
		    },

		    /**
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     */
		    getCenter: function( current ) {
		        var centerCurrent = new $.Point(
		                this.centerSpringX.current.value,
		                this.centerSpringY.current.value
		            ),
		            centerTarget = new $.Point(
		                this.centerSpringX.target.value,
		                this.centerSpringY.target.value
		            ),
		            oldZoomPixel,
		            zoom,
		            width,
		            height,
		            bounds,
		            newZoomPixel,
		            deltaZoomPixels,
		            deltaZoomPoints;

		        if ( current ) {
		            return centerCurrent;
		        } else if ( !this.zoomPoint ) {
		            return centerTarget;
		        }

		        oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);

		        zoom    = this.getZoom();
		        width   = 1.0 / zoom;
		        height  = width / this.getAspectRatio();
		        bounds  = new $.Rect(
		            centerCurrent.x - width / 2.0,
		            centerCurrent.y - height / 2.0,
		            width,
		            height
		        );

		        newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
		        deltaZoomPixels = newZoomPixel.minus( oldZoomPixel ).rotate(-this.getRotation(true));
		        deltaZoomPoints = deltaZoomPixels.divide( this._containerInnerSize.x * zoom );

		        return centerTarget.plus( deltaZoomPoints );
		    },

		    /**
		     * @function
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     */
		    getZoom: function( current ) {
		        if ( current ) {
		            return this.zoomSpring.current.value;
		        } else {
		            return this.zoomSpring.target.value;
		        }
		    },

		    // private
		    _applyZoomConstraints: function(zoom) {
		        return Math.max(
		            Math.min(zoom, this.getMaxZoom()),
		            this.getMinZoom());
		    },

		    /**
		     * @function
		     * @private
		     * @param {OpenSeadragon.Rect} bounds
		     * @returns {OpenSeadragon.Rect} constrained bounds.
		     */
		    _applyBoundaryConstraints: function(bounds) {
		        var newBounds = this.viewportToViewerElementRectangle(bounds).getBoundingBox();
		        var cb = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox();

		        var xConstrained = false;
		        var yConstrained = false;

		        if (this.wrapHorizontal) ; else {
		            var boundsRight = newBounds.x + newBounds.width;
		            var contentRight = cb.x + cb.width;

		            var horizontalThreshold, leftDx, rightDx;
		            if (newBounds.width > cb.width) {
		                horizontalThreshold = this.visibilityRatio * cb.width;
		            } else {
		                horizontalThreshold = this.visibilityRatio * newBounds.width;
		            }

		            leftDx = cb.x - boundsRight + horizontalThreshold;
		            rightDx = contentRight - newBounds.x - horizontalThreshold;
		            if (horizontalThreshold > cb.width) {
		                newBounds.x += (leftDx + rightDx) / 2;
		                xConstrained = true;
		            } else if (rightDx < 0) {
		                newBounds.x += rightDx;
		                xConstrained = true;
		            } else if (leftDx > 0) {
		                newBounds.x += leftDx;
		                xConstrained = true;
		            }

		        }

		        if (this.wrapVertical) ; else {
		            var boundsBottom = newBounds.y + newBounds.height;
		            var contentBottom = cb.y + cb.height;

		            var verticalThreshold, topDy, bottomDy;
		            if (newBounds.height > cb.height) {
		                verticalThreshold = this.visibilityRatio * cb.height;
		            } else {
		                verticalThreshold = this.visibilityRatio * newBounds.height;
		            }

		            topDy = cb.y - boundsBottom + verticalThreshold;
		            bottomDy = contentBottom - newBounds.y - verticalThreshold;
		            if (verticalThreshold > cb.height) {
		                newBounds.y += (topDy + bottomDy) / 2;
		                yConstrained = true;
		            } else if (bottomDy < 0) {
		                newBounds.y += bottomDy;
		                yConstrained = true;
		            } else if (topDy > 0) {
		                newBounds.y += topDy;
		                yConstrained = true;
		            }

		        }

		        var constraintApplied = xConstrained || yConstrained;
		        var newViewportBounds = constraintApplied ? this.viewerElementToViewportRectangle(newBounds) : bounds.clone();
		        newViewportBounds.xConstrained = xConstrained;
		        newViewportBounds.yConstrained = yConstrained;
		        newViewportBounds.constraintApplied = constraintApplied;

		        return newViewportBounds;
		    },

		    /**
		     * @function
		     * @private
		     * @param {Boolean} [immediately=false] - whether the function that triggered this event was
		     * called with the "immediately" flag
		     */
		    _raiseConstraintsEvent: function(immediately) {
		        if (this.viewer) {
		            /**
		             * Raised when the viewport constraints are applied (see {@link OpenSeadragon.Viewport#applyConstraints}).
		             *
		             * @event constrain
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {Boolean} immediately - whether the function that triggered this event was
		             * called with the "immediately" flag
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent( 'constrain', {
		                immediately: immediately
		            });
		        }
		    },

		    /**
		     * Enforces the minZoom, maxZoom and visibilityRatio constraints by
		     * zooming and panning to the closest acceptable zoom and location.
		     * @function
		     * @param {Boolean} [immediately=false]
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
		     */
		    applyConstraints: function(immediately) {
		        var actualZoom = this.getZoom();
		        var constrainedZoom = this._applyZoomConstraints(actualZoom);

		        if (actualZoom !== constrainedZoom) {
		            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
		        }

		        var constrainedBounds = this.getConstrainedBounds(false);

		        if(constrainedBounds.constraintApplied){
		            this.fitBounds(constrainedBounds, immediately);
		            this._raiseConstraintsEvent(immediately);
		        }

		        return this;
		    },

		    /**
		     * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
		     * @function
		     * @param {Boolean} [immediately=false]
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:constrain
		     */
		    ensureVisible: function(immediately) {
		        return this.applyConstraints(immediately);
		    },

		    /**
		     * @function
		     * @private
		     * @param {OpenSeadragon.Rect} bounds
		     * @param {Object} options (immediately=false, constraints=false)
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    _fitBounds: function(bounds, options) {
		        options = options || {};
		        var immediately = options.immediately || false;
		        var constraints = options.constraints || false;

		        var aspect = this.getAspectRatio();
		        var center = bounds.getCenter();

		        // Compute width and height of bounding box.
		        var newBounds = new $.Rect(
		            bounds.x,
		            bounds.y,
		            bounds.width,
		            bounds.height,
		            bounds.degrees + this.getRotation())
		            .getBoundingBox();

		        if (newBounds.getAspectRatio() >= aspect) {
		            newBounds.height = newBounds.width / aspect;
		        } else {
		            newBounds.width = newBounds.height * aspect;
		        }

		        // Compute x and y from width, height and center position
		        newBounds.x = center.x - newBounds.width / 2;
		        newBounds.y = center.y - newBounds.height / 2;
		        var newZoom = 1.0 / newBounds.width;

		        if (immediately) {
		            this.panTo(center, true);
		            this.zoomTo(newZoom, null, true);
		            if(constraints){
		                this.applyConstraints(true);
		            }
		            return this;
		        }

		        var currentCenter = this.getCenter(true);
		        var currentZoom = this.getZoom(true);
		        this.panTo(currentCenter, true);
		        this.zoomTo(currentZoom, null, true);

		        var oldBounds = this.getBounds();
		        var oldZoom   = this.getZoom();

		        if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 0.00000001) {
		            this.zoomTo(newZoom, null, true);
		            this.panTo(center, immediately);
		            if(constraints){
		                this.applyConstraints(false);
		            }
		            return this;
		        }

		        if(constraints){
		            this.panTo(center, false);

		            newZoom = this._applyZoomConstraints(newZoom);
		            this.zoomTo(newZoom, null, false);

		            var constrainedBounds = this.getConstrainedBounds();

		            this.panTo(currentCenter, true);
		            this.zoomTo(currentZoom, null, true);

		            this.fitBounds(constrainedBounds);
		        } else {
		            var rotatedNewBounds = newBounds.rotate(-this.getRotation());
		            var referencePoint = rotatedNewBounds.getTopLeft().times(newZoom)
		                .minus(oldBounds.getTopLeft().times(oldZoom))
		                .divide(newZoom - oldZoom);

		            this.zoomTo(newZoom, referencePoint, immediately);
		        }
		        return this;
		    },

		    /**
		     * Makes the viewport zoom and pan so that the specified bounds take
		     * as much space as possible in the viewport.
		     * Note: this method ignores the constraints (minZoom, maxZoom and
		     * visibilityRatio).
		     * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
		     * them.
		     * @function
		     * @param {OpenSeadragon.Rect} bounds
		     * @param {Boolean} [immediately=false]
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    fitBounds: function(bounds, immediately) {
		        return this._fitBounds(bounds, {
		            immediately: immediately,
		            constraints: false
		        });
		    },

		    /**
		     * Makes the viewport zoom and pan so that the specified bounds take
		     * as much space as possible in the viewport while enforcing the constraints
		     * (minZoom, maxZoom and visibilityRatio).
		     * Note: because this method enforces the constraints, part of the
		     * provided bounds may end up outside of the viewport.
		     * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
		     * @function
		     * @param {OpenSeadragon.Rect} bounds
		     * @param {Boolean} [immediately=false]
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    fitBoundsWithConstraints: function(bounds, immediately) {
		        return this._fitBounds(bounds, {
		            immediately: immediately,
		            constraints: true
		        });
		    },

		    /**
		     * Zooms so the image just fills the viewer vertically.
		     * @param {Boolean} immediately
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    fitVertically: function(immediately) {
		        var box = new $.Rect(
		            this._contentBounds.x + (this._contentBounds.width / 2),
		            this._contentBounds.y,
		            0,
		            this._contentBounds.height);
		        return this.fitBounds(box, immediately);
		    },

		    /**
		     * Zooms so the image just fills the viewer horizontally.
		     * @param {Boolean} immediately
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    fitHorizontally: function(immediately) {
		        var box = new $.Rect(
		            this._contentBounds.x,
		            this._contentBounds.y + (this._contentBounds.height / 2),
		            this._contentBounds.width,
		            0);
		        return this.fitBounds(box, immediately);
		    },


		    /**
		     * Returns bounds taking constraints into account
		     * Added to improve constrained panning
		     * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
		     * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
		     *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
		     *                               These flags indicate whether the viewport bounds were modified by the constraints
		     *                               of the viewer rectangle, and in which dimension(s).
		     */
		    getConstrainedBounds: function(current) {
		        var bounds,
		            constrainedBounds;

		        bounds = this.getBounds(current);

		        constrainedBounds = this._applyBoundaryConstraints(bounds);

		        return constrainedBounds;
		    },

		    /**
		     * @function
		     * @param {OpenSeadragon.Point} delta
		     * @param {Boolean} immediately
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:pan
		     */
		    panBy: function( delta, immediately ) {
		        var center = new $.Point(
		            this.centerSpringX.target.value,
		            this.centerSpringY.target.value
		        );
		        return this.panTo( center.plus( delta ), immediately );
		    },

		    /**
		     * @function
		     * @param {OpenSeadragon.Point} center
		     * @param {Boolean} immediately
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:pan
		     */
		    panTo: function( center, immediately ) {
		        if ( immediately ) {
		            this.centerSpringX.resetTo( center.x );
		            this.centerSpringY.resetTo( center.y );
		        } else {
		            this.centerSpringX.springTo( center.x );
		            this.centerSpringY.springTo( center.y );
		        }

		        if( this.viewer ){
		            /**
		             * Raised when the viewport is panned (see {@link OpenSeadragon.Viewport#panBy} and {@link OpenSeadragon.Viewport#panTo}).
		             *
		             * @event pan
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {OpenSeadragon.Point} center
		             * @property {Boolean} immediately
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent( 'pan', {
		                center: center,
		                immediately: immediately
		            });
		        }

		        return this;
		    },

		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:zoom
		     */
		    zoomBy: function(factor, refPoint, immediately) {
		        return this.zoomTo(
		            this.zoomSpring.target.value * factor, refPoint, immediately);
		    },

		    /**
		     * Zooms to the specified zoom level
		     * @function
		     * @param {Number} zoom The zoom level to zoom to.
		     * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
		     * the same screen location. Defaults to the viewport center.
		     * @param {Boolean} [immediately=false]
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:zoom
		     */
		    zoomTo: function(zoom, refPoint, immediately) {
		        var _this = this;

		        this.zoomPoint = refPoint instanceof $.Point &&
		            !isNaN(refPoint.x) &&
		            !isNaN(refPoint.y) ?
		            refPoint :
		            null;

		        if (immediately) {
		            this._adjustCenterSpringsForZoomPoint(function() {
		                _this.zoomSpring.resetTo(zoom);
		            });
		        } else {
		            this.zoomSpring.springTo(zoom);
		        }

		        if (this.viewer) {
		            /**
		             * Raised when the viewport zoom level changes (see {@link OpenSeadragon.Viewport#zoomBy} and {@link OpenSeadragon.Viewport#zoomTo}).
		             *
		             * @event zoom
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {Number} zoom
		             * @property {OpenSeadragon.Point} refPoint
		             * @property {Boolean} immediately
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent('zoom', {
		                zoom: zoom,
		                refPoint: refPoint,
		                immediately: immediately
		            });
		        }

		        return this;
		    },

		    /**
		     * Rotates this viewport to the angle specified.
		     * @function
		     * @param {Number} degrees The degrees to set the rotation to.
		     * @param {Boolean} [immediately=false] Whether to animate to the new angle
		     * or rotate immediately.
		     * * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    setRotation: function(degrees, immediately) {
		        return this.rotateTo(degrees, null, immediately);
		    },

		    /**
		     * Gets the current rotation in degrees.
		     * @function
		     * @param {Boolean} [current=false] True for current rotation, false for target.
		     * @returns {Number} The current rotation in degrees.
		     */
		    getRotation: function(current) {
		        return current ?
		            this.degreesSpring.current.value :
		            this.degreesSpring.target.value;
		    },

		    /**
		     * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
		     * @function
		     * @param {Number} degrees The degrees to set the rotation to.
		     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
		     * around which the rotation should be performed. Defaults to the center of the viewport.
		     * @param {Boolean} [immediately=false] Whether to animate to the new angle
		     * or rotate immediately.
		     * * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    setRotationWithPivot: function(degrees, pivot, immediately) {
		        return this.rotateTo(degrees, pivot, immediately);
		    },

		    /**
		     * Rotates this viewport to the angle specified.
		     * @function
		     * @param {Number} degrees The degrees to set the rotation to.
		     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
		     * around which the rotation should be performed. Defaults to the center of the viewport.
		     * @param {Boolean} [immediately=false] Whether to animate to the new angle
		     * or rotate immediately.
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    rotateTo: function(degrees, pivot, immediately){
		        if (!this.viewer || !this.viewer.drawer.canRotate()) {
		            return this;
		        }

		        if (this.degreesSpring.target.value === degrees &&
		            this.degreesSpring.isAtTargetValue()) {
		            return this;
		        }
		        this.rotationPivot = pivot instanceof $.Point &&
		            !isNaN(pivot.x) &&
		            !isNaN(pivot.y) ?
		            pivot :
		            null;
		        if (immediately) {
		            if(this.rotationPivot){
		                var changeInDegrees = degrees - this._oldDegrees;
		                if(!changeInDegrees){
		                    this.rotationPivot = null;
		                    return this;
		                }
		                this._rotateAboutPivot(degrees);
		            } else {
		                this.degreesSpring.resetTo(degrees);
		            }
		        } else {
		            var normalizedFrom = $.positiveModulo(this.degreesSpring.current.value, 360);
		            var normalizedTo = $.positiveModulo(degrees, 360);
		            var diff = normalizedTo - normalizedFrom;
		            if (diff > 180) {
		                normalizedTo -= 360;
		            } else if (diff < -180) {
		                normalizedTo += 360;
		            }

		            var reverseDiff = normalizedFrom - normalizedTo;
		            this.degreesSpring.resetTo(degrees + reverseDiff);
		            this.degreesSpring.springTo(degrees);
		        }

		        this._setContentBounds(
		            this.viewer.world.getHomeBounds(),
		            this.viewer.world.getContentFactor());
		        this.viewer.forceRedraw();

		        /**
		         * Raised when rotation has been changed.
		         *
		         * @event rotate
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		         * @property {Number} degrees - The number of degrees the rotation was set to.
		         * @property {Boolean} immediately - Whether the rotation happened immediately or was animated
		         * @property {OpenSeadragon.Point} pivot - The point in viewport coordinates around which the rotation (if any) happened
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.viewer.raiseEvent('rotate', {degrees: degrees, immediately: !!immediately, pivot: this.rotationPivot || this.getCenter()});
		        return this;
		    },

		    /**
		     * Rotates this viewport by the angle specified.
		     * @function
		     * @param {Number} degrees The degrees by which to rotate the viewport.
		     * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
		     * around which the rotation should be performed. Defaults to the center of the viewport.
		     * * @param {Boolean} [immediately=false] Whether to animate to the new angle
		     * or rotate immediately.
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    rotateBy: function(degrees, pivot, immediately){
		        return this.rotateTo(this.degreesSpring.target.value + degrees, pivot, immediately);
		    },

		    /**
		     * @function
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     * @fires OpenSeadragon.Viewer.event:resize
		     */
		    resize: function( newContainerSize, maintain ) {
		        var oldBounds = this.getBoundsNoRotate(),
		            newBounds = oldBounds,
		            widthDeltaFactor;

		        this.containerSize.x = newContainerSize.x;
		        this.containerSize.y = newContainerSize.y;

		        this._updateContainerInnerSize();

		        if ( maintain ) {
		            // TODO: widthDeltaFactor will always be 1; probably not what's intended
		            widthDeltaFactor = newContainerSize.x / this.containerSize.x;
		            newBounds.width  = oldBounds.width * widthDeltaFactor;
		            newBounds.height = newBounds.width / this.getAspectRatio();
		        }

		        if( this.viewer ){
		            /**
		             * Raised when a viewer resize operation is initiated (see {@link OpenSeadragon.Viewport#resize}).
		             * This event happens before the viewport bounds have been updated.
		             * See also {@link OpenSeadragon.Viewer#after-resize} which reflects
		             * the new viewport bounds following the resize action.
		             *
		             * @event resize
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {OpenSeadragon.Point} newContainerSize
		             * @property {Boolean} maintain
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent( 'resize', {
		                newContainerSize: newContainerSize,
		                maintain: maintain
		            });
		        }

		        var output = this.fitBounds( newBounds, true );

		        if( this.viewer ){
		            /**
		             * Raised after the viewer is resized (see {@link OpenSeadragon.Viewport#resize}).
		             * See also {@link OpenSeadragon.Viewer#resize} event which happens
		             * before the new bounds have been calculated and applied.
		             *
		             * @event after-resize
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised this event.
		             * @property {OpenSeadragon.Point} newContainerSize
		             * @property {Boolean} maintain
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent( 'after-resize', {
		                newContainerSize: newContainerSize,
		                maintain: maintain
		            });
		        }

		        return output;
		    },

		    // private
		    _updateContainerInnerSize: function() {
		        this._containerInnerSize = new $.Point(
		            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
		            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
		        );
		    },

		    /**
		     * Update the zoom, degrees, and center (X and Y) springs.
		     * @function
		     * @returns {Boolean} True if the viewport is still animating, false otherwise.
		     */
		    update: function() {
		        var _this = this;
		        this._adjustCenterSpringsForZoomPoint(function() {
		            _this.zoomSpring.update();
		        });
		        if(this.degreesSpring.isAtTargetValue()){
		            this.rotationPivot = null;
		        }
		        this.centerSpringX.update();
		        this.centerSpringY.update();

		        if(this.rotationPivot){
		            this._rotateAboutPivot(true);
		        }
		        else {
		            this.degreesSpring.update();
		        }


		        var changed = this.centerSpringX.current.value !== this._oldCenterX ||
		            this.centerSpringY.current.value !== this._oldCenterY ||
		            this.zoomSpring.current.value !== this._oldZoom ||
		            this.degreesSpring.current.value !== this._oldDegrees;


		        this._oldCenterX = this.centerSpringX.current.value;
		        this._oldCenterY = this.centerSpringY.current.value;
		        this._oldZoom    = this.zoomSpring.current.value;
		        this._oldDegrees = this.degreesSpring.current.value;

		        var isAnimating = changed ||
		                          !this.zoomSpring.isAtTargetValue() ||
		                          !this.centerSpringX.isAtTargetValue() ||
		                          !this.centerSpringY.isAtTargetValue() ||
		                          !this.degreesSpring.isAtTargetValue();

		        return isAnimating;
		    },

		    // private - pass true to use spring, or a number for degrees for immediate rotation
		    _rotateAboutPivot: function(degreesOrUseSpring){
		        var useSpring = degreesOrUseSpring === true;

		        var delta = this.rotationPivot.minus(this.getCenter());
		        this.centerSpringX.shiftBy(delta.x);
		        this.centerSpringY.shiftBy(delta.y);

		        if(useSpring){
		            this.degreesSpring.update();
		        } else {
		            this.degreesSpring.resetTo(degreesOrUseSpring);
		        }

		        var changeInDegrees = this.degreesSpring.current.value - this._oldDegrees;
		        var rdelta = delta.rotate(changeInDegrees * -1).times(-1);
		        this.centerSpringX.shiftBy(rdelta.x);
		        this.centerSpringY.shiftBy(rdelta.y);
		    },

		    // private
		    _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
		        if (this.zoomPoint) {
		            var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
		            zoomSpringHandler();
		            var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);

		            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
		            var deltaZoomPoints = this.deltaPointsFromPixels(
		                deltaZoomPixels, true);

		            this.centerSpringX.shiftBy(deltaZoomPoints.x);
		            this.centerSpringY.shiftBy(deltaZoomPoints.y);

		            if (this.zoomSpring.isAtTargetValue()) {
		                this.zoomPoint = null;
		            }
		        } else {
		            zoomSpringHandler();
		        }
		    },

		    /**
		     * Convert a delta (translation vector) from viewport coordinates to pixels
		     * coordinates. This method does not take rotation into account.
		     * Consider using deltaPixelsFromPoints if you need to account for rotation.
		     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
		        return deltaPoints.times(
		            this._containerInnerSize.x * this.getZoom(current)
		        );
		    },

		    /**
		     * Convert a delta (translation vector) from viewport coordinates to pixels
		     * coordinates.
		     * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    deltaPixelsFromPoints: function(deltaPoints, current) {
		        return this.deltaPixelsFromPointsNoRotate(
		            deltaPoints.rotate(this.getRotation(current)),
		            current);
		    },

		    /**
		     * Convert a delta (translation vector) from pixels coordinates to viewport
		     * coordinates. This method does not take rotation into account.
		     * Consider using deltaPointsFromPixels if you need to account for rotation.
		     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
		        return deltaPixels.divide(
		            this._containerInnerSize.x * this.getZoom(current)
		        );
		    },

		    /**
		     * Convert a delta (translation vector) from pixels coordinates to viewport
		     * coordinates.
		     * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    deltaPointsFromPixels: function(deltaPixels, current) {
		        return this.deltaPointsFromPixelsNoRotate(deltaPixels, current)
		            .rotate(-this.getRotation(current));
		    },

		    /**
		     * Convert viewport coordinates to pixels coordinates.
		     * This method does not take rotation into account.
		     * Consider using pixelFromPoint if you need to account for rotation.
		     * @param {OpenSeadragon.Point} point the viewport coordinates
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    pixelFromPointNoRotate: function(point, current) {
		        return this._pixelFromPointNoRotate(
		            point, this.getBoundsNoRotate(current));
		    },

		    /**
		     * Convert viewport coordinates to pixel coordinates.
		     * @param {OpenSeadragon.Point} point the viewport coordinates
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    pixelFromPoint: function(point, current) {
		        return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
		    },

		    // private
		    _pixelFromPointNoRotate: function(point, bounds) {
		        return point.minus(
		            bounds.getTopLeft()
		        ).times(
		            this._containerInnerSize.x / bounds.width
		        ).plus(
		            new $.Point(this._margins.left, this._margins.top)
		        );
		    },

		    // private
		    _pixelFromPoint: function(point, bounds) {
		        return this._pixelFromPointNoRotate(
		            point.rotate(this.getRotation(true), this.getCenter(true)),
		            bounds);
		    },

		    /**
		     * Convert pixel coordinates to viewport coordinates.
		     * This method does not take rotation into account.
		     * Consider using pointFromPixel if you need to account for rotation.
		     * @param {OpenSeadragon.Point} pixel Pixel coordinates
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    pointFromPixelNoRotate: function(pixel, current) {
		        var bounds = this.getBoundsNoRotate(current);
		        return pixel.minus(
		            new $.Point(this._margins.left, this._margins.top)
		        ).divide(
		            this._containerInnerSize.x / bounds.width
		        ).plus(
		            bounds.getTopLeft()
		        );
		    },

		    /**
		     * Convert pixel coordinates to viewport coordinates.
		     * @param {OpenSeadragon.Point} pixel Pixel coordinates
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * defaults to false (target location).
		     * @returns {OpenSeadragon.Point}
		     */
		    pointFromPixel: function(pixel, current) {
		        return this.pointFromPixelNoRotate(pixel, current).rotate(
		            -this.getRotation(current),
		            this.getCenter(current)
		        );
		    },

		    // private
		    _viewportToImageDelta: function( viewerX, viewerY ) {
		        var scale = this._contentBoundsNoRotate.width;
		        return new $.Point(
		            viewerX * this._contentSizeNoRotate.x / scale,
		            viewerY * this._contentSizeNoRotate.x / scale);
		    },

		    /**
		     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
		     * This method can be called either by passing X,Y coordinates or an
		     * OpenSeadragon.Point
		     * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
		     * @function
		     * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
		     * coordinate in viewport coordinate system.
		     * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
		     * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
		     */
		    viewportToImageCoordinates: function(viewerX, viewerY) {
		        if (viewerX instanceof $.Point) {
		            //they passed a point instead of individual components
		            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
		        }

		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.viewportToImageCoordinates] is not accurate ' +
		                        'with multi-image; use TiledImage.viewportToImageCoordinates instead.');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.viewportToImageCoordinates
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.viewportToImageCoordinates(viewerX, viewerY, true);
		            }
		        }

		        return this._viewportToImageDelta(
		            viewerX - this._contentBoundsNoRotate.x,
		            viewerY - this._contentBoundsNoRotate.y);
		    },

		    // private
		    _imageToViewportDelta: function( imageX, imageY ) {
		        var scale = this._contentBoundsNoRotate.width;
		        return new $.Point(
		            imageX / this._contentSizeNoRotate.x * scale,
		            imageY / this._contentSizeNoRotate.x * scale);
		    },

		    /**
		     * Translates from image coordinate system to OpenSeadragon viewer coordinate system
		     * This method can be called either by passing X,Y coordinates or an
		     * OpenSeadragon.Point
		     * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
		     * @function
		     * @param {(OpenSeadragon.Point | Number)} imageX the point or the
		     * X coordinate in image coordinate system.
		     * @param {Number} [imageY] Y coordinate in image coordinate system.
		     * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
		     */
		    imageToViewportCoordinates: function(imageX, imageY) {
		        if (imageX instanceof $.Point) {
		            //they passed a point instead of individual components
		            return this.imageToViewportCoordinates(imageX.x, imageX.y);
		        }

		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.imageToViewportCoordinates] is not accurate ' +
		                        'with multi-image; use TiledImage.imageToViewportCoordinates instead.');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.viewportToImageCoordinates
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.imageToViewportCoordinates(imageX, imageY, true);
		            }
		        }

		        var point = this._imageToViewportDelta(imageX, imageY);
		        point.x += this._contentBoundsNoRotate.x;
		        point.y += this._contentBoundsNoRotate.y;
		        return point;
		    },

		    /**
		     * Translates from a rectangle which describes a portion of the image in
		     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
		     * This method can be called either by passing X,Y,width,height or an
		     * OpenSeadragon.Rect
		     * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
		     * @function
		     * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
		     * coordinate of the top left corner of the rectangle in image coordinate system.
		     * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
		     * in image coordinate system.
		     * @param {Number} [pixelWidth] the width in pixel of the rectangle.
		     * @param {Number} [pixelHeight] the height in pixel of the rectangle.
		     * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
		     */
		    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
		        var rect = imageX;
		        if (!(rect instanceof $.Rect)) {
		            //they passed individual components instead of a rectangle
		            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
		        }

		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.imageToViewportRectangle] is not accurate ' +
		                       'with multi-image; use TiledImage.imageToViewportRectangle instead.');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.imageToViewportRectangle
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.imageToViewportRectangle(
		                    imageX, imageY, pixelWidth, pixelHeight, true);
		            }
		        }

		        var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
		        var coordB = this._imageToViewportDelta(rect.width, rect.height);
		        return new $.Rect(
		            coordA.x,
		            coordA.y,
		            coordB.x,
		            coordB.y,
		            rect.degrees
		        );
		    },

		    /**
		     * Translates from a rectangle which describes a portion of
		     * the viewport in point coordinates to image rectangle coordinates.
		     * This method can be called either by passing X,Y,width,height or an
		     * OpenSeadragon.Rect
		     * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
		     * @function
		     * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
		     * the X coordinate of the top left corner of the rectangle in viewport
		     * coordinate system.
		     * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
		     * in viewport coordinate system.
		     * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
		     * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
		     */
		    viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
		        var rect = viewerX;
		        if (!(rect instanceof $.Rect)) {
		            //they passed individual components instead of a rectangle
		            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
		        }

		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.viewportToImageRectangle] is not accurate ' +
		                        'with multi-image; use TiledImage.viewportToImageRectangle instead.');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.viewportToImageCoordinates
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.viewportToImageRectangle(
		                    viewerX, viewerY, pointWidth, pointHeight, true);
		            }
		        }

		        var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
		        var coordB = this._viewportToImageDelta(rect.width, rect.height);
		        return new $.Rect(
		            coordA.x,
		            coordA.y,
		            coordB.x,
		            coordB.y,
		            rect.degrees
		        );
		    },

		    /**
		     * Convert pixel coordinates relative to the viewer element to image
		     * coordinates.
		     * Note: not accurate with multi-image.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    viewerElementToImageCoordinates: function( pixel ) {
		        var point = this.pointFromPixel( pixel, true );
		        return this.viewportToImageCoordinates( point );
		    },

		    /**
		     * Convert pixel coordinates relative to the image to
		     * viewer element coordinates.
		     * Note: not accurate with multi-image.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    imageToViewerElementCoordinates: function( pixel ) {
		        var point = this.imageToViewportCoordinates( pixel );
		        return this.pixelFromPoint( point, true );
		    },

		    /**
		     * Convert pixel coordinates relative to the window to image coordinates.
		     * Note: not accurate with multi-image.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    windowToImageCoordinates: function(pixel) {
		        $.console.assert(this.viewer,
		            "[Viewport.windowToImageCoordinates] the viewport must have a viewer.");
		        var viewerCoordinates = pixel.minus(
		                $.getElementPosition(this.viewer.element));
		        return this.viewerElementToImageCoordinates(viewerCoordinates);
		    },

		    /**
		     * Convert image coordinates to pixel coordinates relative to the window.
		     * Note: not accurate with multi-image.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    imageToWindowCoordinates: function(pixel) {
		        $.console.assert(this.viewer,
		            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer.");
		        var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
		        return viewerCoordinates.plus(
		                $.getElementPosition(this.viewer.element));
		    },

		    /**
		     * Convert pixel coordinates relative to the viewer element to viewport
		     * coordinates.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    viewerElementToViewportCoordinates: function( pixel ) {
		        return this.pointFromPixel( pixel, true );
		    },

		    /**
		     * Convert viewport coordinates to pixel coordinates relative to the
		     * viewer element.
		     * @param {OpenSeadragon.Point} point
		     * @returns {OpenSeadragon.Point}
		     */
		    viewportToViewerElementCoordinates: function( point ) {
		        return this.pixelFromPoint( point, true );
		    },

		    /**
		     * Convert a rectangle in pixel coordinates relative to the viewer element
		     * to viewport coordinates.
		     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
		     * @returns {OpenSeadragon.Rect} the converted rectangle
		     */
		    viewerElementToViewportRectangle: function(rectangle) {
		        return $.Rect.fromSummits(
		            this.pointFromPixel(rectangle.getTopLeft(), true),
		            this.pointFromPixel(rectangle.getTopRight(), true),
		            this.pointFromPixel(rectangle.getBottomLeft(), true)
		        );
		    },

		    /**
		     * Convert a rectangle in viewport coordinates to pixel coordinates relative
		     * to the viewer element.
		     * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
		     * @returns {OpenSeadragon.Rect} the converted rectangle
		     */
		    viewportToViewerElementRectangle: function(rectangle) {
		        return $.Rect.fromSummits(
		            this.pixelFromPoint(rectangle.getTopLeft(), true),
		            this.pixelFromPoint(rectangle.getTopRight(), true),
		            this.pixelFromPoint(rectangle.getBottomLeft(), true)
		        );
		    },

		    /**
		     * Convert pixel coordinates relative to the window to viewport coordinates.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    windowToViewportCoordinates: function(pixel) {
		        $.console.assert(this.viewer,
		            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer.");
		        var viewerCoordinates = pixel.minus(
		                $.getElementPosition(this.viewer.element));
		        return this.viewerElementToViewportCoordinates(viewerCoordinates);
		    },

		    /**
		     * Convert viewport coordinates to pixel coordinates relative to the window.
		     * @param {OpenSeadragon.Point} point
		     * @returns {OpenSeadragon.Point}
		     */
		    viewportToWindowCoordinates: function(point) {
		        $.console.assert(this.viewer,
		            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer.");
		        var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
		        return viewerCoordinates.plus(
		                $.getElementPosition(this.viewer.element));
		    },

		    /**
		     * Convert a viewport zoom to an image zoom.
		     * Image zoom: ratio of the original image size to displayed image size.
		     * 1 means original image size, 0.5 half size...
		     * Viewport zoom: ratio of the displayed image's width to viewport's width.
		     * 1 means identical width, 2 means image's width is twice the viewport's width...
		     * Note: not accurate with multi-image.
		     * @function
		     * @param {Number} viewportZoom The viewport zoom
		     * target zoom.
		     * @returns {Number} imageZoom The image zoom
		     */
		    viewportToImageZoom: function(viewportZoom) {
		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.viewportToImageZoom] is not ' +
		                        'accurate with multi-image.');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.viewportToImageZoom
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.viewportToImageZoom(viewportZoom);
		            }
		        }

		        var imageWidth = this._contentSizeNoRotate.x;
		        var containerWidth = this._containerInnerSize.x;
		        var scale = this._contentBoundsNoRotate.width;
		        var viewportToImageZoomRatio = (containerWidth / imageWidth) * scale;
		        return viewportZoom * viewportToImageZoomRatio;
		    },

		    /**
		     * Convert an image zoom to a viewport zoom.
		     * Image zoom: ratio of the original image size to displayed image size.
		     * 1 means original image size, 0.5 half size...
		     * Viewport zoom: ratio of the displayed image's width to viewport's width.
		     * 1 means identical width, 2 means image's width is twice the viewport's width...
		     * Note: not accurate with multi-image; use [TiledImage.imageToViewportZoom] for the specific image of interest.
		     * @function
		     * @param {Number} imageZoom The image zoom
		     * target zoom.
		     * @returns {Number} viewportZoom The viewport zoom
		     */
		    imageToViewportZoom: function(imageZoom) {
		        if (this.viewer) {
		            var count = this.viewer.world.getItemCount();
		            if (count > 1) {
		                if (!this.silenceMultiImageWarnings) {
		                    $.console.error('[Viewport.imageToViewportZoom] is not accurate ' +
		                        'with multi-image. Instead, use [TiledImage.imageToViewportZoom] for the specific image of interest');
		                }
		            } else if (count === 1) {
		                // It is better to use TiledImage.imageToViewportZoom
		                // because this._contentBoundsNoRotate can not be relied on
		                // with clipping.
		                var item = this.viewer.world.getItemAt(0);
		                return item.imageToViewportZoom(imageZoom);
		            }
		        }

		        var imageWidth = this._contentSizeNoRotate.x;
		        var containerWidth = this._containerInnerSize.x;
		        var scale = this._contentBoundsNoRotate.width;
		        var viewportToImageZoomRatio = (imageWidth / containerWidth) / scale;
		        return imageZoom * viewportToImageZoomRatio;
		    },

		    /**
		     * Toggles flip state and demands a new drawing on navigator and viewer objects.
		     * @function
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    toggleFlip: function() {
		      this.setFlip(!this.getFlip());
		      return this;
		    },

		    /**
		     * Get flip state stored on viewport.
		     * @function
		     * @returns {Boolean} Flip state.
		     */
		    getFlip: function() {
		      return this.flipped;
		    },

		    /**
		     * Sets flip state according to the state input argument.
		     * @function
		     * @param {Boolean} state - Flip state to set.
		     * @returns {OpenSeadragon.Viewport} Chainable.
		     */
		    setFlip: function( state ) {
		      if ( this.flipped === state ) {
		        return this;
		      }

		      this.flipped = state;
		      if(this.viewer.navigator){
		        this.viewer.navigator.setFlip(this.getFlip());
		      }
		      this.viewer.forceRedraw();

		      /**
		       * Raised when flip state has been changed.
		       *
		       * @event flip
		       * @memberof OpenSeadragon.Viewer
		       * @type {object}
		       * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		       * @property {Number} flipped - The flip state after this change.
		       * @property {?Object} userData - Arbitrary subscriber-defined object.
		       */
		      this.viewer.raiseEvent('flip', {flipped: state});
		      return this;
		    },

		    /**
		     * Gets current max zoom pixel ratio
		     * @function
		     * @returns {Number} Max zoom pixel ratio
		     */
		    getMaxZoomPixelRatio: function() {
		        return this.maxZoomPixelRatio;
		    },

		    /**
		     * Sets max zoom pixel ratio
		     * @function
		     * @param {Number} ratio - Max zoom pixel ratio
		     * @param {Boolean} [applyConstraints=true] - Apply constraints after setting ratio;
		     * Takes effect only if current zoom is greater than set max zoom pixel ratio
		     * @param {Boolean} [immediately=false] - Whether to animate to new zoom
		     */
		    setMaxZoomPixelRatio: function(ratio, applyConstraints = true, immediately = false) {

		        $.console.assert(!isNaN(ratio), "[Viewport.setMaxZoomPixelRatio] ratio must be a number");

		        if (isNaN(ratio)) {
		            return;
		        }

		        this.maxZoomPixelRatio = ratio;

		        if (applyConstraints) {
		            if (this.getZoom() > this.getMaxZoom()) {
		                this.applyConstraints(immediately);
		            }
		        }
		    },

		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - TiledImage
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * You shouldn't have to create a TiledImage instance directly; get it asynchronously by
		 * using {@link OpenSeadragon.Viewer#open} or {@link OpenSeadragon.Viewer#addTiledImage} instead.
		 * @class TiledImage
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.EventSource
		 * @classdesc Handles rendering of tiles for an {@link OpenSeadragon.Viewer}.
		 * A new instance is created for each TileSource opened.
		 * @param {Object} options - Configuration for this TiledImage.
		 * @param {OpenSeadragon.TileSource} options.source - The TileSource that defines this TiledImage.
		 * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this TiledImage.
		 * @param {OpenSeadragon.TileCache} options.tileCache - The TileCache for this TiledImage to use.
		 * @param {OpenSeadragon.Drawer} options.drawer - The Drawer for this TiledImage to draw onto.
		 * @param {OpenSeadragon.ImageLoader} options.imageLoader - The ImageLoader for this TiledImage to use.
		 * @param {Number} [options.x=0] - Left position, in viewport coordinates.
		 * @param {Number} [options.y=0] - Top position, in viewport coordinates.
		 * @param {Number} [options.width=1] - Width, in viewport coordinates.
		 * @param {Number} [options.height] - Height, in viewport coordinates.
		 * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
		 * to fit the image into. If specified, x, y, width and height get ignored.
		 * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
		 * How to anchor the image in the bounds if options.fitBounds is set.
		 * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
		 * (portions of the image outside of this area will not be visible). Only works on
		 * browsers that support the HTML5 canvas.
		 * @param {Number} [options.springStiffness] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.animationTime] - See {@link OpenSeadragon.Options}.
		 * @param {Number} [options.minZoomImageRatio] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.wrapHorizontal] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.wrapVertical] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.immediateRender] - See {@link OpenSeadragon.Options}.
		 * @param {Number} [options.blendTime] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.alwaysBlend] - See {@link OpenSeadragon.Options}.
		 * @param {Number} [options.minPixelRatio] - See {@link OpenSeadragon.Options}.
		 * @param {Number} [options.smoothTileEdgesMinZoom] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.iOSDevice] - See {@link OpenSeadragon.Options}.
		 * @param {Number} [options.opacity=1] - Set to draw at proportional opacity. If zero, images will not draw.
		 * @param {Boolean} [options.preload=false] - Set true to load even when the image is hidden by zero opacity.
		 * @param {String} [options.compositeOperation] - How the image is composited onto other images;
		 * see compositeOperation in {@link OpenSeadragon.Options} for possible values.
		 * @param {Boolean} [options.debugMode] - See {@link OpenSeadragon.Options}.
		 * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
		 * @param {String|Boolean} [options.crossOriginPolicy] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.ajaxWithCredentials] - See {@link OpenSeadragon.Options}.
		 * @param {Boolean} [options.loadTilesWithAjax]
		 *      Whether to load tile data using AJAX requests.
		 *      Defaults to the setting in {@link OpenSeadragon.Options}.
		 * @param {Object} [options.ajaxHeaders={}]
		 *      A set of headers to include when making tile AJAX requests.
		 */
		$.TiledImage = function( options ) {
		    this._initialized = false;
		    /**
		     * The {@link OpenSeadragon.TileSource} that defines this TiledImage.
		     * @member {OpenSeadragon.TileSource} source
		     * @memberof OpenSeadragon.TiledImage#
		     */
		    $.console.assert( options.tileCache, "[TiledImage] options.tileCache is required" );
		    $.console.assert( options.drawer, "[TiledImage] options.drawer is required" );
		    $.console.assert( options.viewer, "[TiledImage] options.viewer is required" );
		    $.console.assert( options.imageLoader, "[TiledImage] options.imageLoader is required" );
		    $.console.assert( options.source, "[TiledImage] options.source is required" );
		    $.console.assert(!options.clip || options.clip instanceof $.Rect,
		        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present");

		    $.EventSource.call( this );

		    this._tileCache = options.tileCache;
		    delete options.tileCache;

		    this._drawer = options.drawer;
		    delete options.drawer;

		    this._imageLoader = options.imageLoader;
		    delete options.imageLoader;

		    if (options.clip instanceof $.Rect) {
		        this._clip = options.clip.clone();
		    }

		    delete options.clip;

		    var x = options.x || 0;
		    delete options.x;
		    var y = options.y || 0;
		    delete options.y;

		    // Ratio of zoomable image height to width.
		    this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
		    this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;

		    var scale = 1;
		    if ( options.width ) {
		        scale = options.width;
		        delete options.width;

		        if ( options.height ) {
		            $.console.error( "specifying both width and height to a tiledImage is not supported" );
		            delete options.height;
		        }
		    } else if ( options.height ) {
		        scale = options.height / this.normHeight;
		        delete options.height;
		    }

		    var fitBounds = options.fitBounds;
		    delete options.fitBounds;
		    var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
		    delete options.fitBoundsPlacement;

		    var degrees = options.degrees || 0;
		    delete options.degrees;

		    var ajaxHeaders = options.ajaxHeaders;
		    delete options.ajaxHeaders;

		    $.extend( true, this, {

		        //internal state properties
		        viewer:         null,
		        tilesMatrix:    {},    // A '3d' dictionary [level][x][y] --> Tile.
		        coverage:       {},    // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
		        loadingCoverage: {},   // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
		        lastDrawn:      [],    // An unordered list of Tiles drawn last frame.
		        lastResetTime:  0,     // Last time for which the tiledImage was reset.
		        _needsDraw:     true,  // Does the tiledImage need to be drawn again?
		        _needsUpdate:   true,  // Does the tiledImage need to update the viewport again?
		        _hasOpaqueTile: false,  // Do we have even one fully opaque tile?
		        _tilesLoading:  0,     // The number of pending tile requests.
		        _tilesToDraw:   [],    // info about the tiles currently in the viewport, two deep: array[level][tile]
		        _lastDrawn:     [],    // array of tiles that were last fetched by the drawer
		        _isBlending:    false, // Are any tiles still being blended?
		        _wasBlending:   false, // Were any tiles blending before the last draw?
		        _isTainted:     false, // Has a Tile been found with tainted data?
		        //configurable settings
		        springStiffness:                   $.DEFAULT_SETTINGS.springStiffness,
		        animationTime:                     $.DEFAULT_SETTINGS.animationTime,
		        minZoomImageRatio:                 $.DEFAULT_SETTINGS.minZoomImageRatio,
		        wrapHorizontal:                    $.DEFAULT_SETTINGS.wrapHorizontal,
		        wrapVertical:                      $.DEFAULT_SETTINGS.wrapVertical,
		        immediateRender:                   $.DEFAULT_SETTINGS.immediateRender,
		        blendTime:                         $.DEFAULT_SETTINGS.blendTime,
		        alwaysBlend:                       $.DEFAULT_SETTINGS.alwaysBlend,
		        minPixelRatio:                     $.DEFAULT_SETTINGS.minPixelRatio,
		        smoothTileEdgesMinZoom:            $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
		        iOSDevice:                         $.DEFAULT_SETTINGS.iOSDevice,
		        debugMode:                         $.DEFAULT_SETTINGS.debugMode,
		        crossOriginPolicy:                 $.DEFAULT_SETTINGS.crossOriginPolicy,
		        ajaxWithCredentials:               $.DEFAULT_SETTINGS.ajaxWithCredentials,
		        placeholderFillStyle:              $.DEFAULT_SETTINGS.placeholderFillStyle,
		        opacity:                           $.DEFAULT_SETTINGS.opacity,
		        preload:                           $.DEFAULT_SETTINGS.preload,
		        compositeOperation:                $.DEFAULT_SETTINGS.compositeOperation,
		        subPixelRoundingForTransparency:   $.DEFAULT_SETTINGS.subPixelRoundingForTransparency,
		        maxTilesPerFrame:                  $.DEFAULT_SETTINGS.maxTilesPerFrame
		    }, options );

		    this._preload = this.preload;
		    delete this.preload;

		    this._fullyLoaded = false;

		    this._xSpring = new $.Spring({
		        initial: x,
		        springStiffness: this.springStiffness,
		        animationTime: this.animationTime
		    });

		    this._ySpring = new $.Spring({
		        initial: y,
		        springStiffness: this.springStiffness,
		        animationTime: this.animationTime
		    });

		    this._scaleSpring = new $.Spring({
		        initial: scale,
		        springStiffness: this.springStiffness,
		        animationTime: this.animationTime
		    });

		    this._degreesSpring = new $.Spring({
		        initial: degrees,
		        springStiffness: this.springStiffness,
		        animationTime: this.animationTime
		    });

		    this._updateForScale();

		    if (fitBounds) {
		        this.fitBounds(fitBounds, fitBoundsPlacement, true);
		    }

		    this._ownAjaxHeaders = {};
		    this.setAjaxHeaders(ajaxHeaders, false);
		    this._initialized = true;
		};

		$.extend($.TiledImage.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.TiledImage.prototype */{
		    /**
		     * @returns {Boolean} Whether the TiledImage needs to be drawn.
		     */
		    needsDraw: function() {
		        return this._needsDraw;
		    },

		    /**
		     * Mark the tiled image as needing to be (re)drawn
		     */
		    redraw: function() {
		        this._needsDraw = true;
		    },

		    /**
		     * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
		     */
		    getFullyLoaded: function() {
		        return this._fullyLoaded;
		    },

		    // private
		    _setFullyLoaded: function(flag) {
		        if (flag === this._fullyLoaded) {
		            return;
		        }

		        this._fullyLoaded = flag;

		        /**
		         * Fired when the TiledImage's "fully loaded" flag (whether all tiles necessary for this TiledImage
		         * to draw at the current view have been loaded) changes.
		         *
		         * @event fully-loaded-change
		         * @memberof OpenSeadragon.TiledImage
		         * @type {object}
		         * @property {Boolean} fullyLoaded - The new "fully loaded" value.
		         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the TiledImage which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent('fully-loaded-change', {
		            fullyLoaded: this._fullyLoaded
		        });
		    },

		    /**
		     * Clears all tiles and triggers an update on the next call to
		     * {@link OpenSeadragon.TiledImage#update}.
		     */
		    reset: function() {
		        this._tileCache.clearTilesFor(this);
		        this.lastResetTime = $.now();
		        this._needsDraw = true;
		    },

		    /**
		     * Updates the TiledImage's bounds, animating if needed. Based on the new
		     * bounds, updates the levels and tiles to be drawn into the viewport.
		     * @param viewportChanged Whether the viewport changed meaning tiles need to be updated.
		     * @returns {Boolean} Whether the TiledImage needs to be drawn.
		     */
		    update: function(viewportChanged) {
		        let xUpdated = this._xSpring.update();
		        let yUpdated = this._ySpring.update();
		        let scaleUpdated = this._scaleSpring.update();
		        let degreesUpdated = this._degreesSpring.update();

		        let updated = (xUpdated || yUpdated || scaleUpdated || degreesUpdated || this._needsUpdate);

		        if (updated || viewportChanged || !this._fullyLoaded){
		            let fullyLoadedFlag = this._updateLevelsForViewport();
		            this._setFullyLoaded(fullyLoadedFlag);
		        }

		        this._needsUpdate = false;

		        if (updated) {
		            this._updateForScale();
		            this._raiseBoundsChange();
		            this._needsDraw = true;
		            return true;
		        }

		        return false;
		    },

		    /**
		     * Mark this TiledImage as having been drawn, so that it will only be drawn
		     * again if something changes about the image. If the image is still blending,
		     * this will have no effect.
		     * @returns {Boolean} whether the item still needs to be drawn due to blending
		     */
		    setDrawn: function(){
		        this._needsDraw = this._isBlending || this._wasBlending;
		        return this._needsDraw;
		    },

		    /**
		     * Set the internal _isTainted flag for this TiledImage. Lazy loaded - not
		     * checked each time a Tile is loaded, but can be set if a consumer of the
		     * tiles (e.g. a Drawer) discovers a Tile to have tainted data so that further
		     * checks are not needed and alternative rendering strategies can be used.
		     * @private
		     */
		    setTainted(isTainted){
		        this._isTainted = isTainted;
		    },

		    /**
		     * @private
		     * @returns {Boolean} whether the TiledImage has been marked as tainted
		     */
		    isTainted(){
		        return this._isTainted;
		    },

		    /**
		     * Destroy the TiledImage (unload current loaded tiles).
		     */
		    destroy: function() {
		        this.reset();

		        if (this.source.destroy) {
		            this.source.destroy(this.viewer);
		        }
		    },

		    /**
		     * Get this TiledImage's bounds in viewport coordinates.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * false for target location.
		     * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
		     */
		    getBounds: function(current) {
		        return this.getBoundsNoRotate(current)
		            .rotate(this.getRotation(current), this._getRotationPoint(current));
		    },

		    /**
		     * Get this TiledImage's bounds in viewport coordinates without taking
		     * rotation into account.
		     * @param {Boolean} [current=false] - Pass true for the current location;
		     * false for target location.
		     * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
		     */
		    getBoundsNoRotate: function(current) {
		        return current ?
		            new $.Rect(
		                this._xSpring.current.value,
		                this._ySpring.current.value,
		                this._worldWidthCurrent,
		                this._worldHeightCurrent) :
		            new $.Rect(
		                this._xSpring.target.value,
		                this._ySpring.target.value,
		                this._worldWidthTarget,
		                this._worldHeightTarget);
		    },

		    // deprecated
		    getWorldBounds: function() {
		        $.console.error('[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead');
		        return this.getBounds();
		    },

		    /**
		     * Get the bounds of the displayed part of the tiled image.
		     * @param {Boolean} [current=false] Pass true for the current location,
		     * false for the target location.
		     * @returns {$.Rect} The clipped bounds in viewport coordinates.
		     */
		    getClippedBounds: function(current) {
		        var bounds = this.getBoundsNoRotate(current);
		        if (this._clip) {
		            var worldWidth = current ?
		                this._worldWidthCurrent : this._worldWidthTarget;
		            var ratio = worldWidth / this.source.dimensions.x;
		            var clip = this._clip.times(ratio);
		            bounds = new $.Rect(
		                bounds.x + clip.x,
		                bounds.y + clip.y,
		                clip.width,
		                clip.height);
		        }
		        return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
		    },

		    /**
		     * @function
		     * @param {Number} level
		     * @param {Number} x
		     * @param {Number} y
		     * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
		     */
		    getTileBounds: function( level, x, y ) {
		        var numTiles = this.source.getNumTiles(level);
		        var xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
		        var yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
		        var bounds = this.source.getTileBounds(level, xMod, yMod);
		        if (this.getFlip()) {
		            bounds.x = Math.max(0, 1 - bounds.x - bounds.width);
		        }
		        bounds.x += (x - xMod) / numTiles.x;
		        bounds.y += (this._worldHeightCurrent / this._worldWidthCurrent) * ((y - yMod) / numTiles.y);
		        return bounds;
		    },

		    /**
		     * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
		     */
		    getContentSize: function() {
		        return new $.Point(this.source.dimensions.x, this.source.dimensions.y);
		    },

		    /**
		     * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
		     */
		    getSizeInWindowCoordinates: function() {
		        var topLeft = this.imageToWindowCoordinates(new $.Point(0, 0));
		        var bottomRight = this.imageToWindowCoordinates(this.getContentSize());
		        return new $.Point(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
		    },

		    // private
		    _viewportToImageDelta: function( viewerX, viewerY, current ) {
		        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
		        return new $.Point(viewerX * (this.source.dimensions.x / scale),
		            viewerY * ((this.source.dimensions.y * this.contentAspectX) / scale));
		    },

		    /**
		     * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
		     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
		     * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
		     * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
		     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
		     * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
		     */
		    viewportToImageCoordinates: function(viewerX, viewerY, current) {
		        var point;
		        if (viewerX instanceof $.Point) {
		            //they passed a point instead of individual components
		            current = viewerY;
		            point = viewerX;
		        } else {
		            point = new $.Point(viewerX, viewerY);
		        }

		        point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
		        return current ?
		            this._viewportToImageDelta(
		                point.x - this._xSpring.current.value,
		                point.y - this._ySpring.current.value) :
		            this._viewportToImageDelta(
		                point.x - this._xSpring.target.value,
		                point.y - this._ySpring.target.value);
		    },

		    // private
		    _imageToViewportDelta: function( imageX, imageY, current ) {
		        var scale = (current ? this._scaleSpring.current.value : this._scaleSpring.target.value);
		        return new $.Point((imageX / this.source.dimensions.x) * scale,
		            (imageY / this.source.dimensions.y / this.contentAspectX) * scale);
		    },

		    /**
		     * Translates from image coordinate system to OpenSeadragon viewer coordinate system
		     * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
		     * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
		     * @param {Number} [imageY] - The Y coordinate in image coordinate system.
		     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
		     * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
		     */
		    imageToViewportCoordinates: function(imageX, imageY, current) {
		        if (imageX instanceof $.Point) {
		            //they passed a point instead of individual components
		            current = imageY;
		            imageY = imageX.y;
		            imageX = imageX.x;
		        }

		        var point = this._imageToViewportDelta(imageX, imageY, current);
		        if (current) {
		            point.x += this._xSpring.current.value;
		            point.y += this._ySpring.current.value;
		        } else {
		            point.x += this._xSpring.target.value;
		            point.y += this._ySpring.target.value;
		        }

		        return point.rotate(this.getRotation(current), this._getRotationPoint(current));
		    },

		    /**
		     * Translates from a rectangle which describes a portion of the image in
		     * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
		     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
		     * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
		     * @param {Number} [imageY] - The top coordinate in image coordinate system.
		     * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
		     * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
		     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
		     * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
		     */
		    imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
		        var rect = imageX;
		        if (rect instanceof $.Rect) {
		            //they passed a rect instead of individual components
		            current = imageY;
		        } else {
		            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
		        }

		        var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
		        var coordB = this._imageToViewportDelta(rect.width, rect.height, current);

		        return new $.Rect(
		            coordA.x,
		            coordA.y,
		            coordB.x,
		            coordB.y,
		            rect.degrees + this.getRotation(current)
		        );
		    },

		    /**
		     * Translates from a rectangle which describes a portion of
		     * the viewport in point coordinates to image rectangle coordinates.
		     * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
		     * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
		     * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
		     * @param {Number} [pointWidth] - The width in viewport coordinate system.
		     * @param {Number} [pointHeight] - The height in viewport coordinate system.
		     * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
		     * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
		     */
		    viewportToImageRectangle: function( viewerX, viewerY, pointWidth, pointHeight, current ) {
		        var rect = viewerX;
		        if (viewerX instanceof $.Rect) {
		            //they passed a rect instead of individual components
		            current = viewerY;
		        } else {
		            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
		        }

		        var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
		        var coordB = this._viewportToImageDelta(rect.width, rect.height, current);

		        return new $.Rect(
		            coordA.x,
		            coordA.y,
		            coordB.x,
		            coordB.y,
		            rect.degrees - this.getRotation(current)
		        );
		    },

		    /**
		     * Convert pixel coordinates relative to the viewer element to image
		     * coordinates.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    viewerElementToImageCoordinates: function( pixel ) {
		        var point = this.viewport.pointFromPixel( pixel, true );
		        return this.viewportToImageCoordinates( point );
		    },

		    /**
		     * Convert pixel coordinates relative to the image to
		     * viewer element coordinates.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    imageToViewerElementCoordinates: function( pixel ) {
		        var point = this.imageToViewportCoordinates( pixel );
		        return this.viewport.pixelFromPoint( point, true );
		    },

		    /**
		     * Convert pixel coordinates relative to the window to image coordinates.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    windowToImageCoordinates: function( pixel ) {
		        var viewerCoordinates = pixel.minus(
		            OpenSeadragon.getElementPosition( this.viewer.element ));
		        return this.viewerElementToImageCoordinates( viewerCoordinates );
		    },

		    /**
		     * Convert image coordinates to pixel coordinates relative to the window.
		     * @param {OpenSeadragon.Point} pixel
		     * @returns {OpenSeadragon.Point}
		     */
		    imageToWindowCoordinates: function( pixel ) {
		        var viewerCoordinates = this.imageToViewerElementCoordinates( pixel );
		        return viewerCoordinates.plus(
		            OpenSeadragon.getElementPosition( this.viewer.element ));
		    },

		    // private
		    // Convert rectangle in viewport coordinates to this tiled image point
		    // coordinates (x in [0, 1] and y in [0, aspectRatio])
		    _viewportToTiledImageRectangle: function(rect) {
		        var scale = this._scaleSpring.current.value;
		        rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
		        return new $.Rect(
		            (rect.x - this._xSpring.current.value) / scale,
		            (rect.y - this._ySpring.current.value) / scale,
		            rect.width / scale,
		            rect.height / scale,
		            rect.degrees);
		    },

		    /**
		     * Convert a viewport zoom to an image zoom.
		     * Image zoom: ratio of the original image size to displayed image size.
		     * 1 means original image size, 0.5 half size...
		     * Viewport zoom: ratio of the displayed image's width to viewport's width.
		     * 1 means identical width, 2 means image's width is twice the viewport's width...
		     * @function
		     * @param {Number} viewportZoom The viewport zoom
		     * @returns {Number} imageZoom The image zoom
		     */
		    viewportToImageZoom: function( viewportZoom ) {
		        var ratio = this._scaleSpring.current.value *
		            this.viewport._containerInnerSize.x / this.source.dimensions.x;
		        return ratio * viewportZoom;
		    },

		    /**
		     * Convert an image zoom to a viewport zoom.
		     * Image zoom: ratio of the original image size to displayed image size.
		     * 1 means original image size, 0.5 half size...
		     * Viewport zoom: ratio of the displayed image's width to viewport's width.
		     * 1 means identical width, 2 means image's width is twice the viewport's width...
		     * Note: not accurate with multi-image.
		     * @function
		     * @param {Number} imageZoom The image zoom
		     * @returns {Number} viewportZoom The viewport zoom
		     */
		    imageToViewportZoom: function( imageZoom ) {
		        var ratio = this._scaleSpring.current.value *
		            this.viewport._containerInnerSize.x / this.source.dimensions.x;
		        return imageZoom / ratio;
		    },

		    /**
		     * Sets the TiledImage's position in the world.
		     * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
		     * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    setPosition: function(position, immediately) {
		        var sameTarget = (this._xSpring.target.value === position.x &&
		            this._ySpring.target.value === position.y);

		        if (immediately) {
		            if (sameTarget && this._xSpring.current.value === position.x &&
		                this._ySpring.current.value === position.y) {
		                return;
		            }

		            this._xSpring.resetTo(position.x);
		            this._ySpring.resetTo(position.y);
		            this._needsDraw = true;
		            this._needsUpdate = true;
		        } else {
		            if (sameTarget) {
		                return;
		            }

		            this._xSpring.springTo(position.x);
		            this._ySpring.springTo(position.y);
		            this._needsDraw = true;
		            this._needsUpdate = true;
		        }

		        if (!sameTarget) {
		            this._raiseBoundsChange();
		        }
		    },

		    /**
		     * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
		     * @param {Number} width - The new width, in viewport coordinates.
		     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    setWidth: function(width, immediately) {
		        this._setScale(width, immediately);
		    },

		    /**
		     * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
		     * @param {Number} height - The new height, in viewport coordinates.
		     * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    setHeight: function(height, immediately) {
		        this._setScale(height / this.normHeight, immediately);
		    },

		    /**
		     * Sets an array of polygons to crop the TiledImage during draw tiles.
		     * The render function will use the default non-zero winding rule.
		     * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
		     * Example format: [
		     *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
		     *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
		     *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
		     * ]
		     */
		    setCroppingPolygons: function( polygons ) {
		        var isXYObject = function(obj) {
		            return obj instanceof $.Point || (typeof obj.x === 'number' && typeof obj.y === 'number');
		        };

		        var objectToSimpleXYObject = function(objs) {
		            return objs.map(function(obj) {
		                try {
		                    if (isXYObject(obj)) {
		                        return { x: obj.x, y: obj.y };
		                    } else {
		                        throw new Error();
		                    }
		                } catch(e) {
		                    throw new Error('A Provided cropping polygon point is not supported');
		                }
		            });
		        };

		        try {
		            if (!$.isArray(polygons)) {
		                throw new Error('Provided cropping polygon is not an array');
		            }
		            this._croppingPolygons = polygons.map(function(polygon){
		                return objectToSimpleXYObject(polygon);
		            });
		            this._needsDraw = true;
		        } catch (e) {
		            $.console.error('[TiledImage.setCroppingPolygons] Cropping polygon format not supported');
		            $.console.error(e);
		            this.resetCroppingPolygons();
		        }
		    },

		    /**
		     * Resets the cropping polygons, thus next render will remove all cropping
		     * polygon effects.
		     */
		    resetCroppingPolygons: function() {
		        this._croppingPolygons = null;
		        this._needsDraw = true;
		    },

		    /**
		     * Positions and scales the TiledImage to fit in the specified bounds.
		     * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
		     * twice
		     * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
		     * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
		     * How to anchor the image in the bounds.
		     * @param {Boolean} [immediately=false] Whether to animate to the new size
		     * or snap immediately.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    fitBounds: function(bounds, anchor, immediately) {
		        anchor = anchor || $.Placement.CENTER;
		        var anchorProperties = $.Placement.properties[anchor];
		        var aspectRatio = this.contentAspectX;
		        var xOffset = 0;
		        var yOffset = 0;
		        var displayedWidthRatio = 1;
		        var displayedHeightRatio = 1;
		        if (this._clip) {
		            aspectRatio = this._clip.getAspectRatio();
		            displayedWidthRatio = this._clip.width / this.source.dimensions.x;
		            displayedHeightRatio = this._clip.height / this.source.dimensions.y;
		            if (bounds.getAspectRatio() > aspectRatio) {
		                xOffset = this._clip.x / this._clip.height * bounds.height;
		                yOffset = this._clip.y / this._clip.height * bounds.height;
		            } else {
		                xOffset = this._clip.x / this._clip.width * bounds.width;
		                yOffset = this._clip.y / this._clip.width * bounds.width;
		            }
		        }

		        if (bounds.getAspectRatio() > aspectRatio) {
		            // We will have margins on the X axis
		            var height = bounds.height / displayedHeightRatio;
		            var marginLeft = 0;
		            if (anchorProperties.isHorizontallyCentered) {
		                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
		            } else if (anchorProperties.isRight) {
		                marginLeft = bounds.width - bounds.height * aspectRatio;
		            }
		            this.setPosition(
		                new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
		                immediately);
		            this.setHeight(height, immediately);
		        } else {
		            // We will have margins on the Y axis
		            var width = bounds.width / displayedWidthRatio;
		            var marginTop = 0;
		            if (anchorProperties.isVerticallyCentered) {
		                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
		            } else if (anchorProperties.isBottom) {
		                marginTop = bounds.height - bounds.width / aspectRatio;
		            }
		            this.setPosition(
		                new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
		                immediately);
		            this.setWidth(width, immediately);
		        }
		    },

		    /**
		     * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
		     * in image pixels, or null if none.
		     */
		    getClip: function() {
		        if (this._clip) {
		            return this._clip.clone();
		        }

		        return null;
		    },

		    /**
		     * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
		     * (portions of the image outside of this area will not be visible). Only works on
		     * browsers that support the HTML5 canvas.
		     * @fires OpenSeadragon.TiledImage.event:clip-change
		     */
		    setClip: function(newClip) {
		        $.console.assert(!newClip || newClip instanceof $.Rect,
		            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null");

		        if (newClip instanceof $.Rect) {
		            this._clip = newClip.clone();
		        } else {
		            this._clip = null;
		        }

		        this._needsUpdate = true;
		        this._needsDraw = true;
		        /**
		         * Raised when the TiledImage's clip is changed.
		         * @event clip-change
		         * @memberOf OpenSeadragon.TiledImage
		         * @type {object}
		         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
		         * TiledImage which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent('clip-change');
		    },

		    /**
		     * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
		     */
		    getFlip: function() {
		        return this.flipped;
		    },

		    /**
		     * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    setFlip: function(flip) {
		        this.flipped = flip;
		    },

		    get flipped(){
		        return this._flipped;
		    },
		    set flipped(flipped){
		        let changed = this._flipped !== !!flipped;
		        this._flipped = !!flipped;
		        if(changed){
		            this.update(true);
		            this._needsDraw = true;
		            this._raiseBoundsChange();
		        }
		    },

		    get wrapHorizontal(){
		        return this._wrapHorizontal;
		    },
		    set wrapHorizontal(wrap){
		        let changed = this._wrapHorizontal !== !!wrap;
		        this._wrapHorizontal = !!wrap;
		        if(this._initialized && changed){
		            this.update(true);
		            this._needsDraw = true;
		            // this._raiseBoundsChange();
		        }
		    },

		    get wrapVertical(){
		        return this._wrapVertical;
		    },
		    set wrapVertical(wrap){
		        let changed = this._wrapVertical !== !!wrap;
		        this._wrapVertical = !!wrap;
		        if(this._initialized && changed){
		            this.update(true);
		            this._needsDraw = true;
		            // this._raiseBoundsChange();
		        }
		    },

		    get debugMode(){
		        return this._debugMode;
		    },
		    set debugMode(debug){
		        this._debugMode = !!debug;
		        this._needsDraw = true;
		    },

		    /**
		     * @returns {Number} The TiledImage's current opacity.
		     */
		    getOpacity: function() {
		        return this.opacity;
		    },

		    /**
		     * @param {Number} opacity Opacity the tiled image should be drawn at.
		     * @fires OpenSeadragon.TiledImage.event:opacity-change
		     */
		    setOpacity: function(opacity) {
		        this.opacity = opacity;
		    },

		    get opacity() {
		        return this._opacity;
		    },

		    set opacity(opacity) {
		        if (opacity === this.opacity) {
		            return;
		        }

		        this._opacity = opacity;
		        this._needsDraw = true;
		        /**
		         * Raised when the TiledImage's opacity is changed.
		         * @event opacity-change
		         * @memberOf OpenSeadragon.TiledImage
		         * @type {object}
		         * @property {Number} opacity - The new opacity value.
		         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
		         * TiledImage which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent('opacity-change', {
		            opacity: this.opacity
		        });
		    },

		    /**
		     * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
		     */
		    getPreload: function() {
		        return this._preload;
		    },

		    /**
		     * Set true to load even when hidden. Set false to block loading when hidden.
		     */
		    setPreload: function(preload) {
		        this._preload = !!preload;
		        this._needsDraw = true;
		    },

		    /**
		     * Get the rotation of this tiled image in degrees.
		     * @param {Boolean} [current=false] True for current rotation, false for target.
		     * @returns {Number} the rotation of this tiled image in degrees.
		     */
		    getRotation: function(current) {
		        return current ?
		            this._degreesSpring.current.value :
		            this._degreesSpring.target.value;
		    },

		    /**
		     * Set the current rotation of this tiled image in degrees.
		     * @param {Number} degrees the rotation in degrees.
		     * @param {Boolean} [immediately=false] Whether to animate to the new angle
		     * or rotate immediately.
		     * @fires OpenSeadragon.TiledImage.event:bounds-change
		     */
		    setRotation: function(degrees, immediately) {
		        if (this._degreesSpring.target.value === degrees &&
		            this._degreesSpring.isAtTargetValue()) {
		            return;
		        }
		        if (immediately) {
		            this._degreesSpring.resetTo(degrees);
		        } else {
		            this._degreesSpring.springTo(degrees);
		        }
		        this._needsDraw = true;
		        this._needsUpdate = true;
		        this._raiseBoundsChange();
		    },

		    /**
		     * Get the region of this tiled image that falls within the viewport.
		     * @returns {OpenSeadragon.Rect} the region of this tiled image that falls within the viewport.
		     * Returns false for images with opacity==0 unless preload==true
		     */
		    getDrawArea: function(){

		        if( this._opacity === 0 && !this._preload){
		            return false;
		        }

		        var drawArea = this._viewportToTiledImageRectangle(
		            this.viewport.getBoundsWithMargins(true));

		        if (!this.wrapHorizontal && !this.wrapVertical) {
		            var tiledImageBounds = this._viewportToTiledImageRectangle(
		                this.getClippedBounds(true));
		            drawArea = drawArea.intersection(tiledImageBounds);
		        }

		        return drawArea;
		    },

		    /**
		     *
		     * @returns {Array} Array of Tiles that make up the current view
		     */
		    getTilesToDraw: function(){
		        // start with all the tiles added to this._tilesToDraw during the most recent
		        // call to this.update. Then update them so the blending and coverage properties
		        // are updated based on the current time
		        let tileArray = this._tilesToDraw.flat();

		        // update all tiles, which can change the coverage provided
		        this._updateTilesInViewport(tileArray);

		        // _tilesToDraw might have been updated by the update; refresh it
		        tileArray = this._tilesToDraw.flat();

		        // mark the tiles as being drawn, so that they won't be discarded from
		        // the tileCache
		        tileArray.forEach(tileInfo => {
		            tileInfo.tile.beingDrawn = true;
		        });
		        this._lastDrawn = tileArray;
		        return tileArray;
		    },

		    /**
		     * Get the point around which this tiled image is rotated
		     * @private
		     * @param {Boolean} current True for current rotation point, false for target.
		     * @returns {OpenSeadragon.Point}
		     */
		    _getRotationPoint: function(current) {
		        return this.getBoundsNoRotate(current).getCenter();
		    },

		    get compositeOperation(){
		        return this._compositeOperation;
		    },

		    set compositeOperation(compositeOperation){

		        if (compositeOperation === this._compositeOperation) {
		            return;
		        }
		        this._compositeOperation = compositeOperation;
		        this._needsDraw = true;
		        /**
		         * Raised when the TiledImage's opacity is changed.
		         * @event composite-operation-change
		         * @memberOf OpenSeadragon.TiledImage
		         * @type {object}
		         * @property {String} compositeOperation - The new compositeOperation value.
		         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
		         * TiledImage which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent('composite-operation-change', {
		            compositeOperation: this._compositeOperation
		        });

		    },

		    /**
		     * @returns {String} The TiledImage's current compositeOperation.
		     */
		    getCompositeOperation: function() {
		        return this._compositeOperation;
		    },

		    /**
		     * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
		     * @fires OpenSeadragon.TiledImage.event:composite-operation-change
		     */
		    setCompositeOperation: function(compositeOperation) {
		        this.compositeOperation = compositeOperation; //invokes setter
		    },

		    /**
		     * Update headers to include when making AJAX requests.
		     *
		     * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
		     * the updated headers are propagated to all tiles and queued image loader jobs.
		     *
		     * Note that the rules for merging headers still apply, i.e. headers returned by
		     * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
		     * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
		     *
		     * @function
		     * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
		     * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
		     */
		    setAjaxHeaders: function(ajaxHeaders, propagate) {
		        if (ajaxHeaders === null) {
		            ajaxHeaders = {};
		        }
		        if (!$.isPlainObject(ajaxHeaders)) {
		            console.error('[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object');
		            return;
		        }

		        this._ownAjaxHeaders = ajaxHeaders;
		        this._updateAjaxHeaders(propagate);
		    },

		    /**
		     * Update headers to include when making AJAX requests.
		     *
		     * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
		     * except that the headers for this tiled image do not change. This is especially useful
		     * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
		     * to existing tiles.
		     *
		     * @private
		     * @function
		     * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
		     */
		    _updateAjaxHeaders: function(propagate) {
		        if (propagate === undefined) {
		            propagate = true;
		        }

		        // merge with viewer's headers
		        if ($.isPlainObject(this.viewer.ajaxHeaders)) {
		            this.ajaxHeaders = $.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders);
		        } else {
		            this.ajaxHeaders = this._ownAjaxHeaders;
		        }

		        // propagate header updates to all tiles and queued image loader jobs
		        if (propagate) {
		            var numTiles, xMod, yMod, tile;

		            for (var level in this.tilesMatrix) {
		                numTiles = this.source.getNumTiles(level);

		                for (var x in this.tilesMatrix[level]) {
		                    xMod = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;

		                    for (var y in this.tilesMatrix[level][x]) {
		                        yMod = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
		                        tile = this.tilesMatrix[level][x][y];

		                        tile.loadWithAjax = this.loadTilesWithAjax;
		                        if (tile.loadWithAjax) {
		                            var tileAjaxHeaders = this.source.getTileAjaxHeaders( level, xMod, yMod );
		                            tile.ajaxHeaders = $.extend({}, this.ajaxHeaders, tileAjaxHeaders);
		                        } else {
		                            tile.ajaxHeaders = null;
		                        }
		                    }
		                }
		            }

		            for (var i = 0; i < this._imageLoader.jobQueue.length; i++) {
		                var job = this._imageLoader.jobQueue[i];
		                job.loadWithAjax = job.tile.loadWithAjax;
		                job.ajaxHeaders = job.tile.loadWithAjax ? job.tile.ajaxHeaders : null;
		            }
		        }
		    },

		    // private
		    _setScale: function(scale, immediately) {
		        var sameTarget = (this._scaleSpring.target.value === scale);
		        if (immediately) {
		            if (sameTarget && this._scaleSpring.current.value === scale) {
		                return;
		            }

		            this._scaleSpring.resetTo(scale);
		            this._updateForScale();
		            this._needsDraw = true;
		            this._needsUpdate = true;
		        } else {
		            if (sameTarget) {
		                return;
		            }

		            this._scaleSpring.springTo(scale);
		            this._updateForScale();
		            this._needsDraw = true;
		            this._needsUpdate = true;
		        }

		        if (!sameTarget) {
		            this._raiseBoundsChange();
		        }
		    },

		    // private
		    _updateForScale: function() {
		        this._worldWidthTarget = this._scaleSpring.target.value;
		        this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
		        this._worldWidthCurrent = this._scaleSpring.current.value;
		        this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
		    },

		    // private
		    _raiseBoundsChange: function() {
		        /**
		         * Raised when the TiledImage's bounds are changed.
		         * Note that this event is triggered only when the animation target is changed;
		         * not for every frame of animation.
		         * @event bounds-change
		         * @memberOf OpenSeadragon.TiledImage
		         * @type {object}
		         * @property {OpenSeadragon.TiledImage} eventSource - A reference to the
		         * TiledImage which raised the event.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent('bounds-change');
		    },

		    // private
		    _isBottomItem: function() {
		        return this.viewer.world.getItemAt(0) === this;
		    },

		    // private
		    _getLevelsInterval: function() {
		        var lowestLevel = Math.max(
		            this.source.minLevel,
		            Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
		        );
		        var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
		            this.source.getPixelRatio(0), true).x *
		            this._scaleSpring.current.value;
		        var highestLevel = Math.min(
		            Math.abs(this.source.maxLevel),
		            Math.abs(Math.floor(
		                Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
		            ))
		        );

		        // Calculations for the interval of levels to draw
		        // can return invalid intervals; fix that here if necessary
		        highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
		        lowestLevel = Math.min(lowestLevel, highestLevel);
		        return {
		            lowestLevel: lowestLevel,
		            highestLevel: highestLevel
		        };
		    },

		    // returns boolean flag of whether the image should be marked as fully loaded
		    _updateLevelsForViewport: function(){
		        var levelsInterval = this._getLevelsInterval();
		        var lowestLevel = levelsInterval.lowestLevel; // the lowest level we should draw at our current zoom
		        var highestLevel = levelsInterval.highestLevel; // the highest level we should draw at our current zoom
		        var bestTiles = [];
		        var drawArea = this.getDrawArea();
		        var currentTime = $.now();

		        // reset each tile's beingDrawn flag
		        this._lastDrawn.forEach(tileinfo => {
		            tileinfo.tile.beingDrawn = false;
		        });
		        // clear the list of tiles to draw
		        this._tilesToDraw = [];
		        this._tilesLoading = 0;
		        this.loadingCoverage = {};

		        if(!drawArea){
		            this._needsDraw = false;
		            return this._fullyLoaded;
		        }

		        // make a list of levels to use for the current zoom level
		        var levelList = new Array(highestLevel - lowestLevel + 1);
		        // go from highest to lowest resolution
		        for(let i = 0, level = highestLevel; level >= lowestLevel; level--, i++){
		            levelList[i] = level;
		        }

		        // if a single-tile level is loaded, add that to the end of the list
		        // as a fallback to use during zooming out, until a lower-res tile is
		        // loaded
		        for(let level = highestLevel + 1; level <= this.source.maxLevel; level++){
		            var tile = (
		                this.tilesMatrix[level] &&
		                this.tilesMatrix[level][0] &&
		                this.tilesMatrix[level][0][0]
		            );
		            if(tile && tile.isBottomMost && tile.isRightMost && tile.loaded){
		                levelList.push(level);
		                break;
		            }
		        }


		        // Update any level that will be drawn.
		        // We are iterating from highest resolution to lowest resolution
		        // Once a level fully covers the viewport the loop is halted and
		        // lower-resolution levels are skipped
		        let useLevel = false;
		        for (let i = 0; i < levelList.length; i++) {
		            let level = levelList[i];

		            var currentRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(
		                this.source.getPixelRatio(level),
		                true
		            ).x * this._scaleSpring.current.value;

		            // make sure we skip levels until currentRenderPixelRatio becomes >= minPixelRatio
		            // but always use the last level in the list so we draw something
		            if (i === levelList.length - 1 || currentRenderPixelRatio >= this.minPixelRatio ) {
		                useLevel = true;
		            } else if (!useLevel) {
		                continue;
		            }

		            var targetRenderPixelRatio = this.viewport.deltaPixelsFromPointsNoRotate(
		                this.source.getPixelRatio(level),
		                false
		            ).x * this._scaleSpring.current.value;

		            var targetZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
		                this.source.getPixelRatio(
		                    Math.max(
		                        this.source.getClosestLevel(),
		                        0
		                    )
		                ),
		                false
		            ).x * this._scaleSpring.current.value;

		            var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
		            var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
		            var levelVisibility = optimalRatio / Math.abs(
		                optimalRatio - targetRenderPixelRatio
		            );

		            // Update the level and keep track of 'best' tiles to load
		            var result = this._updateLevel(
		                level,
		                levelOpacity,
		                levelVisibility,
		                drawArea,
		                currentTime,
		                bestTiles
		            );

		            bestTiles = result.bestTiles;
		            var tiles = result.updatedTiles.filter(tile => tile.loaded);
		            var makeTileInfoObject = (function(level, levelOpacity, currentTime){
		                return function(tile){
		                    return {
		                        tile: tile,
		                        level: level,
		                        levelOpacity: levelOpacity,
		                        currentTime: currentTime
		                    };
		                };
		            })(level, levelOpacity, currentTime);

		            this._tilesToDraw[level] = tiles.map(makeTileInfoObject);

		            // Stop the loop if lower-res tiles would all be covered by
		            // already drawn tiles
		            if (this._providesCoverage(this.coverage, level)) {
		                break;
		            }
		        }


		        // Load the new 'best' n tiles
		        if (bestTiles && bestTiles.length > 0) {
		            bestTiles.forEach(function (tile) {
		                if (tile && !tile.context2D) {
		                    this._loadTile(tile, currentTime);
		                }
		            }, this);

		            this._needsDraw = true;
		            return false;
		        } else {
		            return this._tilesLoading === 0;
		        }

		        // Update

		    },

		    /**
		     * Update all tiles that contribute to the current view
		     * @private
		     *
		     */
		    _updateTilesInViewport: function(tiles) {
		        let currentTime = $.now();
		        let _this = this;
		        this._tilesLoading = 0;
		        this._wasBlending = this._isBlending;
		        this._isBlending = false;
		        this.loadingCoverage = {};
		        let lowestLevel = tiles.length ? tiles[0].level : 0;

		        let drawArea = this.getDrawArea();
		        if(!drawArea){
		            return;
		        }

		        function updateTile(info){
		            let tile = info.tile;
		            if(tile && tile.loaded){
		                let tileIsBlending = _this._blendTile(
		                    tile,
		                    tile.x,
		                    tile.y,
		                    info.level,
		                    info.levelOpacity,
		                    currentTime,
		                    lowestLevel
		                );
		                _this._isBlending = _this._isBlending || tileIsBlending;
		                _this._needsDraw = _this._needsDraw || tileIsBlending || _this._wasBlending;
		            }
		        }

		        // Update each tile in the list of tiles. As the tiles are updated,
		        // the coverage provided is also updated. If a level provides coverage
		        // as part of this process, discard tiles from lower levels
		        let level = 0;
		        for(let i = 0; i < tiles.length; i++){
		            let tile = tiles[i];
		            updateTile(tile);
		            if(this._providesCoverage(this.coverage, tile.level)){
		                level = Math.max(level, tile.level);
		            }
		        }
		        if(level > 0){
		            for( let levelKey in this._tilesToDraw ){
		                if( levelKey < level ){
		                    delete this._tilesToDraw[levelKey];
		                }
		            }
		        }

		    },

		    /**
		     * Updates the opacity of a tile according to the time it has been on screen
		     * to perform a fade-in.
		     * Updates coverage once a tile is fully opaque.
		     * Returns whether the fade-in has completed.
		     * @private
		     *
		     * @param {OpenSeadragon.Tile} tile
		     * @param {Number} x
		     * @param {Number} y
		     * @param {Number} level
		     * @param {Number} levelOpacity
		     * @param {Number} currentTime
		     * @param {Boolean} lowestLevel
		     * @returns {Boolean} true if blending did not yet finish
		     */
		    _blendTile: function(tile, x, y, level, levelOpacity, currentTime, lowestLevel ){
		        let blendTimeMillis = 1000 * this.blendTime,
		            deltaTime,
		            opacity;

		        if ( !tile.blendStart ) {
		            tile.blendStart = currentTime;
		        }

		        deltaTime   = currentTime - tile.blendStart;
		        opacity     = blendTimeMillis ? Math.min( 1, deltaTime / ( blendTimeMillis ) ) : 1;

		        // if this tile is at the lowest level being drawn, render at opacity=1
		        if(level === lowestLevel){
		            opacity = 1;
		            deltaTime = blendTimeMillis;
		        }

		        if ( this.alwaysBlend ) {
		            opacity *= levelOpacity;
		        }
		        tile.opacity = opacity;

		        if ( opacity === 1 ) {
		            this._setCoverage( this.coverage, level, x, y, true );
		            this._hasOpaqueTile = true;
		        }
		        // return true if the tile is still blending
		        return deltaTime < blendTimeMillis;
		    },

		    /**
		     * Updates all tiles at a given resolution level.
		     * @private
		     * @param {Number} level
		     * @param {Number} levelOpacity
		     * @param {Number} levelVisibility
		     * @param {OpenSeadragon.Rect} drawArea
		     * @param {Number} currentTime
		     * @param {OpenSeadragon.Tile[]} best Array of the current best tiles
		     * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile - the current "best" tiles to draw, updatedTiles: OpenSeadragon.Tile) - the updated tiles}.
		     */
		    _updateLevel: function(level, levelOpacity,
		                            levelVisibility, drawArea, currentTime, best) {

		        var topLeftBound = drawArea.getBoundingBox().getTopLeft();
		        var bottomRightBound = drawArea.getBoundingBox().getBottomRight();

		        if (this.viewer) {
		            /**
		             * <em>- Needs documentation -</em>
		             *
		             * @event update-level
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		             * @property {Object} havedrawn - deprecated, always true (kept for backwards compatibility)
		             * @property {Object} level
		             * @property {Object} opacity
		             * @property {Object} visibility
		             * @property {OpenSeadragon.Rect} drawArea
		             * @property {Object} topleft deprecated, use drawArea instead
		             * @property {Object} bottomright deprecated, use drawArea instead
		             * @property {Object} currenttime
		             * @property {Object[]} best
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent('update-level', {
		                tiledImage: this,
		                havedrawn: true, // deprecated, kept for backwards compatibility
		                level: level,
		                opacity: levelOpacity,
		                visibility: levelVisibility,
		                drawArea: drawArea,
		                topleft: topLeftBound,
		                bottomright: bottomRightBound,
		                currenttime: currentTime,
		                best: best
		            });
		        }

		        this._resetCoverage(this.coverage, level);
		        this._resetCoverage(this.loadingCoverage, level);

		        //OK, a new drawing so do your calculations
		        var cornerTiles = this._getCornerTiles(level, topLeftBound, bottomRightBound);
		        var topLeftTile = cornerTiles.topLeft;
		        var bottomRightTile = cornerTiles.bottomRight;
		        var numberOfTiles  = this.source.getNumTiles(level);

		        var viewportCenter = this.viewport.pixelFromPoint(this.viewport.getCenter());

		        if (this.getFlip()) {
		            // The right-most tile can be narrower than the others. When flipped,
		            // this tile is now on the left. Because it is narrower than the normal
		            // left-most tile, the subsequent tiles may not be wide enough to completely
		            // fill the viewport. Fix this by rendering an extra column of tiles. If we
		            // are not wrapping, make sure we never render more than the number of tiles
		            // in the image.
		            bottomRightTile.x += 1;
		            if (!this.wrapHorizontal) {
		                bottomRightTile.x  = Math.min(bottomRightTile.x, numberOfTiles.x - 1);
		            }
		        }
		        var numTiles = Math.max(0, (bottomRightTile.x - topLeftTile.x) * (bottomRightTile.y - topLeftTile.y));
		        var tiles = new Array(numTiles);
		        var tileIndex = 0;
		        for (var x = topLeftTile.x; x <= bottomRightTile.x; x++) {
		            for (var y = topLeftTile.y; y <= bottomRightTile.y; y++) {

		                var flippedX;
		                if (this.getFlip()) {
		                    var xMod = ( numberOfTiles.x + ( x % numberOfTiles.x ) ) % numberOfTiles.x;
		                    flippedX = x + numberOfTiles.x - xMod - xMod - 1;
		                } else {
		                    flippedX = x;
		                }

		                if (drawArea.intersection(this.getTileBounds(level, flippedX, y)) === null) {
		                    // This tile is outside of the viewport, no need to draw it
		                    continue;
		                }

		                var result = this._updateTile(
		                    flippedX, y,
		                    level,
		                    levelVisibility,
		                    viewportCenter,
		                    numberOfTiles,
		                    currentTime,
		                    best
		                );
		                best = result.bestTiles;
		                tiles[tileIndex] = result.tile;
		                tileIndex += 1;
		            }
		        }

		        return {
		            bestTiles: best,
		            updatedTiles: tiles
		        };
		    },

		    /**
		     * @private
		     * @param {OpenSeadragon.Tile} tile
		     * @param {Boolean} overlap
		     * @param {OpenSeadragon.Viewport} viewport
		     * @param {OpenSeadragon.Point} viewportCenter
		     * @param {Number} levelVisibility
		     */
		    _positionTile: function( tile, overlap, viewport, viewportCenter, levelVisibility ){
		        var boundsTL = tile.bounds.getTopLeft();

		        boundsTL.x *= this._scaleSpring.current.value;
		        boundsTL.y *= this._scaleSpring.current.value;
		        boundsTL.x += this._xSpring.current.value;
		        boundsTL.y += this._ySpring.current.value;

		        var boundsSize   = tile.bounds.getSize();

		        boundsSize.x *= this._scaleSpring.current.value;
		        boundsSize.y *= this._scaleSpring.current.value;

		        tile.positionedBounds.x = boundsTL.x;
		        tile.positionedBounds.y = boundsTL.y;
		        tile.positionedBounds.width = boundsSize.x;
		        tile.positionedBounds.height = boundsSize.y;

		        var positionC = viewport.pixelFromPointNoRotate(boundsTL, true),
		            positionT = viewport.pixelFromPointNoRotate(boundsTL, false),
		            sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true),
		            sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false),
		            tileCenter = positionT.plus( sizeT.divide( 2 ) ),
		            tileSquaredDistance = viewportCenter.squaredDistanceTo( tileCenter );

		        if(this.viewer.drawer.minimumOverlapRequired(this)){
		            if ( !overlap ) {
		                sizeC = sizeC.plus( new $.Point(1, 1));
		            }

		            if (tile.isRightMost && this.wrapHorizontal) {
		                sizeC.x += 0.75; // Otherwise Firefox and Safari show seams
		            }

		            if (tile.isBottomMost && this.wrapVertical) {
		                sizeC.y += 0.75; // Otherwise Firefox and Safari show seams
		            }
		        }

		        tile.position   = positionC;
		        tile.size       = sizeC;
		        tile.squaredDistance   = tileSquaredDistance;
		        tile.visibility = levelVisibility;
		    },

		    /**
		     * Update a single tile at a particular resolution level.
		     * @private
		     * @param {Number} x
		     * @param {Number} y
		     * @param {Number} level
		     * @param {Number} levelVisibility
		     * @param {OpenSeadragon.Point} viewportCenter
		     * @param {Number} numberOfTiles
		     * @param {Number} currentTime
		     * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
		     * @returns {Object} Dictionary {bestTiles: OpenSeadragon.Tile[] - the current best tiles, tile: OpenSeadragon.Tile the current tile}
		     */
		    _updateTile: function( x, y, level,
		                            levelVisibility, viewportCenter, numberOfTiles, currentTime, best){

		        var tile = this._getTile(
		            x, y,
		            level,
		            currentTime,
		            numberOfTiles
		            );

		        if( this.viewer ){
		            /**
		             * <em>- Needs documentation -</em>
		             *
		             * @event update-tile
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Viewer} eventSource - A reference to the Viewer which raised the event.
		             * @property {OpenSeadragon.TiledImage} tiledImage - Which TiledImage is being drawn.
		             * @property {OpenSeadragon.Tile} tile
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.viewer.raiseEvent( 'update-tile', {
		                tiledImage: this,
		                tile: tile
		            });
		        }

		        this._setCoverage( this.coverage, level, x, y, false );

		        var loadingCoverage = tile.loaded || tile.loading || this._isCovered(this.loadingCoverage, level, x, y);
		        this._setCoverage(this.loadingCoverage, level, x, y, loadingCoverage);

		        if ( !tile.exists ) {
		            return {
		                bestTiles: best,
		                tile: tile
		            };
		        }
		        if (tile.loaded && tile.opacity === 1){
		            this._setCoverage( this.coverage, level, x, y, true );
		        }

		        this._positionTile(
		            tile,
		            this.source.tileOverlap,
		            this.viewport,
		            viewportCenter,
		            levelVisibility
		        );

		        if (!tile.loaded) {
		            if (tile.context2D) {
		                this._setTileLoaded(tile);
		            } else {
		                var imageRecord = this._tileCache.getImageRecord(tile.cacheKey);
		                if (imageRecord) {
		                    this._setTileLoaded(tile, imageRecord.getData());
		                }
		            }
		        }

		        if ( tile.loading ) {
		            // the tile is already in the download queue
		            this._tilesLoading++;
		        } else if (!loadingCoverage) {
		            best = this._compareTiles( best, tile, this.maxTilesPerFrame );
		        }

		        return {
		            bestTiles: best,
		            tile: tile
		        };
		    },

		    // private
		    _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
		        var leftX;
		        var rightX;
		        if (this.wrapHorizontal) {
		            leftX = $.positiveModulo(topLeftBound.x, 1);
		            rightX = $.positiveModulo(bottomRightBound.x, 1);
		        } else {
		            leftX = Math.max(0, topLeftBound.x);
		            rightX = Math.min(1, bottomRightBound.x);
		        }
		        var topY;
		        var bottomY;
		        var aspectRatio = 1 / this.source.aspectRatio;
		        if (this.wrapVertical) {
		            topY = $.positiveModulo(topLeftBound.y, aspectRatio);
		            bottomY = $.positiveModulo(bottomRightBound.y, aspectRatio);
		        } else {
		            topY = Math.max(0, topLeftBound.y);
		            bottomY = Math.min(aspectRatio, bottomRightBound.y);
		        }

		        var topLeftTile = this.source.getTileAtPoint(level, new $.Point(leftX, topY));
		        var bottomRightTile = this.source.getTileAtPoint(level, new $.Point(rightX, bottomY));
		        var numTiles  = this.source.getNumTiles(level);

		        if (this.wrapHorizontal) {
		            topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
		            bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
		        }
		        if (this.wrapVertical) {
		            topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
		            bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
		        }

		        return {
		            topLeft: topLeftTile,
		            bottomRight: bottomRightTile,
		        };
		    },

		    /**
		     * Obtains a tile at the given location.
		     * @private
		     * @param {Number} x
		     * @param {Number} y
		     * @param {Number} level
		     * @param {Number} time
		     * @param {Number} numTiles
		     * @returns {OpenSeadragon.Tile}
		     */
		    _getTile: function(
		        x, y,
		        level,
		        time,
		        numTiles
		    ) {
		        var xMod,
		            yMod,
		            bounds,
		            sourceBounds,
		            exists,
		            urlOrGetter,
		            post,
		            ajaxHeaders,
		            context2D,
		            tile,
		            tilesMatrix = this.tilesMatrix,
		            tileSource = this.source;

		        if ( !tilesMatrix[ level ] ) {
		            tilesMatrix[ level ] = {};
		        }
		        if ( !tilesMatrix[ level ][ x ] ) {
		            tilesMatrix[ level ][ x ] = {};
		        }

		        if ( !tilesMatrix[ level ][ x ][ y ] || !tilesMatrix[ level ][ x ][ y ].flipped !== !this.flipped ) {
		            xMod    = ( numTiles.x + ( x % numTiles.x ) ) % numTiles.x;
		            yMod    = ( numTiles.y + ( y % numTiles.y ) ) % numTiles.y;
		            bounds  = this.getTileBounds( level, x, y );
		            sourceBounds = tileSource.getTileBounds( level, xMod, yMod, true );
		            exists  = tileSource.tileExists( level, xMod, yMod );
		            urlOrGetter     = tileSource.getTileUrl( level, xMod, yMod );
		            post    = tileSource.getTilePostData( level, xMod, yMod );

		            // Headers are only applicable if loadTilesWithAjax is set
		            if (this.loadTilesWithAjax) {
		                ajaxHeaders = tileSource.getTileAjaxHeaders( level, xMod, yMod );
		                // Combine tile AJAX headers with tiled image AJAX headers (if applicable)
		                if ($.isPlainObject(this.ajaxHeaders)) {
		                    ajaxHeaders = $.extend({}, this.ajaxHeaders, ajaxHeaders);
		                }
		            } else {
		                ajaxHeaders = null;
		            }

		            context2D = tileSource.getContext2D ?
		                tileSource.getContext2D(level, xMod, yMod) : undefined;

		            tile = new $.Tile(
		                level,
		                x,
		                y,
		                bounds,
		                exists,
		                urlOrGetter,
		                context2D,
		                this.loadTilesWithAjax,
		                ajaxHeaders,
		                sourceBounds,
		                post,
		                tileSource.getTileHashKey(level, xMod, yMod, urlOrGetter, ajaxHeaders, post)
		            );

		            if (this.getFlip()) {
		                if (xMod === 0) {
		                    tile.isRightMost = true;
		                }
		            } else {
		                if (xMod === numTiles.x - 1) {
		                    tile.isRightMost = true;
		                }
		            }

		            if (yMod === numTiles.y - 1) {
		                tile.isBottomMost = true;
		            }

		            tile.flipped = this.flipped;

		            tilesMatrix[ level ][ x ][ y ] = tile;
		        }

		        tile = tilesMatrix[ level ][ x ][ y ];
		        tile.lastTouchTime = time;

		        return tile;
		    },

		    /**
		     * Dispatch a job to the ImageLoader to load the Image for a Tile.
		     * @private
		     * @param {OpenSeadragon.Tile} tile
		     * @param {Number} time
		     */
		    _loadTile: function(tile, time ) {
		        var _this = this;
		        tile.loading = true;
		        this._imageLoader.addJob({
		            src: tile.getUrl(),
		            tile: tile,
		            source: this.source,
		            postData: tile.postData,
		            loadWithAjax: tile.loadWithAjax,
		            ajaxHeaders: tile.ajaxHeaders,
		            crossOriginPolicy: this.crossOriginPolicy,
		            ajaxWithCredentials: this.ajaxWithCredentials,
		            callback: function( data, errorMsg, tileRequest ){
		                _this._onTileLoad( tile, time, data, errorMsg, tileRequest );
		            },
		            abort: function() {
		                tile.loading = false;
		            }
		        });
		    },

		    /**
		     * Callback fired when a Tile's Image finished downloading.
		     * @private
		     * @param {OpenSeadragon.Tile} tile
		     * @param {Number} time
		     * @param {*} data image data
		     * @param {String} errorMsg
		     * @param {XMLHttpRequest} tileRequest
		     */
		    _onTileLoad: function( tile, time, data, errorMsg, tileRequest ) {
		        if ( !data ) {
		            $.console.error( "Tile %s failed to load: %s - error: %s", tile, tile.getUrl(), errorMsg );
		            /**
		             * Triggered when a tile fails to load.
		             *
		             * @event tile-load-failed
		             * @memberof OpenSeadragon.Viewer
		             * @type {object}
		             * @property {OpenSeadragon.Tile} tile - The tile that failed to load.
		             * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image the tile belongs to.
		             * @property {number} time - The time in milliseconds when the tile load began.
		             * @property {string} message - The error message.
		             * @property {XMLHttpRequest} tileRequest - The XMLHttpRequest used to load the tile if available.
		             */
		            this.viewer.raiseEvent("tile-load-failed", {
		                tile: tile,
		                tiledImage: this,
		                time: time,
		                message: errorMsg,
		                tileRequest: tileRequest
		            });
		            tile.loading = false;
		            tile.exists = false;
		            return;
		        } else {
		            tile.exists = true;
		        }

		        if ( time < this.lastResetTime ) {
		            $.console.warn( "Ignoring tile %s loaded before reset: %s", tile, tile.getUrl() );
		            tile.loading = false;
		            return;
		        }

		        var _this = this,
		            finish = function() {
		                var ccc = _this.source;
		                var cutoff = ccc.getClosestLevel();
		                _this._setTileLoaded(tile, data, cutoff, tileRequest);
		        };


		        finish();
		    },

		    /**
		     * @private
		     * @param {OpenSeadragon.Tile} tile
		     * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
		     * @param {Number|undefined} cutoff
		     * @param {XMLHttpRequest|undefined} tileRequest
		     */
		    _setTileLoaded: function(tile, data, cutoff, tileRequest) {
		        var increment = 0,
		            eventFinished = false,
		            _this = this;

		        function getCompletionCallback() {
		            if (eventFinished) {
		                $.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. " +
		                    "Its return value should be called asynchronously.");
		            }
		            increment++;
		            return completionCallback;
		        }

		        function completionCallback() {
		            increment--;
		            if (increment === 0) {
		                tile.loading = false;
		                tile.loaded = true;
		                tile.hasTransparency = _this.source.hasTransparency(
		                    tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData
		                );
		                if (!tile.context2D) {
		                    _this._tileCache.cacheTile({
		                        data: data,
		                        tile: tile,
		                        cutoff: cutoff,
		                        tiledImage: _this
		                    });
		                }
		                /**
		                 * Triggered when a tile is loaded and pre-processing is compelete,
		                 * and the tile is ready to draw.
		                 *
		                 * @event tile-ready
		                 * @memberof OpenSeadragon.Viewer
		                 * @type {object}
		                 * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.
		                 * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.
		                 * @property {XMLHttpRequest} tileRequest - The AJAX request that loaded this tile (if applicable).
		                 * @private
		                 */
		                _this.viewer.raiseEvent("tile-ready", {
		                    tile: tile,
		                    tiledImage: _this,
		                    tileRequest: tileRequest
		                });
		                _this._needsDraw = true;
		            }
		        }

		        /**
		         * Triggered when a tile has just been loaded in memory. That means that the
		         * image has been downloaded and can be modified before being drawn to the canvas.
		         *
		         * @event tile-loaded
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {Image|*} image - The image (data) of the tile. Deprecated.
		         * @property {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
		         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the loaded tile.
		         * @property {OpenSeadragon.Tile} tile - The tile which has been loaded.
		         * @property {XMLHttpRequest} tileRequest - The AJAX request that loaded this tile (if applicable).
		         * @property {function} getCompletionCallback - A function giving a callback to call
		         * when the asynchronous processing of the image is done. The image will be
		         * marked as entirely loaded when the callback has been called once for each
		         * call to getCompletionCallback.
		         */

		        var fallbackCompletion = getCompletionCallback();
		        this.viewer.raiseEvent("tile-loaded", {
		            tile: tile,
		            tiledImage: this,
		            tileRequest: tileRequest,
		            get image() {
		                $.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead.");
		                return data;
		            },
		            data: data,
		            getCompletionCallback: getCompletionCallback
		        });
		        eventFinished = true;
		        // In case the completion callback is never called, we at least force it once.
		        fallbackCompletion();
		    },


		    /**
		     * Determines the 'best tiles' from the given 'last best' tiles and the
		     * tile in question.
		     * @private
		     *
		     * @param {OpenSeadragon.Tile[]} previousBest The best tiles so far.
		     * @param {OpenSeadragon.Tile} tile The new tile to consider.
		     * @param {Number} maxNTiles The max number of best tiles.
		     * @returns {OpenSeadragon.Tile[]} The new best tiles.
		     */
		    _compareTiles: function( previousBest, tile, maxNTiles ) {
		        if ( !previousBest ) {
		            return [tile];
		        }
		        previousBest.push(tile);
		        this._sortTiles(previousBest);
		        if (previousBest.length > maxNTiles) {
		            previousBest.pop();
		        }
		        return previousBest;
		    },

		    /**
		     * Sorts tiles in an array according to distance and visibility.
		     * @private
		     *
		     * @param {OpenSeadragon.Tile[]} tiles The tiles.
		     */
		    _sortTiles: function( tiles ) {
		        tiles.sort(function (a, b) {
		            if (a === null) {
		                return 1;
		            }
		            if (b === null) {
		                return -1;
		            }
		            if (a.visibility === b.visibility) {
		                // sort by smallest squared distance
		                return (a.squaredDistance - b.squaredDistance);
		            } else {
		                // sort by largest visibility value
		                return (b.visibility - a.visibility);
		            }
		        });
		    },


		    /**
		     * Returns true if the given tile provides coverage to lower-level tiles of
		     * lower resolution representing the same content. If neither x nor y is
		     * given, returns true if the entire visible level provides coverage.
		     *
		     * Note that out-of-bounds tiles provide coverage in this sense, since
		     * there's no content that they would need to cover. Tiles at non-existent
		     * levels that are within the image bounds, however, do not.
		     * @private
		     *
		     * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
		     * @param {Number} level - The resolution level of the tile.
		     * @param {Number} x - The X position of the tile.
		     * @param {Number} y - The Y position of the tile.
		     * @returns {Boolean}
		     */
		    _providesCoverage: function( coverage, level, x, y ) {
		        var rows,
		            cols,
		            i, j;

		        if ( !coverage[ level ] ) {
		            return false;
		        }

		        if ( x === undefined || y === undefined ) {
		            rows = coverage[ level ];
		            for ( i in rows ) {
		                if ( Object.prototype.hasOwnProperty.call( rows, i ) ) {
		                    cols = rows[ i ];
		                    for ( j in cols ) {
		                        if ( Object.prototype.hasOwnProperty.call( cols, j ) && !cols[ j ] ) {
		                            return false;
		                        }
		                    }
		                }
		            }

		            return true;
		        }

		        return (
		            coverage[ level ][ x] === undefined ||
		            coverage[ level ][ x ][ y ] === undefined ||
		            coverage[ level ][ x ][ y ] === true
		        );
		    },

		    /**
		     * Returns true if the given tile is completely covered by higher-level
		     * tiles of higher resolution representing the same content. If neither x
		     * nor y is given, returns true if the entire visible level is covered.
		     * @private
		     *
		     * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
		     * @param {Number} level - The resolution level of the tile.
		     * @param {Number} x - The X position of the tile.
		     * @param {Number} y - The Y position of the tile.
		     * @returns {Boolean}
		     */
		    _isCovered: function( coverage, level, x, y ) {
		        if ( x === undefined || y === undefined ) {
		            return this._providesCoverage( coverage, level + 1 );
		        } else {
		            return (
		                this._providesCoverage( coverage, level + 1, 2 * x, 2 * y ) &&
		                this._providesCoverage( coverage, level + 1, 2 * x, 2 * y + 1 ) &&
		                this._providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y ) &&
		                this._providesCoverage( coverage, level + 1, 2 * x + 1, 2 * y + 1 )
		            );
		        }
		    },

		    /**
		     * Sets whether the given tile provides coverage or not.
		     * @private
		     *
		     * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
		     * @param {Number} level - The resolution level of the tile.
		     * @param {Number} x - The X position of the tile.
		     * @param {Number} y - The Y position of the tile.
		     * @param {Boolean} covers - Whether the tile provides coverage.
		     */
		    _setCoverage: function( coverage, level, x, y, covers ) {
		        if ( !coverage[ level ] ) {
		            $.console.warn(
		                "Setting coverage for a tile before its level's coverage has been reset: %s",
		                level
		            );
		            return;
		        }

		        if ( !coverage[ level ][ x ] ) {
		            coverage[ level ][ x ] = {};
		        }

		        coverage[ level ][ x ][ y ] = covers;
		    },

		    /**
		     * Resets coverage information for the given level. This should be called
		     * after every draw routine. Note that at the beginning of the next draw
		     * routine, coverage for every visible tile should be explicitly set.
		     * @private
		     *
		     * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
		     * @param {Number} level - The resolution level of tiles to completely reset.
		     */
		    _resetCoverage: function( coverage, level ) {
		        coverage[ level ] = {};
		    }
		});



		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - TileCache
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		// private class
		var TileRecord = function( options ) {
		    $.console.assert( options, "[TileCache.cacheTile] options is required" );
		    $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );
		    $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );
		    this.tile = options.tile;
		    this.tiledImage = options.tiledImage;
		};

		// private class
		var ImageRecord = function(options) {
		    $.console.assert( options, "[ImageRecord] options is required" );
		    $.console.assert( options.data, "[ImageRecord] options.data is required" );
		    this._tiles = [];

		    options.create.apply(null, [this, options.data, options.ownerTile]);
		    this._destroyImplementation = options.destroy.bind(null, this);
		    this.getImage = options.getImage.bind(null, this);
		    this.getData = options.getData.bind(null, this);
		    this.getRenderedContext = options.getRenderedContext.bind(null, this);
		};

		ImageRecord.prototype = {
		    destroy: function() {
		        this._destroyImplementation();
		        this._tiles = null;
		    },

		    addTile: function(tile) {
		        $.console.assert(tile, '[ImageRecord.addTile] tile is required');
		        this._tiles.push(tile);
		    },

		    removeTile: function(tile) {
		        for (var i = 0; i < this._tiles.length; i++) {
		            if (this._tiles[i] === tile) {
		                this._tiles.splice(i, 1);
		                return;
		            }
		        }

		        $.console.warn('[ImageRecord.removeTile] trying to remove unknown tile', tile);
		    },

		    getTileCount: function() {
		        return this._tiles.length;
		    }
		};

		/**
		 * @class TileCache
		 * @memberof OpenSeadragon
		 * @classdesc Stores all the tiles displayed in a {@link OpenSeadragon.Viewer}.
		 * You generally won't have to interact with the TileCache directly.
		 * @param {Object} options - Configuration for this TileCache.
		 * @param {Number} [options.maxImageCacheCount] - See maxImageCacheCount in
		 * {@link OpenSeadragon.Options} for details.
		 */
		$.TileCache = function( options ) {
		    options = options || {};

		    this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
		    this._tilesLoaded = [];
		    this._imagesLoaded = [];
		    this._imagesLoadedCount = 0;
		};

		/** @lends OpenSeadragon.TileCache.prototype */
		$.TileCache.prototype = {
		    /**
		     * @returns {Number} The total number of tiles that have been loaded by
		     * this TileCache.
		     */
		    numTilesLoaded: function() {
		        return this._tilesLoaded.length;
		    },

		    /**
		     * Caches the specified tile, removing an old tile if necessary to stay under the
		     * maxImageCacheCount specified on construction. Note that if multiple tiles reference
		     * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
		     * the number of images below that number. Note, as well, that even the number of images
		     * may temporarily surpass that number, but should eventually come back down to the max specified.
		     * @param {Object} options - Tile info.
		     * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
		     * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
		     * @param {Image} options.image - The image of the tile to cache.
		     * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
		     * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
		     * function will release an old tile. The cutoff option specifies a tile level at or below which
		     * tiles will not be released.
		     */
		    cacheTile: function( options ) {
		        $.console.assert( options, "[TileCache.cacheTile] options is required" );
		        $.console.assert( options.tile, "[TileCache.cacheTile] options.tile is required" );
		        $.console.assert( options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required" );
		        $.console.assert( options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required" );

		        var cutoff = options.cutoff || 0;
		        var insertionIndex = this._tilesLoaded.length;

		        var imageRecord = this._imagesLoaded[options.tile.cacheKey];
		        if (!imageRecord) {

		            if (!options.data) {
		                $.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute " +
		                    "has been deprecated and will be removed in the future.");
		                options.data = options.image;
		            }

		            $.console.assert( options.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord" );
		            imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
		                data: options.data,
		                ownerTile: options.tile,
		                create: options.tiledImage.source.createTileCache,
		                destroy: options.tiledImage.source.destroyTileCache,
		                getImage: options.tiledImage.source.getTileCacheDataAsImage,
		                getData: options.tiledImage.source.getTileCacheData,
		                getRenderedContext: options.tiledImage.source.getTileCacheDataAsContext2D,
		            });

		            this._imagesLoadedCount++;
		        }

		        imageRecord.addTile(options.tile);
		        options.tile.cacheImageRecord = imageRecord;

		        // Note that just because we're unloading a tile doesn't necessarily mean
		        // we're unloading an image. With repeated calls it should sort itself out, though.
		        if ( this._imagesLoadedCount > this._maxImageCacheCount ) {
		            var worstTile       = null;
		            var worstTileIndex  = -1;
		            var worstTileRecord = null;
		            var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;

		            for ( var i = this._tilesLoaded.length - 1; i >= 0; i-- ) {
		                prevTileRecord = this._tilesLoaded[ i ];
		                prevTile = prevTileRecord.tile;

		                if ( prevTile.level <= cutoff || prevTile.beingDrawn ) {
		                    continue;
		                } else if ( !worstTile ) {
		                    worstTile       = prevTile;
		                    worstTileIndex  = i;
		                    worstTileRecord = prevTileRecord;
		                    continue;
		                }

		                prevTime    = prevTile.lastTouchTime;
		                worstTime   = worstTile.lastTouchTime;
		                prevLevel   = prevTile.level;
		                worstLevel  = worstTile.level;

		                if ( prevTime < worstTime ||
		                    ( prevTime === worstTime && prevLevel > worstLevel ) ) {
		                    worstTile       = prevTile;
		                    worstTileIndex  = i;
		                    worstTileRecord = prevTileRecord;
		                }
		            }

		            if ( worstTile && worstTileIndex >= 0 ) {
		                this._unloadTile(worstTileRecord);
		                insertionIndex = worstTileIndex;
		            }
		        }

		        this._tilesLoaded[ insertionIndex ] = new TileRecord({
		            tile: options.tile,
		            tiledImage: options.tiledImage
		        });
		    },

		    /**
		     * Clears all tiles associated with the specified tiledImage.
		     * @param {OpenSeadragon.TiledImage} tiledImage
		     */
		    clearTilesFor: function( tiledImage ) {
		        $.console.assert(tiledImage, '[TileCache.clearTilesFor] tiledImage is required');
		        var tileRecord;
		        for ( var i = 0; i < this._tilesLoaded.length; ++i ) {
		            tileRecord = this._tilesLoaded[ i ];
		            if ( tileRecord.tiledImage === tiledImage ) {
		                this._unloadTile(tileRecord);
		                this._tilesLoaded.splice( i, 1 );
		                i--;
		            }
		        }
		    },

		    // private
		    getImageRecord: function(cacheKey) {
		        $.console.assert(cacheKey, '[TileCache.getImageRecord] cacheKey is required');
		        return this._imagesLoaded[cacheKey];
		    },

		    // private
		    _unloadTile: function(tileRecord) {
		        $.console.assert(tileRecord, '[TileCache._unloadTile] tileRecord is required');
		        var tile = tileRecord.tile;
		        var tiledImage = tileRecord.tiledImage;

		        // tile.getCanvasContext should always exist in normal usage (with $.Tile)
		        // but the tile cache test passes in a dummy object
		        let context2D = tile.getCanvasContext && tile.getCanvasContext();

		        tile.unload();
		        tile.cacheImageRecord = null;

		        var imageRecord = this._imagesLoaded[tile.cacheKey];
		        if(!imageRecord){
		            return;
		        }
		        imageRecord.removeTile(tile);
		        if (!imageRecord.getTileCount()) {

		            imageRecord.destroy();
		            delete this._imagesLoaded[tile.cacheKey];
		            this._imagesLoadedCount--;

		            if(context2D){
		                /**
		                 * Free up canvas memory
		                 * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
		                 * and Safari keeps canvas until its height and width will be set to 0).
		                 */
		                context2D.canvas.width = 0;
		                context2D.canvas.height = 0;

		                /**
		                 * Triggered when an image has just been unloaded
		                 *
		                 * @event image-unloaded
		                 * @memberof OpenSeadragon.Viewer
		                 * @type {object}
		                 * @property {CanvasRenderingContext2D} context2D - The context that is being unloaded
		                 * @private
		                 */
		                tiledImage.viewer.raiseEvent("image-unloaded", {
		                    context2D: context2D,
		                    tile: tile
		                });
		            }

		        }

		        /**
		         * Triggered when a tile has just been unloaded from the cache.
		         *
		         * @event tile-unloaded
		         * @memberof OpenSeadragon.Viewer
		         * @type {object}
		         * @property {OpenSeadragon.TiledImage} tiledImage - The tiled image of the unloaded tile.
		         * @property {OpenSeadragon.Tile} tile - The tile which has been unloaded.
		         */
		        tiledImage.viewer.raiseEvent("tile-unloaded", {
		            tile: tile,
		            tiledImage: tiledImage
		        });

		    }
		};

		}( OpenSeadragon ));

		/*
		 * OpenSeadragon - World
		 *
		 * Copyright (C) 2009 CodePlex Foundation
		 * Copyright (C) 2010-2024 OpenSeadragon contributors
		 *
		 * Redistribution and use in source and binary forms, with or without
		 * modification, are permitted provided that the following conditions are
		 * met:
		 *
		 * - Redistributions of source code must retain the above copyright notice,
		 *   this list of conditions and the following disclaimer.
		 *
		 * - Redistributions in binary form must reproduce the above copyright
		 *   notice, this list of conditions and the following disclaimer in the
		 *   documentation and/or other materials provided with the distribution.
		 *
		 * - Neither the name of CodePlex Foundation nor the names of its
		 *   contributors may be used to endorse or promote products derived from
		 *   this software without specific prior written permission.
		 *
		 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
		 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
		 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
		 * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
		 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
		 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
		 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
		 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
		 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
		 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
		 */

		(function( $ ){

		/**
		 * @class World
		 * @memberof OpenSeadragon
		 * @extends OpenSeadragon.EventSource
		 * @classdesc Keeps track of all of the tiled images in the scene.
		 * @param {Object} options - World options.
		 * @param {OpenSeadragon.Viewer} options.viewer - The Viewer that owns this World.
		 **/
		$.World = function( options ) {
		    var _this = this;

		    $.console.assert( options.viewer, "[World] options.viewer is required" );

		    $.EventSource.call( this );

		    this.viewer = options.viewer;
		    this._items = [];
		    this._needsDraw = false;
		    this._autoRefigureSizes = true;
		    this._needsSizesFigured = false;
		    this._delegatedFigureSizes = function(event) {
		        if (_this._autoRefigureSizes) {
		            _this._figureSizes();
		        } else {
		            _this._needsSizesFigured = true;
		        }
		    };

		    this._figureSizes();
		};

		$.extend( $.World.prototype, $.EventSource.prototype, /** @lends OpenSeadragon.World.prototype */{
		    /**
		     * Add the specified item.
		     * @param {OpenSeadragon.TiledImage} item - The item to add.
		     * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
		     * @fires OpenSeadragon.World.event:add-item
		     * @fires OpenSeadragon.World.event:metrics-change
		     */
		    addItem: function( item, options ) {
		        $.console.assert(item, "[World.addItem] item is required");
		        $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");

		        options = options || {};
		        if (options.index !== undefined) {
		            var index = Math.max(0, Math.min(this._items.length, options.index));
		            this._items.splice(index, 0, item);
		        } else {
		            this._items.push( item );
		        }

		        if (this._autoRefigureSizes) {
		            this._figureSizes();
		        } else {
		            this._needsSizesFigured = true;
		        }

		        this._needsDraw = true;

		        item.addHandler('bounds-change', this._delegatedFigureSizes);
		        item.addHandler('clip-change', this._delegatedFigureSizes);

		        /**
		         * Raised when an item is added to the World.
		         * @event add-item
		         * @memberOf OpenSeadragon.World
		         * @type {object}
		         * @property {OpenSeadragon.Viewer} eventSource - A reference to the World which raised the event.
		         * @property {OpenSeadragon.TiledImage} item - The item that has been added.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'add-item', {
		            item: item
		        } );
		    },

		    /**
		     * Get the item at the specified index.
		     * @param {Number} index - The item's index.
		     * @returns {OpenSeadragon.TiledImage} The item at the specified index.
		     */
		    getItemAt: function( index ) {
		        $.console.assert(index !== undefined, "[World.getItemAt] index is required");
		        return this._items[ index ];
		    },

		    /**
		     * Get the index of the given item or -1 if not present.
		     * @param {OpenSeadragon.TiledImage} item - The item.
		     * @returns {Number} The index of the item or -1 if not present.
		     */
		    getIndexOfItem: function( item ) {
		        $.console.assert(item, "[World.getIndexOfItem] item is required");
		        return $.indexOf( this._items, item );
		    },

		    /**
		     * @returns {Number} The number of items used.
		     */
		    getItemCount: function() {
		        return this._items.length;
		    },

		    /**
		     * Change the index of a item so that it appears over or under others.
		     * @param {OpenSeadragon.TiledImage} item - The item to move.
		     * @param {Number} index - The new index.
		     * @fires OpenSeadragon.World.event:item-index-change
		     */
		    setItemIndex: function( item, index ) {
		        $.console.assert(item, "[World.setItemIndex] item is required");
		        $.console.assert(index !== undefined, "[World.setItemIndex] index is required");

		        var oldIndex = this.getIndexOfItem( item );

		        if ( index >= this._items.length ) {
		            throw new Error( "Index bigger than number of layers." );
		        }

		        if ( index === oldIndex || oldIndex === -1 ) {
		            return;
		        }

		        this._items.splice( oldIndex, 1 );
		        this._items.splice( index, 0, item );
		        this._needsDraw = true;

		        /**
		         * Raised when the order of the indexes has been changed.
		         * @event item-index-change
		         * @memberOf OpenSeadragon.World
		         * @type {object}
		         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
		         * @property {OpenSeadragon.TiledImage} item - The item whose index has
		         * been changed
		         * @property {Number} previousIndex - The previous index of the item
		         * @property {Number} newIndex - The new index of the item
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'item-index-change', {
		            item: item,
		            previousIndex: oldIndex,
		            newIndex: index
		        } );
		    },

		    /**
		     * Remove an item.
		     * @param {OpenSeadragon.TiledImage} item - The item to remove.
		     * @fires OpenSeadragon.World.event:remove-item
		     * @fires OpenSeadragon.World.event:metrics-change
		     */
		    removeItem: function( item ) {
		        $.console.assert(item, "[World.removeItem] item is required");

		        var index = $.indexOf(this._items, item );
		        if ( index === -1 ) {
		            return;
		        }

		        item.removeHandler('bounds-change', this._delegatedFigureSizes);
		        item.removeHandler('clip-change', this._delegatedFigureSizes);
		        item.destroy();
		        this._items.splice( index, 1 );
		        this._figureSizes();
		        this._needsDraw = true;
		        this._raiseRemoveItem(item);
		    },

		    /**
		     * Remove all items.
		     * @fires OpenSeadragon.World.event:remove-item
		     * @fires OpenSeadragon.World.event:metrics-change
		     */
		    removeAll: function() {
		        // We need to make sure any pending images are canceled so the world items don't get messed up
		        this.viewer._cancelPendingImages();
		        var item;
		        var i;
		        for (i = 0; i < this._items.length; i++) {
		            item = this._items[i];
		            item.removeHandler('bounds-change', this._delegatedFigureSizes);
		            item.removeHandler('clip-change', this._delegatedFigureSizes);
		            item.destroy();
		        }

		        var removedItems = this._items;
		        this._items = [];
		        this._figureSizes();
		        this._needsDraw = true;

		        for (i = 0; i < removedItems.length; i++) {
		            item = removedItems[i];
		            this._raiseRemoveItem(item);
		        }
		    },

		    /**
		     * Clears all tiles and triggers updates for all items.
		     */
		    resetItems: function() {
		        for ( var i = 0; i < this._items.length; i++ ) {
		            this._items[i].reset();
		        }
		    },

		    /**
		     * Updates (i.e. animates bounds of) all items.
		     * @function
		     * @param viewportChanged Whether the viewport changed, which indicates that
		     * all TiledImages need to be updated.
		     */
		    update: function(viewportChanged) {
		        var animated = false;
		        for ( var i = 0; i < this._items.length; i++ ) {
		            animated = this._items[i].update(viewportChanged) || animated;
		        }

		        return animated;
		    },

		    /**
		     * Draws all items.
		     */
		    draw: function() {
		        this.viewer.drawer.draw(this._items);
		        this._needsDraw = false;
		        this._items.forEach((item) => {
		            this._needsDraw = item.setDrawn() || this._needsDraw;
		        });
		    },

		    /**
		     * @returns {Boolean} true if any items need updating.
		     */
		    needsDraw: function() {
		        for ( var i = 0; i < this._items.length; i++ ) {
		            if ( this._items[i].needsDraw() ) {
		                return true;
		            }
		        }
		        return this._needsDraw;
		    },

		    /**
		     * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
		     */
		    getHomeBounds: function() {
		        return this._homeBounds.clone();
		    },

		    /**
		     * To facilitate zoom constraints, we keep track of the pixel density of the
		     * densest item in the World (i.e. the item whose content size to viewport size
		     * ratio is the highest) and save it as this "content factor".
		     * @returns {Number} the number of content units per viewport unit.
		     */
		    getContentFactor: function() {
		        return this._contentFactor;
		    },

		    /**
		     * As a performance optimization, setting this flag to false allows the bounds-change event handler
		     * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
		     * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
		     * or the system may behave oddly.
		     * @param {Boolean} [value] The value to which to set the flag.
		     */
		    setAutoRefigureSizes: function(value) {
		        this._autoRefigureSizes = value;
		        if (value & this._needsSizesFigured) {
		            this._figureSizes();
		            this._needsSizesFigured = false;
		        }
		    },

		    /**
		     * Arranges all of the TiledImages with the specified settings.
		     * @param {Object} options - Specifies how to arrange.
		     * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
		     * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
		     * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
		     * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
		     * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
		     * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
		     * @fires OpenSeadragon.World.event:metrics-change
		     */
		    arrange: function(options) {
		        options = options || {};
		        var immediately = options.immediately || false;
		        var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
		        var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
		        var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
		        var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
		        var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
		        var increment = tileSize + tileMargin;
		        var wrap;
		        if (!options.rows && columns) {
		            wrap = columns;
		        } else {
		            wrap = Math.ceil(this._items.length / rows);
		        }
		        var x = 0;
		        var y = 0;
		        var item, box, width, height, position;

		        this.setAutoRefigureSizes(false);
		        for (var i = 0; i < this._items.length; i++) {
		            if (i && (i % wrap) === 0) {
		                if (layout === 'horizontal') {
		                    y += increment;
		                    x = 0;
		                } else {
		                    x += increment;
		                    y = 0;
		                }
		            }

		            item = this._items[i];
		            box = item.getBounds();
		            if (box.width > box.height) {
		                width = tileSize;
		            } else {
		                width = tileSize * (box.width / box.height);
		            }

		            height = width * (box.height / box.width);
		            position = new $.Point(x + ((tileSize - width) / 2),
		                y + ((tileSize - height) / 2));

		            item.setPosition(position, immediately);
		            item.setWidth(width, immediately);

		            if (layout === 'horizontal') {
		                x += increment;
		            } else {
		                y += increment;
		            }
		        }
		        this.setAutoRefigureSizes(true);
		    },

		    // private
		    _figureSizes: function() {
		        var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
		        var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
		        var oldContentFactor = this._contentFactor || 0;

		        if (!this._items.length) {
		            this._homeBounds = new $.Rect(0, 0, 1, 1);
		            this._contentSize = new $.Point(1, 1);
		            this._contentFactor = 1;
		        } else {
		            var item = this._items[0];
		            var bounds = item.getBounds();
		            this._contentFactor = item.getContentSize().x / bounds.width;
		            var clippedBounds = item.getClippedBounds().getBoundingBox();
		            var left = clippedBounds.x;
		            var top = clippedBounds.y;
		            var right = clippedBounds.x + clippedBounds.width;
		            var bottom = clippedBounds.y + clippedBounds.height;
		            for (var i = 1; i < this._items.length; i++) {
		                item = this._items[i];
		                bounds = item.getBounds();
		                this._contentFactor = Math.max(this._contentFactor,
		                    item.getContentSize().x / bounds.width);
		                clippedBounds = item.getClippedBounds().getBoundingBox();
		                left = Math.min(left, clippedBounds.x);
		                top = Math.min(top, clippedBounds.y);
		                right = Math.max(right, clippedBounds.x + clippedBounds.width);
		                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
		            }

		            this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
		            this._contentSize = new $.Point(
		                this._homeBounds.width * this._contentFactor,
		                this._homeBounds.height * this._contentFactor);
		        }

		        if (this._contentFactor !== oldContentFactor ||
		            !this._homeBounds.equals(oldHomeBounds) ||
		            !this._contentSize.equals(oldContentSize)) {
		            /**
		             * Raised when the home bounds or content factor change.
		             * @event metrics-change
		             * @memberOf OpenSeadragon.World
		             * @type {object}
		             * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
		             * @property {?Object} userData - Arbitrary subscriber-defined object.
		             */
		            this.raiseEvent('metrics-change', {});
		        }
		    },

		    // private
		    _raiseRemoveItem: function(item) {
		        /**
		         * Raised when an item is removed.
		         * @event remove-item
		         * @memberOf OpenSeadragon.World
		         * @type {object}
		         * @property {OpenSeadragon.World} eventSource - A reference to the World which raised the event.
		         * @property {OpenSeadragon.TiledImage} item - The item's underlying item.
		         * @property {?Object} userData - Arbitrary subscriber-defined object.
		         */
		        this.raiseEvent( 'remove-item', { item: item } );
		    }
		});

		}( OpenSeadragon ));

		
	} (openseadragon$1));
	return openseadragon$1.exports;
}

var openseadragonExports = requireOpenseadragon();
var osd = /*@__PURE__*/getDefaultExportFromCjs(openseadragonExports);

// Converts radians to degrees.
function angleToDegrees(angle){
  return angle * 180 / Math.PI;
}

// Calculates the angle of a line, in degrees.
function lineAngle(line){
  return angleToDegrees(Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]));
}

// Calculates the distance between the endpoints of a line segment.
function lineLength(line){
  return Math.sqrt(Math.pow(line[1][0] - line[0][0], 2) + Math.pow(line[1][1] - line[0][1], 2));
}

// Converts degrees to radians.
function angleToRadians(angle){
  return angle / 180 * Math.PI;
}

// Rotates a point by an angle in degrees around an origin.
function pointRotate(point, angle, origin){
  const r = angleToRadians(angle || 0);

  if (!origin || (origin[0] === 0 && origin[1] === 0)){
    return rotate(point, r);
  }
  else {
    // See: https://math.stackexchange.com/questions/1964905/rotation-around-non-zero-point
    const p0 = point.map((c, i) => c - origin[i]);
    const rotated = rotate(p0, r);
    return rotated.map((c, i) => c + origin[i]);
  }
}

function rotate(point, angle){
  // See: https://en.wikipedia.org/wiki/Cartesian_coordinate_system#Rotation
  return [(point[0] * Math.cos(angle)) - point[1] * Math.sin(angle), (point[0] * Math.sin(angle)) + point[1] * Math.cos(angle)];
}

// Determines whether a point is inside of a polygon, represented as an array of vertices.
// From https://github.com/substack/point-in-polygon/blob/master/index.js,
// based on the ray-casting algorithm from https://web.archive.org/web/20180115151705/https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
// Wikipedia: https://en.wikipedia.org/wiki/Point_in_polygon#Ray_casting_algorithm
// Returns a boolean.
function pointInPolygon(point, polygon) {
  let x = point[0],
      y = point[1],
      inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], yi = polygon[i][1],
          xj = polygon[j][0], yj = polygon[j][1];
  
    if (((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) { inside = !inside; }
  }
  
  return inside;
}

// æ¸²æŸ“æ–¹æ³•
const render = (doodle) => {
  const viewport = doodle.viewer.viewport; // osd è§†å£å¯¹è±¡
  const scale = doodle.getScale(); // ç¼©æ”¾
  const flipped = viewport.getFlip(); // ç¿»è½¬
  const angle = viewport.getRotation(true); // æ—‹è½¬è§’åº¦
  let rotation = angle * (Math.PI / 180); // æ—‹è½¬å¼§åº¦
  // å½’ä¸€åŒ–åˆ° [0, 2Ï€] èŒƒå›´
  if (rotation < 0) rotation += 2 * Math.PI;
  if (rotation > 2 * Math.PI) rotation -= 2 * Math.PI;
  // æ—‹è½¬ç¿»è½¬
  rotation = flipped ? -rotation : rotation;
  // å›¾åƒå·¦ä¸Šè§’åŽŸç‚¹ç›¸å¯¹äºŽè§†å£çš„åç§»
  const origin = viewport.pixelFromPoint(new osd.Point(0, 0), true);
  if (flipped) {
    origin.x = viewport._containerInnerSize.x - origin.x;
  }
  const tx = origin.x; // xè½´å¹³ç§»
  const ty = origin.y; // yè½´å¹³ç§»
  doodle.scale = scale;
  doodle.translate.x = tx;
  doodle.translate.y = ty;
  doodle.pixiApp.stage.x = tx;
  doodle.pixiApp.stage.y = ty;
  doodle.pixiApp.stage.scale.set(flipped ? -scale : scale, scale);
  doodle.pixiApp.stage.rotation = rotation;
  // æ›´æ–°éžç‚¹å›¾å½¢
  drawShapes(doodle);
  // Mesh
  updatePointMesh(doodle);
};
// æ›´æ–°ç‚¹çš„Mesh
const updatePointMesh = (doodle) => {
  if (!doodle.pointMesh) return
  const scale = doodle.scale;
  doodle.pointMesh.scale = 1 / scale;
  const instancePositionBuffer =
    doodle.pointMesh.geometry.attributes.aPositionOffset.buffer;
  const data = instancePositionBuffer.data;
  let count = 0;
  for (let _i in doodle.points) {
    let i = Number(_i);
    const point = doodle.points[i];
    data[count++] = point.pos[0] * scale;
    data[count++] = point.pos[1] * scale;
  }
  instancePositionBuffer.update();
};

// ç»˜åˆ¶shapes
const drawShapes = (doodle) => {
  doodle.graphics.clear();
  // å·²æœ‰å½¢çŠ¶
  for (const shape of doodle.shapes) {
    if (doodle.tempShape && doodle.tempShape.id === shape.id) continue
    if (shape.type === doodle.tools.point) continue
    drawShape(shape, doodle);
  }
  // æ–°å¢žå½¢çŠ¶
  if (doodle.tempShape) drawShape(doodle.tempShape, doodle);
  // é”šç‚¹
  drawAnchors(doodle);
};

// ç»˜åˆ¶shape
const drawShape = (shape, doodle) => {
  const isHover = doodle.hoverShape && doodle.hoverShape.id === shape.id;
  const isEdit =
    doodle.tempShape && doodle.tempShape.id && doodle.tempShape.id === shape.id;

  const shapeStrokeWidth = shape.strokeWidth ?? doodle.strokeWidth;
  const strokeWidth =
    (isHover ? shapeStrokeWidth + 1 : shapeStrokeWidth) / doodle.scale;
  const pointRadius =
    (isHover ? doodle.pointRadius + 1 : doodle.pointRadius) / doodle.scale;
  const alpha = shape.fillAlpha ?? (isEdit ? 0.2 : 0);
  const color = shape.id
    ? shape.color || doodle.defaultColor
    : shape.color || doodle.brushColor;

  const graphics = doodle.graphics;
  const pos = shape.pos;

  switch (shape.type) {
    case doodle.tools.rect:
      // çŸ©å½¢
      graphics.rect(pos[0], pos[1], pos[2], pos[3]);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      break
    case doodle.tools.polygon:
      // å¤šè¾¹å½¢
      graphics.poly(pos, !!shape.id);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      // é—­åˆé”šç‚¹
      if (!shape.id) {
        const anchorStrokeWidth = (doodle.strokeWidth + 2) / doodle.scale;
        const anchorRadius = doodle.anchorRadius / doodle.scale;
        graphics.circle(pos[0], pos[1], anchorRadius);
        graphics.stroke({
          width: anchorStrokeWidth,
          color: doodle.parseColor(color),
        });
        graphics.fill({
          color: doodle.parseColor("#FFFFFF"),
          alpha: 1,
        });
      }
      break
    case doodle.tools.circle:
      // åœ†
      graphics.circle(pos[0], pos[1], pos[2]);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      break
    case doodle.tools.ellipse:
      // æ¤­åœ†
      graphics.ellipse(pos[0], pos[1], pos[2], pos[3]);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      break
    case doodle.tools.path:
      // è·¯å¾„
      graphics.poly(pos, false);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      break
    case doodle.tools.closed_path:
      // é—­åˆè·¯å¾„
      graphics.poly(pos, !!shape.id);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha,
      });
      break
    case doodle.tools.line:
      // ç›´çº¿
      graphics.poly(pos, false);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha: 0,
      });
      break
    case doodle.tools.arrow_line:
      // ç®­å¤´ç›´çº¿
      graphics.poly(pos, false);
      // ç®­å¤´
      graphics.poly(generateArrowPath(shape, doodle), false);
      graphics.stroke({
        width: strokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(color),
        alpha: 0,
      });
      break
    case doodle.tools.point:
      // ç‚¹
      graphics.circle(pos[0], pos[1], pointRadius);
      const myStrokeWidth = (isEdit ? doodle.strokeWidth + 2 : 0) / doodle.scale;
      const fillColor = isEdit ? "#FFFFFF" : color;
      graphics.stroke({
        width: myStrokeWidth,
        color: doodle.parseColor(color),
      });
      graphics.fill({
        color: doodle.parseColor(fillColor),
        alpha: 1,
      });
      break
  }
};

// èŽ·å–ç®­å¤´çš„path
const generateArrowPath = (shape, doodle) => {
  const startPoint = [shape.pos[0], shape.pos[1]];
  const endPoint = [shape.pos[2], shape.pos[3]];
  // @ts-ignore
  const angle = lineAngle([startPoint, endPoint]);
  const referencePoint = [endPoint[0], endPoint[1] + 10 / doodle.scale];
  // @ts-ignore
  const pointA = pointRotate(referencePoint, angle + 90 + 30, endPoint);
  // @ts-ignore
  const pointB = pointRotate(referencePoint, angle + 90 - 30, endPoint);
  return [pointA[0], pointA[1], endPoint[0], endPoint[1], pointB[0], pointB[1]]
};

// ç»˜åˆ¶é”šç‚¹
const drawAnchors = (doodle) => {
  const strokeWidth = (doodle.strokeWidth + 2) / doodle.scale;
  const anchorRadius = doodle.anchorRadius / doodle.scale;
  const graphics = doodle.graphics;
  const color = doodle.tempShape?.id
    ? doodle.tempShape?.color || doodle.defaultColor
    : doodle.tempShape?.color || doodle.brushColor;
  for (const anchor of doodle.anchors) {
    graphics.circle(anchor.x, anchor.y, anchorRadius);
    graphics.stroke({
      width: strokeWidth,
      color: doodle.parseColor(color),
    });
    graphics.fill({
      color: doodle.parseColor("#FFFFFF"),
      alpha: 1,
    });
  }
};

var lodash$1 = {exports: {}};

/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;

var hasRequiredLodash;

function requireLodash () {
	if (hasRequiredLodash) return lodash$1.exports;
	hasRequiredLodash = 1;
	(function (module, exports$1) {
(function() {

		  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
		  var undefined$1;

		  /** Used as the semantic version number. */
		  var VERSION = '4.17.23';

		  /** Used as the size to enable large array optimizations. */
		  var LARGE_ARRAY_SIZE = 200;

		  /** Error message constants. */
		  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
		      FUNC_ERROR_TEXT = 'Expected a function',
		      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

		  /** Used to stand-in for `undefined` hash values. */
		  var HASH_UNDEFINED = '__lodash_hash_undefined__';

		  /** Used as the maximum memoize cache size. */
		  var MAX_MEMOIZE_SIZE = 500;

		  /** Used as the internal argument placeholder. */
		  var PLACEHOLDER = '__lodash_placeholder__';

		  /** Used to compose bitmasks for cloning. */
		  var CLONE_DEEP_FLAG = 1,
		      CLONE_FLAT_FLAG = 2,
		      CLONE_SYMBOLS_FLAG = 4;

		  /** Used to compose bitmasks for value comparisons. */
		  var COMPARE_PARTIAL_FLAG = 1,
		      COMPARE_UNORDERED_FLAG = 2;

		  /** Used to compose bitmasks for function metadata. */
		  var WRAP_BIND_FLAG = 1,
		      WRAP_BIND_KEY_FLAG = 2,
		      WRAP_CURRY_BOUND_FLAG = 4,
		      WRAP_CURRY_FLAG = 8,
		      WRAP_CURRY_RIGHT_FLAG = 16,
		      WRAP_PARTIAL_FLAG = 32,
		      WRAP_PARTIAL_RIGHT_FLAG = 64,
		      WRAP_ARY_FLAG = 128,
		      WRAP_REARG_FLAG = 256,
		      WRAP_FLIP_FLAG = 512;

		  /** Used as default options for `_.truncate`. */
		  var DEFAULT_TRUNC_LENGTH = 30,
		      DEFAULT_TRUNC_OMISSION = '...';

		  /** Used to detect hot functions by number of calls within a span of milliseconds. */
		  var HOT_COUNT = 800,
		      HOT_SPAN = 16;

		  /** Used to indicate the type of lazy iteratees. */
		  var LAZY_FILTER_FLAG = 1,
		      LAZY_MAP_FLAG = 2,
		      LAZY_WHILE_FLAG = 3;

		  /** Used as references for various `Number` constants. */
		  var INFINITY = 1 / 0,
		      MAX_SAFE_INTEGER = 9007199254740991,
		      MAX_INTEGER = 1.7976931348623157e+308,
		      NAN = 0 / 0;

		  /** Used as references for the maximum length and index of an array. */
		  var MAX_ARRAY_LENGTH = 4294967295,
		      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
		      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

		  /** Used to associate wrap methods with their bit flags. */
		  var wrapFlags = [
		    ['ary', WRAP_ARY_FLAG],
		    ['bind', WRAP_BIND_FLAG],
		    ['bindKey', WRAP_BIND_KEY_FLAG],
		    ['curry', WRAP_CURRY_FLAG],
		    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
		    ['flip', WRAP_FLIP_FLAG],
		    ['partial', WRAP_PARTIAL_FLAG],
		    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
		    ['rearg', WRAP_REARG_FLAG]
		  ];

		  /** `Object#toString` result references. */
		  var argsTag = '[object Arguments]',
		      arrayTag = '[object Array]',
		      asyncTag = '[object AsyncFunction]',
		      boolTag = '[object Boolean]',
		      dateTag = '[object Date]',
		      domExcTag = '[object DOMException]',
		      errorTag = '[object Error]',
		      funcTag = '[object Function]',
		      genTag = '[object GeneratorFunction]',
		      mapTag = '[object Map]',
		      numberTag = '[object Number]',
		      nullTag = '[object Null]',
		      objectTag = '[object Object]',
		      promiseTag = '[object Promise]',
		      proxyTag = '[object Proxy]',
		      regexpTag = '[object RegExp]',
		      setTag = '[object Set]',
		      stringTag = '[object String]',
		      symbolTag = '[object Symbol]',
		      undefinedTag = '[object Undefined]',
		      weakMapTag = '[object WeakMap]',
		      weakSetTag = '[object WeakSet]';

		  var arrayBufferTag = '[object ArrayBuffer]',
		      dataViewTag = '[object DataView]',
		      float32Tag = '[object Float32Array]',
		      float64Tag = '[object Float64Array]',
		      int8Tag = '[object Int8Array]',
		      int16Tag = '[object Int16Array]',
		      int32Tag = '[object Int32Array]',
		      uint8Tag = '[object Uint8Array]',
		      uint8ClampedTag = '[object Uint8ClampedArray]',
		      uint16Tag = '[object Uint16Array]',
		      uint32Tag = '[object Uint32Array]';

		  /** Used to match empty string literals in compiled template source. */
		  var reEmptyStringLeading = /\b__p \+= '';/g,
		      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
		      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

		  /** Used to match HTML entities and HTML characters. */
		  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
		      reUnescapedHtml = /[&<>"']/g,
		      reHasEscapedHtml = RegExp(reEscapedHtml.source),
		      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

		  /** Used to match template delimiters. */
		  var reEscape = /<%-([\s\S]+?)%>/g,
		      reEvaluate = /<%([\s\S]+?)%>/g,
		      reInterpolate = /<%=([\s\S]+?)%>/g;

		  /** Used to match property names within property paths. */
		  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
		      reIsPlainProp = /^\w*$/,
		      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

		  /**
		   * Used to match `RegExp`
		   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
		   */
		  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
		      reHasRegExpChar = RegExp(reRegExpChar.source);

		  /** Used to match leading whitespace. */
		  var reTrimStart = /^\s+/;

		  /** Used to match a single whitespace character. */
		  var reWhitespace = /\s/;

		  /** Used to match wrap detail comments. */
		  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
		      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
		      reSplitDetails = /,? & /;

		  /** Used to match words composed of alphanumeric characters. */
		  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

		  /**
		   * Used to validate the `validate` option in `_.template` variable.
		   *
		   * Forbids characters which could potentially change the meaning of the function argument definition:
		   * - "()," (modification of function parameters)
		   * - "=" (default value)
		   * - "[]{}" (destructuring of function parameters)
		   * - "/" (beginning of a comment)
		   * - whitespace
		   */
		  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

		  /** Used to match backslashes in property paths. */
		  var reEscapeChar = /\\(\\)?/g;

		  /**
		   * Used to match
		   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
		   */
		  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

		  /** Used to match `RegExp` flags from their coerced string values. */
		  var reFlags = /\w*$/;

		  /** Used to detect bad signed hexadecimal string values. */
		  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

		  /** Used to detect binary string values. */
		  var reIsBinary = /^0b[01]+$/i;

		  /** Used to detect host constructors (Safari). */
		  var reIsHostCtor = /^\[object .+?Constructor\]$/;

		  /** Used to detect octal string values. */
		  var reIsOctal = /^0o[0-7]+$/i;

		  /** Used to detect unsigned integer values. */
		  var reIsUint = /^(?:0|[1-9]\d*)$/;

		  /** Used to match Latin Unicode letters (excluding mathematical operators). */
		  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

		  /** Used to ensure capturing order of template delimiters. */
		  var reNoMatch = /($^)/;

		  /** Used to match unescaped characters in compiled string literals. */
		  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

		  /** Used to compose unicode character classes. */
		  var rsAstralRange = '\\ud800-\\udfff',
		      rsComboMarksRange = '\\u0300-\\u036f',
		      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
		      rsComboSymbolsRange = '\\u20d0-\\u20ff',
		      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
		      rsDingbatRange = '\\u2700-\\u27bf',
		      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
		      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
		      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
		      rsPunctuationRange = '\\u2000-\\u206f',
		      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
		      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
		      rsVarRange = '\\ufe0e\\ufe0f',
		      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

		  /** Used to compose unicode capture groups. */
		  var rsApos = "['\u2019]",
		      rsAstral = '[' + rsAstralRange + ']',
		      rsBreak = '[' + rsBreakRange + ']',
		      rsCombo = '[' + rsComboRange + ']',
		      rsDigits = '\\d+',
		      rsDingbat = '[' + rsDingbatRange + ']',
		      rsLower = '[' + rsLowerRange + ']',
		      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
		      rsFitz = '\\ud83c[\\udffb-\\udfff]',
		      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
		      rsNonAstral = '[^' + rsAstralRange + ']',
		      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
		      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
		      rsUpper = '[' + rsUpperRange + ']',
		      rsZWJ = '\\u200d';

		  /** Used to compose unicode regexes. */
		  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
		      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
		      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
		      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
		      reOptMod = rsModifier + '?',
		      rsOptVar = '[' + rsVarRange + ']?',
		      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
		      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
		      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
		      rsSeq = rsOptVar + reOptMod + rsOptJoin,
		      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
		      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

		  /** Used to match apostrophes. */
		  var reApos = RegExp(rsApos, 'g');

		  /**
		   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
		   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
		   */
		  var reComboMark = RegExp(rsCombo, 'g');

		  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
		  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

		  /** Used to match complex or compound words. */
		  var reUnicodeWord = RegExp([
		    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
		    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
		    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
		    rsUpper + '+' + rsOptContrUpper,
		    rsOrdUpper,
		    rsOrdLower,
		    rsDigits,
		    rsEmoji
		  ].join('|'), 'g');

		  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
		  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

		  /** Used to detect strings that need a more robust regexp to match words. */
		  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

		  /** Used to assign default `context` object properties. */
		  var contextProps = [
		    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
		    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
		    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
		    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
		    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
		  ];

		  /** Used to make template sourceURLs easier to identify. */
		  var templateCounter = -1;

		  /** Used to identify `toStringTag` values of typed arrays. */
		  var typedArrayTags = {};
		  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
		  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
		  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
		  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
		  typedArrayTags[uint32Tag] = true;
		  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
		  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
		  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
		  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
		  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
		  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
		  typedArrayTags[setTag] = typedArrayTags[stringTag] =
		  typedArrayTags[weakMapTag] = false;

		  /** Used to identify `toStringTag` values supported by `_.clone`. */
		  var cloneableTags = {};
		  cloneableTags[argsTag] = cloneableTags[arrayTag] =
		  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
		  cloneableTags[boolTag] = cloneableTags[dateTag] =
		  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
		  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
		  cloneableTags[int32Tag] = cloneableTags[mapTag] =
		  cloneableTags[numberTag] = cloneableTags[objectTag] =
		  cloneableTags[regexpTag] = cloneableTags[setTag] =
		  cloneableTags[stringTag] = cloneableTags[symbolTag] =
		  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
		  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
		  cloneableTags[errorTag] = cloneableTags[funcTag] =
		  cloneableTags[weakMapTag] = false;

		  /** Used to map Latin Unicode letters to basic Latin letters. */
		  var deburredLetters = {
		    // Latin-1 Supplement block.
		    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
		    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
		    '\xc7': 'C',  '\xe7': 'c',
		    '\xd0': 'D',  '\xf0': 'd',
		    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
		    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
		    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
		    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
		    '\xd1': 'N',  '\xf1': 'n',
		    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
		    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
		    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
		    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
		    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
		    '\xc6': 'Ae', '\xe6': 'ae',
		    '\xde': 'Th', '\xfe': 'th',
		    '\xdf': 'ss',
		    // Latin Extended-A block.
		    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
		    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
		    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
		    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
		    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
		    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
		    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
		    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
		    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
		    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
		    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
		    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
		    '\u0134': 'J',  '\u0135': 'j',
		    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
		    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
		    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
		    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
		    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
		    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
		    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
		    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
		    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
		    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
		    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
		    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
		    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
		    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
		    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
		    '\u0174': 'W',  '\u0175': 'w',
		    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
		    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
		    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
		    '\u0132': 'IJ', '\u0133': 'ij',
		    '\u0152': 'Oe', '\u0153': 'oe',
		    '\u0149': "'n", '\u017f': 's'
		  };

		  /** Used to map characters to HTML entities. */
		  var htmlEscapes = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#39;'
		  };

		  /** Used to map HTML entities to characters. */
		  var htmlUnescapes = {
		    '&amp;': '&',
		    '&lt;': '<',
		    '&gt;': '>',
		    '&quot;': '"',
		    '&#39;': "'"
		  };

		  /** Used to escape characters for inclusion in compiled string literals. */
		  var stringEscapes = {
		    '\\': '\\',
		    "'": "'",
		    '\n': 'n',
		    '\r': 'r',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  /** Built-in method references without a dependency on `root`. */
		  var freeParseFloat = parseFloat,
		      freeParseInt = parseInt;

		  /** Detect free variable `global` from Node.js. */
		  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

		  /** Detect free variable `self`. */
		  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

		  /** Used as a reference to the global object. */
		  var root = freeGlobal || freeSelf || Function('return this')();

		  /** Detect free variable `exports`. */
		  var freeExports = exports$1 && !exports$1.nodeType && exports$1;

		  /** Detect free variable `module`. */
		  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		  /** Detect the popular CommonJS extension `module.exports`. */
		  var moduleExports = freeModule && freeModule.exports === freeExports;

		  /** Detect free variable `process` from Node.js. */
		  var freeProcess = moduleExports && freeGlobal.process;

		  /** Used to access faster Node.js helpers. */
		  var nodeUtil = (function() {
		    try {
		      // Use `util.types` for Node.js 10+.
		      var types = freeModule && freeModule.require && freeModule.require('util').types;

		      if (types) {
		        return types;
		      }

		      // Legacy `process.binding('util')` for Node.js < 10.
		      return freeProcess && freeProcess.binding && freeProcess.binding('util');
		    } catch (e) {}
		  }());

		  /* Node.js helper references. */
		  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
		      nodeIsDate = nodeUtil && nodeUtil.isDate,
		      nodeIsMap = nodeUtil && nodeUtil.isMap,
		      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
		      nodeIsSet = nodeUtil && nodeUtil.isSet,
		      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

		  /*--------------------------------------------------------------------------*/

		  /**
		   * A faster alternative to `Function#apply`, this function invokes `func`
		   * with the `this` binding of `thisArg` and the arguments of `args`.
		   *
		   * @private
		   * @param {Function} func The function to invoke.
		   * @param {*} thisArg The `this` binding of `func`.
		   * @param {Array} args The arguments to invoke `func` with.
		   * @returns {*} Returns the result of `func`.
		   */
		  function apply(func, thisArg, args) {
		    switch (args.length) {
		      case 0: return func.call(thisArg);
		      case 1: return func.call(thisArg, args[0]);
		      case 2: return func.call(thisArg, args[0], args[1]);
		      case 3: return func.call(thisArg, args[0], args[1], args[2]);
		    }
		    return func.apply(thisArg, args);
		  }

		  /**
		   * A specialized version of `baseAggregator` for arrays.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} setter The function to set `accumulator` values.
		   * @param {Function} iteratee The iteratee to transform keys.
		   * @param {Object} accumulator The initial aggregated object.
		   * @returns {Function} Returns `accumulator`.
		   */
		  function arrayAggregator(array, setter, iteratee, accumulator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      var value = array[index];
		      setter(accumulator, value, iteratee(value), array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.forEach` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEach(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (iteratee(array[index], index, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.forEachRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayEachRight(array, iteratee) {
		    var length = array == null ? 0 : array.length;

		    while (length--) {
		      if (iteratee(array[length], length, array) === false) {
		        break;
		      }
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.every` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if all elements pass the predicate check,
		   *  else `false`.
		   */
		  function arrayEvery(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (!predicate(array[index], index, array)) {
		        return false;
		      }
		    }
		    return true;
		  }

		  /**
		   * A specialized version of `_.filter` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {Array} Returns the new filtered array.
		   */
		  function arrayFilter(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (predicate(value, index, array)) {
		        result[resIndex++] = value;
		      }
		    }
		    return result;
		  }

		  /**
		   * A specialized version of `_.includes` for arrays without support for
		   * specifying an index to search from.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludes(array, value) {
		    var length = array == null ? 0 : array.length;
		    return !!length && baseIndexOf(array, value, 0) > -1;
		  }

		  /**
		   * This function is like `arrayIncludes` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} [array] The array to inspect.
		   * @param {*} target The value to search for.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {boolean} Returns `true` if `target` is found, else `false`.
		   */
		  function arrayIncludesWith(array, value, comparator) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (comparator(value, array[index])) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * A specialized version of `_.map` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the new mapped array.
		   */
		  function arrayMap(array, iteratee) {
		    var index = -1,
		        length = array == null ? 0 : array.length,
		        result = Array(length);

		    while (++index < length) {
		      result[index] = iteratee(array[index], index, array);
		    }
		    return result;
		  }

		  /**
		   * Appends the elements of `values` to `array`.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {Array} values The values to append.
		   * @returns {Array} Returns `array`.
		   */
		  function arrayPush(array, values) {
		    var index = -1,
		        length = values.length,
		        offset = array.length;

		    while (++index < length) {
		      array[offset + index] = values[index];
		    }
		    return array;
		  }

		  /**
		   * A specialized version of `_.reduce` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the first element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduce(array, iteratee, accumulator, initAccum) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    if (initAccum && length) {
		      accumulator = array[++index];
		    }
		    while (++index < length) {
		      accumulator = iteratee(accumulator, array[index], index, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.reduceRight` for arrays without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} [accumulator] The initial value.
		   * @param {boolean} [initAccum] Specify using the last element of `array` as
		   *  the initial value.
		   * @returns {*} Returns the accumulated value.
		   */
		  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
		    var length = array == null ? 0 : array.length;
		    if (initAccum && length) {
		      accumulator = array[--length];
		    }
		    while (length--) {
		      accumulator = iteratee(accumulator, array[length], length, array);
		    }
		    return accumulator;
		  }

		  /**
		   * A specialized version of `_.some` for arrays without support for iteratee
		   * shorthands.
		   *
		   * @private
		   * @param {Array} [array] The array to iterate over.
		   * @param {Function} predicate The function invoked per iteration.
		   * @returns {boolean} Returns `true` if any element passes the predicate check,
		   *  else `false`.
		   */
		  function arraySome(array, predicate) {
		    var index = -1,
		        length = array == null ? 0 : array.length;

		    while (++index < length) {
		      if (predicate(array[index], index, array)) {
		        return true;
		      }
		    }
		    return false;
		  }

		  /**
		   * Gets the size of an ASCII `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  var asciiSize = baseProperty('length');

		  /**
		   * Converts an ASCII `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function asciiToArray(string) {
		    return string.split('');
		  }

		  /**
		   * Splits an ASCII `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function asciiWords(string) {
		    return string.match(reAsciiWord) || [];
		  }

		  /**
		   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
		   * without support for iteratee shorthands, which iterates over `collection`
		   * using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the found element or its key, else `undefined`.
		   */
		  function baseFindKey(collection, predicate, eachFunc) {
		    var result;
		    eachFunc(collection, function(value, key, collection) {
		      if (predicate(value, key, collection)) {
		        result = key;
		        return false;
		      }
		    });
		    return result;
		  }

		  /**
		   * The base implementation of `_.findIndex` and `_.findLastIndex` without
		   * support for iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {Function} predicate The function invoked per iteration.
		   * @param {number} fromIndex The index to search from.
		   * @param {boolean} [fromRight] Specify iterating from right to left.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseFindIndex(array, predicate, fromIndex, fromRight) {
		    var length = array.length,
		        index = fromIndex + (fromRight ? 1 : -1);

		    while ((fromRight ? index-- : ++index < length)) {
		      if (predicate(array[index], index, array)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOf(array, value, fromIndex) {
		    return value === value
		      ? strictIndexOf(array, value, fromIndex)
		      : baseFindIndex(array, baseIsNaN, fromIndex);
		  }

		  /**
		   * This function is like `baseIndexOf` except that it accepts a comparator.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @param {Function} comparator The comparator invoked per element.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function baseIndexOfWith(array, value, fromIndex, comparator) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (comparator(array[index], value)) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * The base implementation of `_.isNaN` without support for number objects.
		   *
		   * @private
		   * @param {*} value The value to check.
		   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		   */
		  function baseIsNaN(value) {
		    return value !== value;
		  }

		  /**
		   * The base implementation of `_.mean` and `_.meanBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the mean.
		   */
		  function baseMean(array, iteratee) {
		    var length = array == null ? 0 : array.length;
		    return length ? (baseSum(array, iteratee) / length) : NAN;
		  }

		  /**
		   * The base implementation of `_.property` without support for deep paths.
		   *
		   * @private
		   * @param {string} key The key of the property to get.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function baseProperty(key) {
		    return function(object) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.propertyOf` without support for deep paths.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @returns {Function} Returns the new accessor function.
		   */
		  function basePropertyOf(object) {
		    return function(key) {
		      return object == null ? undefined$1 : object[key];
		    };
		  }

		  /**
		   * The base implementation of `_.reduce` and `_.reduceRight`, without support
		   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
		   *
		   * @private
		   * @param {Array|Object} collection The collection to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @param {*} accumulator The initial value.
		   * @param {boolean} initAccum Specify using the first or last element of
		   *  `collection` as the initial value.
		   * @param {Function} eachFunc The function to iterate over `collection`.
		   * @returns {*} Returns the accumulated value.
		   */
		  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
		    eachFunc(collection, function(value, index, collection) {
		      accumulator = initAccum
		        ? (initAccum = false, value)
		        : iteratee(accumulator, value, index, collection);
		    });
		    return accumulator;
		  }

		  /**
		   * The base implementation of `_.sortBy` which uses `comparer` to define the
		   * sort order of `array` and replaces criteria objects with their corresponding
		   * values.
		   *
		   * @private
		   * @param {Array} array The array to sort.
		   * @param {Function} comparer The function to define sort order.
		   * @returns {Array} Returns `array`.
		   */
		  function baseSortBy(array, comparer) {
		    var length = array.length;

		    array.sort(comparer);
		    while (length--) {
		      array[length] = array[length].value;
		    }
		    return array;
		  }

		  /**
		   * The base implementation of `_.sum` and `_.sumBy` without support for
		   * iteratee shorthands.
		   *
		   * @private
		   * @param {Array} array The array to iterate over.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {number} Returns the sum.
		   */
		  function baseSum(array, iteratee) {
		    var result,
		        index = -1,
		        length = array.length;

		    while (++index < length) {
		      var current = iteratee(array[index]);
		      if (current !== undefined$1) {
		        result = result === undefined$1 ? current : (result + current);
		      }
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.times` without support for iteratee shorthands
		   * or max array length checks.
		   *
		   * @private
		   * @param {number} n The number of times to invoke `iteratee`.
		   * @param {Function} iteratee The function invoked per iteration.
		   * @returns {Array} Returns the array of results.
		   */
		  function baseTimes(n, iteratee) {
		    var index = -1,
		        result = Array(n);

		    while (++index < n) {
		      result[index] = iteratee(index);
		    }
		    return result;
		  }

		  /**
		   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
		   * of key-value pairs for `object` corresponding to the property names of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the key-value pairs.
		   */
		  function baseToPairs(object, props) {
		    return arrayMap(props, function(key) {
		      return [key, object[key]];
		    });
		  }

		  /**
		   * The base implementation of `_.trim`.
		   *
		   * @private
		   * @param {string} string The string to trim.
		   * @returns {string} Returns the trimmed string.
		   */
		  function baseTrim(string) {
		    return string
		      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
		      : string;
		  }

		  /**
		   * The base implementation of `_.unary` without support for storing metadata.
		   *
		   * @private
		   * @param {Function} func The function to cap arguments for.
		   * @returns {Function} Returns the new capped function.
		   */
		  function baseUnary(func) {
		    return function(value) {
		      return func(value);
		    };
		  }

		  /**
		   * The base implementation of `_.values` and `_.valuesIn` which creates an
		   * array of `object` property values corresponding to the property names
		   * of `props`.
		   *
		   * @private
		   * @param {Object} object The object to query.
		   * @param {Array} props The property names to get values for.
		   * @returns {Object} Returns the array of property values.
		   */
		  function baseValues(object, props) {
		    return arrayMap(props, function(key) {
		      return object[key];
		    });
		  }

		  /**
		   * Checks if a `cache` value for `key` exists.
		   *
		   * @private
		   * @param {Object} cache The cache to query.
		   * @param {string} key The key of the entry to check.
		   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		   */
		  function cacheHas(cache, key) {
		    return cache.has(key);
		  }

		  /**
		   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the first unmatched string symbol.
		   */
		  function charsStartIndex(strSymbols, chrSymbols) {
		    var index = -1,
		        length = strSymbols.length;

		    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
		   * that is not found in the character symbols.
		   *
		   * @private
		   * @param {Array} strSymbols The string symbols to inspect.
		   * @param {Array} chrSymbols The character symbols to find.
		   * @returns {number} Returns the index of the last unmatched string symbol.
		   */
		  function charsEndIndex(strSymbols, chrSymbols) {
		    var index = strSymbols.length;

		    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
		    return index;
		  }

		  /**
		   * Gets the number of `placeholder` occurrences in `array`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} placeholder The placeholder to search for.
		   * @returns {number} Returns the placeholder count.
		   */
		  function countHolders(array, placeholder) {
		    var length = array.length,
		        result = 0;

		    while (length--) {
		      if (array[length] === placeholder) {
		        ++result;
		      }
		    }
		    return result;
		  }

		  /**
		   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
		   * letters to basic Latin letters.
		   *
		   * @private
		   * @param {string} letter The matched letter to deburr.
		   * @returns {string} Returns the deburred letter.
		   */
		  var deburrLetter = basePropertyOf(deburredLetters);

		  /**
		   * Used by `_.escape` to convert characters to HTML entities.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  var escapeHtmlChar = basePropertyOf(htmlEscapes);

		  /**
		   * Used by `_.template` to escape characters for inclusion in compiled string literals.
		   *
		   * @private
		   * @param {string} chr The matched character to escape.
		   * @returns {string} Returns the escaped character.
		   */
		  function escapeStringChar(chr) {
		    return '\\' + stringEscapes[chr];
		  }

		  /**
		   * Gets the value at `key` of `object`.
		   *
		   * @private
		   * @param {Object} [object] The object to query.
		   * @param {string} key The key of the property to get.
		   * @returns {*} Returns the property value.
		   */
		  function getValue(object, key) {
		    return object == null ? undefined$1 : object[key];
		  }

		  /**
		   * Checks if `string` contains Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
		   */
		  function hasUnicode(string) {
		    return reHasUnicode.test(string);
		  }

		  /**
		   * Checks if `string` contains a word composed of Unicode symbols.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {boolean} Returns `true` if a word is found, else `false`.
		   */
		  function hasUnicodeWord(string) {
		    return reHasUnicodeWord.test(string);
		  }

		  /**
		   * Converts `iterator` to an array.
		   *
		   * @private
		   * @param {Object} iterator The iterator to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function iteratorToArray(iterator) {
		    var data,
		        result = [];

		    while (!(data = iterator.next()).done) {
		      result.push(data.value);
		    }
		    return result;
		  }

		  /**
		   * Converts `map` to its key-value pairs.
		   *
		   * @private
		   * @param {Object} map The map to convert.
		   * @returns {Array} Returns the key-value pairs.
		   */
		  function mapToArray(map) {
		    var index = -1,
		        result = Array(map.size);

		    map.forEach(function(value, key) {
		      result[++index] = [key, value];
		    });
		    return result;
		  }

		  /**
		   * Creates a unary function that invokes `func` with its argument transformed.
		   *
		   * @private
		   * @param {Function} func The function to wrap.
		   * @param {Function} transform The argument transform.
		   * @returns {Function} Returns the new function.
		   */
		  function overArg(func, transform) {
		    return function(arg) {
		      return func(transform(arg));
		    };
		  }

		  /**
		   * Replaces all `placeholder` elements in `array` with an internal placeholder
		   * and returns an array of their indexes.
		   *
		   * @private
		   * @param {Array} array The array to modify.
		   * @param {*} placeholder The placeholder to replace.
		   * @returns {Array} Returns the new array of placeholder indexes.
		   */
		  function replaceHolders(array, placeholder) {
		    var index = -1,
		        length = array.length,
		        resIndex = 0,
		        result = [];

		    while (++index < length) {
		      var value = array[index];
		      if (value === placeholder || value === PLACEHOLDER) {
		        array[index] = PLACEHOLDER;
		        result[resIndex++] = index;
		      }
		    }
		    return result;
		  }

		  /**
		   * Converts `set` to an array of its values.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the values.
		   */
		  function setToArray(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = value;
		    });
		    return result;
		  }

		  /**
		   * Converts `set` to its value-value pairs.
		   *
		   * @private
		   * @param {Object} set The set to convert.
		   * @returns {Array} Returns the value-value pairs.
		   */
		  function setToPairs(set) {
		    var index = -1,
		        result = Array(set.size);

		    set.forEach(function(value) {
		      result[++index] = [value, value];
		    });
		    return result;
		  }

		  /**
		   * A specialized version of `_.indexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictIndexOf(array, value, fromIndex) {
		    var index = fromIndex - 1,
		        length = array.length;

		    while (++index < length) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return -1;
		  }

		  /**
		   * A specialized version of `_.lastIndexOf` which performs strict equality
		   * comparisons of values, i.e. `===`.
		   *
		   * @private
		   * @param {Array} array The array to inspect.
		   * @param {*} value The value to search for.
		   * @param {number} fromIndex The index to search from.
		   * @returns {number} Returns the index of the matched value, else `-1`.
		   */
		  function strictLastIndexOf(array, value, fromIndex) {
		    var index = fromIndex + 1;
		    while (index--) {
		      if (array[index] === value) {
		        return index;
		      }
		    }
		    return index;
		  }

		  /**
		   * Gets the number of symbols in `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the string size.
		   */
		  function stringSize(string) {
		    return hasUnicode(string)
		      ? unicodeSize(string)
		      : asciiSize(string);
		  }

		  /**
		   * Converts `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function stringToArray(string) {
		    return hasUnicode(string)
		      ? unicodeToArray(string)
		      : asciiToArray(string);
		  }

		  /**
		   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
		   * character of `string`.
		   *
		   * @private
		   * @param {string} string The string to inspect.
		   * @returns {number} Returns the index of the last non-whitespace character.
		   */
		  function trimmedEndIndex(string) {
		    var index = string.length;

		    while (index-- && reWhitespace.test(string.charAt(index))) {}
		    return index;
		  }

		  /**
		   * Used by `_.unescape` to convert HTML entities to characters.
		   *
		   * @private
		   * @param {string} chr The matched character to unescape.
		   * @returns {string} Returns the unescaped character.
		   */
		  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

		  /**
		   * Gets the size of a Unicode `string`.
		   *
		   * @private
		   * @param {string} string The string inspect.
		   * @returns {number} Returns the string size.
		   */
		  function unicodeSize(string) {
		    var result = reUnicode.lastIndex = 0;
		    while (reUnicode.test(string)) {
		      ++result;
		    }
		    return result;
		  }

		  /**
		   * Converts a Unicode `string` to an array.
		   *
		   * @private
		   * @param {string} string The string to convert.
		   * @returns {Array} Returns the converted array.
		   */
		  function unicodeToArray(string) {
		    return string.match(reUnicode) || [];
		  }

		  /**
		   * Splits a Unicode `string` into an array of its words.
		   *
		   * @private
		   * @param {string} The string to inspect.
		   * @returns {Array} Returns the words of `string`.
		   */
		  function unicodeWords(string) {
		    return string.match(reUnicodeWord) || [];
		  }

		  /*--------------------------------------------------------------------------*/

		  /**
		   * Create a new pristine `lodash` function using the `context` object.
		   *
		   * @static
		   * @memberOf _
		   * @since 1.1.0
		   * @category Util
		   * @param {Object} [context=root] The context object.
		   * @returns {Function} Returns a new `lodash` function.
		   * @example
		   *
		   * _.mixin({ 'foo': _.constant('foo') });
		   *
		   * var lodash = _.runInContext();
		   * lodash.mixin({ 'bar': lodash.constant('bar') });
		   *
		   * _.isFunction(_.foo);
		   * // => true
		   * _.isFunction(_.bar);
		   * // => false
		   *
		   * lodash.isFunction(lodash.foo);
		   * // => false
		   * lodash.isFunction(lodash.bar);
		   * // => true
		   *
		   * // Create a suped-up `defer` in Node.js.
		   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
		   */
		  var runInContext = (function runInContext(context) {
		    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

		    /** Built-in constructor references. */
		    var Array = context.Array,
		        Date = context.Date,
		        Error = context.Error,
		        Function = context.Function,
		        Math = context.Math,
		        Object = context.Object,
		        RegExp = context.RegExp,
		        String = context.String,
		        TypeError = context.TypeError;

		    /** Used for built-in method references. */
		    var arrayProto = Array.prototype,
		        funcProto = Function.prototype,
		        objectProto = Object.prototype;

		    /** Used to detect overreaching core-js shims. */
		    var coreJsData = context['__core-js_shared__'];

		    /** Used to resolve the decompiled source of functions. */
		    var funcToString = funcProto.toString;

		    /** Used to check objects for own properties. */
		    var hasOwnProperty = objectProto.hasOwnProperty;

		    /** Used to generate unique IDs. */
		    var idCounter = 0;

		    /** Used to detect methods masquerading as native. */
		    var maskSrcKey = (function() {
		      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
		      return uid ? ('Symbol(src)_1.' + uid) : '';
		    }());

		    /**
		     * Used to resolve the
		     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
		     * of values.
		     */
		    var nativeObjectToString = objectProto.toString;

		    /** Used to infer the `Object` constructor. */
		    var objectCtorString = funcToString.call(Object);

		    /** Used to restore the original `_` reference in `_.noConflict`. */
		    var oldDash = root._;

		    /** Used to detect if a method is native. */
		    var reIsNative = RegExp('^' +
		      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
		      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
		    );

		    /** Built-in value references. */
		    var Buffer = moduleExports ? context.Buffer : undefined$1,
		        Symbol = context.Symbol,
		        Uint8Array = context.Uint8Array,
		        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
		        getPrototype = overArg(Object.getPrototypeOf, Object),
		        objectCreate = Object.create,
		        propertyIsEnumerable = objectProto.propertyIsEnumerable,
		        splice = arrayProto.splice,
		        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
		        symIterator = Symbol ? Symbol.iterator : undefined$1,
		        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

		    var defineProperty = (function() {
		      try {
		        var func = getNative(Object, 'defineProperty');
		        func({}, '', {});
		        return func;
		      } catch (e) {}
		    }());

		    /** Mocked built-ins. */
		    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
		        ctxNow = Date && Date.now !== root.Date.now && Date.now,
		        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

		    /* Built-in method references for those with the same name as other `lodash` methods. */
		    var nativeCeil = Math.ceil,
		        nativeFloor = Math.floor,
		        nativeGetSymbols = Object.getOwnPropertySymbols,
		        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
		        nativeIsFinite = context.isFinite,
		        nativeJoin = arrayProto.join,
		        nativeKeys = overArg(Object.keys, Object),
		        nativeMax = Math.max,
		        nativeMin = Math.min,
		        nativeNow = Date.now,
		        nativeParseInt = context.parseInt,
		        nativeRandom = Math.random,
		        nativeReverse = arrayProto.reverse;

		    /* Built-in method references that are verified to be native. */
		    var DataView = getNative(context, 'DataView'),
		        Map = getNative(context, 'Map'),
		        Promise = getNative(context, 'Promise'),
		        Set = getNative(context, 'Set'),
		        WeakMap = getNative(context, 'WeakMap'),
		        nativeCreate = getNative(Object, 'create');

		    /** Used to store function metadata. */
		    var metaMap = WeakMap && new WeakMap;

		    /** Used to lookup unminified function names. */
		    var realNames = {};

		    /** Used to detect maps, sets, and weakmaps. */
		    var dataViewCtorString = toSource(DataView),
		        mapCtorString = toSource(Map),
		        promiseCtorString = toSource(Promise),
		        setCtorString = toSource(Set),
		        weakMapCtorString = toSource(WeakMap);

		    /** Used to convert symbols to primitives and strings. */
		    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
		        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
		        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` object which wraps `value` to enable implicit method
		     * chain sequences. Methods that operate on and return arrays, collections,
		     * and functions can be chained together. Methods that retrieve a single value
		     * or may return a primitive value will automatically end the chain sequence
		     * and return the unwrapped value. Otherwise, the value must be unwrapped
		     * with `_#value`.
		     *
		     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
		     * enabled using `_.chain`.
		     *
		     * The execution of chained methods is lazy, that is, it's deferred until
		     * `_#value` is implicitly or explicitly called.
		     *
		     * Lazy evaluation allows several methods to support shortcut fusion.
		     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
		     * the creation of intermediate arrays and can greatly reduce the number of
		     * iteratee executions. Sections of a chain sequence qualify for shortcut
		     * fusion if the section is applied to an array and iteratees accept only
		     * one argument. The heuristic for whether a section qualifies for shortcut
		     * fusion is subject to change.
		     *
		     * Chaining is supported in custom builds as long as the `_#value` method is
		     * directly or indirectly included in the build.
		     *
		     * In addition to lodash methods, wrappers have `Array` and `String` methods.
		     *
		     * The wrapper `Array` methods are:
		     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
		     *
		     * The wrapper `String` methods are:
		     * `replace` and `split`
		     *
		     * The wrapper methods that support shortcut fusion are:
		     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
		     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
		     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
		     *
		     * The chainable wrapper methods are:
		     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
		     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
		     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
		     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
		     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
		     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
		     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
		     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
		     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
		     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
		     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
		     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
		     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
		     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
		     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
		     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
		     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
		     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
		     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
		     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
		     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
		     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
		     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
		     * `zipObject`, `zipObjectDeep`, and `zipWith`
		     *
		     * The wrapper methods that are **not** chainable by default are:
		     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
		     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
		     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
		     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
		     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
		     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
		     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
		     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
		     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
		     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
		     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
		     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
		     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
		     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
		     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
		     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
		     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
		     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
		     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
		     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
		     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
		     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
		     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
		     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
		     * `upperFirst`, `value`, and `words`
		     *
		     * @name _
		     * @constructor
		     * @category Seq
		     * @param {*} value The value to wrap in a `lodash` instance.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2, 3]);
		     *
		     * // Returns an unwrapped value.
		     * wrapped.reduce(_.add);
		     * // => 6
		     *
		     * // Returns a wrapped value.
		     * var squares = wrapped.map(square);
		     *
		     * _.isArray(squares);
		     * // => false
		     *
		     * _.isArray(squares.value());
		     * // => true
		     */
		    function lodash(value) {
		      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
		        if (value instanceof LodashWrapper) {
		          return value;
		        }
		        if (hasOwnProperty.call(value, '__wrapped__')) {
		          return wrapperClone(value);
		        }
		      }
		      return new LodashWrapper(value);
		    }

		    /**
		     * The base implementation of `_.create` without support for assigning
		     * properties to the created object.
		     *
		     * @private
		     * @param {Object} proto The object to inherit from.
		     * @returns {Object} Returns the new object.
		     */
		    var baseCreate = (function() {
		      function object() {}
		      return function(proto) {
		        if (!isObject(proto)) {
		          return {};
		        }
		        if (objectCreate) {
		          return objectCreate(proto);
		        }
		        object.prototype = proto;
		        var result = new object;
		        object.prototype = undefined$1;
		        return result;
		      };
		    }());

		    /**
		     * The function whose prototype chain sequence wrappers inherit from.
		     *
		     * @private
		     */
		    function baseLodash() {
		      // No operation performed.
		    }

		    /**
		     * The base constructor for creating `lodash` wrapper objects.
		     *
		     * @private
		     * @param {*} value The value to wrap.
		     * @param {boolean} [chainAll] Enable explicit method chain sequences.
		     */
		    function LodashWrapper(value, chainAll) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__chain__ = !!chainAll;
		      this.__index__ = 0;
		      this.__values__ = undefined$1;
		    }

		    /**
		     * By default, the template delimiters used by lodash are like those in
		     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
		     * following template settings to use alternative delimiters.
		     *
		     * @static
		     * @memberOf _
		     * @type {Object}
		     */
		    lodash.templateSettings = {

		      /**
		       * Used to detect `data` property values to be HTML-escaped.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'escape': reEscape,

		      /**
		       * Used to detect code to be evaluated.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'evaluate': reEvaluate,

		      /**
		       * Used to detect `data` property values to inject.
		       *
		       * @memberOf _.templateSettings
		       * @type {RegExp}
		       */
		      'interpolate': reInterpolate,

		      /**
		       * Used to reference the data object in the template text.
		       *
		       * @memberOf _.templateSettings
		       * @type {string}
		       */
		      'variable': '',

		      /**
		       * Used to import variables into the compiled template.
		       *
		       * @memberOf _.templateSettings
		       * @type {Object}
		       */
		      'imports': {

		        /**
		         * A reference to the `lodash` function.
		         *
		         * @memberOf _.templateSettings.imports
		         * @type {Function}
		         */
		        '_': lodash
		      }
		    };

		    // Ensure wrappers are instances of `baseLodash`.
		    lodash.prototype = baseLodash.prototype;
		    lodash.prototype.constructor = lodash;

		    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
		    LodashWrapper.prototype.constructor = LodashWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
		     *
		     * @private
		     * @constructor
		     * @param {*} value The value to wrap.
		     */
		    function LazyWrapper(value) {
		      this.__wrapped__ = value;
		      this.__actions__ = [];
		      this.__dir__ = 1;
		      this.__filtered__ = false;
		      this.__iteratees__ = [];
		      this.__takeCount__ = MAX_ARRAY_LENGTH;
		      this.__views__ = [];
		    }

		    /**
		     * Creates a clone of the lazy wrapper object.
		     *
		     * @private
		     * @name clone
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the cloned `LazyWrapper` object.
		     */
		    function lazyClone() {
		      var result = new LazyWrapper(this.__wrapped__);
		      result.__actions__ = copyArray(this.__actions__);
		      result.__dir__ = this.__dir__;
		      result.__filtered__ = this.__filtered__;
		      result.__iteratees__ = copyArray(this.__iteratees__);
		      result.__takeCount__ = this.__takeCount__;
		      result.__views__ = copyArray(this.__views__);
		      return result;
		    }

		    /**
		     * Reverses the direction of lazy iteration.
		     *
		     * @private
		     * @name reverse
		     * @memberOf LazyWrapper
		     * @returns {Object} Returns the new reversed `LazyWrapper` object.
		     */
		    function lazyReverse() {
		      if (this.__filtered__) {
		        var result = new LazyWrapper(this);
		        result.__dir__ = -1;
		        result.__filtered__ = true;
		      } else {
		        result = this.clone();
		        result.__dir__ *= -1;
		      }
		      return result;
		    }

		    /**
		     * Extracts the unwrapped value from its lazy wrapper.
		     *
		     * @private
		     * @name value
		     * @memberOf LazyWrapper
		     * @returns {*} Returns the unwrapped value.
		     */
		    function lazyValue() {
		      var array = this.__wrapped__.value(),
		          dir = this.__dir__,
		          isArr = isArray(array),
		          isRight = dir < 0,
		          arrLength = isArr ? array.length : 0,
		          view = getView(0, arrLength, this.__views__),
		          start = view.start,
		          end = view.end,
		          length = end - start,
		          index = isRight ? end : (start - 1),
		          iteratees = this.__iteratees__,
		          iterLength = iteratees.length,
		          resIndex = 0,
		          takeCount = nativeMin(length, this.__takeCount__);

		      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
		        return baseWrapperValue(array, this.__actions__);
		      }
		      var result = [];

		      outer:
		      while (length-- && resIndex < takeCount) {
		        index += dir;

		        var iterIndex = -1,
		            value = array[index];

		        while (++iterIndex < iterLength) {
		          var data = iteratees[iterIndex],
		              iteratee = data.iteratee,
		              type = data.type,
		              computed = iteratee(value);

		          if (type == LAZY_MAP_FLAG) {
		            value = computed;
		          } else if (!computed) {
		            if (type == LAZY_FILTER_FLAG) {
		              continue outer;
		            } else {
		              break outer;
		            }
		          }
		        }
		        result[resIndex++] = value;
		      }
		      return result;
		    }

		    // Ensure `LazyWrapper` is an instance of `baseLodash`.
		    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
		    LazyWrapper.prototype.constructor = LazyWrapper;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a hash object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Hash(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the hash.
		     *
		     * @private
		     * @name clear
		     * @memberOf Hash
		     */
		    function hashClear() {
		      this.__data__ = nativeCreate ? nativeCreate(null) : {};
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the hash.
		     *
		     * @private
		     * @name delete
		     * @memberOf Hash
		     * @param {Object} hash The hash to modify.
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function hashDelete(key) {
		      var result = this.has(key) && delete this.__data__[key];
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the hash value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Hash
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function hashGet(key) {
		      var data = this.__data__;
		      if (nativeCreate) {
		        var result = data[key];
		        return result === HASH_UNDEFINED ? undefined$1 : result;
		      }
		      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
		    }

		    /**
		     * Checks if a hash value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Hash
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function hashHas(key) {
		      var data = this.__data__;
		      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
		    }

		    /**
		     * Sets the hash `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Hash
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the hash instance.
		     */
		    function hashSet(key, value) {
		      var data = this.__data__;
		      this.size += this.has(key) ? 0 : 1;
		      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
		      return this;
		    }

		    // Add methods to `Hash`.
		    Hash.prototype.clear = hashClear;
		    Hash.prototype['delete'] = hashDelete;
		    Hash.prototype.get = hashGet;
		    Hash.prototype.has = hashHas;
		    Hash.prototype.set = hashSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an list cache object.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function ListCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the list cache.
		     *
		     * @private
		     * @name clear
		     * @memberOf ListCache
		     */
		    function listCacheClear() {
		      this.__data__ = [];
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the list cache.
		     *
		     * @private
		     * @name delete
		     * @memberOf ListCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function listCacheDelete(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        return false;
		      }
		      var lastIndex = data.length - 1;
		      if (index == lastIndex) {
		        data.pop();
		      } else {
		        splice.call(data, index, 1);
		      }
		      --this.size;
		      return true;
		    }

		    /**
		     * Gets the list cache value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf ListCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function listCacheGet(key) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      return index < 0 ? undefined$1 : data[index][1];
		    }

		    /**
		     * Checks if a list cache value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf ListCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function listCacheHas(key) {
		      return assocIndexOf(this.__data__, key) > -1;
		    }

		    /**
		     * Sets the list cache `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf ListCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the list cache instance.
		     */
		    function listCacheSet(key, value) {
		      var data = this.__data__,
		          index = assocIndexOf(data, key);

		      if (index < 0) {
		        ++this.size;
		        data.push([key, value]);
		      } else {
		        data[index][1] = value;
		      }
		      return this;
		    }

		    // Add methods to `ListCache`.
		    ListCache.prototype.clear = listCacheClear;
		    ListCache.prototype['delete'] = listCacheDelete;
		    ListCache.prototype.get = listCacheGet;
		    ListCache.prototype.has = listCacheHas;
		    ListCache.prototype.set = listCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a map cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function MapCache(entries) {
		      var index = -1,
		          length = entries == null ? 0 : entries.length;

		      this.clear();
		      while (++index < length) {
		        var entry = entries[index];
		        this.set(entry[0], entry[1]);
		      }
		    }

		    /**
		     * Removes all key-value entries from the map.
		     *
		     * @private
		     * @name clear
		     * @memberOf MapCache
		     */
		    function mapCacheClear() {
		      this.size = 0;
		      this.__data__ = {
		        'hash': new Hash,
		        'map': new (Map || ListCache),
		        'string': new Hash
		      };
		    }

		    /**
		     * Removes `key` and its value from the map.
		     *
		     * @private
		     * @name delete
		     * @memberOf MapCache
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function mapCacheDelete(key) {
		      var result = getMapData(this, key)['delete'](key);
		      this.size -= result ? 1 : 0;
		      return result;
		    }

		    /**
		     * Gets the map value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf MapCache
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function mapCacheGet(key) {
		      return getMapData(this, key).get(key);
		    }

		    /**
		     * Checks if a map value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf MapCache
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function mapCacheHas(key) {
		      return getMapData(this, key).has(key);
		    }

		    /**
		     * Sets the map `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf MapCache
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the map cache instance.
		     */
		    function mapCacheSet(key, value) {
		      var data = getMapData(this, key),
		          size = data.size;

		      data.set(key, value);
		      this.size += data.size == size ? 0 : 1;
		      return this;
		    }

		    // Add methods to `MapCache`.
		    MapCache.prototype.clear = mapCacheClear;
		    MapCache.prototype['delete'] = mapCacheDelete;
		    MapCache.prototype.get = mapCacheGet;
		    MapCache.prototype.has = mapCacheHas;
		    MapCache.prototype.set = mapCacheSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     *
		     * Creates an array cache object to store unique values.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [values] The values to cache.
		     */
		    function SetCache(values) {
		      var index = -1,
		          length = values == null ? 0 : values.length;

		      this.__data__ = new MapCache;
		      while (++index < length) {
		        this.add(values[index]);
		      }
		    }

		    /**
		     * Adds `value` to the array cache.
		     *
		     * @private
		     * @name add
		     * @memberOf SetCache
		     * @alias push
		     * @param {*} value The value to cache.
		     * @returns {Object} Returns the cache instance.
		     */
		    function setCacheAdd(value) {
		      this.__data__.set(value, HASH_UNDEFINED);
		      return this;
		    }

		    /**
		     * Checks if `value` is in the array cache.
		     *
		     * @private
		     * @name has
		     * @memberOf SetCache
		     * @param {*} value The value to search for.
		     * @returns {number} Returns `true` if `value` is found, else `false`.
		     */
		    function setCacheHas(value) {
		      return this.__data__.has(value);
		    }

		    // Add methods to `SetCache`.
		    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
		    SetCache.prototype.has = setCacheHas;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a stack cache object to store key-value pairs.
		     *
		     * @private
		     * @constructor
		     * @param {Array} [entries] The key-value pairs to cache.
		     */
		    function Stack(entries) {
		      var data = this.__data__ = new ListCache(entries);
		      this.size = data.size;
		    }

		    /**
		     * Removes all key-value entries from the stack.
		     *
		     * @private
		     * @name clear
		     * @memberOf Stack
		     */
		    function stackClear() {
		      this.__data__ = new ListCache;
		      this.size = 0;
		    }

		    /**
		     * Removes `key` and its value from the stack.
		     *
		     * @private
		     * @name delete
		     * @memberOf Stack
		     * @param {string} key The key of the value to remove.
		     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
		     */
		    function stackDelete(key) {
		      var data = this.__data__,
		          result = data['delete'](key);

		      this.size = data.size;
		      return result;
		    }

		    /**
		     * Gets the stack value for `key`.
		     *
		     * @private
		     * @name get
		     * @memberOf Stack
		     * @param {string} key The key of the value to get.
		     * @returns {*} Returns the entry value.
		     */
		    function stackGet(key) {
		      return this.__data__.get(key);
		    }

		    /**
		     * Checks if a stack value for `key` exists.
		     *
		     * @private
		     * @name has
		     * @memberOf Stack
		     * @param {string} key The key of the entry to check.
		     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
		     */
		    function stackHas(key) {
		      return this.__data__.has(key);
		    }

		    /**
		     * Sets the stack `key` to `value`.
		     *
		     * @private
		     * @name set
		     * @memberOf Stack
		     * @param {string} key The key of the value to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns the stack cache instance.
		     */
		    function stackSet(key, value) {
		      var data = this.__data__;
		      if (data instanceof ListCache) {
		        var pairs = data.__data__;
		        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
		          pairs.push([key, value]);
		          this.size = ++data.size;
		          return this;
		        }
		        data = this.__data__ = new MapCache(pairs);
		      }
		      data.set(key, value);
		      this.size = data.size;
		      return this;
		    }

		    // Add methods to `Stack`.
		    Stack.prototype.clear = stackClear;
		    Stack.prototype['delete'] = stackDelete;
		    Stack.prototype.get = stackGet;
		    Stack.prototype.has = stackHas;
		    Stack.prototype.set = stackSet;

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of the enumerable property names of the array-like `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @param {boolean} inherited Specify returning inherited property names.
		     * @returns {Array} Returns the array of property names.
		     */
		    function arrayLikeKeys(value, inherited) {
		      var isArr = isArray(value),
		          isArg = !isArr && isArguments(value),
		          isBuff = !isArr && !isArg && isBuffer(value),
		          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
		          skipIndexes = isArr || isArg || isBuff || isType,
		          result = skipIndexes ? baseTimes(value.length, String) : [],
		          length = result.length;

		      for (var key in value) {
		        if ((inherited || hasOwnProperty.call(value, key)) &&
		            !(skipIndexes && (
		               // Safari 9 has enumerable `arguments.length` in strict mode.
		               key == 'length' ||
		               // Node.js 0.10 has enumerable non-index properties on buffers.
		               (isBuff && (key == 'offset' || key == 'parent')) ||
		               // PhantomJS 2 has enumerable non-index properties on typed arrays.
		               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
		               // Skip index properties.
		               isIndex(key, length)
		            ))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `_.sample` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @returns {*} Returns the random element.
		     */
		    function arraySample(array) {
		      var length = array.length;
		      return length ? array[baseRandom(0, length - 1)] : undefined$1;
		    }

		    /**
		     * A specialized version of `_.sampleSize` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function arraySampleSize(array, n) {
		      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
		    }

		    /**
		     * A specialized version of `_.shuffle` for arrays.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function arrayShuffle(array) {
		      return shuffleSelf(copyArray(array));
		    }

		    /**
		     * This function is like `assignValue` except that it doesn't assign
		     * `undefined` values.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignMergeValue(object, key, value) {
		      if ((value !== undefined$1 && !eq(object[key], value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Assigns `value` to `key` of `object` if the existing value is not equivalent
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function assignValue(object, key, value) {
		      var objValue = object[key];
		      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
		          (value === undefined$1 && !(key in object))) {
		        baseAssignValue(object, key, value);
		      }
		    }

		    /**
		     * Gets the index at which the `key` is found in `array` of key-value pairs.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {*} key The key to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     */
		    function assocIndexOf(array, key) {
		      var length = array.length;
		      while (length--) {
		        if (eq(array[length][0], key)) {
		          return length;
		        }
		      }
		      return -1;
		    }

		    /**
		     * Aggregates elements of `collection` on `accumulator` with keys transformed
		     * by `iteratee` and values set by `setter`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform keys.
		     * @param {Object} accumulator The initial aggregated object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseAggregator(collection, setter, iteratee, accumulator) {
		      baseEach(collection, function(value, key, collection) {
		        setter(accumulator, value, iteratee(value), collection);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.assign` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssign(object, source) {
		      return object && copyObject(source, keys(source), object);
		    }

		    /**
		     * The base implementation of `_.assignIn` without support for multiple sources
		     * or `customizer` functions.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @returns {Object} Returns `object`.
		     */
		    function baseAssignIn(object, source) {
		      return object && copyObject(source, keysIn(source), object);
		    }

		    /**
		     * The base implementation of `assignValue` and `assignMergeValue` without
		     * value checks.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {string} key The key of the property to assign.
		     * @param {*} value The value to assign.
		     */
		    function baseAssignValue(object, key, value) {
		      if (key == '__proto__' && defineProperty) {
		        defineProperty(object, key, {
		          'configurable': true,
		          'enumerable': true,
		          'value': value,
		          'writable': true
		        });
		      } else {
		        object[key] = value;
		      }
		    }

		    /**
		     * The base implementation of `_.at` without support for individual paths.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Array} Returns the picked elements.
		     */
		    function baseAt(object, paths) {
		      var index = -1,
		          length = paths.length,
		          result = Array(length),
		          skip = object == null;

		      while (++index < length) {
		        result[index] = skip ? undefined$1 : get(object, paths[index]);
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.clamp` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     */
		    function baseClamp(number, lower, upper) {
		      if (number === number) {
		        if (upper !== undefined$1) {
		          number = number <= upper ? number : upper;
		        }
		        if (lower !== undefined$1) {
		          number = number >= lower ? number : lower;
		        }
		      }
		      return number;
		    }

		    /**
		     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
		     * traversed objects.
		     *
		     * @private
		     * @param {*} value The value to clone.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Deep clone
		     *  2 - Flatten inherited properties
		     *  4 - Clone symbols
		     * @param {Function} [customizer] The function to customize cloning.
		     * @param {string} [key] The key of `value`.
		     * @param {Object} [object] The parent object of `value`.
		     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
		     * @returns {*} Returns the cloned value.
		     */
		    function baseClone(value, bitmask, customizer, key, object, stack) {
		      var result,
		          isDeep = bitmask & CLONE_DEEP_FLAG,
		          isFlat = bitmask & CLONE_FLAT_FLAG,
		          isFull = bitmask & CLONE_SYMBOLS_FLAG;

		      if (customizer) {
		        result = object ? customizer(value, key, object, stack) : customizer(value);
		      }
		      if (result !== undefined$1) {
		        return result;
		      }
		      if (!isObject(value)) {
		        return value;
		      }
		      var isArr = isArray(value);
		      if (isArr) {
		        result = initCloneArray(value);
		        if (!isDeep) {
		          return copyArray(value, result);
		        }
		      } else {
		        var tag = getTag(value),
		            isFunc = tag == funcTag || tag == genTag;

		        if (isBuffer(value)) {
		          return cloneBuffer(value, isDeep);
		        }
		        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
		          result = (isFlat || isFunc) ? {} : initCloneObject(value);
		          if (!isDeep) {
		            return isFlat
		              ? copySymbolsIn(value, baseAssignIn(result, value))
		              : copySymbols(value, baseAssign(result, value));
		          }
		        } else {
		          if (!cloneableTags[tag]) {
		            return object ? value : {};
		          }
		          result = initCloneByTag(value, tag, isDeep);
		        }
		      }
		      // Check for circular references and return its corresponding clone.
		      stack || (stack = new Stack);
		      var stacked = stack.get(value);
		      if (stacked) {
		        return stacked;
		      }
		      stack.set(value, result);

		      if (isSet(value)) {
		        value.forEach(function(subValue) {
		          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
		        });
		      } else if (isMap(value)) {
		        value.forEach(function(subValue, key) {
		          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
		        });
		      }

		      var keysFunc = isFull
		        ? (isFlat ? getAllKeysIn : getAllKeys)
		        : (isFlat ? keysIn : keys);

		      var props = isArr ? undefined$1 : keysFunc(value);
		      arrayEach(props || value, function(subValue, key) {
		        if (props) {
		          key = subValue;
		          subValue = value[key];
		        }
		        // Recursively populate clone (susceptible to call stack limits).
		        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.conforms` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseConforms(source) {
		      var props = keys(source);
		      return function(object) {
		        return baseConformsTo(object, source, props);
		      };
		    }

		    /**
		     * The base implementation of `_.conformsTo` which accepts `props` to check.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     */
		    function baseConformsTo(object, source, props) {
		      var length = props.length;
		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (length--) {
		        var key = props[length],
		            predicate = source[key],
		            value = object[key];

		        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.delay` and `_.defer` which accepts `args`
		     * to provide to `func`.
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {Array} args The arguments to provide to `func`.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    function baseDelay(func, wait, args) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
		    }

		    /**
		     * The base implementation of methods like `_.difference` without support
		     * for excluding multiple arrays or iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Array} values The values to exclude.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     */
		    function baseDifference(array, values, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          isCommon = true,
		          length = array.length,
		          result = [],
		          valuesLength = values.length;

		      if (!length) {
		        return result;
		      }
		      if (iteratee) {
		        values = arrayMap(values, baseUnary(iteratee));
		      }
		      if (comparator) {
		        includes = arrayIncludesWith;
		        isCommon = false;
		      }
		      else if (values.length >= LARGE_ARRAY_SIZE) {
		        includes = cacheHas;
		        isCommon = false;
		        values = new SetCache(values);
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee == null ? value : iteratee(value);

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var valuesIndex = valuesLength;
		          while (valuesIndex--) {
		            if (values[valuesIndex] === computed) {
		              continue outer;
		            }
		          }
		          result.push(value);
		        }
		        else if (!includes(values, computed, comparator)) {
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.forEach` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEach = createBaseEach(baseForOwn);

		    /**
		     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     */
		    var baseEachRight = createBaseEach(baseForOwnRight, true);

		    /**
		     * The base implementation of `_.every` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`
		     */
		    function baseEvery(collection, predicate) {
		      var result = true;
		      baseEach(collection, function(value, index, collection) {
		        result = !!predicate(value, index, collection);
		        return result;
		      });
		      return result;
		    }

		    /**
		     * The base implementation of methods like `_.max` and `_.min` which accepts a
		     * `comparator` to determine the extremum value.
		     *
		     * @private
		     * @param {Array} array The array to iterate over.
		     * @param {Function} iteratee The iteratee invoked per iteration.
		     * @param {Function} comparator The comparator used to compare values.
		     * @returns {*} Returns the extremum value.
		     */
		    function baseExtremum(array, iteratee, comparator) {
		      var index = -1,
		          length = array.length;

		      while (++index < length) {
		        var value = array[index],
		            current = iteratee(value);

		        if (current != null && (computed === undefined$1
		              ? (current === current && !isSymbol(current))
		              : comparator(current, computed)
		            )) {
		          var computed = current,
		              result = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.fill` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     */
		    function baseFill(array, value, start, end) {
		      var length = array.length;

		      start = toInteger(start);
		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = (end === undefined$1 || end > length) ? length : toInteger(end);
		      if (end < 0) {
		        end += length;
		      }
		      end = start > end ? 0 : toLength(end);
		      while (start < end) {
		        array[start++] = value;
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.filter` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     */
		    function baseFilter(collection, predicate) {
		      var result = [];
		      baseEach(collection, function(value, index, collection) {
		        if (predicate(value, index, collection)) {
		          result.push(value);
		        }
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.flatten` with support for restricting flattening.
		     *
		     * @private
		     * @param {Array} array The array to flatten.
		     * @param {number} depth The maximum recursion depth.
		     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
		     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
		     * @param {Array} [result=[]] The initial result value.
		     * @returns {Array} Returns the new flattened array.
		     */
		    function baseFlatten(array, depth, predicate, isStrict, result) {
		      var index = -1,
		          length = array.length;

		      predicate || (predicate = isFlattenable);
		      result || (result = []);

		      while (++index < length) {
		        var value = array[index];
		        if (depth > 0 && predicate(value)) {
		          if (depth > 1) {
		            // Recursively flatten arrays (susceptible to call stack limits).
		            baseFlatten(value, depth - 1, predicate, isStrict, result);
		          } else {
		            arrayPush(result, value);
		          }
		        } else if (!isStrict) {
		          result[result.length] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `baseForOwn` which iterates over `object`
		     * properties returned by `keysFunc` and invokes `iteratee` for each property.
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseFor = createBaseFor();

		    /**
		     * This function is like `baseFor` except that it iterates over properties
		     * in the opposite order.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @returns {Object} Returns `object`.
		     */
		    var baseForRight = createBaseFor(true);

		    /**
		     * The base implementation of `_.forOwn` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwn(object, iteratee) {
		      return object && baseFor(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     */
		    function baseForOwnRight(object, iteratee) {
		      return object && baseForRight(object, iteratee, keys);
		    }

		    /**
		     * The base implementation of `_.functions` which creates an array of
		     * `object` function property names filtered from `props`.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Array} props The property names to filter.
		     * @returns {Array} Returns the function names.
		     */
		    function baseFunctions(object, props) {
		      return arrayFilter(props, function(key) {
		        return isFunction(object[key]);
		      });
		    }

		    /**
		     * The base implementation of `_.get` without support for default values.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseGet(object, path) {
		      path = castPath(path, object);

		      var index = 0,
		          length = path.length;

		      while (object != null && index < length) {
		        object = object[toKey(path[index++])];
		      }
		      return (index && index == length) ? object : undefined$1;
		    }

		    /**
		     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
		     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Function} keysFunc The function to get the keys of `object`.
		     * @param {Function} symbolsFunc The function to get the symbols of `object`.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
		      var result = keysFunc(object);
		      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
		    }

		    /**
		     * The base implementation of `getTag` without fallbacks for buggy environments.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    function baseGetTag(value) {
		      if (value == null) {
		        return value === undefined$1 ? undefinedTag : nullTag;
		      }
		      return (symToStringTag && symToStringTag in Object(value))
		        ? getRawTag(value)
		        : objectToString(value);
		    }

		    /**
		     * The base implementation of `_.gt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     */
		    function baseGt(value, other) {
		      return value > other;
		    }

		    /**
		     * The base implementation of `_.has` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHas(object, key) {
		      return object != null && hasOwnProperty.call(object, key);
		    }

		    /**
		     * The base implementation of `_.hasIn` without support for deep paths.
		     *
		     * @private
		     * @param {Object} [object] The object to query.
		     * @param {Array|string} key The key to check.
		     * @returns {boolean} Returns `true` if `key` exists, else `false`.
		     */
		    function baseHasIn(object, key) {
		      return object != null && key in Object(object);
		    }

		    /**
		     * The base implementation of `_.inRange` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {number} number The number to check.
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     */
		    function baseInRange(number, start, end) {
		      return number >= nativeMin(start, end) && number < nativeMax(start, end);
		    }

		    /**
		     * The base implementation of methods like `_.intersection`, without support
		     * for iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of shared values.
		     */
		    function baseIntersection(arrays, iteratee, comparator) {
		      var includes = comparator ? arrayIncludesWith : arrayIncludes,
		          length = arrays[0].length,
		          othLength = arrays.length,
		          othIndex = othLength,
		          caches = Array(othLength),
		          maxLength = Infinity,
		          result = [];

		      while (othIndex--) {
		        var array = arrays[othIndex];
		        if (othIndex && iteratee) {
		          array = arrayMap(array, baseUnary(iteratee));
		        }
		        maxLength = nativeMin(array.length, maxLength);
		        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
		          ? new SetCache(othIndex && array)
		          : undefined$1;
		      }
		      array = arrays[0];

		      var index = -1,
		          seen = caches[0];

		      outer:
		      while (++index < length && result.length < maxLength) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (!(seen
		              ? cacheHas(seen, computed)
		              : includes(result, computed, comparator)
		            )) {
		          othIndex = othLength;
		          while (--othIndex) {
		            var cache = caches[othIndex];
		            if (!(cache
		                  ? cacheHas(cache, computed)
		                  : includes(arrays[othIndex], computed, comparator))
		                ) {
		              continue outer;
		            }
		          }
		          if (seen) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.invert` and `_.invertBy` which inverts
		     * `object` with values transformed by `iteratee` and set by `setter`.
		     *
		     * @private
		     * @param {Object} object The object to iterate over.
		     * @param {Function} setter The function to set `accumulator` values.
		     * @param {Function} iteratee The iteratee to transform values.
		     * @param {Object} accumulator The initial inverted object.
		     * @returns {Function} Returns `accumulator`.
		     */
		    function baseInverter(object, setter, iteratee, accumulator) {
		      baseForOwn(object, function(value, key, object) {
		        setter(accumulator, iteratee(value), key, object);
		      });
		      return accumulator;
		    }

		    /**
		     * The base implementation of `_.invoke` without support for individual
		     * method arguments.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {Array} args The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     */
		    function baseInvoke(object, path, args) {
		      path = castPath(path, object);
		      object = parent(object, path);
		      var func = object == null ? object : object[toKey(last(path))];
		      return func == null ? undefined$1 : apply(func, object, args);
		    }

		    /**
		     * The base implementation of `_.isArguments`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     */
		    function baseIsArguments(value) {
		      return isObjectLike(value) && baseGetTag(value) == argsTag;
		    }

		    /**
		     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     */
		    function baseIsArrayBuffer(value) {
		      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
		    }

		    /**
		     * The base implementation of `_.isDate` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     */
		    function baseIsDate(value) {
		      return isObjectLike(value) && baseGetTag(value) == dateTag;
		    }

		    /**
		     * The base implementation of `_.isEqual` which supports partial comparisons
		     * and tracks traversed objects.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {boolean} bitmask The bitmask flags.
		     *  1 - Unordered comparison
		     *  2 - Partial comparison
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     */
		    function baseIsEqual(value, other, bitmask, customizer, stack) {
		      if (value === other) {
		        return true;
		      }
		      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
		        return value !== value && other !== other;
		      }
		      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
		    }

		    /**
		     * A specialized version of `baseIsEqual` for arrays and objects which performs
		     * deep comparisons and tracks traversed objects enabling objects with circular
		     * references to be compared.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
		      var objIsArr = isArray(object),
		          othIsArr = isArray(other),
		          objTag = objIsArr ? arrayTag : getTag(object),
		          othTag = othIsArr ? arrayTag : getTag(other);

		      objTag = objTag == argsTag ? objectTag : objTag;
		      othTag = othTag == argsTag ? objectTag : othTag;

		      var objIsObj = objTag == objectTag,
		          othIsObj = othTag == objectTag,
		          isSameTag = objTag == othTag;

		      if (isSameTag && isBuffer(object)) {
		        if (!isBuffer(other)) {
		          return false;
		        }
		        objIsArr = true;
		        objIsObj = false;
		      }
		      if (isSameTag && !objIsObj) {
		        stack || (stack = new Stack);
		        return (objIsArr || isTypedArray(object))
		          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
		          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
		      }
		      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
		        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
		            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

		        if (objIsWrapped || othIsWrapped) {
		          var objUnwrapped = objIsWrapped ? object.value() : object,
		              othUnwrapped = othIsWrapped ? other.value() : other;

		          stack || (stack = new Stack);
		          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
		        }
		      }
		      if (!isSameTag) {
		        return false;
		      }
		      stack || (stack = new Stack);
		      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
		    }

		    /**
		     * The base implementation of `_.isMap` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     */
		    function baseIsMap(value) {
		      return isObjectLike(value) && getTag(value) == mapTag;
		    }

		    /**
		     * The base implementation of `_.isMatch` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Array} matchData The property names, values, and compare flags to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     */
		    function baseIsMatch(object, source, matchData, customizer) {
		      var index = matchData.length,
		          length = index,
		          noCustomizer = !customizer;

		      if (object == null) {
		        return !length;
		      }
		      object = Object(object);
		      while (index--) {
		        var data = matchData[index];
		        if ((noCustomizer && data[2])
		              ? data[1] !== object[data[0]]
		              : !(data[0] in object)
		            ) {
		          return false;
		        }
		      }
		      while (++index < length) {
		        data = matchData[index];
		        var key = data[0],
		            objValue = object[key],
		            srcValue = data[1];

		        if (noCustomizer && data[2]) {
		          if (objValue === undefined$1 && !(key in object)) {
		            return false;
		          }
		        } else {
		          var stack = new Stack;
		          if (customizer) {
		            var result = customizer(objValue, srcValue, key, object, source, stack);
		          }
		          if (!(result === undefined$1
		                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
		                : result
		              )) {
		            return false;
		          }
		        }
		      }
		      return true;
		    }

		    /**
		     * The base implementation of `_.isNative` without bad shim checks.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     */
		    function baseIsNative(value) {
		      if (!isObject(value) || isMasked(value)) {
		        return false;
		      }
		      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
		      return pattern.test(toSource(value));
		    }

		    /**
		     * The base implementation of `_.isRegExp` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     */
		    function baseIsRegExp(value) {
		      return isObjectLike(value) && baseGetTag(value) == regexpTag;
		    }

		    /**
		     * The base implementation of `_.isSet` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     */
		    function baseIsSet(value) {
		      return isObjectLike(value) && getTag(value) == setTag;
		    }

		    /**
		     * The base implementation of `_.isTypedArray` without Node.js optimizations.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     */
		    function baseIsTypedArray(value) {
		      return isObjectLike(value) &&
		        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
		    }

		    /**
		     * The base implementation of `_.iteratee`.
		     *
		     * @private
		     * @param {*} [value=_.identity] The value to convert to an iteratee.
		     * @returns {Function} Returns the iteratee.
		     */
		    function baseIteratee(value) {
		      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
		      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
		      if (typeof value == 'function') {
		        return value;
		      }
		      if (value == null) {
		        return identity;
		      }
		      if (typeof value == 'object') {
		        return isArray(value)
		          ? baseMatchesProperty(value[0], value[1])
		          : baseMatches(value);
		      }
		      return property(value);
		    }

		    /**
		     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeys(object) {
		      if (!isPrototype(object)) {
		        return nativeKeys(object);
		      }
		      var result = [];
		      for (var key in Object(object)) {
		        if (hasOwnProperty.call(object, key) && key != 'constructor') {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function baseKeysIn(object) {
		      if (!isObject(object)) {
		        return nativeKeysIn(object);
		      }
		      var isProto = isPrototype(object),
		          result = [];

		      for (var key in object) {
		        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.lt` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     */
		    function baseLt(value, other) {
		      return value < other;
		    }

		    /**
		     * The base implementation of `_.map` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} iteratee The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     */
		    function baseMap(collection, iteratee) {
		      var index = -1,
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value, key, collection) {
		        result[++index] = iteratee(value, key, collection);
		      });
		      return result;
		    }

		    /**
		     * The base implementation of `_.matches` which doesn't clone `source`.
		     *
		     * @private
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatches(source) {
		      var matchData = getMatchData(source);
		      if (matchData.length == 1 && matchData[0][2]) {
		        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
		      }
		      return function(object) {
		        return object === source || baseIsMatch(object, source, matchData);
		      };
		    }

		    /**
		     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
		     *
		     * @private
		     * @param {string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function baseMatchesProperty(path, srcValue) {
		      if (isKey(path) && isStrictComparable(srcValue)) {
		        return matchesStrictComparable(toKey(path), srcValue);
		      }
		      return function(object) {
		        var objValue = get(object, path);
		        return (objValue === undefined$1 && objValue === srcValue)
		          ? hasIn(object, path)
		          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
		      };
		    }

		    /**
		     * The base implementation of `_.merge` without support for multiple sources.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} [customizer] The function to customize merged values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMerge(object, source, srcIndex, customizer, stack) {
		      if (object === source) {
		        return;
		      }
		      baseFor(source, function(srcValue, key) {
		        stack || (stack = new Stack);
		        if (isObject(srcValue)) {
		          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
		        }
		        else {
		          var newValue = customizer
		            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
		            : undefined$1;

		          if (newValue === undefined$1) {
		            newValue = srcValue;
		          }
		          assignMergeValue(object, key, newValue);
		        }
		      }, keysIn);
		    }

		    /**
		     * A specialized version of `baseMerge` for arrays and objects which performs
		     * deep merges and tracks traversed objects enabling objects with circular
		     * references to be merged.
		     *
		     * @private
		     * @param {Object} object The destination object.
		     * @param {Object} source The source object.
		     * @param {string} key The key of the value to merge.
		     * @param {number} srcIndex The index of `source`.
		     * @param {Function} mergeFunc The function to merge values.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     */
		    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
		      var objValue = safeGet(object, key),
		          srcValue = safeGet(source, key),
		          stacked = stack.get(srcValue);

		      if (stacked) {
		        assignMergeValue(object, key, stacked);
		        return;
		      }
		      var newValue = customizer
		        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
		        : undefined$1;

		      var isCommon = newValue === undefined$1;

		      if (isCommon) {
		        var isArr = isArray(srcValue),
		            isBuff = !isArr && isBuffer(srcValue),
		            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

		        newValue = srcValue;
		        if (isArr || isBuff || isTyped) {
		          if (isArray(objValue)) {
		            newValue = objValue;
		          }
		          else if (isArrayLikeObject(objValue)) {
		            newValue = copyArray(objValue);
		          }
		          else if (isBuff) {
		            isCommon = false;
		            newValue = cloneBuffer(srcValue, true);
		          }
		          else if (isTyped) {
		            isCommon = false;
		            newValue = cloneTypedArray(srcValue, true);
		          }
		          else {
		            newValue = [];
		          }
		        }
		        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
		          newValue = objValue;
		          if (isArguments(objValue)) {
		            newValue = toPlainObject(objValue);
		          }
		          else if (!isObject(objValue) || isFunction(objValue)) {
		            newValue = initCloneObject(srcValue);
		          }
		        }
		        else {
		          isCommon = false;
		        }
		      }
		      if (isCommon) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, newValue);
		        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
		        stack['delete'](srcValue);
		      }
		      assignMergeValue(object, key, newValue);
		    }

		    /**
		     * The base implementation of `_.nth` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {number} n The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     */
		    function baseNth(array, n) {
		      var length = array.length;
		      if (!length) {
		        return;
		      }
		      n += n < 0 ? length : 0;
		      return isIndex(n, length) ? array[n] : undefined$1;
		    }

		    /**
		     * The base implementation of `_.orderBy` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
		     * @param {string[]} orders The sort orders of `iteratees`.
		     * @returns {Array} Returns the new sorted array.
		     */
		    function baseOrderBy(collection, iteratees, orders) {
		      if (iteratees.length) {
		        iteratees = arrayMap(iteratees, function(iteratee) {
		          if (isArray(iteratee)) {
		            return function(value) {
		              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
		            };
		          }
		          return iteratee;
		        });
		      } else {
		        iteratees = [identity];
		      }

		      var index = -1;
		      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

		      var result = baseMap(collection, function(value, key, collection) {
		        var criteria = arrayMap(iteratees, function(iteratee) {
		          return iteratee(value);
		        });
		        return { 'criteria': criteria, 'index': ++index, 'value': value };
		      });

		      return baseSortBy(result, function(object, other) {
		        return compareMultiple(object, other, orders);
		      });
		    }

		    /**
		     * The base implementation of `_.pick` without support for individual
		     * property identifiers.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @returns {Object} Returns the new object.
		     */
		    function basePick(object, paths) {
		      return basePickBy(object, paths, function(value, path) {
		        return hasIn(object, path);
		      });
		    }

		    /**
		     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Object} object The source object.
		     * @param {string[]} paths The property paths to pick.
		     * @param {Function} predicate The function invoked per property.
		     * @returns {Object} Returns the new object.
		     */
		    function basePickBy(object, paths, predicate) {
		      var index = -1,
		          length = paths.length,
		          result = {};

		      while (++index < length) {
		        var path = paths[index],
		            value = baseGet(object, path);

		        if (predicate(value, path)) {
		          baseSet(result, castPath(path, object), value);
		        }
		      }
		      return result;
		    }

		    /**
		     * A specialized version of `baseProperty` which supports deep paths.
		     *
		     * @private
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     */
		    function basePropertyDeep(path) {
		      return function(object) {
		        return baseGet(object, path);
		      };
		    }

		    /**
		     * The base implementation of `_.pullAllBy` without support for iteratee
		     * shorthands.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAll(array, values, iteratee, comparator) {
		      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
		          index = -1,
		          length = values.length,
		          seen = array;

		      if (array === values) {
		        values = copyArray(values);
		      }
		      if (iteratee) {
		        seen = arrayMap(array, baseUnary(iteratee));
		      }
		      while (++index < length) {
		        var fromIndex = 0,
		            value = values[index],
		            computed = iteratee ? iteratee(value) : value;

		        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
		          if (seen !== array) {
		            splice.call(seen, fromIndex, 1);
		          }
		          splice.call(array, fromIndex, 1);
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.pullAt` without support for individual
		     * indexes or capturing the removed elements.
		     *
		     * @private
		     * @param {Array} array The array to modify.
		     * @param {number[]} indexes The indexes of elements to remove.
		     * @returns {Array} Returns `array`.
		     */
		    function basePullAt(array, indexes) {
		      var length = array ? indexes.length : 0,
		          lastIndex = length - 1;

		      while (length--) {
		        var index = indexes[length];
		        if (length == lastIndex || index !== previous) {
		          var previous = index;
		          if (isIndex(index)) {
		            splice.call(array, index, 1);
		          } else {
		            baseUnset(array, index);
		          }
		        }
		      }
		      return array;
		    }

		    /**
		     * The base implementation of `_.random` without support for returning
		     * floating-point numbers.
		     *
		     * @private
		     * @param {number} lower The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the random number.
		     */
		    function baseRandom(lower, upper) {
		      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
		    }

		    /**
		     * The base implementation of `_.range` and `_.rangeRight` which doesn't
		     * coerce arguments.
		     *
		     * @private
		     * @param {number} start The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} step The value to increment or decrement by.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the range of numbers.
		     */
		    function baseRange(start, end, step, fromRight) {
		      var index = -1,
		          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
		          result = Array(length);

		      while (length--) {
		        result[fromRight ? length : ++index] = start;
		        start += step;
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.repeat` which doesn't coerce arguments.
		     *
		     * @private
		     * @param {string} string The string to repeat.
		     * @param {number} n The number of times to repeat the string.
		     * @returns {string} Returns the repeated string.
		     */
		    function baseRepeat(string, n) {
		      var result = '';
		      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
		        return result;
		      }
		      // Leverage the exponentiation by squaring algorithm for a faster repeat.
		      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
		      do {
		        if (n % 2) {
		          result += string;
		        }
		        n = nativeFloor(n / 2);
		        if (n) {
		          string += string;
		        }
		      } while (n);

		      return result;
		    }

		    /**
		     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     */
		    function baseRest(func, start) {
		      return setToString(overRest(func, start, identity), func + '');
		    }

		    /**
		     * The base implementation of `_.sample`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     */
		    function baseSample(collection) {
		      return arraySample(values(collection));
		    }

		    /**
		     * The base implementation of `_.sampleSize` without param guards.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} n The number of elements to sample.
		     * @returns {Array} Returns the random elements.
		     */
		    function baseSampleSize(collection, n) {
		      var array = values(collection);
		      return shuffleSelf(array, baseClamp(n, 0, array.length));
		    }

		    /**
		     * The base implementation of `_.set`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseSet(object, path, value, customizer) {
		      if (!isObject(object)) {
		        return object;
		      }
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          lastIndex = length - 1,
		          nested = object;

		      while (nested != null && ++index < length) {
		        var key = toKey(path[index]),
		            newValue = value;

		        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
		          return object;
		        }

		        if (index != lastIndex) {
		          var objValue = nested[key];
		          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
		          if (newValue === undefined$1) {
		            newValue = isObject(objValue)
		              ? objValue
		              : (isIndex(path[index + 1]) ? [] : {});
		          }
		        }
		        assignValue(nested, key, newValue);
		        nested = nested[key];
		      }
		      return object;
		    }

		    /**
		     * The base implementation of `setData` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetData = !metaMap ? identity : function(func, data) {
		      metaMap.set(func, data);
		      return func;
		    };

		    /**
		     * The base implementation of `setToString` without support for hot loop shorting.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var baseSetToString = !defineProperty ? identity : function(func, string) {
		      return defineProperty(func, 'toString', {
		        'configurable': true,
		        'enumerable': false,
		        'value': constant(string),
		        'writable': true
		      });
		    };

		    /**
		     * The base implementation of `_.shuffle`.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     */
		    function baseShuffle(collection) {
		      return shuffleSelf(values(collection));
		    }

		    /**
		     * The base implementation of `_.slice` without an iteratee call guard.
		     *
		     * @private
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseSlice(array, start, end) {
		      var index = -1,
		          length = array.length;

		      if (start < 0) {
		        start = -start > length ? 0 : (length + start);
		      }
		      end = end > length ? length : end;
		      if (end < 0) {
		        end += length;
		      }
		      length = start > end ? 0 : ((end - start) >>> 0);
		      start >>>= 0;

		      var result = Array(length);
		      while (++index < length) {
		        result[index] = array[index + start];
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.some` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} predicate The function invoked per iteration.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     */
		    function baseSome(collection, predicate) {
		      var result;

		      baseEach(collection, function(value, index, collection) {
		        result = predicate(value, index, collection);
		        return !result;
		      });
		      return !!result;
		    }

		    /**
		     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
		     * performs a binary search of `array` to determine the index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndex(array, value, retHighest) {
		      var low = 0,
		          high = array == null ? low : array.length;

		      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
		        while (low < high) {
		          var mid = (low + high) >>> 1,
		              computed = array[mid];

		          if (computed !== null && !isSymbol(computed) &&
		              (retHighest ? (computed <= value) : (computed < value))) {
		            low = mid + 1;
		          } else {
		            high = mid;
		          }
		        }
		        return high;
		      }
		      return baseSortedIndexBy(array, value, identity, retHighest);
		    }

		    /**
		     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
		     * which invokes `iteratee` for `value` and each element of `array` to compute
		     * their sort ranking. The iteratee is invoked with one argument; (value).
		     *
		     * @private
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} iteratee The iteratee invoked per element.
		     * @param {boolean} [retHighest] Specify returning the highest qualified index.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     */
		    function baseSortedIndexBy(array, value, iteratee, retHighest) {
		      var low = 0,
		          high = array == null ? 0 : array.length;
		      if (high === 0) {
		        return 0;
		      }

		      value = iteratee(value);
		      var valIsNaN = value !== value,
		          valIsNull = value === null,
		          valIsSymbol = isSymbol(value),
		          valIsUndefined = value === undefined$1;

		      while (low < high) {
		        var mid = nativeFloor((low + high) / 2),
		            computed = iteratee(array[mid]),
		            othIsDefined = computed !== undefined$1,
		            othIsNull = computed === null,
		            othIsReflexive = computed === computed,
		            othIsSymbol = isSymbol(computed);

		        if (valIsNaN) {
		          var setLow = retHighest || othIsReflexive;
		        } else if (valIsUndefined) {
		          setLow = othIsReflexive && (retHighest || othIsDefined);
		        } else if (valIsNull) {
		          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
		        } else if (valIsSymbol) {
		          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
		        } else if (othIsNull || othIsSymbol) {
		          setLow = false;
		        } else {
		          setLow = retHighest ? (computed <= value) : (computed < value);
		        }
		        if (setLow) {
		          low = mid + 1;
		        } else {
		          high = mid;
		        }
		      }
		      return nativeMin(high, MAX_ARRAY_INDEX);
		    }

		    /**
		     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
		     * support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseSortedUniq(array, iteratee) {
		      var index = -1,
		          length = array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        if (!index || !eq(computed, seen)) {
		          var seen = computed;
		          result[resIndex++] = value === 0 ? 0 : value;
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.toNumber` which doesn't ensure correct
		     * conversions of binary, hexadecimal, or octal string values.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     */
		    function baseToNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      return +value;
		    }

		    /**
		     * The base implementation of `_.toString` which doesn't convert nullish
		     * values to empty strings.
		     *
		     * @private
		     * @param {*} value The value to process.
		     * @returns {string} Returns the string.
		     */
		    function baseToString(value) {
		      // Exit early for strings to avoid a performance hit in some environments.
		      if (typeof value == 'string') {
		        return value;
		      }
		      if (isArray(value)) {
		        // Recursively convert values (susceptible to call stack limits).
		        return arrayMap(value, baseToString) + '';
		      }
		      if (isSymbol(value)) {
		        return symbolToString ? symbolToString.call(value) : '';
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     */
		    function baseUniq(array, iteratee, comparator) {
		      var index = -1,
		          includes = arrayIncludes,
		          length = array.length,
		          isCommon = true,
		          result = [],
		          seen = result;

		      if (comparator) {
		        isCommon = false;
		        includes = arrayIncludesWith;
		      }
		      else if (length >= LARGE_ARRAY_SIZE) {
		        var set = iteratee ? null : createSet(array);
		        if (set) {
		          return setToArray(set);
		        }
		        isCommon = false;
		        includes = cacheHas;
		        seen = new SetCache;
		      }
		      else {
		        seen = iteratee ? [] : result;
		      }
		      outer:
		      while (++index < length) {
		        var value = array[index],
		            computed = iteratee ? iteratee(value) : value;

		        value = (comparator || value !== 0) ? value : 0;
		        if (isCommon && computed === computed) {
		          var seenIndex = seen.length;
		          while (seenIndex--) {
		            if (seen[seenIndex] === computed) {
		              continue outer;
		            }
		          }
		          if (iteratee) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		        else if (!includes(seen, computed, comparator)) {
		          if (seen !== result) {
		            seen.push(computed);
		          }
		          result.push(value);
		        }
		      }
		      return result;
		    }

		    /**
		     * The base implementation of `_.unset`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The property path to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     */
		    function baseUnset(object, path) {
		      path = castPath(path, object);

		      // Prevent prototype pollution, see: https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg
		      var index = -1,
		          length = path.length;

		      if (!length) {
		        return true;
		      }

		      var isRootPrimitive = object == null || (typeof object !== 'object' && typeof object !== 'function');

		      while (++index < length) {
		        var key = path[index];

		        // skip non-string keys (e.g., Symbols, numbers)
		        if (typeof key !== 'string') {
		          continue;
		        }

		        // Always block "__proto__" anywhere in the path if it's not expected
		        if (key === '__proto__' && !hasOwnProperty.call(object, '__proto__')) {
		          return false;
		        }

		        // Block "constructor.prototype" chains
		        if (key === 'constructor' &&
		            (index + 1) < length &&
		            typeof path[index + 1] === 'string' &&
		            path[index + 1] === 'prototype') {

		          // Allow ONLY when the path starts at a primitive root, e.g., _.unset(0, 'constructor.prototype.a')
		          if (isRootPrimitive && index === 0) {
		            continue;
		          }

		          return false;
		        }
		      }

		      var obj = parent(object, path);
		      return obj == null || delete obj[toKey(last(path))];
		    }

		    /**
		     * The base implementation of `_.update`.
		     *
		     * @private
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to update.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize path creation.
		     * @returns {Object} Returns `object`.
		     */
		    function baseUpdate(object, path, updater, customizer) {
		      return baseSet(object, path, updater(baseGet(object, path)), customizer);
		    }

		    /**
		     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
		     * without support for iteratee shorthands.
		     *
		     * @private
		     * @param {Array} array The array to query.
		     * @param {Function} predicate The function invoked per iteration.
		     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function baseWhile(array, predicate, isDrop, fromRight) {
		      var length = array.length,
		          index = fromRight ? length : -1;

		      while ((fromRight ? index-- : ++index < length) &&
		        predicate(array[index], index, array)) {}

		      return isDrop
		        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
		        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
		    }

		    /**
		     * The base implementation of `wrapperValue` which returns the result of
		     * performing a sequence of actions on the unwrapped `value`, where each
		     * successive action is supplied the return value of the previous.
		     *
		     * @private
		     * @param {*} value The unwrapped value.
		     * @param {Array} actions Actions to perform to resolve the unwrapped value.
		     * @returns {*} Returns the resolved value.
		     */
		    function baseWrapperValue(value, actions) {
		      var result = value;
		      if (result instanceof LazyWrapper) {
		        result = result.value();
		      }
		      return arrayReduce(actions, function(result, action) {
		        return action.func.apply(action.thisArg, arrayPush([result], action.args));
		      }, result);
		    }

		    /**
		     * The base implementation of methods like `_.xor`, without support for
		     * iteratee shorthands, that accepts an array of arrays to inspect.
		     *
		     * @private
		     * @param {Array} arrays The arrays to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of values.
		     */
		    function baseXor(arrays, iteratee, comparator) {
		      var length = arrays.length;
		      if (length < 2) {
		        return length ? baseUniq(arrays[0]) : [];
		      }
		      var index = -1,
		          result = Array(length);

		      while (++index < length) {
		        var array = arrays[index],
		            othIndex = -1;

		        while (++othIndex < length) {
		          if (othIndex != index) {
		            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
		          }
		        }
		      }
		      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
		    }

		    /**
		     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
		     *
		     * @private
		     * @param {Array} props The property identifiers.
		     * @param {Array} values The property values.
		     * @param {Function} assignFunc The function to assign values.
		     * @returns {Object} Returns the new object.
		     */
		    function baseZipObject(props, values, assignFunc) {
		      var index = -1,
		          length = props.length,
		          valsLength = values.length,
		          result = {};

		      while (++index < length) {
		        var value = index < valsLength ? values[index] : undefined$1;
		        assignFunc(result, props[index], value);
		      }
		      return result;
		    }

		    /**
		     * Casts `value` to an empty array if it's not an array like object.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Array|Object} Returns the cast array-like object.
		     */
		    function castArrayLikeObject(value) {
		      return isArrayLikeObject(value) ? value : [];
		    }

		    /**
		     * Casts `value` to `identity` if it's not a function.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {Function} Returns cast function.
		     */
		    function castFunction(value) {
		      return typeof value == 'function' ? value : identity;
		    }

		    /**
		     * Casts `value` to a path array if it's not one.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {Array} Returns the cast property path array.
		     */
		    function castPath(value, object) {
		      if (isArray(value)) {
		        return value;
		      }
		      return isKey(value, object) ? [value] : stringToPath(toString(value));
		    }

		    /**
		     * A `baseRest` alias which can be replaced with `identity` by module
		     * replacement plugins.
		     *
		     * @private
		     * @type {Function}
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    var castRest = baseRest;

		    /**
		     * Casts `array` to a slice if it's needed.
		     *
		     * @private
		     * @param {Array} array The array to inspect.
		     * @param {number} start The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the cast slice.
		     */
		    function castSlice(array, start, end) {
		      var length = array.length;
		      end = end === undefined$1 ? length : end;
		      return (!start && end >= length) ? array : baseSlice(array, start, end);
		    }

		    /**
		     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
		     *
		     * @private
		     * @param {number|Object} id The timer id or timeout object of the timer to clear.
		     */
		    var clearTimeout = ctxClearTimeout || function(id) {
		      return root.clearTimeout(id);
		    };

		    /**
		     * Creates a clone of  `buffer`.
		     *
		     * @private
		     * @param {Buffer} buffer The buffer to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Buffer} Returns the cloned buffer.
		     */
		    function cloneBuffer(buffer, isDeep) {
		      if (isDeep) {
		        return buffer.slice();
		      }
		      var length = buffer.length,
		          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		      buffer.copy(result);
		      return result;
		    }

		    /**
		     * Creates a clone of `arrayBuffer`.
		     *
		     * @private
		     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
		     * @returns {ArrayBuffer} Returns the cloned array buffer.
		     */
		    function cloneArrayBuffer(arrayBuffer) {
		      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
		      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
		      return result;
		    }

		    /**
		     * Creates a clone of `dataView`.
		     *
		     * @private
		     * @param {Object} dataView The data view to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned data view.
		     */
		    function cloneDataView(dataView, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
		      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
		    }

		    /**
		     * Creates a clone of `regexp`.
		     *
		     * @private
		     * @param {Object} regexp The regexp to clone.
		     * @returns {Object} Returns the cloned regexp.
		     */
		    function cloneRegExp(regexp) {
		      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
		      result.lastIndex = regexp.lastIndex;
		      return result;
		    }

		    /**
		     * Creates a clone of the `symbol` object.
		     *
		     * @private
		     * @param {Object} symbol The symbol object to clone.
		     * @returns {Object} Returns the cloned symbol object.
		     */
		    function cloneSymbol(symbol) {
		      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
		    }

		    /**
		     * Creates a clone of `typedArray`.
		     *
		     * @private
		     * @param {Object} typedArray The typed array to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the cloned typed array.
		     */
		    function cloneTypedArray(typedArray, isDeep) {
		      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
		      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
		    }

		    /**
		     * Compares values to sort them in ascending order.
		     *
		     * @private
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {number} Returns the sort order indicator for `value`.
		     */
		    function compareAscending(value, other) {
		      if (value !== other) {
		        var valIsDefined = value !== undefined$1,
		            valIsNull = value === null,
		            valIsReflexive = value === value,
		            valIsSymbol = isSymbol(value);

		        var othIsDefined = other !== undefined$1,
		            othIsNull = other === null,
		            othIsReflexive = other === other,
		            othIsSymbol = isSymbol(other);

		        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
		            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
		            (valIsNull && othIsDefined && othIsReflexive) ||
		            (!valIsDefined && othIsReflexive) ||
		            !valIsReflexive) {
		          return 1;
		        }
		        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
		            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
		            (othIsNull && valIsDefined && valIsReflexive) ||
		            (!othIsDefined && valIsReflexive) ||
		            !othIsReflexive) {
		          return -1;
		        }
		      }
		      return 0;
		    }

		    /**
		     * Used by `_.orderBy` to compare multiple properties of a value to another
		     * and stable sort them.
		     *
		     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
		     * specify an order of "desc" for descending or "asc" for ascending sort order
		     * of corresponding values.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {boolean[]|string[]} orders The order to sort by for each property.
		     * @returns {number} Returns the sort order indicator for `object`.
		     */
		    function compareMultiple(object, other, orders) {
		      var index = -1,
		          objCriteria = object.criteria,
		          othCriteria = other.criteria,
		          length = objCriteria.length,
		          ordersLength = orders.length;

		      while (++index < length) {
		        var result = compareAscending(objCriteria[index], othCriteria[index]);
		        if (result) {
		          if (index >= ordersLength) {
		            return result;
		          }
		          var order = orders[index];
		          return result * (order == 'desc' ? -1 : 1);
		        }
		      }
		      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
		      // that causes it, under certain circumstances, to provide the same value for
		      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
		      // for more details.
		      //
		      // This also ensures a stable sort in V8 and other engines.
		      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
		      return object.index - other.index;
		    }

		    /**
		     * Creates an array that is the composition of partially applied arguments,
		     * placeholders, and provided arguments into a single array of arguments.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to prepend to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgs(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersLength = holders.length,
		          leftIndex = -1,
		          leftLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(leftLength + rangeLength),
		          isUncurried = !isCurried;

		      while (++leftIndex < leftLength) {
		        result[leftIndex] = partials[leftIndex];
		      }
		      while (++argsIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[holders[argsIndex]] = args[argsIndex];
		        }
		      }
		      while (rangeLength--) {
		        result[leftIndex++] = args[argsIndex++];
		      }
		      return result;
		    }

		    /**
		     * This function is like `composeArgs` except that the arguments composition
		     * is tailored for `_.partialRight`.
		     *
		     * @private
		     * @param {Array} args The provided arguments.
		     * @param {Array} partials The arguments to append to those provided.
		     * @param {Array} holders The `partials` placeholder indexes.
		     * @params {boolean} [isCurried] Specify composing for a curried function.
		     * @returns {Array} Returns the new array of composed arguments.
		     */
		    function composeArgsRight(args, partials, holders, isCurried) {
		      var argsIndex = -1,
		          argsLength = args.length,
		          holdersIndex = -1,
		          holdersLength = holders.length,
		          rightIndex = -1,
		          rightLength = partials.length,
		          rangeLength = nativeMax(argsLength - holdersLength, 0),
		          result = Array(rangeLength + rightLength),
		          isUncurried = !isCurried;

		      while (++argsIndex < rangeLength) {
		        result[argsIndex] = args[argsIndex];
		      }
		      var offset = argsIndex;
		      while (++rightIndex < rightLength) {
		        result[offset + rightIndex] = partials[rightIndex];
		      }
		      while (++holdersIndex < holdersLength) {
		        if (isUncurried || argsIndex < argsLength) {
		          result[offset + holders[holdersIndex]] = args[argsIndex++];
		        }
		      }
		      return result;
		    }

		    /**
		     * Copies the values of `source` to `array`.
		     *
		     * @private
		     * @param {Array} source The array to copy values from.
		     * @param {Array} [array=[]] The array to copy values to.
		     * @returns {Array} Returns `array`.
		     */
		    function copyArray(source, array) {
		      var index = -1,
		          length = source.length;

		      array || (array = Array(length));
		      while (++index < length) {
		        array[index] = source[index];
		      }
		      return array;
		    }

		    /**
		     * Copies properties of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy properties from.
		     * @param {Array} props The property identifiers to copy.
		     * @param {Object} [object={}] The object to copy properties to.
		     * @param {Function} [customizer] The function to customize copied values.
		     * @returns {Object} Returns `object`.
		     */
		    function copyObject(source, props, object, customizer) {
		      var isNew = !object;
		      object || (object = {});

		      var index = -1,
		          length = props.length;

		      while (++index < length) {
		        var key = props[index];

		        var newValue = customizer
		          ? customizer(object[key], source[key], key, object, source)
		          : undefined$1;

		        if (newValue === undefined$1) {
		          newValue = source[key];
		        }
		        if (isNew) {
		          baseAssignValue(object, key, newValue);
		        } else {
		          assignValue(object, key, newValue);
		        }
		      }
		      return object;
		    }

		    /**
		     * Copies own symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbols(source, object) {
		      return copyObject(source, getSymbols(source), object);
		    }

		    /**
		     * Copies own and inherited symbols of `source` to `object`.
		     *
		     * @private
		     * @param {Object} source The object to copy symbols from.
		     * @param {Object} [object={}] The object to copy symbols to.
		     * @returns {Object} Returns `object`.
		     */
		    function copySymbolsIn(source, object) {
		      return copyObject(source, getSymbolsIn(source), object);
		    }

		    /**
		     * Creates a function like `_.groupBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} [initializer] The accumulator object initializer.
		     * @returns {Function} Returns the new aggregator function.
		     */
		    function createAggregator(setter, initializer) {
		      return function(collection, iteratee) {
		        var func = isArray(collection) ? arrayAggregator : baseAggregator,
		            accumulator = initializer ? initializer() : {};

		        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
		      };
		    }

		    /**
		     * Creates a function like `_.assign`.
		     *
		     * @private
		     * @param {Function} assigner The function to assign values.
		     * @returns {Function} Returns the new assigner function.
		     */
		    function createAssigner(assigner) {
		      return baseRest(function(object, sources) {
		        var index = -1,
		            length = sources.length,
		            customizer = length > 1 ? sources[length - 1] : undefined$1,
		            guard = length > 2 ? sources[2] : undefined$1;

		        customizer = (assigner.length > 3 && typeof customizer == 'function')
		          ? (length--, customizer)
		          : undefined$1;

		        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		          customizer = length < 3 ? undefined$1 : customizer;
		          length = 1;
		        }
		        object = Object(object);
		        while (++index < length) {
		          var source = sources[index];
		          if (source) {
		            assigner(object, source, index, customizer);
		          }
		        }
		        return object;
		      });
		    }

		    /**
		     * Creates a `baseEach` or `baseEachRight` function.
		     *
		     * @private
		     * @param {Function} eachFunc The function to iterate over a collection.
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseEach(eachFunc, fromRight) {
		      return function(collection, iteratee) {
		        if (collection == null) {
		          return collection;
		        }
		        if (!isArrayLike(collection)) {
		          return eachFunc(collection, iteratee);
		        }
		        var length = collection.length,
		            index = fromRight ? length : -1,
		            iterable = Object(collection);

		        while ((fromRight ? index-- : ++index < length)) {
		          if (iteratee(iterable[index], index, iterable) === false) {
		            break;
		          }
		        }
		        return collection;
		      };
		    }

		    /**
		     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new base function.
		     */
		    function createBaseFor(fromRight) {
		      return function(object, iteratee, keysFunc) {
		        var index = -1,
		            iterable = Object(object),
		            props = keysFunc(object),
		            length = props.length;

		        while (length--) {
		          var key = props[fromRight ? length : ++index];
		          if (iteratee(iterable[key], key, iterable) === false) {
		            break;
		          }
		        }
		        return object;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the optional `this`
		     * binding of `thisArg`.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createBind(func, bitmask, thisArg) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return fn.apply(isBind ? thisArg : this, arguments);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.lowerFirst`.
		     *
		     * @private
		     * @param {string} methodName The name of the `String` case method to use.
		     * @returns {Function} Returns the new case function.
		     */
		    function createCaseFirst(methodName) {
		      return function(string) {
		        string = toString(string);

		        var strSymbols = hasUnicode(string)
		          ? stringToArray(string)
		          : undefined$1;

		        var chr = strSymbols
		          ? strSymbols[0]
		          : string.charAt(0);

		        var trailing = strSymbols
		          ? castSlice(strSymbols, 1).join('')
		          : string.slice(1);

		        return chr[methodName]() + trailing;
		      };
		    }

		    /**
		     * Creates a function like `_.camelCase`.
		     *
		     * @private
		     * @param {Function} callback The function to combine each word.
		     * @returns {Function} Returns the new compounder function.
		     */
		    function createCompounder(callback) {
		      return function(string) {
		        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
		      };
		    }

		    /**
		     * Creates a function that produces an instance of `Ctor` regardless of
		     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
		     *
		     * @private
		     * @param {Function} Ctor The constructor to wrap.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCtor(Ctor) {
		      return function() {
		        // Use a `switch` statement to work with class constructors. See
		        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
		        // for more details.
		        var args = arguments;
		        switch (args.length) {
		          case 0: return new Ctor;
		          case 1: return new Ctor(args[0]);
		          case 2: return new Ctor(args[0], args[1]);
		          case 3: return new Ctor(args[0], args[1], args[2]);
		          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
		          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
		          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
		          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
		        }
		        var thisBinding = baseCreate(Ctor.prototype),
		            result = Ctor.apply(thisBinding, args);

		        // Mimic the constructor's `return` behavior.
		        // See https://es5.github.io/#x13.2.2 for more details.
		        return isObject(result) ? result : thisBinding;
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to enable currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {number} arity The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createCurry(func, bitmask, arity) {
		      var Ctor = createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length,
		            placeholder = getHolder(wrapper);

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
		          ? []
		          : replaceHolders(args, placeholder);

		        length -= holders.length;
		        if (length < arity) {
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
		            args, holders, undefined$1, undefined$1, arity - length);
		        }
		        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
		        return apply(fn, this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.find` or `_.findLast` function.
		     *
		     * @private
		     * @param {Function} findIndexFunc The function to find the collection index.
		     * @returns {Function} Returns the new find function.
		     */
		    function createFind(findIndexFunc) {
		      return function(collection, predicate, fromIndex) {
		        var iterable = Object(collection);
		        if (!isArrayLike(collection)) {
		          var iteratee = getIteratee(predicate, 3);
		          collection = keys(collection);
		          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
		        }
		        var index = findIndexFunc(collection, predicate, fromIndex);
		        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
		      };
		    }

		    /**
		     * Creates a `_.flow` or `_.flowRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new flow function.
		     */
		    function createFlow(fromRight) {
		      return flatRest(function(funcs) {
		        var length = funcs.length,
		            index = length,
		            prereq = LodashWrapper.prototype.thru;

		        if (fromRight) {
		          funcs.reverse();
		        }
		        while (index--) {
		          var func = funcs[index];
		          if (typeof func != 'function') {
		            throw new TypeError(FUNC_ERROR_TEXT);
		          }
		          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
		            var wrapper = new LodashWrapper([], true);
		          }
		        }
		        index = wrapper ? index : length;
		        while (++index < length) {
		          func = funcs[index];

		          var funcName = getFuncName(func),
		              data = funcName == 'wrapper' ? getData(func) : undefined$1;

		          if (data && isLaziable(data[0]) &&
		                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
		                !data[4].length && data[9] == 1
		              ) {
		            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
		          } else {
		            wrapper = (func.length == 1 && isLaziable(func))
		              ? wrapper[funcName]()
		              : wrapper.thru(func);
		          }
		        }
		        return function() {
		          var args = arguments,
		              value = args[0];

		          if (wrapper && args.length == 1 && isArray(value)) {
		            return wrapper.plant(value).value();
		          }
		          var index = 0,
		              result = length ? funcs[index].apply(this, args) : value;

		          while (++index < length) {
		            result = funcs[index].call(this, result);
		          }
		          return result;
		        };
		      });
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with optional `this`
		     * binding of `thisArg`, partial application, and currying.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [partialsRight] The arguments to append to those provided
		     *  to the new function.
		     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
		      var isAry = bitmask & WRAP_ARY_FLAG,
		          isBind = bitmask & WRAP_BIND_FLAG,
		          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
		          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
		          isFlip = bitmask & WRAP_FLIP_FLAG,
		          Ctor = isBindKey ? undefined$1 : createCtor(func);

		      function wrapper() {
		        var length = arguments.length,
		            args = Array(length),
		            index = length;

		        while (index--) {
		          args[index] = arguments[index];
		        }
		        if (isCurried) {
		          var placeholder = getHolder(wrapper),
		              holdersCount = countHolders(args, placeholder);
		        }
		        if (partials) {
		          args = composeArgs(args, partials, holders, isCurried);
		        }
		        if (partialsRight) {
		          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
		        }
		        length -= holdersCount;
		        if (isCurried && length < arity) {
		          var newHolders = replaceHolders(args, placeholder);
		          return createRecurry(
		            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
		            args, newHolders, argPos, ary, arity - length
		          );
		        }
		        var thisBinding = isBind ? thisArg : this,
		            fn = isBindKey ? thisBinding[func] : func;

		        length = args.length;
		        if (argPos) {
		          args = reorder(args, argPos);
		        } else if (isFlip && length > 1) {
		          args.reverse();
		        }
		        if (isAry && ary < length) {
		          args.length = ary;
		        }
		        if (this && this !== root && this instanceof wrapper) {
		          fn = Ctor || createCtor(fn);
		        }
		        return fn.apply(thisBinding, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a function like `_.invertBy`.
		     *
		     * @private
		     * @param {Function} setter The function to set accumulator values.
		     * @param {Function} toIteratee The function to resolve iteratees.
		     * @returns {Function} Returns the new inverter function.
		     */
		    function createInverter(setter, toIteratee) {
		      return function(object, iteratee) {
		        return baseInverter(object, setter, toIteratee(iteratee), {});
		      };
		    }

		    /**
		     * Creates a function that performs a mathematical operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @param {number} [defaultValue] The value used for `undefined` arguments.
		     * @returns {Function} Returns the new mathematical operation function.
		     */
		    function createMathOperation(operator, defaultValue) {
		      return function(value, other) {
		        var result;
		        if (value === undefined$1 && other === undefined$1) {
		          return defaultValue;
		        }
		        if (value !== undefined$1) {
		          result = value;
		        }
		        if (other !== undefined$1) {
		          if (result === undefined$1) {
		            return other;
		          }
		          if (typeof value == 'string' || typeof other == 'string') {
		            value = baseToString(value);
		            other = baseToString(other);
		          } else {
		            value = baseToNumber(value);
		            other = baseToNumber(other);
		          }
		          result = operator(value, other);
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function like `_.over`.
		     *
		     * @private
		     * @param {Function} arrayFunc The function to iterate over iteratees.
		     * @returns {Function} Returns the new over function.
		     */
		    function createOver(arrayFunc) {
		      return flatRest(function(iteratees) {
		        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
		        return baseRest(function(args) {
		          var thisArg = this;
		          return arrayFunc(iteratees, function(iteratee) {
		            return apply(iteratee, thisArg, args);
		          });
		        });
		      });
		    }

		    /**
		     * Creates the padding for `string` based on `length`. The `chars` string
		     * is truncated if the number of characters exceeds `length`.
		     *
		     * @private
		     * @param {number} length The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padding for `string`.
		     */
		    function createPadding(length, chars) {
		      chars = chars === undefined$1 ? ' ' : baseToString(chars);

		      var charsLength = chars.length;
		      if (charsLength < 2) {
		        return charsLength ? baseRepeat(chars, length) : chars;
		      }
		      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
		      return hasUnicode(chars)
		        ? castSlice(stringToArray(result), 0, length).join('')
		        : result.slice(0, length);
		    }

		    /**
		     * Creates a function that wraps `func` to invoke it with the `this` binding
		     * of `thisArg` and `partials` prepended to the arguments it receives.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {Array} partials The arguments to prepend to those provided to
		     *  the new function.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createPartial(func, bitmask, thisArg, partials) {
		      var isBind = bitmask & WRAP_BIND_FLAG,
		          Ctor = createCtor(func);

		      function wrapper() {
		        var argsIndex = -1,
		            argsLength = arguments.length,
		            leftIndex = -1,
		            leftLength = partials.length,
		            args = Array(leftLength + argsLength),
		            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

		        while (++leftIndex < leftLength) {
		          args[leftIndex] = partials[leftIndex];
		        }
		        while (argsLength--) {
		          args[leftIndex++] = arguments[++argsIndex];
		        }
		        return apply(fn, isBind ? thisArg : this, args);
		      }
		      return wrapper;
		    }

		    /**
		     * Creates a `_.range` or `_.rangeRight` function.
		     *
		     * @private
		     * @param {boolean} [fromRight] Specify iterating from right to left.
		     * @returns {Function} Returns the new range function.
		     */
		    function createRange(fromRight) {
		      return function(start, end, step) {
		        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
		          end = step = undefined$1;
		        }
		        // Ensure the sign of `-0` is preserved.
		        start = toFinite(start);
		        if (end === undefined$1) {
		          end = start;
		          start = 0;
		        } else {
		          end = toFinite(end);
		        }
		        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
		        return baseRange(start, end, step, fromRight);
		      };
		    }

		    /**
		     * Creates a function that performs a relational operation on two values.
		     *
		     * @private
		     * @param {Function} operator The function to perform the operation.
		     * @returns {Function} Returns the new relational operation function.
		     */
		    function createRelationalOperation(operator) {
		      return function(value, other) {
		        if (!(typeof value == 'string' && typeof other == 'string')) {
		          value = toNumber(value);
		          other = toNumber(other);
		        }
		        return operator(value, other);
		      };
		    }

		    /**
		     * Creates a function that wraps `func` to continue currying.
		     *
		     * @private
		     * @param {Function} func The function to wrap.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @param {Function} wrapFunc The function to create the `func` wrapper.
		     * @param {*} placeholder The placeholder value.
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to prepend to those provided to
		     *  the new function.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
		      var isCurry = bitmask & WRAP_CURRY_FLAG,
		          newHolders = isCurry ? holders : undefined$1,
		          newHoldersRight = isCurry ? undefined$1 : holders,
		          newPartials = isCurry ? partials : undefined$1,
		          newPartialsRight = isCurry ? undefined$1 : partials;

		      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
		      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

		      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
		        bitmask &= -4;
		      }
		      var newData = [
		        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
		        newHoldersRight, argPos, ary, arity
		      ];

		      var result = wrapFunc.apply(undefined$1, newData);
		      if (isLaziable(func)) {
		        setData(result, newData);
		      }
		      result.placeholder = placeholder;
		      return setWrapToString(result, func, bitmask);
		    }

		    /**
		     * Creates a function like `_.round`.
		     *
		     * @private
		     * @param {string} methodName The name of the `Math` method to use when rounding.
		     * @returns {Function} Returns the new round function.
		     */
		    function createRound(methodName) {
		      var func = Math[methodName];
		      return function(number, precision) {
		        number = toNumber(number);
		        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
		        if (precision && nativeIsFinite(number)) {
		          // Shift with exponential notation to avoid floating-point issues.
		          // See [MDN](https://mdn.io/round#Examples) for more details.
		          var pair = (toString(number) + 'e').split('e'),
		              value = func(pair[0] + 'e' + (+pair[1] + precision));

		          pair = (toString(value) + 'e').split('e');
		          return +(pair[0] + 'e' + (+pair[1] - precision));
		        }
		        return func(number);
		      };
		    }

		    /**
		     * Creates a set object of `values`.
		     *
		     * @private
		     * @param {Array} values The values to add to the set.
		     * @returns {Object} Returns the new set.
		     */
		    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
		      return new Set(values);
		    };

		    /**
		     * Creates a `_.toPairs` or `_.toPairsIn` function.
		     *
		     * @private
		     * @param {Function} keysFunc The function to get the keys of a given object.
		     * @returns {Function} Returns the new pairs function.
		     */
		    function createToPairs(keysFunc) {
		      return function(object) {
		        var tag = getTag(object);
		        if (tag == mapTag) {
		          return mapToArray(object);
		        }
		        if (tag == setTag) {
		          return setToPairs(object);
		        }
		        return baseToPairs(object, keysFunc(object));
		      };
		    }

		    /**
		     * Creates a function that either curries or invokes `func` with optional
		     * `this` binding and partially applied arguments.
		     *
		     * @private
		     * @param {Function|string} func The function or method name to wrap.
		     * @param {number} bitmask The bitmask flags.
		     *    1 - `_.bind`
		     *    2 - `_.bindKey`
		     *    4 - `_.curry` or `_.curryRight` of a bound function
		     *    8 - `_.curry`
		     *   16 - `_.curryRight`
		     *   32 - `_.partial`
		     *   64 - `_.partialRight`
		     *  128 - `_.rearg`
		     *  256 - `_.ary`
		     *  512 - `_.flip`
		     * @param {*} [thisArg] The `this` binding of `func`.
		     * @param {Array} [partials] The arguments to be partially applied.
		     * @param {Array} [holders] The `partials` placeholder indexes.
		     * @param {Array} [argPos] The argument positions of the new function.
		     * @param {number} [ary] The arity cap of `func`.
		     * @param {number} [arity] The arity of `func`.
		     * @returns {Function} Returns the new wrapped function.
		     */
		    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
		      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
		      if (!isBindKey && typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var length = partials ? partials.length : 0;
		      if (!length) {
		        bitmask &= -97;
		        partials = holders = undefined$1;
		      }
		      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
		      arity = arity === undefined$1 ? arity : toInteger(arity);
		      length -= holders ? holders.length : 0;

		      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
		        var partialsRight = partials,
		            holdersRight = holders;

		        partials = holders = undefined$1;
		      }
		      var data = isBindKey ? undefined$1 : getData(func);

		      var newData = [
		        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
		        argPos, ary, arity
		      ];

		      if (data) {
		        mergeData(newData, data);
		      }
		      func = newData[0];
		      bitmask = newData[1];
		      thisArg = newData[2];
		      partials = newData[3];
		      holders = newData[4];
		      arity = newData[9] = newData[9] === undefined$1
		        ? (isBindKey ? 0 : func.length)
		        : nativeMax(newData[9] - length, 0);

		      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
		        bitmask &= -25;
		      }
		      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
		        var result = createBind(func, bitmask, thisArg);
		      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
		        result = createCurry(func, bitmask, arity);
		      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
		        result = createPartial(func, bitmask, thisArg, partials);
		      } else {
		        result = createHybrid.apply(undefined$1, newData);
		      }
		      var setter = data ? baseSetData : setData;
		      return setWrapToString(setter(result, newData), func, bitmask);
		    }

		    /**
		     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
		     * of source objects to the destination object for all destination properties
		     * that resolve to `undefined`.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to assign.
		     * @param {Object} object The parent object of `objValue`.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsAssignIn(objValue, srcValue, key, object) {
		      if (objValue === undefined$1 ||
		          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		        return srcValue;
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
		     * objects into destination objects that are passed thru.
		     *
		     * @private
		     * @param {*} objValue The destination value.
		     * @param {*} srcValue The source value.
		     * @param {string} key The key of the property to merge.
		     * @param {Object} object The parent object of `objValue`.
		     * @param {Object} source The parent object of `srcValue`.
		     * @param {Object} [stack] Tracks traversed source values and their merged
		     *  counterparts.
		     * @returns {*} Returns the value to assign.
		     */
		    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
		      if (isObject(objValue) && isObject(srcValue)) {
		        // Recursively merge objects and arrays (susceptible to call stack limits).
		        stack.set(srcValue, objValue);
		        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
		        stack['delete'](srcValue);
		      }
		      return objValue;
		    }

		    /**
		     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
		     * objects.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @param {string} key The key of the property to inspect.
		     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
		     */
		    function customOmitClone(value) {
		      return isPlainObject(value) ? undefined$1 : value;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for arrays with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Array} array The array to compare.
		     * @param {Array} other The other array to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `array` and `other` objects.
		     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
		     */
		    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          arrLength = array.length,
		          othLength = other.length;

		      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
		        return false;
		      }
		      // Check that cyclic values are equal.
		      var arrStacked = stack.get(array);
		      var othStacked = stack.get(other);
		      if (arrStacked && othStacked) {
		        return arrStacked == other && othStacked == array;
		      }
		      var index = -1,
		          result = true,
		          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

		      stack.set(array, other);
		      stack.set(other, array);

		      // Ignore non-index properties.
		      while (++index < arrLength) {
		        var arrValue = array[index],
		            othValue = other[index];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, arrValue, index, other, array, stack)
		            : customizer(arrValue, othValue, index, array, other, stack);
		        }
		        if (compared !== undefined$1) {
		          if (compared) {
		            continue;
		          }
		          result = false;
		          break;
		        }
		        // Recursively compare arrays (susceptible to call stack limits).
		        if (seen) {
		          if (!arraySome(other, function(othValue, othIndex) {
		                if (!cacheHas(seen, othIndex) &&
		                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
		                  return seen.push(othIndex);
		                }
		              })) {
		            result = false;
		            break;
		          }
		        } else if (!(
		              arrValue === othValue ||
		                equalFunc(arrValue, othValue, bitmask, customizer, stack)
		            )) {
		          result = false;
		          break;
		        }
		      }
		      stack['delete'](array);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for comparing objects of
		     * the same `toStringTag`.
		     *
		     * **Note:** This function only supports comparing values with tags of
		     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {string} tag The `toStringTag` of the objects to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
		      switch (tag) {
		        case dataViewTag:
		          if ((object.byteLength != other.byteLength) ||
		              (object.byteOffset != other.byteOffset)) {
		            return false;
		          }
		          object = object.buffer;
		          other = other.buffer;

		        case arrayBufferTag:
		          if ((object.byteLength != other.byteLength) ||
		              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
		            return false;
		          }
		          return true;

		        case boolTag:
		        case dateTag:
		        case numberTag:
		          // Coerce booleans to `1` or `0` and dates to milliseconds.
		          // Invalid dates are coerced to `NaN`.
		          return eq(+object, +other);

		        case errorTag:
		          return object.name == other.name && object.message == other.message;

		        case regexpTag:
		        case stringTag:
		          // Coerce regexes to strings and treat strings, primitives and objects,
		          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
		          // for more details.
		          return object == (other + '');

		        case mapTag:
		          var convert = mapToArray;

		        case setTag:
		          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
		          convert || (convert = setToArray);

		          if (object.size != other.size && !isPartial) {
		            return false;
		          }
		          // Assume cyclic values are equal.
		          var stacked = stack.get(object);
		          if (stacked) {
		            return stacked == other;
		          }
		          bitmask |= COMPARE_UNORDERED_FLAG;

		          // Recursively compare objects (susceptible to call stack limits).
		          stack.set(object, other);
		          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
		          stack['delete'](object);
		          return result;

		        case symbolTag:
		          if (symbolValueOf) {
		            return symbolValueOf.call(object) == symbolValueOf.call(other);
		          }
		      }
		      return false;
		    }

		    /**
		     * A specialized version of `baseIsEqualDeep` for objects with support for
		     * partial deep comparisons.
		     *
		     * @private
		     * @param {Object} object The object to compare.
		     * @param {Object} other The other object to compare.
		     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
		     * @param {Function} customizer The function to customize comparisons.
		     * @param {Function} equalFunc The function to determine equivalents of values.
		     * @param {Object} stack Tracks traversed `object` and `other` objects.
		     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
		     */
		    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
		      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
		          objProps = getAllKeys(object),
		          objLength = objProps.length,
		          othProps = getAllKeys(other),
		          othLength = othProps.length;

		      if (objLength != othLength && !isPartial) {
		        return false;
		      }
		      var index = objLength;
		      while (index--) {
		        var key = objProps[index];
		        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
		          return false;
		        }
		      }
		      // Check that cyclic values are equal.
		      var objStacked = stack.get(object);
		      var othStacked = stack.get(other);
		      if (objStacked && othStacked) {
		        return objStacked == other && othStacked == object;
		      }
		      var result = true;
		      stack.set(object, other);
		      stack.set(other, object);

		      var skipCtor = isPartial;
		      while (++index < objLength) {
		        key = objProps[index];
		        var objValue = object[key],
		            othValue = other[key];

		        if (customizer) {
		          var compared = isPartial
		            ? customizer(othValue, objValue, key, other, object, stack)
		            : customizer(objValue, othValue, key, object, other, stack);
		        }
		        // Recursively compare objects (susceptible to call stack limits).
		        if (!(compared === undefined$1
		              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
		              : compared
		            )) {
		          result = false;
		          break;
		        }
		        skipCtor || (skipCtor = key == 'constructor');
		      }
		      if (result && !skipCtor) {
		        var objCtor = object.constructor,
		            othCtor = other.constructor;

		        // Non `Object` object instances with different constructors are not equal.
		        if (objCtor != othCtor &&
		            ('constructor' in object && 'constructor' in other) &&
		            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
		              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
		          result = false;
		        }
		      }
		      stack['delete'](object);
		      stack['delete'](other);
		      return result;
		    }

		    /**
		     * A specialized version of `baseRest` which flattens the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @returns {Function} Returns the new function.
		     */
		    function flatRest(func) {
		      return setToString(overRest(func, undefined$1, flatten), func + '');
		    }

		    /**
		     * Creates an array of own enumerable property names and symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeys(object) {
		      return baseGetAllKeys(object, keys, getSymbols);
		    }

		    /**
		     * Creates an array of own and inherited enumerable property names and
		     * symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names and symbols.
		     */
		    function getAllKeysIn(object) {
		      return baseGetAllKeys(object, keysIn, getSymbolsIn);
		    }

		    /**
		     * Gets metadata for `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {*} Returns the metadata for `func`.
		     */
		    var getData = !metaMap ? noop : function(func) {
		      return metaMap.get(func);
		    };

		    /**
		     * Gets the name of `func`.
		     *
		     * @private
		     * @param {Function} func The function to query.
		     * @returns {string} Returns the function name.
		     */
		    function getFuncName(func) {
		      var result = (func.name + ''),
		          array = realNames[result],
		          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

		      while (length--) {
		        var data = array[length],
		            otherFunc = data.func;
		        if (otherFunc == null || otherFunc == func) {
		          return data.name;
		        }
		      }
		      return result;
		    }

		    /**
		     * Gets the argument placeholder value for `func`.
		     *
		     * @private
		     * @param {Function} func The function to inspect.
		     * @returns {*} Returns the placeholder value.
		     */
		    function getHolder(func) {
		      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
		      return object.placeholder;
		    }

		    /**
		     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
		     * this function returns the custom method, otherwise it returns `baseIteratee`.
		     * If arguments are provided, the chosen function is invoked with them and
		     * its result is returned.
		     *
		     * @private
		     * @param {*} [value] The value to convert to an iteratee.
		     * @param {number} [arity] The arity of the created iteratee.
		     * @returns {Function} Returns the chosen function or its result.
		     */
		    function getIteratee() {
		      var result = lodash.iteratee || iteratee;
		      result = result === iteratee ? baseIteratee : result;
		      return arguments.length ? result(arguments[0], arguments[1]) : result;
		    }

		    /**
		     * Gets the data for `map`.
		     *
		     * @private
		     * @param {Object} map The map to query.
		     * @param {string} key The reference key.
		     * @returns {*} Returns the map data.
		     */
		    function getMapData(map, key) {
		      var data = map.__data__;
		      return isKeyable(key)
		        ? data[typeof key == 'string' ? 'string' : 'hash']
		        : data.map;
		    }

		    /**
		     * Gets the property names, values, and compare flags of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the match data of `object`.
		     */
		    function getMatchData(object) {
		      var result = keys(object),
		          length = result.length;

		      while (length--) {
		        var key = result[length],
		            value = object[key];

		        result[length] = [key, value, isStrictComparable(value)];
		      }
		      return result;
		    }

		    /**
		     * Gets the native function at `key` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the method to get.
		     * @returns {*} Returns the function if it's native, else `undefined`.
		     */
		    function getNative(object, key) {
		      var value = getValue(object, key);
		      return baseIsNative(value) ? value : undefined$1;
		    }

		    /**
		     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the raw `toStringTag`.
		     */
		    function getRawTag(value) {
		      var isOwn = hasOwnProperty.call(value, symToStringTag),
		          tag = value[symToStringTag];

		      try {
		        value[symToStringTag] = undefined$1;
		        var unmasked = true;
		      } catch (e) {}

		      var result = nativeObjectToString.call(value);
		      if (unmasked) {
		        if (isOwn) {
		          value[symToStringTag] = tag;
		        } else {
		          delete value[symToStringTag];
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates an array of the own enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
		      if (object == null) {
		        return [];
		      }
		      object = Object(object);
		      return arrayFilter(nativeGetSymbols(object), function(symbol) {
		        return propertyIsEnumerable.call(object, symbol);
		      });
		    };

		    /**
		     * Creates an array of the own and inherited enumerable symbols of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of symbols.
		     */
		    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
		      var result = [];
		      while (object) {
		        arrayPush(result, getSymbols(object));
		        object = getPrototype(object);
		      }
		      return result;
		    };

		    /**
		     * Gets the `toStringTag` of `value`.
		     *
		     * @private
		     * @param {*} value The value to query.
		     * @returns {string} Returns the `toStringTag`.
		     */
		    var getTag = baseGetTag;

		    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
		    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
		        (Map && getTag(new Map) != mapTag) ||
		        (Promise && getTag(Promise.resolve()) != promiseTag) ||
		        (Set && getTag(new Set) != setTag) ||
		        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
		      getTag = function(value) {
		        var result = baseGetTag(value),
		            Ctor = result == objectTag ? value.constructor : undefined$1,
		            ctorString = Ctor ? toSource(Ctor) : '';

		        if (ctorString) {
		          switch (ctorString) {
		            case dataViewCtorString: return dataViewTag;
		            case mapCtorString: return mapTag;
		            case promiseCtorString: return promiseTag;
		            case setCtorString: return setTag;
		            case weakMapCtorString: return weakMapTag;
		          }
		        }
		        return result;
		      };
		    }

		    /**
		     * Gets the view, applying any `transforms` to the `start` and `end` positions.
		     *
		     * @private
		     * @param {number} start The start of the view.
		     * @param {number} end The end of the view.
		     * @param {Array} transforms The transformations to apply to the view.
		     * @returns {Object} Returns an object containing the `start` and `end`
		     *  positions of the view.
		     */
		    function getView(start, end, transforms) {
		      var index = -1,
		          length = transforms.length;

		      while (++index < length) {
		        var data = transforms[index],
		            size = data.size;

		        switch (data.type) {
		          case 'drop':      start += size; break;
		          case 'dropRight': end -= size; break;
		          case 'take':      end = nativeMin(end, start + size); break;
		          case 'takeRight': start = nativeMax(start, end - size); break;
		        }
		      }
		      return { 'start': start, 'end': end };
		    }

		    /**
		     * Extracts wrapper details from the `source` body comment.
		     *
		     * @private
		     * @param {string} source The source to inspect.
		     * @returns {Array} Returns the wrapper details.
		     */
		    function getWrapDetails(source) {
		      var match = source.match(reWrapDetails);
		      return match ? match[1].split(reSplitDetails) : [];
		    }

		    /**
		     * Checks if `path` exists on `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @param {Function} hasFunc The function to check properties.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     */
		    function hasPath(object, path, hasFunc) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length,
		          result = false;

		      while (++index < length) {
		        var key = toKey(path[index]);
		        if (!(result = object != null && hasFunc(object, key))) {
		          break;
		        }
		        object = object[key];
		      }
		      if (result || ++index != length) {
		        return result;
		      }
		      length = object == null ? 0 : object.length;
		      return !!length && isLength(length) && isIndex(key, length) &&
		        (isArray(object) || isArguments(object));
		    }

		    /**
		     * Initializes an array clone.
		     *
		     * @private
		     * @param {Array} array The array to clone.
		     * @returns {Array} Returns the initialized clone.
		     */
		    function initCloneArray(array) {
		      var length = array.length,
		          result = new array.constructor(length);

		      // Add properties assigned by `RegExp#exec`.
		      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
		        result.index = array.index;
		        result.input = array.input;
		      }
		      return result;
		    }

		    /**
		     * Initializes an object clone.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneObject(object) {
		      return (typeof object.constructor == 'function' && !isPrototype(object))
		        ? baseCreate(getPrototype(object))
		        : {};
		    }

		    /**
		     * Initializes an object clone based on its `toStringTag`.
		     *
		     * **Note:** This function only supports cloning values with tags of
		     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
		     *
		     * @private
		     * @param {Object} object The object to clone.
		     * @param {string} tag The `toStringTag` of the object to clone.
		     * @param {boolean} [isDeep] Specify a deep clone.
		     * @returns {Object} Returns the initialized clone.
		     */
		    function initCloneByTag(object, tag, isDeep) {
		      var Ctor = object.constructor;
		      switch (tag) {
		        case arrayBufferTag:
		          return cloneArrayBuffer(object);

		        case boolTag:
		        case dateTag:
		          return new Ctor(+object);

		        case dataViewTag:
		          return cloneDataView(object, isDeep);

		        case float32Tag: case float64Tag:
		        case int8Tag: case int16Tag: case int32Tag:
		        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
		          return cloneTypedArray(object, isDeep);

		        case mapTag:
		          return new Ctor;

		        case numberTag:
		        case stringTag:
		          return new Ctor(object);

		        case regexpTag:
		          return cloneRegExp(object);

		        case setTag:
		          return new Ctor;

		        case symbolTag:
		          return cloneSymbol(object);
		      }
		    }

		    /**
		     * Inserts wrapper `details` in a comment at the top of the `source` body.
		     *
		     * @private
		     * @param {string} source The source to modify.
		     * @returns {Array} details The details to insert.
		     * @returns {string} Returns the modified source.
		     */
		    function insertWrapDetails(source, details) {
		      var length = details.length;
		      if (!length) {
		        return source;
		      }
		      var lastIndex = length - 1;
		      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
		      details = details.join(length > 2 ? ', ' : ' ');
		      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
		    }

		    /**
		     * Checks if `value` is a flattenable `arguments` object or array.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
		     */
		    function isFlattenable(value) {
		      return isArray(value) || isArguments(value) ||
		        !!(spreadableSymbol && value && value[spreadableSymbol]);
		    }

		    /**
		     * Checks if `value` is a valid array-like index.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
		     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
		     */
		    function isIndex(value, length) {
		      var type = typeof value;
		      length = length == null ? MAX_SAFE_INTEGER : length;

		      return !!length &&
		        (type == 'number' ||
		          (type != 'symbol' && reIsUint.test(value))) &&
		            (value > -1 && value % 1 == 0 && value < length);
		    }

		    /**
		     * Checks if the given arguments are from an iteratee call.
		     *
		     * @private
		     * @param {*} value The potential iteratee value argument.
		     * @param {*} index The potential iteratee index or key argument.
		     * @param {*} object The potential iteratee object argument.
		     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
		     *  else `false`.
		     */
		    function isIterateeCall(value, index, object) {
		      if (!isObject(object)) {
		        return false;
		      }
		      var type = typeof index;
		      if (type == 'number'
		            ? (isArrayLike(object) && isIndex(index, object.length))
		            : (type == 'string' && index in object)
		          ) {
		        return eq(object[index], value);
		      }
		      return false;
		    }

		    /**
		     * Checks if `value` is a property name and not a property path.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @param {Object} [object] The object to query keys on.
		     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
		     */
		    function isKey(value, object) {
		      if (isArray(value)) {
		        return false;
		      }
		      var type = typeof value;
		      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
		          value == null || isSymbol(value)) {
		        return true;
		      }
		      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
		        (object != null && value in Object(object));
		    }

		    /**
		     * Checks if `value` is suitable for use as unique object key.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
		     */
		    function isKeyable(value) {
		      var type = typeof value;
		      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
		        ? (value !== '__proto__')
		        : (value === null);
		    }

		    /**
		     * Checks if `func` has a lazy counterpart.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
		     *  else `false`.
		     */
		    function isLaziable(func) {
		      var funcName = getFuncName(func),
		          other = lodash[funcName];

		      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
		        return false;
		      }
		      if (func === other) {
		        return true;
		      }
		      var data = getData(other);
		      return !!data && func === data[0];
		    }

		    /**
		     * Checks if `func` has its source masked.
		     *
		     * @private
		     * @param {Function} func The function to check.
		     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
		     */
		    function isMasked(func) {
		      return !!maskSrcKey && (maskSrcKey in func);
		    }

		    /**
		     * Checks if `func` is capable of being masked.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
		     */
		    var isMaskable = coreJsData ? isFunction : stubFalse;

		    /**
		     * Checks if `value` is likely a prototype object.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
		     */
		    function isPrototype(value) {
		      var Ctor = value && value.constructor,
		          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

		      return value === proto;
		    }

		    /**
		     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` if suitable for strict
		     *  equality comparisons, else `false`.
		     */
		    function isStrictComparable(value) {
		      return value === value && !isObject(value);
		    }

		    /**
		     * A specialized version of `matchesProperty` for source values suitable
		     * for strict equality comparisons, i.e. `===`.
		     *
		     * @private
		     * @param {string} key The key of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     */
		    function matchesStrictComparable(key, srcValue) {
		      return function(object) {
		        if (object == null) {
		          return false;
		        }
		        return object[key] === srcValue &&
		          (srcValue !== undefined$1 || (key in Object(object)));
		      };
		    }

		    /**
		     * A specialized version of `_.memoize` which clears the memoized function's
		     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
		     *
		     * @private
		     * @param {Function} func The function to have its output memoized.
		     * @returns {Function} Returns the new memoized function.
		     */
		    function memoizeCapped(func) {
		      var result = memoize(func, function(key) {
		        if (cache.size === MAX_MEMOIZE_SIZE) {
		          cache.clear();
		        }
		        return key;
		      });

		      var cache = result.cache;
		      return result;
		    }

		    /**
		     * Merges the function metadata of `source` into `data`.
		     *
		     * Merging metadata reduces the number of wrappers used to invoke a function.
		     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
		     * may be applied regardless of execution order. Methods like `_.ary` and
		     * `_.rearg` modify function arguments, making the order in which they are
		     * executed important, preventing the merging of metadata. However, we make
		     * an exception for a safe combined case where curried functions have `_.ary`
		     * and or `_.rearg` applied.
		     *
		     * @private
		     * @param {Array} data The destination metadata.
		     * @param {Array} source The source metadata.
		     * @returns {Array} Returns `data`.
		     */
		    function mergeData(data, source) {
		      var bitmask = data[1],
		          srcBitmask = source[1],
		          newBitmask = bitmask | srcBitmask,
		          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

		      var isCombo =
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
		        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
		        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

		      // Exit early if metadata can't be merged.
		      if (!(isCommon || isCombo)) {
		        return data;
		      }
		      // Use source `thisArg` if available.
		      if (srcBitmask & WRAP_BIND_FLAG) {
		        data[2] = source[2];
		        // Set when currying a bound function.
		        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
		      }
		      // Compose partial arguments.
		      var value = source[3];
		      if (value) {
		        var partials = data[3];
		        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
		        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
		      }
		      // Compose partial right arguments.
		      value = source[5];
		      if (value) {
		        partials = data[5];
		        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
		        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
		      }
		      // Use source `argPos` if available.
		      value = source[7];
		      if (value) {
		        data[7] = value;
		      }
		      // Use source `ary` if it's smaller.
		      if (srcBitmask & WRAP_ARY_FLAG) {
		        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
		      }
		      // Use source `arity` if one is not provided.
		      if (data[9] == null) {
		        data[9] = source[9];
		      }
		      // Use source `func` and merge bitmasks.
		      data[0] = source[0];
		      data[1] = newBitmask;

		      return data;
		    }

		    /**
		     * This function is like
		     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * except that it includes inherited enumerable properties.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     */
		    function nativeKeysIn(object) {
		      var result = [];
		      if (object != null) {
		        for (var key in Object(object)) {
		          result.push(key);
		        }
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a string using `Object.prototype.toString`.
		     *
		     * @private
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     */
		    function objectToString(value) {
		      return nativeObjectToString.call(value);
		    }

		    /**
		     * A specialized version of `baseRest` which transforms the rest array.
		     *
		     * @private
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @param {Function} transform The rest array transform.
		     * @returns {Function} Returns the new function.
		     */
		    function overRest(func, start, transform) {
		      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
		      return function() {
		        var args = arguments,
		            index = -1,
		            length = nativeMax(args.length - start, 0),
		            array = Array(length);

		        while (++index < length) {
		          array[index] = args[start + index];
		        }
		        index = -1;
		        var otherArgs = Array(start + 1);
		        while (++index < start) {
		          otherArgs[index] = args[index];
		        }
		        otherArgs[start] = transform(array);
		        return apply(func, this, otherArgs);
		      };
		    }

		    /**
		     * Gets the parent value at `path` of `object`.
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {Array} path The path to get the parent value of.
		     * @returns {*} Returns the parent value.
		     */
		    function parent(object, path) {
		      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
		    }

		    /**
		     * Reorder `array` according to the specified indexes where the element at
		     * the first index is assigned as the first element, the element at
		     * the second index is assigned as the second element, and so on.
		     *
		     * @private
		     * @param {Array} array The array to reorder.
		     * @param {Array} indexes The arranged array indexes.
		     * @returns {Array} Returns `array`.
		     */
		    function reorder(array, indexes) {
		      var arrLength = array.length,
		          length = nativeMin(indexes.length, arrLength),
		          oldArray = copyArray(array);

		      while (length--) {
		        var index = indexes[length];
		        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
		      }
		      return array;
		    }

		    /**
		     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
		     *
		     * @private
		     * @param {Object} object The object to query.
		     * @param {string} key The key of the property to get.
		     * @returns {*} Returns the property value.
		     */
		    function safeGet(object, key) {
		      if (key === 'constructor' && typeof object[key] === 'function') {
		        return;
		      }

		      if (key == '__proto__') {
		        return;
		      }

		      return object[key];
		    }

		    /**
		     * Sets metadata for `func`.
		     *
		     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
		     * period of time, it will trip its breaker and transition to an identity
		     * function to avoid garbage collection pauses in V8. See
		     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
		     * for more details.
		     *
		     * @private
		     * @param {Function} func The function to associate metadata with.
		     * @param {*} data The metadata.
		     * @returns {Function} Returns `func`.
		     */
		    var setData = shortOut(baseSetData);

		    /**
		     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
		     *
		     * @private
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @returns {number|Object} Returns the timer id or timeout object.
		     */
		    var setTimeout = ctxSetTimeout || function(func, wait) {
		      return root.setTimeout(func, wait);
		    };

		    /**
		     * Sets the `toString` method of `func` to return `string`.
		     *
		     * @private
		     * @param {Function} func The function to modify.
		     * @param {Function} string The `toString` result.
		     * @returns {Function} Returns `func`.
		     */
		    var setToString = shortOut(baseSetToString);

		    /**
		     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
		     * with wrapper details in a comment at the top of the source body.
		     *
		     * @private
		     * @param {Function} wrapper The function to modify.
		     * @param {Function} reference The reference function.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Function} Returns `wrapper`.
		     */
		    function setWrapToString(wrapper, reference, bitmask) {
		      var source = (reference + '');
		      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
		    }

		    /**
		     * Creates a function that'll short out and invoke `identity` instead
		     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
		     * milliseconds.
		     *
		     * @private
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new shortable function.
		     */
		    function shortOut(func) {
		      var count = 0,
		          lastCalled = 0;

		      return function() {
		        var stamp = nativeNow(),
		            remaining = HOT_SPAN - (stamp - lastCalled);

		        lastCalled = stamp;
		        if (remaining > 0) {
		          if (++count >= HOT_COUNT) {
		            return arguments[0];
		          }
		        } else {
		          count = 0;
		        }
		        return func.apply(undefined$1, arguments);
		      };
		    }

		    /**
		     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
		     *
		     * @private
		     * @param {Array} array The array to shuffle.
		     * @param {number} [size=array.length] The size of `array`.
		     * @returns {Array} Returns `array`.
		     */
		    function shuffleSelf(array, size) {
		      var index = -1,
		          length = array.length,
		          lastIndex = length - 1;

		      size = size === undefined$1 ? length : size;
		      while (++index < size) {
		        var rand = baseRandom(index, lastIndex),
		            value = array[rand];

		        array[rand] = array[index];
		        array[index] = value;
		      }
		      array.length = size;
		      return array;
		    }

		    /**
		     * Converts `string` to a property path array.
		     *
		     * @private
		     * @param {string} string The string to convert.
		     * @returns {Array} Returns the property path array.
		     */
		    var stringToPath = memoizeCapped(function(string) {
		      var result = [];
		      if (string.charCodeAt(0) === 46 /* . */) {
		        result.push('');
		      }
		      string.replace(rePropName, function(match, number, quote, subString) {
		        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
		      });
		      return result;
		    });

		    /**
		     * Converts `value` to a string key if it's not a string or symbol.
		     *
		     * @private
		     * @param {*} value The value to inspect.
		     * @returns {string|symbol} Returns the key.
		     */
		    function toKey(value) {
		      if (typeof value == 'string' || isSymbol(value)) {
		        return value;
		      }
		      var result = (value + '');
		      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
		    }

		    /**
		     * Converts `func` to its source code.
		     *
		     * @private
		     * @param {Function} func The function to convert.
		     * @returns {string} Returns the source code.
		     */
		    function toSource(func) {
		      if (func != null) {
		        try {
		          return funcToString.call(func);
		        } catch (e) {}
		        try {
		          return (func + '');
		        } catch (e) {}
		      }
		      return '';
		    }

		    /**
		     * Updates wrapper `details` based on `bitmask` flags.
		     *
		     * @private
		     * @returns {Array} details The details to modify.
		     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
		     * @returns {Array} Returns `details`.
		     */
		    function updateWrapDetails(details, bitmask) {
		      arrayEach(wrapFlags, function(pair) {
		        var value = '_.' + pair[0];
		        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
		          details.push(value);
		        }
		      });
		      return details.sort();
		    }

		    /**
		     * Creates a clone of `wrapper`.
		     *
		     * @private
		     * @param {Object} wrapper The wrapper to clone.
		     * @returns {Object} Returns the cloned wrapper.
		     */
		    function wrapperClone(wrapper) {
		      if (wrapper instanceof LazyWrapper) {
		        return wrapper.clone();
		      }
		      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
		      result.__actions__ = copyArray(wrapper.__actions__);
		      result.__index__  = wrapper.__index__;
		      result.__values__ = wrapper.__values__;
		      return result;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an array of elements split into groups the length of `size`.
		     * If `array` can't be split evenly, the final chunk will be the remaining
		     * elements.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to process.
		     * @param {number} [size=1] The length of each chunk
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the new array of chunks.
		     * @example
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 2);
		     * // => [['a', 'b'], ['c', 'd']]
		     *
		     * _.chunk(['a', 'b', 'c', 'd'], 3);
		     * // => [['a', 'b', 'c'], ['d']]
		     */
		    function chunk(array, size, guard) {
		      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
		        size = 1;
		      } else {
		        size = nativeMax(toInteger(size), 0);
		      }
		      var length = array == null ? 0 : array.length;
		      if (!length || size < 1) {
		        return [];
		      }
		      var index = 0,
		          resIndex = 0,
		          result = Array(nativeCeil(length / size));

		      while (index < length) {
		        result[resIndex++] = baseSlice(array, index, (index += size));
		      }
		      return result;
		    }

		    /**
		     * Creates an array with all falsey values removed. The values `false`, `null`,
		     * `0`, `""`, `undefined`, and `NaN` are falsey.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to compact.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.compact([0, 1, false, 2, '', 3]);
		     * // => [1, 2, 3]
		     */
		    function compact(array) {
		      var index = -1,
		          length = array == null ? 0 : array.length,
		          resIndex = 0,
		          result = [];

		      while (++index < length) {
		        var value = array[index];
		        if (value) {
		          result[resIndex++] = value;
		        }
		      }
		      return result;
		    }

		    /**
		     * Creates a new array concatenating `array` with any additional arrays
		     * and/or values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to concatenate.
		     * @param {...*} [values] The values to concatenate.
		     * @returns {Array} Returns the new concatenated array.
		     * @example
		     *
		     * var array = [1];
		     * var other = _.concat(array, 2, [3], [[4]]);
		     *
		     * console.log(other);
		     * // => [1, 2, 3, [4]]
		     *
		     * console.log(array);
		     * // => [1]
		     */
		    function concat() {
		      var length = arguments.length;
		      if (!length) {
		        return [];
		      }
		      var args = Array(length - 1),
		          array = arguments[0],
		          index = length;

		      while (index--) {
		        args[index - 1] = arguments[index];
		      }
		      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
		    }

		    /**
		     * Creates an array of `array` values not included in the other given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * **Note:** Unlike `_.pullAll`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.without, _.xor
		     * @example
		     *
		     * _.difference([2, 1], [2, 3]);
		     * // => [1]
		     */
		    var difference = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `iteratee` which
		     * is invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var differenceBy = baseRest(function(array, values) {
		      var iteratee = last(values);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.difference` except that it accepts `comparator`
		     * which is invoked to compare elements of `array` to `values`. The order and
		     * references of result values are determined by the first array. The comparator
		     * is invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...Array} [values] The values to exclude.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     *
		     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }]
		     */
		    var differenceWith = baseRest(function(array, values) {
		      var comparator = last(values);
		      if (isArrayLikeObject(comparator)) {
		        comparator = undefined$1;
		      }
		      return isArrayLikeObject(array)
		        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.drop([1, 2, 3]);
		     * // => [2, 3]
		     *
		     * _.drop([1, 2, 3], 2);
		     * // => [3]
		     *
		     * _.drop([1, 2, 3], 5);
		     * // => []
		     *
		     * _.drop([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function drop(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements dropped from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to drop.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.dropRight([1, 2, 3]);
		     * // => [1, 2]
		     *
		     * _.dropRight([1, 2, 3], 2);
		     * // => [1]
		     *
		     * _.dropRight([1, 2, 3], 5);
		     * // => []
		     *
		     * _.dropRight([1, 2, 3], 0);
		     * // => [1, 2, 3]
		     */
		    function dropRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the end.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.dropRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropRightWhile(users, ['active', false]);
		     * // => objects for ['barney']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropRightWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` excluding elements dropped from the beginning.
		     * Elements are dropped until `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.dropWhile(users, function(o) { return !o.active; });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.dropWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.dropWhile(users, ['active', false]);
		     * // => objects for ['pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.dropWhile(users, 'active');
		     * // => objects for ['barney', 'fred', 'pebbles']
		     */
		    function dropWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), true)
		        : [];
		    }

		    /**
		     * Fills elements of `array` with `value` from `start` up to, but not
		     * including, `end`.
		     *
		     * **Note:** This method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Array
		     * @param {Array} array The array to fill.
		     * @param {*} value The value to fill `array` with.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.fill(array, 'a');
		     * console.log(array);
		     * // => ['a', 'a', 'a']
		     *
		     * _.fill(Array(3), 2);
		     * // => [2, 2, 2]
		     *
		     * _.fill([4, 6, 8, 10], '*', 1, 3);
		     * // => [4, '*', '*', 10]
		     */
		    function fill(array, value, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
		        start = 0;
		        end = length;
		      }
		      return baseFill(array, value, start, end);
		    }

		    /**
		     * This method is like `_.find` except that it returns the index of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.findIndex(users, function(o) { return o.user == 'barney'; });
		     * // => 0
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findIndex(users, { 'user': 'fred', 'active': false });
		     * // => 1
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findIndex(users, ['active', false]);
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findIndex(users, 'active');
		     * // => 2
		     */
		    function findIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index);
		    }

		    /**
		     * This method is like `_.findIndex` except that it iterates over elements
		     * of `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the found element, else `-1`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
		     * // => 2
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
		     * // => 0
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastIndex(users, ['active', false]);
		     * // => 2
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastIndex(users, 'active');
		     * // => 0
		     */
		    function findLastIndex(array, predicate, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length - 1;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = fromIndex < 0
		          ? nativeMax(length + index, 0)
		          : nativeMin(index, length - 1);
		      }
		      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
		    }

		    /**
		     * Flattens `array` a single level deep.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flatten([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, [3, [4]], 5]
		     */
		    function flatten(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, 1) : [];
		    }

		    /**
		     * Recursively flattens `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * _.flattenDeep([1, [2, [3, [4]], 5]]);
		     * // => [1, 2, 3, 4, 5]
		     */
		    function flattenDeep(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseFlatten(array, INFINITY) : [];
		    }

		    /**
		     * Recursively flatten `array` up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Array
		     * @param {Array} array The array to flatten.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * var array = [1, [2, [3, [4]], 5]];
		     *
		     * _.flattenDepth(array, 1);
		     * // => [1, 2, [3, [4]], 5]
		     *
		     * _.flattenDepth(array, 2);
		     * // => [1, 2, 3, [4], 5]
		     */
		    function flattenDepth(array, depth) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(array, depth);
		    }

		    /**
		     * The inverse of `_.toPairs`; this method returns an object composed
		     * from key-value `pairs`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} pairs The key-value pairs.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.fromPairs([['a', 1], ['b', 2]]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function fromPairs(pairs) {
		      var index = -1,
		          length = pairs == null ? 0 : pairs.length,
		          result = {};

		      while (++index < length) {
		        var pair = pairs[index];
		        result[pair[0]] = pair[1];
		      }
		      return result;
		    }

		    /**
		     * Gets the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias first
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the first element of `array`.
		     * @example
		     *
		     * _.head([1, 2, 3]);
		     * // => 1
		     *
		     * _.head([]);
		     * // => undefined
		     */
		    function head(array) {
		      return (array && array.length) ? array[0] : undefined$1;
		    }

		    /**
		     * Gets the index at which the first occurrence of `value` is found in `array`
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. If `fromIndex` is negative, it's used as the
		     * offset from the end of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.indexOf([1, 2, 1, 2], 2);
		     * // => 1
		     *
		     * // Search from the `fromIndex`.
		     * _.indexOf([1, 2, 1, 2], 2, 2);
		     * // => 3
		     */
		    function indexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = fromIndex == null ? 0 : toInteger(fromIndex);
		      if (index < 0) {
		        index = nativeMax(length + index, 0);
		      }
		      return baseIndexOf(array, value, index);
		    }

		    /**
		     * Gets all but the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.initial([1, 2, 3]);
		     * // => [1, 2]
		     */
		    function initial(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 0, -1) : [];
		    }

		    /**
		     * Creates an array of unique values that are included in all given arrays
		     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons. The order and references of result values are
		     * determined by the first array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersection([2, 1], [2, 3]);
		     * // => [2]
		     */
		    var intersection = baseRest(function(arrays) {
		      var mapped = arrayMap(arrays, castArrayLikeObject);
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped)
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `iteratee`
		     * which is invoked for each element of each `arrays` to generate the criterion
		     * by which they're compared. The order and references of result values are
		     * determined by the first array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [2.1]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }]
		     */
		    var intersectionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      if (iteratee === last(mapped)) {
		        iteratee = undefined$1;
		      } else {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, getIteratee(iteratee, 2))
		        : [];
		    });

		    /**
		     * This method is like `_.intersection` except that it accepts `comparator`
		     * which is invoked to compare elements of `arrays`. The order and references
		     * of result values are determined by the first array. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of intersecting values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.intersectionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }]
		     */
		    var intersectionWith = baseRest(function(arrays) {
		      var comparator = last(arrays),
		          mapped = arrayMap(arrays, castArrayLikeObject);

		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      if (comparator) {
		        mapped.pop();
		      }
		      return (mapped.length && mapped[0] === arrays[0])
		        ? baseIntersection(mapped, undefined$1, comparator)
		        : [];
		    });

		    /**
		     * Converts all elements in `array` into a string separated by `separator`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to convert.
		     * @param {string} [separator=','] The element separator.
		     * @returns {string} Returns the joined string.
		     * @example
		     *
		     * _.join(['a', 'b', 'c'], '~');
		     * // => 'a~b~c'
		     */
		    function join(array, separator) {
		      return array == null ? '' : nativeJoin.call(array, separator);
		    }

		    /**
		     * Gets the last element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {*} Returns the last element of `array`.
		     * @example
		     *
		     * _.last([1, 2, 3]);
		     * // => 3
		     */
		    function last(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? array[length - 1] : undefined$1;
		    }

		    /**
		     * This method is like `_.indexOf` except that it iterates over elements of
		     * `array` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=array.length-1] The index to search from.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.lastIndexOf([1, 2, 1, 2], 2);
		     * // => 3
		     *
		     * // Search from the `fromIndex`.
		     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
		     * // => 1
		     */
		    function lastIndexOf(array, value, fromIndex) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return -1;
		      }
		      var index = length;
		      if (fromIndex !== undefined$1) {
		        index = toInteger(fromIndex);
		        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
		      }
		      return value === value
		        ? strictLastIndexOf(array, value, index)
		        : baseFindIndex(array, baseIsNaN, index, true);
		    }

		    /**
		     * Gets the element at index `n` of `array`. If `n` is negative, the nth
		     * element from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.11.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=0] The index of the element to return.
		     * @returns {*} Returns the nth element of `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     *
		     * _.nth(array, 1);
		     * // => 'b'
		     *
		     * _.nth(array, -2);
		     * // => 'c';
		     */
		    function nth(array, n) {
		      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
		    }

		    /**
		     * Removes all given values from `array` using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
		     * to remove elements from an array by predicate.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...*} [values] The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pull(array, 'a', 'c');
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    var pull = baseRest(pullAll);

		    /**
		     * This method is like `_.pull` except that it accepts an array of values to remove.
		     *
		     * **Note:** Unlike `_.difference`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
		     *
		     * _.pullAll(array, ['a', 'c']);
		     * console.log(array);
		     * // => ['b', 'b']
		     */
		    function pullAll(array, values) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values)
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `iteratee` which is
		     * invoked for each element of `array` and `values` to generate the criterion
		     * by which they're compared. The iteratee is invoked with one argument: (value).
		     *
		     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
		     *
		     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
		     * console.log(array);
		     * // => [{ 'x': 2 }]
		     */
		    function pullAllBy(array, values, iteratee) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, getIteratee(iteratee, 2))
		        : array;
		    }

		    /**
		     * This method is like `_.pullAll` except that it accepts `comparator` which
		     * is invoked to compare elements of `array` to `values`. The comparator is
		     * invoked with two arguments: (arrVal, othVal).
		     *
		     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Array} values The values to remove.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
		     *
		     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
		     * console.log(array);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
		     */
		    function pullAllWith(array, values, comparator) {
		      return (array && array.length && values && values.length)
		        ? basePullAll(array, values, undefined$1, comparator)
		        : array;
		    }

		    /**
		     * Removes elements from `array` corresponding to `indexes` and returns an
		     * array of removed elements.
		     *
		     * **Note:** Unlike `_.at`, this method mutates `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = ['a', 'b', 'c', 'd'];
		     * var pulled = _.pullAt(array, [1, 3]);
		     *
		     * console.log(array);
		     * // => ['a', 'c']
		     *
		     * console.log(pulled);
		     * // => ['b', 'd']
		     */
		    var pullAt = flatRest(function(array, indexes) {
		      var length = array == null ? 0 : array.length,
		          result = baseAt(array, indexes);

		      basePullAt(array, arrayMap(indexes, function(index) {
		        return isIndex(index, length) ? +index : index;
		      }).sort(compareAscending));

		      return result;
		    });

		    /**
		     * Removes all elements from `array` that `predicate` returns truthy for
		     * and returns an array of the removed elements. The predicate is invoked
		     * with three arguments: (value, index, array).
		     *
		     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
		     * to pull elements from an array by value.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new array of removed elements.
		     * @example
		     *
		     * var array = [1, 2, 3, 4];
		     * var evens = _.remove(array, function(n) {
		     *   return n % 2 == 0;
		     * });
		     *
		     * console.log(array);
		     * // => [1, 3]
		     *
		     * console.log(evens);
		     * // => [2, 4]
		     */
		    function remove(array, predicate) {
		      var result = [];
		      if (!(array && array.length)) {
		        return result;
		      }
		      var index = -1,
		          indexes = [],
		          length = array.length;

		      predicate = getIteratee(predicate, 3);
		      while (++index < length) {
		        var value = array[index];
		        if (predicate(value, index, array)) {
		          result.push(value);
		          indexes.push(index);
		        }
		      }
		      basePullAt(array, indexes);
		      return result;
		    }

		    /**
		     * Reverses `array` so that the first element becomes the last, the second
		     * element becomes the second to last, and so on.
		     *
		     * **Note:** This method mutates `array` and is based on
		     * [`Array#reverse`](https://mdn.io/Array/reverse).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to modify.
		     * @returns {Array} Returns `array`.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _.reverse(array);
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function reverse(array) {
		      return array == null ? array : nativeReverse.call(array);
		    }

		    /**
		     * Creates a slice of `array` from `start` up to, but not including, `end`.
		     *
		     * **Note:** This method is used instead of
		     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
		     * returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to slice.
		     * @param {number} [start=0] The start position.
		     * @param {number} [end=array.length] The end position.
		     * @returns {Array} Returns the slice of `array`.
		     */
		    function slice(array, start, end) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
		        start = 0;
		        end = length;
		      }
		      else {
		        start = start == null ? 0 : toInteger(start);
		        end = end === undefined$1 ? length : toInteger(end);
		      }
		      return baseSlice(array, start, end);
		    }

		    /**
		     * Uses a binary search to determine the lowest index at which `value`
		     * should be inserted into `array` in order to maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedIndex([30, 50], 40);
		     * // => 1
		     */
		    function sortedIndex(array, value) {
		      return baseSortedIndex(array, value);
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 0
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 0
		     */
		    function sortedIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
		    }

		    /**
		     * This method is like `_.indexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 1
		     */
		    function sortedIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value);
		        if (index < length && eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.sortedIndex` except that it returns the highest
		     * index at which `value` should be inserted into `array` in order to
		     * maintain its sort order.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
		     * // => 4
		     */
		    function sortedLastIndex(array, value) {
		      return baseSortedIndex(array, value, true);
		    }

		    /**
		     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
		     * which is invoked for `value` and each element of `array` to compute their
		     * sort ranking. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The sorted array to inspect.
		     * @param {*} value The value to evaluate.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the index at which `value` should be inserted
		     *  into `array`.
		     * @example
		     *
		     * var objects = [{ 'x': 4 }, { 'x': 5 }];
		     *
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
		     * // => 1
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
		     * // => 1
		     */
		    function sortedLastIndexBy(array, value, iteratee) {
		      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
		    }

		    /**
		     * This method is like `_.lastIndexOf` except that it performs a binary
		     * search on a sorted `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {*} value The value to search for.
		     * @returns {number} Returns the index of the matched value, else `-1`.
		     * @example
		     *
		     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
		     * // => 3
		     */
		    function sortedLastIndexOf(array, value) {
		      var length = array == null ? 0 : array.length;
		      if (length) {
		        var index = baseSortedIndex(array, value, true) - 1;
		        if (eq(array[index], value)) {
		          return index;
		        }
		      }
		      return -1;
		    }

		    /**
		     * This method is like `_.uniq` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniq([1, 1, 2]);
		     * // => [1, 2]
		     */
		    function sortedUniq(array) {
		      return (array && array.length)
		        ? baseSortedUniq(array)
		        : [];
		    }

		    /**
		     * This method is like `_.uniqBy` except that it's designed and optimized
		     * for sorted arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
		     * // => [1.1, 2.3]
		     */
		    function sortedUniqBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSortedUniq(array, getIteratee(iteratee, 2))
		        : [];
		    }

		    /**
		     * Gets all but the first element of `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.tail([1, 2, 3]);
		     * // => [2, 3]
		     */
		    function tail(array) {
		      var length = array == null ? 0 : array.length;
		      return length ? baseSlice(array, 1, length) : [];
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the beginning.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.take([1, 2, 3]);
		     * // => [1]
		     *
		     * _.take([1, 2, 3], 2);
		     * // => [1, 2]
		     *
		     * _.take([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.take([1, 2, 3], 0);
		     * // => []
		     */
		    function take(array, n, guard) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      return baseSlice(array, 0, n < 0 ? 0 : n);
		    }

		    /**
		     * Creates a slice of `array` with `n` elements taken from the end.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {number} [n=1] The number of elements to take.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * _.takeRight([1, 2, 3]);
		     * // => [3]
		     *
		     * _.takeRight([1, 2, 3], 2);
		     * // => [2, 3]
		     *
		     * _.takeRight([1, 2, 3], 5);
		     * // => [1, 2, 3]
		     *
		     * _.takeRight([1, 2, 3], 0);
		     * // => []
		     */
		    function takeRight(array, n, guard) {
		      var length = array == null ? 0 : array.length;
		      if (!length) {
		        return [];
		      }
		      n = (guard || n === undefined$1) ? 1 : toInteger(n);
		      n = length - n;
		      return baseSlice(array, n < 0 ? 0 : n, length);
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the end. Elements are
		     * taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': true },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': false }
		     * ];
		     *
		     * _.takeRightWhile(users, function(o) { return !o.active; });
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
		     * // => objects for ['pebbles']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeRightWhile(users, ['active', false]);
		     * // => objects for ['fred', 'pebbles']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeRightWhile(users, 'active');
		     * // => []
		     */
		    function takeRightWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3), false, true)
		        : [];
		    }

		    /**
		     * Creates a slice of `array` with elements taken from the beginning. Elements
		     * are taken until `predicate` returns falsey. The predicate is invoked with
		     * three arguments: (value, index, array).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Array
		     * @param {Array} array The array to query.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the slice of `array`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'active': false },
		     *   { 'user': 'fred',    'active': false },
		     *   { 'user': 'pebbles', 'active': true }
		     * ];
		     *
		     * _.takeWhile(users, function(o) { return !o.active; });
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.takeWhile(users, { 'user': 'barney', 'active': false });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.takeWhile(users, ['active', false]);
		     * // => objects for ['barney', 'fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.takeWhile(users, 'active');
		     * // => []
		     */
		    function takeWhile(array, predicate) {
		      return (array && array.length)
		        ? baseWhile(array, getIteratee(predicate, 3))
		        : [];
		    }

		    /**
		     * Creates an array of unique values, in order, from all given arrays using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.union([2], [1, 2]);
		     * // => [2, 1]
		     */
		    var union = baseRest(function(arrays) {
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which uniqueness is computed. Result values are chosen from the first
		     * array in which the value occurs. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    var unionBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.union` except that it accepts `comparator` which
		     * is invoked to compare elements of `arrays`. Result values are chosen from
		     * the first array in which the value occurs. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of combined values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.unionWith(objects, others, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var unionWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
		    });

		    /**
		     * Creates a duplicate-free version of an array, using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons, in which only the first occurrence of each element
		     * is kept. The order of result values is determined by the order they occur
		     * in the array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniq([2, 1, 2]);
		     * // => [2, 1]
		     */
		    function uniq(array) {
		      return (array && array.length) ? baseUniq(array) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * uniqueness is computed. The order of result values is determined by the
		     * order they occur in the array. The iteratee is invoked with one argument:
		     * (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
		     * // => [2.1, 1.2]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 1 }, { 'x': 2 }]
		     */
		    function uniqBy(array, iteratee) {
		      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
		    }

		    /**
		     * This method is like `_.uniq` except that it accepts `comparator` which
		     * is invoked to compare elements of `array`. The order of result values is
		     * determined by the order they occur in the array.The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new duplicate free array.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.uniqWith(objects, _.isEqual);
		     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
		     */
		    function uniqWith(array, comparator) {
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
		    }

		    /**
		     * This method is like `_.zip` except that it accepts an array of grouped
		     * elements and creates an array regrouping the elements to their pre-zip
		     * configuration.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.2.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     *
		     * _.unzip(zipped);
		     * // => [['a', 'b'], [1, 2], [true, false]]
		     */
		    function unzip(array) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var length = 0;
		      array = arrayFilter(array, function(group) {
		        if (isArrayLikeObject(group)) {
		          length = nativeMax(group.length, length);
		          return true;
		        }
		      });
		      return baseTimes(length, function(index) {
		        return arrayMap(array, baseProperty(index));
		      });
		    }

		    /**
		     * This method is like `_.unzip` except that it accepts `iteratee` to specify
		     * how regrouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {Array} array The array of grouped elements to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  regrouped values.
		     * @returns {Array} Returns the new array of regrouped elements.
		     * @example
		     *
		     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
		     * // => [[1, 10, 100], [2, 20, 200]]
		     *
		     * _.unzipWith(zipped, _.add);
		     * // => [3, 30, 300]
		     */
		    function unzipWith(array, iteratee) {
		      if (!(array && array.length)) {
		        return [];
		      }
		      var result = unzip(array);
		      if (iteratee == null) {
		        return result;
		      }
		      return arrayMap(result, function(group) {
		        return apply(iteratee, undefined$1, group);
		      });
		    }

		    /**
		     * Creates an array excluding all given values using
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * for equality comparisons.
		     *
		     * **Note:** Unlike `_.pull`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {Array} array The array to inspect.
		     * @param {...*} [values] The values to exclude.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.xor
		     * @example
		     *
		     * _.without([2, 1, 2, 3], 1, 2);
		     * // => [3]
		     */
		    var without = baseRest(function(array, values) {
		      return isArrayLikeObject(array)
		        ? baseDifference(array, values)
		        : [];
		    });

		    /**
		     * Creates an array of unique values that is the
		     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
		     * of the given arrays. The order of result values is determined by the order
		     * they occur in the arrays.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @returns {Array} Returns the new array of filtered values.
		     * @see _.difference, _.without
		     * @example
		     *
		     * _.xor([2, 1], [2, 3]);
		     * // => [1, 3]
		     */
		    var xor = baseRest(function(arrays) {
		      return baseXor(arrayFilter(arrays, isArrayLikeObject));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `iteratee` which is
		     * invoked for each element of each `arrays` to generate the criterion by
		     * which by which they're compared. The order of result values is determined
		     * by the order they occur in the arrays. The iteratee is invoked with one
		     * argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
		     * // => [1.2, 3.4]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
		     * // => [{ 'x': 2 }]
		     */
		    var xorBy = baseRest(function(arrays) {
		      var iteratee = last(arrays);
		      if (isArrayLikeObject(iteratee)) {
		        iteratee = undefined$1;
		      }
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
		    });

		    /**
		     * This method is like `_.xor` except that it accepts `comparator` which is
		     * invoked to compare elements of `arrays`. The order of result values is
		     * determined by the order they occur in the arrays. The comparator is invoked
		     * with two arguments: (arrVal, othVal).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to inspect.
		     * @param {Function} [comparator] The comparator invoked per element.
		     * @returns {Array} Returns the new array of filtered values.
		     * @example
		     *
		     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
		     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
		     *
		     * _.xorWith(objects, others, _.isEqual);
		     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
		     */
		    var xorWith = baseRest(function(arrays) {
		      var comparator = last(arrays);
		      comparator = typeof comparator == 'function' ? comparator : undefined$1;
		      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
		    });

		    /**
		     * Creates an array of grouped elements, the first of which contains the
		     * first elements of the given arrays, the second of which contains the
		     * second elements of the given arrays, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zip(['a', 'b'], [1, 2], [true, false]);
		     * // => [['a', 1, true], ['b', 2, false]]
		     */
		    var zip = baseRest(unzip);

		    /**
		     * This method is like `_.fromPairs` except that it accepts two arrays,
		     * one of property identifiers and one of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.4.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObject(['a', 'b'], [1, 2]);
		     * // => { 'a': 1, 'b': 2 }
		     */
		    function zipObject(props, values) {
		      return baseZipObject(props || [], values || [], assignValue);
		    }

		    /**
		     * This method is like `_.zipObject` except that it supports property paths.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Array
		     * @param {Array} [props=[]] The property identifiers.
		     * @param {Array} [values=[]] The property values.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
		     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
		     */
		    function zipObjectDeep(props, values) {
		      return baseZipObject(props || [], values || [], baseSet);
		    }

		    /**
		     * This method is like `_.zip` except that it accepts `iteratee` to specify
		     * how grouped values should be combined. The iteratee is invoked with the
		     * elements of each group: (...group).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Array
		     * @param {...Array} [arrays] The arrays to process.
		     * @param {Function} [iteratee=_.identity] The function to combine
		     *  grouped values.
		     * @returns {Array} Returns the new array of grouped elements.
		     * @example
		     *
		     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
		     *   return a + b + c;
		     * });
		     * // => [111, 222]
		     */
		    var zipWith = baseRest(function(arrays) {
		      var length = arrays.length,
		          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

		      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
		      return unzipWith(arrays, iteratee);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
		     * chain sequences enabled. The result of such sequences must be unwrapped
		     * with `_#value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Seq
		     * @param {*} value The value to wrap.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36 },
		     *   { 'user': 'fred',    'age': 40 },
		     *   { 'user': 'pebbles', 'age': 1 }
		     * ];
		     *
		     * var youngest = _
		     *   .chain(users)
		     *   .sortBy('age')
		     *   .map(function(o) {
		     *     return o.user + ' is ' + o.age;
		     *   })
		     *   .head()
		     *   .value();
		     * // => 'pebbles is 1'
		     */
		    function chain(value) {
		      var result = lodash(value);
		      result.__chain__ = true;
		      return result;
		    }

		    /**
		     * This method invokes `interceptor` and returns `value`. The interceptor
		     * is invoked with one argument; (value). The purpose of this method is to
		     * "tap into" a method chain sequence in order to modify intermediate results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * _([1, 2, 3])
		     *  .tap(function(array) {
		     *    // Mutate input array.
		     *    array.pop();
		     *  })
		     *  .reverse()
		     *  .value();
		     * // => [2, 1]
		     */
		    function tap(value, interceptor) {
		      interceptor(value);
		      return value;
		    }

		    /**
		     * This method is like `_.tap` except that it returns the result of `interceptor`.
		     * The purpose of this method is to "pass thru" values replacing intermediate
		     * results in a method chain sequence.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Seq
		     * @param {*} value The value to provide to `interceptor`.
		     * @param {Function} interceptor The function to invoke.
		     * @returns {*} Returns the result of `interceptor`.
		     * @example
		     *
		     * _('  abc  ')
		     *  .chain()
		     *  .trim()
		     *  .thru(function(value) {
		     *    return [value];
		     *  })
		     *  .value();
		     * // => ['abc']
		     */
		    function thru(value, interceptor) {
		      return interceptor(value);
		    }

		    /**
		     * This method is the wrapper version of `_.at`.
		     *
		     * @name at
		     * @memberOf _
		     * @since 1.0.0
		     * @category Seq
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _(object).at(['a[0].b.c', 'a[1]']).value();
		     * // => [3, 4]
		     */
		    var wrapperAt = flatRest(function(paths) {
		      var length = paths.length,
		          start = length ? paths[0] : 0,
		          value = this.__wrapped__,
		          interceptor = function(object) { return baseAt(object, paths); };

		      if (length > 1 || this.__actions__.length ||
		          !(value instanceof LazyWrapper) || !isIndex(start)) {
		        return this.thru(interceptor);
		      }
		      value = value.slice(start, +start + (length ? 1 : 0));
		      value.__actions__.push({
		        'func': thru,
		        'args': [interceptor],
		        'thisArg': undefined$1
		      });
		      return new LodashWrapper(value, this.__chain__).thru(function(array) {
		        if (length && !array.length) {
		          array.push(undefined$1);
		        }
		        return array;
		      });
		    });

		    /**
		     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
		     *
		     * @name chain
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 40 }
		     * ];
		     *
		     * // A sequence without explicit chaining.
		     * _(users).head();
		     * // => { 'user': 'barney', 'age': 36 }
		     *
		     * // A sequence with explicit chaining.
		     * _(users)
		     *   .chain()
		     *   .head()
		     *   .pick('user')
		     *   .value();
		     * // => { 'user': 'barney' }
		     */
		    function wrapperChain() {
		      return chain(this);
		    }

		    /**
		     * Executes the chain sequence and returns the wrapped result.
		     *
		     * @name commit
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2];
		     * var wrapped = _(array).push(3);
		     *
		     * console.log(array);
		     * // => [1, 2]
		     *
		     * wrapped = wrapped.commit();
		     * console.log(array);
		     * // => [1, 2, 3]
		     *
		     * wrapped.last();
		     * // => 3
		     *
		     * console.log(array);
		     * // => [1, 2, 3]
		     */
		    function wrapperCommit() {
		      return new LodashWrapper(this.value(), this.__chain__);
		    }

		    /**
		     * Gets the next value on a wrapped object following the
		     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
		     *
		     * @name next
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the next iterator value.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 1 }
		     *
		     * wrapped.next();
		     * // => { 'done': false, 'value': 2 }
		     *
		     * wrapped.next();
		     * // => { 'done': true, 'value': undefined }
		     */
		    function wrapperNext() {
		      if (this.__values__ === undefined$1) {
		        this.__values__ = toArray(this.value());
		      }
		      var done = this.__index__ >= this.__values__.length,
		          value = done ? undefined$1 : this.__values__[this.__index__++];

		      return { 'done': done, 'value': value };
		    }

		    /**
		     * Enables the wrapper to be iterable.
		     *
		     * @name Symbol.iterator
		     * @memberOf _
		     * @since 4.0.0
		     * @category Seq
		     * @returns {Object} Returns the wrapper object.
		     * @example
		     *
		     * var wrapped = _([1, 2]);
		     *
		     * wrapped[Symbol.iterator]() === wrapped;
		     * // => true
		     *
		     * Array.from(wrapped);
		     * // => [1, 2]
		     */
		    function wrapperToIterator() {
		      return this;
		    }

		    /**
		     * Creates a clone of the chain sequence planting `value` as the wrapped value.
		     *
		     * @name plant
		     * @memberOf _
		     * @since 3.2.0
		     * @category Seq
		     * @param {*} value The value to plant.
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var wrapped = _([1, 2]).map(square);
		     * var other = wrapped.plant([3, 4]);
		     *
		     * other.value();
		     * // => [9, 16]
		     *
		     * wrapped.value();
		     * // => [1, 4]
		     */
		    function wrapperPlant(value) {
		      var result,
		          parent = this;

		      while (parent instanceof baseLodash) {
		        var clone = wrapperClone(parent);
		        clone.__index__ = 0;
		        clone.__values__ = undefined$1;
		        if (result) {
		          previous.__wrapped__ = clone;
		        } else {
		          result = clone;
		        }
		        var previous = clone;
		        parent = parent.__wrapped__;
		      }
		      previous.__wrapped__ = value;
		      return result;
		    }

		    /**
		     * This method is the wrapper version of `_.reverse`.
		     *
		     * **Note:** This method mutates the wrapped array.
		     *
		     * @name reverse
		     * @memberOf _
		     * @since 0.1.0
		     * @category Seq
		     * @returns {Object} Returns the new `lodash` wrapper instance.
		     * @example
		     *
		     * var array = [1, 2, 3];
		     *
		     * _(array).reverse().value()
		     * // => [3, 2, 1]
		     *
		     * console.log(array);
		     * // => [3, 2, 1]
		     */
		    function wrapperReverse() {
		      var value = this.__wrapped__;
		      if (value instanceof LazyWrapper) {
		        var wrapped = value;
		        if (this.__actions__.length) {
		          wrapped = new LazyWrapper(this);
		        }
		        wrapped = wrapped.reverse();
		        wrapped.__actions__.push({
		          'func': thru,
		          'args': [reverse],
		          'thisArg': undefined$1
		        });
		        return new LodashWrapper(wrapped, this.__chain__);
		      }
		      return this.thru(reverse);
		    }

		    /**
		     * Executes the chain sequence to resolve the unwrapped value.
		     *
		     * @name value
		     * @memberOf _
		     * @since 0.1.0
		     * @alias toJSON, valueOf
		     * @category Seq
		     * @returns {*} Returns the resolved unwrapped value.
		     * @example
		     *
		     * _([1, 2, 3]).value();
		     * // => [1, 2, 3]
		     */
		    function wrapperValue() {
		      return baseWrapperValue(this.__wrapped__, this.__actions__);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the number of times the key was returned by `iteratee`. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.countBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': 1, '6': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.countBy(['one', 'two', 'three'], 'length');
		     * // => { '3': 2, '5': 1 }
		     */
		    var countBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        ++result[key];
		      } else {
		        baseAssignValue(result, key, 1);
		      }
		    });

		    /**
		     * Checks if `predicate` returns truthy for **all** elements of `collection`.
		     * Iteration is stopped once `predicate` returns falsey. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * **Note:** This method returns `true` for
		     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
		     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
		     * elements of empty collections.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if all elements pass the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.every([true, 1, null, 'yes'], Boolean);
		     * // => false
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.every(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.every(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.every(users, 'active');
		     * // => false
		     */
		    function every(collection, predicate, guard) {
		      var func = isArray(collection) ? arrayEvery : baseEvery;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning an array of all elements
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * **Note:** Unlike `_.remove`, this method returns a new array.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.reject
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * _.filter(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, { 'age': 36, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.filter(users, 'active');
		     * // => objects for ['barney']
		     *
		     * // Combining several predicates using `_.overEvery` or `_.overSome`.
		     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
		     * // => objects for ['fred', 'barney']
		     */
		    function filter(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Iterates over elements of `collection`, returning the first element
		     * `predicate` returns truthy for. The predicate is invoked with three
		     * arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': true },
		     *   { 'user': 'fred',    'age': 40, 'active': false },
		     *   { 'user': 'pebbles', 'age': 1,  'active': true }
		     * ];
		     *
		     * _.find(users, function(o) { return o.age < 40; });
		     * // => object for 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.find(users, { 'age': 1, 'active': true });
		     * // => object for 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.find(users, ['active', false]);
		     * // => object for 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.find(users, 'active');
		     * // => object for 'barney'
		     */
		    var find = createFind(findIndex);

		    /**
		     * This method is like `_.find` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param {number} [fromIndex=collection.length-1] The index to search from.
		     * @returns {*} Returns the matched element, else `undefined`.
		     * @example
		     *
		     * _.findLast([1, 2, 3, 4], function(n) {
		     *   return n % 2 == 1;
		     * });
		     * // => 3
		     */
		    var findLast = createFind(findLastIndex);

		    /**
		     * Creates a flattened array of values by running each element in `collection`
		     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
		     * with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [n, n];
		     * }
		     *
		     * _.flatMap([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMap(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), 1);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDeep([1, 2], duplicate);
		     * // => [1, 1, 2, 2]
		     */
		    function flatMapDeep(collection, iteratee) {
		      return baseFlatten(map(collection, iteratee), INFINITY);
		    }

		    /**
		     * This method is like `_.flatMap` except that it recursively flattens the
		     * mapped results up to `depth` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {number} [depth=1] The maximum recursion depth.
		     * @returns {Array} Returns the new flattened array.
		     * @example
		     *
		     * function duplicate(n) {
		     *   return [[[n, n]]];
		     * }
		     *
		     * _.flatMapDepth([1, 2], duplicate, 2);
		     * // => [[1, 1], [2, 2]]
		     */
		    function flatMapDepth(collection, iteratee, depth) {
		      depth = depth === undefined$1 ? 1 : toInteger(depth);
		      return baseFlatten(map(collection, iteratee), depth);
		    }

		    /**
		     * Iterates over elements of `collection` and invokes `iteratee` for each element.
		     * The iteratee is invoked with three arguments: (value, index|key, collection).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * **Note:** As with other "Collections" methods, objects with a "length"
		     * property are iterated like arrays. To avoid this behavior use `_.forIn`
		     * or `_.forOwn` for object iteration.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @alias each
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEachRight
		     * @example
		     *
		     * _.forEach([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `1` then `2`.
		     *
		     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forEach(collection, iteratee) {
		      var func = isArray(collection) ? arrayEach : baseEach;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forEach` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @alias eachRight
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array|Object} Returns `collection`.
		     * @see _.forEach
		     * @example
		     *
		     * _.forEachRight([1, 2], function(value) {
		     *   console.log(value);
		     * });
		     * // => Logs `2` then `1`.
		     */
		    function forEachRight(collection, iteratee) {
		      var func = isArray(collection) ? arrayEachRight : baseEachRight;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The order of grouped values
		     * is determined by the order they occur in `collection`. The corresponding
		     * value of each key is an array of elements responsible for generating the
		     * key. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
		     * // => { '4': [4.2], '6': [6.1, 6.3] }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.groupBy(['one', 'two', 'three'], 'length');
		     * // => { '3': ['one', 'two'], '5': ['three'] }
		     */
		    var groupBy = createAggregator(function(result, value, key) {
		      if (hasOwnProperty.call(result, key)) {
		        result[key].push(value);
		      } else {
		        baseAssignValue(result, key, [value]);
		      }
		    });

		    /**
		     * Checks if `value` is in `collection`. If `collection` is a string, it's
		     * checked for a substring of `value`, otherwise
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * is used for equality comparisons. If `fromIndex` is negative, it's used as
		     * the offset from the end of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @param {*} value The value to search for.
		     * @param {number} [fromIndex=0] The index to search from.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {boolean} Returns `true` if `value` is found, else `false`.
		     * @example
		     *
		     * _.includes([1, 2, 3], 1);
		     * // => true
		     *
		     * _.includes([1, 2, 3], 1, 2);
		     * // => false
		     *
		     * _.includes({ 'a': 1, 'b': 2 }, 1);
		     * // => true
		     *
		     * _.includes('abcd', 'bc');
		     * // => true
		     */
		    function includes(collection, value, fromIndex, guard) {
		      collection = isArrayLike(collection) ? collection : values(collection);
		      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

		      var length = collection.length;
		      if (fromIndex < 0) {
		        fromIndex = nativeMax(length + fromIndex, 0);
		      }
		      return isString(collection)
		        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
		        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
		    }

		    /**
		     * Invokes the method at `path` of each element in `collection`, returning
		     * an array of the results of each invoked method. Any additional arguments
		     * are provided to each invoked method. If `path` is a function, it's invoked
		     * for, and `this` bound to, each element in `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array|Function|string} path The path of the method to invoke or
		     *  the function invoked per iteration.
		     * @param {...*} [args] The arguments to invoke each method with.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
		     * // => [[1, 5, 7], [1, 2, 3]]
		     *
		     * _.invokeMap([123, 456], String.prototype.split, '');
		     * // => [['1', '2', '3'], ['4', '5', '6']]
		     */
		    var invokeMap = baseRest(function(collection, path, args) {
		      var index = -1,
		          isFunc = typeof path == 'function',
		          result = isArrayLike(collection) ? Array(collection.length) : [];

		      baseEach(collection, function(value) {
		        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
		      });
		      return result;
		    });

		    /**
		     * Creates an object composed of keys generated from the results of running
		     * each element of `collection` thru `iteratee`. The corresponding value of
		     * each key is the last element responsible for generating the key. The
		     * iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
		     * @returns {Object} Returns the composed aggregate object.
		     * @example
		     *
		     * var array = [
		     *   { 'dir': 'left', 'code': 97 },
		     *   { 'dir': 'right', 'code': 100 }
		     * ];
		     *
		     * _.keyBy(array, function(o) {
		     *   return String.fromCharCode(o.code);
		     * });
		     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
		     *
		     * _.keyBy(array, 'dir');
		     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
		     */
		    var keyBy = createAggregator(function(result, value, key) {
		      baseAssignValue(result, key, value);
		    });

		    /**
		     * Creates an array of values by running each element in `collection` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
		     *
		     * The guarded methods are:
		     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
		     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
		     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
		     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new mapped array.
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * _.map([4, 8], square);
		     * // => [16, 64]
		     *
		     * _.map({ 'a': 4, 'b': 8 }, square);
		     * // => [16, 64] (iteration order is not guaranteed)
		     *
		     * var users = [
		     *   { 'user': 'barney' },
		     *   { 'user': 'fred' }
		     * ];
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, 'user');
		     * // => ['barney', 'fred']
		     */
		    function map(collection, iteratee) {
		      var func = isArray(collection) ? arrayMap : baseMap;
		      return func(collection, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.sortBy` except that it allows specifying the sort
		     * orders of the iteratees to sort by. If `orders` is unspecified, all values
		     * are sorted in ascending order. Otherwise, specify an order of "desc" for
		     * descending or "asc" for ascending sort order of corresponding values.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @param {string[]} [orders] The sort orders of `iteratees`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 34 },
		     *   { 'user': 'fred',   'age': 40 },
		     *   { 'user': 'barney', 'age': 36 }
		     * ];
		     *
		     * // Sort by `user` in ascending order and by `age` in descending order.
		     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
		     */
		    function orderBy(collection, iteratees, orders, guard) {
		      if (collection == null) {
		        return [];
		      }
		      if (!isArray(iteratees)) {
		        iteratees = iteratees == null ? [] : [iteratees];
		      }
		      orders = guard ? undefined$1 : orders;
		      if (!isArray(orders)) {
		        orders = orders == null ? [] : [orders];
		      }
		      return baseOrderBy(collection, iteratees, orders);
		    }

		    /**
		     * Creates an array of elements split into two groups, the first of which
		     * contains elements `predicate` returns truthy for, the second of which
		     * contains elements `predicate` returns falsey for. The predicate is
		     * invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of grouped elements.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney',  'age': 36, 'active': false },
		     *   { 'user': 'fred',    'age': 40, 'active': true },
		     *   { 'user': 'pebbles', 'age': 1,  'active': false }
		     * ];
		     *
		     * _.partition(users, function(o) { return o.active; });
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.partition(users, { 'age': 1, 'active': false });
		     * // => objects for [['pebbles'], ['barney', 'fred']]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.partition(users, ['active', false]);
		     * // => objects for [['barney', 'pebbles'], ['fred']]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.partition(users, 'active');
		     * // => objects for [['fred'], ['barney', 'pebbles']]
		     */
		    var partition = createAggregator(function(result, value, key) {
		      result[key ? 0 : 1].push(value);
		    }, function() { return [[], []]; });

		    /**
		     * Reduces `collection` to a value which is the accumulated result of running
		     * each element in `collection` thru `iteratee`, where each successive
		     * invocation is supplied the return value of the previous. If `accumulator`
		     * is not given, the first element of `collection` is used as the initial
		     * value. The iteratee is invoked with four arguments:
		     * (accumulator, value, index|key, collection).
		     *
		     * Many lodash methods are guarded to work as iteratees for methods like
		     * `_.reduce`, `_.reduceRight`, and `_.transform`.
		     *
		     * The guarded methods are:
		     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
		     * and `sortBy`
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduceRight
		     * @example
		     *
		     * _.reduce([1, 2], function(sum, n) {
		     *   return sum + n;
		     * }, 0);
		     * // => 3
		     *
		     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     *   return result;
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
		     */
		    function reduce(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduce : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
		    }

		    /**
		     * This method is like `_.reduce` except that it iterates over elements of
		     * `collection` from right to left.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The initial value.
		     * @returns {*} Returns the accumulated value.
		     * @see _.reduce
		     * @example
		     *
		     * var array = [[0, 1], [2, 3], [4, 5]];
		     *
		     * _.reduceRight(array, function(flattened, other) {
		     *   return flattened.concat(other);
		     * }, []);
		     * // => [4, 5, 2, 3, 0, 1]
		     */
		    function reduceRight(collection, iteratee, accumulator) {
		      var func = isArray(collection) ? arrayReduceRight : baseReduce,
		          initAccum = arguments.length < 3;

		      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
		    }

		    /**
		     * The opposite of `_.filter`; this method returns the elements of `collection`
		     * that `predicate` does **not** return truthy for.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the new filtered array.
		     * @see _.filter
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': false },
		     *   { 'user': 'fred',   'age': 40, 'active': true }
		     * ];
		     *
		     * _.reject(users, function(o) { return !o.active; });
		     * // => objects for ['fred']
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.reject(users, { 'age': 40, 'active': true });
		     * // => objects for ['barney']
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.reject(users, ['active', false]);
		     * // => objects for ['fred']
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.reject(users, 'active');
		     * // => objects for ['barney']
		     */
		    function reject(collection, predicate) {
		      var func = isArray(collection) ? arrayFilter : baseFilter;
		      return func(collection, negate(getIteratee(predicate, 3)));
		    }

		    /**
		     * Gets a random element from `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @returns {*} Returns the random element.
		     * @example
		     *
		     * _.sample([1, 2, 3, 4]);
		     * // => 2
		     */
		    function sample(collection) {
		      var func = isArray(collection) ? arraySample : baseSample;
		      return func(collection);
		    }

		    /**
		     * Gets `n` random elements at unique keys from `collection` up to the
		     * size of `collection`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to sample.
		     * @param {number} [n=1] The number of elements to sample.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the random elements.
		     * @example
		     *
		     * _.sampleSize([1, 2, 3], 2);
		     * // => [3, 1]
		     *
		     * _.sampleSize([1, 2, 3], 4);
		     * // => [2, 3, 1]
		     */
		    function sampleSize(collection, n, guard) {
		      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
		      return func(collection, n);
		    }

		    /**
		     * Creates an array of shuffled values, using a version of the
		     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to shuffle.
		     * @returns {Array} Returns the new shuffled array.
		     * @example
		     *
		     * _.shuffle([1, 2, 3, 4]);
		     * // => [4, 1, 3, 2]
		     */
		    function shuffle(collection) {
		      var func = isArray(collection) ? arrayShuffle : baseShuffle;
		      return func(collection);
		    }

		    /**
		     * Gets the size of `collection` by returning its length for array-like
		     * values or the number of own enumerable string keyed properties for objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object|string} collection The collection to inspect.
		     * @returns {number} Returns the collection size.
		     * @example
		     *
		     * _.size([1, 2, 3]);
		     * // => 3
		     *
		     * _.size({ 'a': 1, 'b': 2 });
		     * // => 2
		     *
		     * _.size('pebbles');
		     * // => 7
		     */
		    function size(collection) {
		      if (collection == null) {
		        return 0;
		      }
		      if (isArrayLike(collection)) {
		        return isString(collection) ? stringSize(collection) : collection.length;
		      }
		      var tag = getTag(collection);
		      if (tag == mapTag || tag == setTag) {
		        return collection.size;
		      }
		      return baseKeys(collection).length;
		    }

		    /**
		     * Checks if `predicate` returns truthy for **any** element of `collection`.
		     * Iteration is stopped once `predicate` returns truthy. The predicate is
		     * invoked with three arguments: (value, index|key, collection).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {boolean} Returns `true` if any element passes the predicate check,
		     *  else `false`.
		     * @example
		     *
		     * _.some([null, 0, 'yes', false], Boolean);
		     * // => true
		     *
		     * var users = [
		     *   { 'user': 'barney', 'active': true },
		     *   { 'user': 'fred',   'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.some(users, { 'user': 'barney', 'active': false });
		     * // => false
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.some(users, ['active', false]);
		     * // => true
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.some(users, 'active');
		     * // => true
		     */
		    function some(collection, predicate, guard) {
		      var func = isArray(collection) ? arraySome : baseSome;
		      if (guard && isIterateeCall(collection, predicate, guard)) {
		        predicate = undefined$1;
		      }
		      return func(collection, getIteratee(predicate, 3));
		    }

		    /**
		     * Creates an array of elements, sorted in ascending order by the results of
		     * running each element in a collection thru each iteratee. This method
		     * performs a stable sort, that is, it preserves the original sort order of
		     * equal elements. The iteratees are invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Collection
		     * @param {Array|Object} collection The collection to iterate over.
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to sort by.
		     * @returns {Array} Returns the new sorted array.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'fred',   'age': 48 },
		     *   { 'user': 'barney', 'age': 36 },
		     *   { 'user': 'fred',   'age': 30 },
		     *   { 'user': 'barney', 'age': 34 }
		     * ];
		     *
		     * _.sortBy(users, [function(o) { return o.user; }]);
		     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
		     *
		     * _.sortBy(users, ['user', 'age']);
		     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
		     */
		    var sortBy = baseRest(function(collection, iteratees) {
		      if (collection == null) {
		        return [];
		      }
		      var length = iteratees.length;
		      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
		        iteratees = [];
		      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
		        iteratees = [iteratees[0]];
		      }
		      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
		    });

		    /*------------------------------------------------------------------------*/

		    /**
		     * Gets the timestamp of the number of milliseconds that have elapsed since
		     * the Unix epoch (1 January 1970 00:00:00 UTC).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Date
		     * @returns {number} Returns the timestamp.
		     * @example
		     *
		     * _.defer(function(stamp) {
		     *   console.log(_.now() - stamp);
		     * }, _.now());
		     * // => Logs the number of milliseconds it took for the deferred invocation.
		     */
		    var now = ctxNow || function() {
		      return root.Date.now();
		    };

		    /*------------------------------------------------------------------------*/

		    /**
		     * The opposite of `_.before`; this method creates a function that invokes
		     * `func` once it's called `n` or more times.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {number} n The number of calls before `func` is invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var saves = ['profile', 'settings'];
		     *
		     * var done = _.after(saves.length, function() {
		     *   console.log('done saving!');
		     * });
		     *
		     * _.forEach(saves, function(type) {
		     *   asyncSave({ 'type': type, 'complete': done });
		     * });
		     * // => Logs 'done saving!' after the two async saves have completed.
		     */
		    function after(n, func) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n < 1) {
		          return func.apply(this, arguments);
		        }
		      };
		    }

		    /**
		     * Creates a function that invokes `func`, with up to `n` arguments,
		     * ignoring any additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @param {number} [n=func.length] The arity cap.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
		     * // => [6, 8, 10]
		     */
		    function ary(func, n, guard) {
		      n = guard ? undefined$1 : n;
		      n = (func && n == null) ? func.length : n;
		      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
		    }

		    /**
		     * Creates a function that invokes `func`, with the `this` binding and arguments
		     * of the created function, while it's called less than `n` times. Subsequent
		     * calls to the created function return the result of the last `func` invocation.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {number} n The number of calls at which `func` is no longer invoked.
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * jQuery(element).on('click', _.before(5, addContactToList));
		     * // => Allows adding up to 4 contacts to the list.
		     */
		    function before(n, func) {
		      var result;
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      n = toInteger(n);
		      return function() {
		        if (--n > 0) {
		          result = func.apply(this, arguments);
		        }
		        if (n <= 1) {
		          func = undefined$1;
		        }
		        return result;
		      };
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of `thisArg`
		     * and `partials` prepended to the arguments it receives.
		     *
		     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
		     * property of bound functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to bind.
		     * @param {*} thisArg The `this` binding of `func`.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * function greet(greeting, punctuation) {
		     *   return greeting + ' ' + this.user + punctuation;
		     * }
		     *
		     * var object = { 'user': 'fred' };
		     *
		     * var bound = _.bind(greet, object, 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bind(greet, object, _, '!');
		     * bound('hi');
		     * // => 'hi fred!'
		     */
		    var bind = baseRest(function(func, thisArg, partials) {
		      var bitmask = WRAP_BIND_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bind));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(func, bitmask, thisArg, partials, holders);
		    });

		    /**
		     * Creates a function that invokes the method at `object[key]` with `partials`
		     * prepended to the arguments it receives.
		     *
		     * This method differs from `_.bind` by allowing bound functions to reference
		     * methods that may be redefined or don't yet exist. See
		     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
		     * for more details.
		     *
		     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Function
		     * @param {Object} object The object to invoke the method on.
		     * @param {string} key The key of the method.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new bound function.
		     * @example
		     *
		     * var object = {
		     *   'user': 'fred',
		     *   'greet': function(greeting, punctuation) {
		     *     return greeting + ' ' + this.user + punctuation;
		     *   }
		     * };
		     *
		     * var bound = _.bindKey(object, 'greet', 'hi');
		     * bound('!');
		     * // => 'hi fred!'
		     *
		     * object.greet = function(greeting, punctuation) {
		     *   return greeting + 'ya ' + this.user + punctuation;
		     * };
		     *
		     * bound('!');
		     * // => 'hiya fred!'
		     *
		     * // Bound with placeholders.
		     * var bound = _.bindKey(object, 'greet', _, '!');
		     * bound('hi');
		     * // => 'hiya fred!'
		     */
		    var bindKey = baseRest(function(object, key, partials) {
		      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
		      if (partials.length) {
		        var holders = replaceHolders(partials, getHolder(bindKey));
		        bitmask |= WRAP_PARTIAL_FLAG;
		      }
		      return createWrap(key, bitmask, object, partials, holders);
		    });

		    /**
		     * Creates a function that accepts arguments of `func` and either invokes
		     * `func` returning its result, if at least `arity` number of arguments have
		     * been provided, or returns a function that accepts the remaining `func`
		     * arguments, and so on. The arity of `func` may be specified if `func.length`
		     * is not sufficient.
		     *
		     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
		     * may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curry(abc);
		     *
		     * curried(1)(2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2)(3);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(1)(_, 3)(2);
		     * // => [1, 2, 3]
		     */
		    function curry(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curry.placeholder;
		      return result;
		    }

		    /**
		     * This method is like `_.curry` except that arguments are applied to `func`
		     * in the manner of `_.partialRight` instead of `_.partial`.
		     *
		     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for provided arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of curried functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to curry.
		     * @param {number} [arity=func.length] The arity of `func`.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the new curried function.
		     * @example
		     *
		     * var abc = function(a, b, c) {
		     *   return [a, b, c];
		     * };
		     *
		     * var curried = _.curryRight(abc);
		     *
		     * curried(3)(2)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(2, 3)(1);
		     * // => [1, 2, 3]
		     *
		     * curried(1, 2, 3);
		     * // => [1, 2, 3]
		     *
		     * // Curried with placeholders.
		     * curried(3)(1, _)(2);
		     * // => [1, 2, 3]
		     */
		    function curryRight(func, arity, guard) {
		      arity = guard ? undefined$1 : arity;
		      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
		      result.placeholder = curryRight.placeholder;
		      return result;
		    }

		    /**
		     * Creates a debounced function that delays invoking `func` until after `wait`
		     * milliseconds have elapsed since the last time the debounced function was
		     * invoked. The debounced function comes with a `cancel` method to cancel
		     * delayed `func` invocations and a `flush` method to immediately invoke them.
		     * Provide `options` to indicate whether `func` should be invoked on the
		     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
		     * with the last arguments provided to the debounced function. Subsequent
		     * calls to the debounced function return the result of the last `func`
		     * invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the debounced function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.debounce` and `_.throttle`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to debounce.
		     * @param {number} [wait=0] The number of milliseconds to delay.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=false]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {number} [options.maxWait]
		     *  The maximum time `func` is allowed to be delayed before it's invoked.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new debounced function.
		     * @example
		     *
		     * // Avoid costly calculations while the window size is in flux.
		     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
		     *
		     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
		     * jQuery(element).on('click', _.debounce(sendMail, 300, {
		     *   'leading': true,
		     *   'trailing': false
		     * }));
		     *
		     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
		     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
		     * var source = new EventSource('/stream');
		     * jQuery(source).on('message', debounced);
		     *
		     * // Cancel the trailing debounced invocation.
		     * jQuery(window).on('popstate', debounced.cancel);
		     */
		    function debounce(func, wait, options) {
		      var lastArgs,
		          lastThis,
		          maxWait,
		          result,
		          timerId,
		          lastCallTime,
		          lastInvokeTime = 0,
		          leading = false,
		          maxing = false,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      wait = toNumber(wait) || 0;
		      if (isObject(options)) {
		        leading = !!options.leading;
		        maxing = 'maxWait' in options;
		        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }

		      function invokeFunc(time) {
		        var args = lastArgs,
		            thisArg = lastThis;

		        lastArgs = lastThis = undefined$1;
		        lastInvokeTime = time;
		        result = func.apply(thisArg, args);
		        return result;
		      }

		      function leadingEdge(time) {
		        // Reset any `maxWait` timer.
		        lastInvokeTime = time;
		        // Start the timer for the trailing edge.
		        timerId = setTimeout(timerExpired, wait);
		        // Invoke the leading edge.
		        return leading ? invokeFunc(time) : result;
		      }

		      function remainingWait(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime,
		            timeWaiting = wait - timeSinceLastCall;

		        return maxing
		          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
		          : timeWaiting;
		      }

		      function shouldInvoke(time) {
		        var timeSinceLastCall = time - lastCallTime,
		            timeSinceLastInvoke = time - lastInvokeTime;

		        // Either this is the first call, activity has stopped and we're at the
		        // trailing edge, the system time has gone backwards and we're treating
		        // it as the trailing edge, or we've hit the `maxWait` limit.
		        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
		          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
		      }

		      function timerExpired() {
		        var time = now();
		        if (shouldInvoke(time)) {
		          return trailingEdge(time);
		        }
		        // Restart the timer.
		        timerId = setTimeout(timerExpired, remainingWait(time));
		      }

		      function trailingEdge(time) {
		        timerId = undefined$1;

		        // Only invoke if we have `lastArgs` which means `func` has been
		        // debounced at least once.
		        if (trailing && lastArgs) {
		          return invokeFunc(time);
		        }
		        lastArgs = lastThis = undefined$1;
		        return result;
		      }

		      function cancel() {
		        if (timerId !== undefined$1) {
		          clearTimeout(timerId);
		        }
		        lastInvokeTime = 0;
		        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
		      }

		      function flush() {
		        return timerId === undefined$1 ? result : trailingEdge(now());
		      }

		      function debounced() {
		        var time = now(),
		            isInvoking = shouldInvoke(time);

		        lastArgs = arguments;
		        lastThis = this;
		        lastCallTime = time;

		        if (isInvoking) {
		          if (timerId === undefined$1) {
		            return leadingEdge(lastCallTime);
		          }
		          if (maxing) {
		            // Handle invocations in a tight loop.
		            clearTimeout(timerId);
		            timerId = setTimeout(timerExpired, wait);
		            return invokeFunc(lastCallTime);
		          }
		        }
		        if (timerId === undefined$1) {
		          timerId = setTimeout(timerExpired, wait);
		        }
		        return result;
		      }
		      debounced.cancel = cancel;
		      debounced.flush = flush;
		      return debounced;
		    }

		    /**
		     * Defers invoking the `func` until the current call stack has cleared. Any
		     * additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to defer.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.defer(function(text) {
		     *   console.log(text);
		     * }, 'deferred');
		     * // => Logs 'deferred' after one millisecond.
		     */
		    var defer = baseRest(function(func, args) {
		      return baseDelay(func, 1, args);
		    });

		    /**
		     * Invokes `func` after `wait` milliseconds. Any additional arguments are
		     * provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to delay.
		     * @param {number} wait The number of milliseconds to delay invocation.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {number} Returns the timer id.
		     * @example
		     *
		     * _.delay(function(text) {
		     *   console.log(text);
		     * }, 1000, 'later');
		     * // => Logs 'later' after one second.
		     */
		    var delay = baseRest(function(func, wait, args) {
		      return baseDelay(func, toNumber(wait) || 0, args);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments reversed.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to flip arguments for.
		     * @returns {Function} Returns the new flipped function.
		     * @example
		     *
		     * var flipped = _.flip(function() {
		     *   return _.toArray(arguments);
		     * });
		     *
		     * flipped('a', 'b', 'c', 'd');
		     * // => ['d', 'c', 'b', 'a']
		     */
		    function flip(func) {
		      return createWrap(func, WRAP_FLIP_FLAG);
		    }

		    /**
		     * Creates a function that memoizes the result of `func`. If `resolver` is
		     * provided, it determines the cache key for storing the result based on the
		     * arguments provided to the memoized function. By default, the first argument
		     * provided to the memoized function is used as the map cache key. The `func`
		     * is invoked with the `this` binding of the memoized function.
		     *
		     * **Note:** The cache is exposed as the `cache` property on the memoized
		     * function. Its creation may be customized by replacing the `_.memoize.Cache`
		     * constructor with one whose instances implement the
		     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
		     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to have its output memoized.
		     * @param {Function} [resolver] The function to resolve the cache key.
		     * @returns {Function} Returns the new memoized function.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     * var other = { 'c': 3, 'd': 4 };
		     *
		     * var values = _.memoize(_.values);
		     * values(object);
		     * // => [1, 2]
		     *
		     * values(other);
		     * // => [3, 4]
		     *
		     * object.a = 2;
		     * values(object);
		     * // => [1, 2]
		     *
		     * // Modify the result cache.
		     * values.cache.set(object, ['a', 'b']);
		     * values(object);
		     * // => ['a', 'b']
		     *
		     * // Replace `_.memoize.Cache`.
		     * _.memoize.Cache = WeakMap;
		     */
		    function memoize(func, resolver) {
		      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      var memoized = function() {
		        var args = arguments,
		            key = resolver ? resolver.apply(this, args) : args[0],
		            cache = memoized.cache;

		        if (cache.has(key)) {
		          return cache.get(key);
		        }
		        var result = func.apply(this, args);
		        memoized.cache = cache.set(key, result) || cache;
		        return result;
		      };
		      memoized.cache = new (memoize.Cache || MapCache);
		      return memoized;
		    }

		    // Expose `MapCache`.
		    memoize.Cache = MapCache;

		    /**
		     * Creates a function that negates the result of the predicate `func`. The
		     * `func` predicate is invoked with the `this` binding and arguments of the
		     * created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} predicate The predicate to negate.
		     * @returns {Function} Returns the new negated function.
		     * @example
		     *
		     * function isEven(n) {
		     *   return n % 2 == 0;
		     * }
		     *
		     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
		     * // => [1, 3, 5]
		     */
		    function negate(predicate) {
		      if (typeof predicate != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      return function() {
		        var args = arguments;
		        switch (args.length) {
		          case 0: return !predicate.call(this);
		          case 1: return !predicate.call(this, args[0]);
		          case 2: return !predicate.call(this, args[0], args[1]);
		          case 3: return !predicate.call(this, args[0], args[1], args[2]);
		        }
		        return !predicate.apply(this, args);
		      };
		    }

		    /**
		     * Creates a function that is restricted to invoking `func` once. Repeat calls
		     * to the function return the value of the first invocation. The `func` is
		     * invoked with the `this` binding and arguments of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to restrict.
		     * @returns {Function} Returns the new restricted function.
		     * @example
		     *
		     * var initialize = _.once(createApplication);
		     * initialize();
		     * initialize();
		     * // => `createApplication` is invoked once
		     */
		    function once(func) {
		      return before(2, func);
		    }

		    /**
		     * Creates a function that invokes `func` with its arguments transformed.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Function
		     * @param {Function} func The function to wrap.
		     * @param {...(Function|Function[])} [transforms=[_.identity]]
		     *  The argument transforms.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * function doubled(n) {
		     *   return n * 2;
		     * }
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var func = _.overArgs(function(x, y) {
		     *   return [x, y];
		     * }, [square, doubled]);
		     *
		     * func(9, 3);
		     * // => [81, 6]
		     *
		     * func(10, 5);
		     * // => [100, 10]
		     */
		    var overArgs = castRest(function(func, transforms) {
		      transforms = (transforms.length == 1 && isArray(transforms[0]))
		        ? arrayMap(transforms[0], baseUnary(getIteratee()))
		        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

		      var funcsLength = transforms.length;
		      return baseRest(function(args) {
		        var index = -1,
		            length = nativeMin(args.length, funcsLength);

		        while (++index < length) {
		          args[index] = transforms[index].call(this, args[index]);
		        }
		        return apply(func, this, args);
		      });
		    });

		    /**
		     * Creates a function that invokes `func` with `partials` prepended to the
		     * arguments it receives. This method is like `_.bind` except it does **not**
		     * alter the `this` binding.
		     *
		     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.2.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var sayHelloTo = _.partial(greet, 'hello');
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     *
		     * // Partially applied with placeholders.
		     * var greetFred = _.partial(greet, _, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     */
		    var partial = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partial));
		      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * This method is like `_.partial` except that partially applied arguments
		     * are appended to the arguments it receives.
		     *
		     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
		     * builds, may be used as a placeholder for partially applied arguments.
		     *
		     * **Note:** This method doesn't set the "length" property of partially
		     * applied functions.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Function
		     * @param {Function} func The function to partially apply arguments to.
		     * @param {...*} [partials] The arguments to be partially applied.
		     * @returns {Function} Returns the new partially applied function.
		     * @example
		     *
		     * function greet(greeting, name) {
		     *   return greeting + ' ' + name;
		     * }
		     *
		     * var greetFred = _.partialRight(greet, 'fred');
		     * greetFred('hi');
		     * // => 'hi fred'
		     *
		     * // Partially applied with placeholders.
		     * var sayHelloTo = _.partialRight(greet, 'hello', _);
		     * sayHelloTo('fred');
		     * // => 'hello fred'
		     */
		    var partialRight = baseRest(function(func, partials) {
		      var holders = replaceHolders(partials, getHolder(partialRight));
		      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
		    });

		    /**
		     * Creates a function that invokes `func` with arguments arranged according
		     * to the specified `indexes` where the argument value at the first index is
		     * provided as the first argument, the argument value at the second index is
		     * provided as the second argument, and so on.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Function
		     * @param {Function} func The function to rearrange arguments for.
		     * @param {...(number|number[])} indexes The arranged argument indexes.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var rearged = _.rearg(function(a, b, c) {
		     *   return [a, b, c];
		     * }, [2, 0, 1]);
		     *
		     * rearged('b', 'c', 'a')
		     * // => ['a', 'b', 'c']
		     */
		    var rearg = flatRest(function(func, indexes) {
		      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
		    });

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * created function and arguments from `start` and beyond provided as
		     * an array.
		     *
		     * **Note:** This method is based on the
		     * [rest parameter](https://mdn.io/rest_parameters).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to apply a rest parameter to.
		     * @param {number} [start=func.length-1] The start position of the rest parameter.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.rest(function(what, names) {
		     *   return what + ' ' + _.initial(names).join(', ') +
		     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
		     * });
		     *
		     * say('hello', 'fred', 'barney', 'pebbles');
		     * // => 'hello fred, barney, & pebbles'
		     */
		    function rest(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start === undefined$1 ? start : toInteger(start);
		      return baseRest(func, start);
		    }

		    /**
		     * Creates a function that invokes `func` with the `this` binding of the
		     * create function and an array of arguments much like
		     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
		     *
		     * **Note:** This method is based on the
		     * [spread operator](https://mdn.io/spread_operator).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Function
		     * @param {Function} func The function to spread arguments over.
		     * @param {number} [start=0] The start position of the spread.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var say = _.spread(function(who, what) {
		     *   return who + ' says ' + what;
		     * });
		     *
		     * say(['fred', 'hello']);
		     * // => 'fred says hello'
		     *
		     * var numbers = Promise.all([
		     *   Promise.resolve(40),
		     *   Promise.resolve(36)
		     * ]);
		     *
		     * numbers.then(_.spread(function(x, y) {
		     *   return x + y;
		     * }));
		     * // => a Promise of 76
		     */
		    function spread(func, start) {
		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      start = start == null ? 0 : nativeMax(toInteger(start), 0);
		      return baseRest(function(args) {
		        var array = args[start],
		            otherArgs = castSlice(args, 0, start);

		        if (array) {
		          arrayPush(otherArgs, array);
		        }
		        return apply(func, this, otherArgs);
		      });
		    }

		    /**
		     * Creates a throttled function that only invokes `func` at most once per
		     * every `wait` milliseconds. The throttled function comes with a `cancel`
		     * method to cancel delayed `func` invocations and a `flush` method to
		     * immediately invoke them. Provide `options` to indicate whether `func`
		     * should be invoked on the leading and/or trailing edge of the `wait`
		     * timeout. The `func` is invoked with the last arguments provided to the
		     * throttled function. Subsequent calls to the throttled function return the
		     * result of the last `func` invocation.
		     *
		     * **Note:** If `leading` and `trailing` options are `true`, `func` is
		     * invoked on the trailing edge of the timeout only if the throttled function
		     * is invoked more than once during the `wait` timeout.
		     *
		     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
		     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
		     *
		     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
		     * for details over the differences between `_.throttle` and `_.debounce`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {Function} func The function to throttle.
		     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.leading=true]
		     *  Specify invoking on the leading edge of the timeout.
		     * @param {boolean} [options.trailing=true]
		     *  Specify invoking on the trailing edge of the timeout.
		     * @returns {Function} Returns the new throttled function.
		     * @example
		     *
		     * // Avoid excessively updating the position while scrolling.
		     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
		     *
		     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
		     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
		     * jQuery(element).on('click', throttled);
		     *
		     * // Cancel the trailing throttled invocation.
		     * jQuery(window).on('popstate', throttled.cancel);
		     */
		    function throttle(func, wait, options) {
		      var leading = true,
		          trailing = true;

		      if (typeof func != 'function') {
		        throw new TypeError(FUNC_ERROR_TEXT);
		      }
		      if (isObject(options)) {
		        leading = 'leading' in options ? !!options.leading : leading;
		        trailing = 'trailing' in options ? !!options.trailing : trailing;
		      }
		      return debounce(func, wait, {
		        'leading': leading,
		        'maxWait': wait,
		        'trailing': trailing
		      });
		    }

		    /**
		     * Creates a function that accepts up to one argument, ignoring any
		     * additional arguments.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Function
		     * @param {Function} func The function to cap arguments for.
		     * @returns {Function} Returns the new capped function.
		     * @example
		     *
		     * _.map(['6', '8', '10'], _.unary(parseInt));
		     * // => [6, 8, 10]
		     */
		    function unary(func) {
		      return ary(func, 1);
		    }

		    /**
		     * Creates a function that provides `value` to `wrapper` as its first
		     * argument. Any additional arguments provided to the function are appended
		     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
		     * binding of the created function.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Function
		     * @param {*} value The value to wrap.
		     * @param {Function} [wrapper=identity] The wrapper function.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var p = _.wrap(_.escape, function(func, text) {
		     *   return '<p>' + func(text) + '</p>';
		     * });
		     *
		     * p('fred, barney, & pebbles');
		     * // => '<p>fred, barney, &amp; pebbles</p>'
		     */
		    function wrap(value, wrapper) {
		      return partial(castFunction(wrapper), value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Casts `value` as an array if it's not one.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.4.0
		     * @category Lang
		     * @param {*} value The value to inspect.
		     * @returns {Array} Returns the cast array.
		     * @example
		     *
		     * _.castArray(1);
		     * // => [1]
		     *
		     * _.castArray({ 'a': 1 });
		     * // => [{ 'a': 1 }]
		     *
		     * _.castArray('abc');
		     * // => ['abc']
		     *
		     * _.castArray(null);
		     * // => [null]
		     *
		     * _.castArray(undefined);
		     * // => [undefined]
		     *
		     * _.castArray();
		     * // => []
		     *
		     * var array = [1, 2, 3];
		     * console.log(_.castArray(array) === array);
		     * // => true
		     */
		    function castArray() {
		      if (!arguments.length) {
		        return [];
		      }
		      var value = arguments[0];
		      return isArray(value) ? value : [value];
		    }

		    /**
		     * Creates a shallow clone of `value`.
		     *
		     * **Note:** This method is loosely based on the
		     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
		     * and supports cloning arrays, array buffers, booleans, date objects, maps,
		     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
		     * arrays. The own enumerable properties of `arguments` objects are cloned
		     * as plain objects. An empty object is returned for uncloneable values such
		     * as error objects, functions, DOM nodes, and WeakMaps.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeep
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var shallow = _.clone(objects);
		     * console.log(shallow[0] === objects[0]);
		     * // => true
		     */
		    function clone(value) {
		      return baseClone(value, CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.clone` except that it accepts `customizer` which
		     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
		     * cloning is handled by the method instead. The `customizer` is invoked with
		     * up to four arguments; (value [, index|key, object, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the cloned value.
		     * @see _.cloneDeepWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(false);
		     *   }
		     * }
		     *
		     * var el = _.cloneWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 0
		     */
		    function cloneWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * This method is like `_.clone` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.clone
		     * @example
		     *
		     * var objects = [{ 'a': 1 }, { 'b': 2 }];
		     *
		     * var deep = _.cloneDeep(objects);
		     * console.log(deep[0] === objects[0]);
		     * // => false
		     */
		    function cloneDeep(value) {
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
		    }

		    /**
		     * This method is like `_.cloneWith` except that it recursively clones `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to recursively clone.
		     * @param {Function} [customizer] The function to customize cloning.
		     * @returns {*} Returns the deep cloned value.
		     * @see _.cloneWith
		     * @example
		     *
		     * function customizer(value) {
		     *   if (_.isElement(value)) {
		     *     return value.cloneNode(true);
		     *   }
		     * }
		     *
		     * var el = _.cloneDeepWith(document.body, customizer);
		     *
		     * console.log(el === document.body);
		     * // => false
		     * console.log(el.nodeName);
		     * // => 'BODY'
		     * console.log(el.childNodes.length);
		     * // => 20
		     */
		    function cloneDeepWith(value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
		    }

		    /**
		     * Checks if `object` conforms to `source` by invoking the predicate
		     * properties of `source` with the corresponding property values of `object`.
		     *
		     * **Note:** This method is equivalent to `_.conforms` when `source` is
		     * partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
		     * // => true
		     *
		     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
		     * // => false
		     */
		    function conformsTo(object, source) {
		      return source == null || baseConformsTo(object, source, keys(source));
		    }

		    /**
		     * Performs a
		     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
		     * comparison between two values to determine if they are equivalent.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.eq(object, object);
		     * // => true
		     *
		     * _.eq(object, other);
		     * // => false
		     *
		     * _.eq('a', 'a');
		     * // => true
		     *
		     * _.eq('a', Object('a'));
		     * // => false
		     *
		     * _.eq(NaN, NaN);
		     * // => true
		     */
		    function eq(value, other) {
		      return value === other || (value !== value && other !== other);
		    }

		    /**
		     * Checks if `value` is greater than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than `other`,
		     *  else `false`.
		     * @see _.lt
		     * @example
		     *
		     * _.gt(3, 1);
		     * // => true
		     *
		     * _.gt(3, 3);
		     * // => false
		     *
		     * _.gt(1, 3);
		     * // => false
		     */
		    var gt = createRelationalOperation(baseGt);

		    /**
		     * Checks if `value` is greater than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is greater than or equal to
		     *  `other`, else `false`.
		     * @see _.lte
		     * @example
		     *
		     * _.gte(3, 1);
		     * // => true
		     *
		     * _.gte(3, 3);
		     * // => true
		     *
		     * _.gte(1, 3);
		     * // => false
		     */
		    var gte = createRelationalOperation(function(value, other) {
		      return value >= other;
		    });

		    /**
		     * Checks if `value` is likely an `arguments` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArguments(function() { return arguments; }());
		     * // => true
		     *
		     * _.isArguments([1, 2, 3]);
		     * // => false
		     */
		    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
		      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
		        !propertyIsEnumerable.call(value, 'callee');
		    };

		    /**
		     * Checks if `value` is classified as an `Array` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
		     * @example
		     *
		     * _.isArray([1, 2, 3]);
		     * // => true
		     *
		     * _.isArray(document.body.children);
		     * // => false
		     *
		     * _.isArray('abc');
		     * // => false
		     *
		     * _.isArray(_.noop);
		     * // => false
		     */
		    var isArray = Array.isArray;

		    /**
		     * Checks if `value` is classified as an `ArrayBuffer` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
		     * @example
		     *
		     * _.isArrayBuffer(new ArrayBuffer(2));
		     * // => true
		     *
		     * _.isArrayBuffer(new Array(2));
		     * // => false
		     */
		    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

		    /**
		     * Checks if `value` is array-like. A value is considered array-like if it's
		     * not a function and has a `value.length` that's an integer greater than or
		     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
		     * @example
		     *
		     * _.isArrayLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLike(document.body.children);
		     * // => true
		     *
		     * _.isArrayLike('abc');
		     * // => true
		     *
		     * _.isArrayLike(_.noop);
		     * // => false
		     */
		    function isArrayLike(value) {
		      return value != null && isLength(value.length) && !isFunction(value);
		    }

		    /**
		     * This method is like `_.isArrayLike` except that it also checks if `value`
		     * is an object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an array-like object,
		     *  else `false`.
		     * @example
		     *
		     * _.isArrayLikeObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isArrayLikeObject(document.body.children);
		     * // => true
		     *
		     * _.isArrayLikeObject('abc');
		     * // => false
		     *
		     * _.isArrayLikeObject(_.noop);
		     * // => false
		     */
		    function isArrayLikeObject(value) {
		      return isObjectLike(value) && isArrayLike(value);
		    }

		    /**
		     * Checks if `value` is classified as a boolean primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
		     * @example
		     *
		     * _.isBoolean(false);
		     * // => true
		     *
		     * _.isBoolean(null);
		     * // => false
		     */
		    function isBoolean(value) {
		      return value === true || value === false ||
		        (isObjectLike(value) && baseGetTag(value) == boolTag);
		    }

		    /**
		     * Checks if `value` is a buffer.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		     * @example
		     *
		     * _.isBuffer(new Buffer(2));
		     * // => true
		     *
		     * _.isBuffer(new Uint8Array(2));
		     * // => false
		     */
		    var isBuffer = nativeIsBuffer || stubFalse;

		    /**
		     * Checks if `value` is classified as a `Date` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
		     * @example
		     *
		     * _.isDate(new Date);
		     * // => true
		     *
		     * _.isDate('Mon April 23 2012');
		     * // => false
		     */
		    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

		    /**
		     * Checks if `value` is likely a DOM element.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
		     * @example
		     *
		     * _.isElement(document.body);
		     * // => true
		     *
		     * _.isElement('<body>');
		     * // => false
		     */
		    function isElement(value) {
		      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
		    }

		    /**
		     * Checks if `value` is an empty object, collection, map, or set.
		     *
		     * Objects are considered empty if they have no own enumerable string keyed
		     * properties.
		     *
		     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
		     * jQuery-like collections are considered empty if they have a `length` of `0`.
		     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
		     * @example
		     *
		     * _.isEmpty(null);
		     * // => true
		     *
		     * _.isEmpty(true);
		     * // => true
		     *
		     * _.isEmpty(1);
		     * // => true
		     *
		     * _.isEmpty([1, 2, 3]);
		     * // => false
		     *
		     * _.isEmpty({ 'a': 1 });
		     * // => false
		     */
		    function isEmpty(value) {
		      if (value == null) {
		        return true;
		      }
		      if (isArrayLike(value) &&
		          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
		            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
		        return !value.length;
		      }
		      var tag = getTag(value);
		      if (tag == mapTag || tag == setTag) {
		        return !value.size;
		      }
		      if (isPrototype(value)) {
		        return !baseKeys(value).length;
		      }
		      for (var key in value) {
		        if (hasOwnProperty.call(value, key)) {
		          return false;
		        }
		      }
		      return true;
		    }

		    /**
		     * Performs a deep comparison between two values to determine if they are
		     * equivalent.
		     *
		     * **Note:** This method supports comparing arrays, array buffers, booleans,
		     * date objects, error objects, maps, numbers, `Object` objects, regexes,
		     * sets, strings, symbols, and typed arrays. `Object` objects are compared
		     * by their own, not inherited, enumerable properties. Functions and DOM
		     * nodes are compared by strict equality, i.e. `===`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     * var other = { 'a': 1 };
		     *
		     * _.isEqual(object, other);
		     * // => true
		     *
		     * object === other;
		     * // => false
		     */
		    function isEqual(value, other) {
		      return baseIsEqual(value, other);
		    }

		    /**
		     * This method is like `_.isEqual` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with up to
		     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, othValue) {
		     *   if (isGreeting(objValue) && isGreeting(othValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var array = ['hello', 'goodbye'];
		     * var other = ['hi', 'goodbye'];
		     *
		     * _.isEqualWith(array, other, customizer);
		     * // => true
		     */
		    function isEqualWith(value, other, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      var result = customizer ? customizer(value, other) : undefined$1;
		      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
		    }

		    /**
		     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
		     * `SyntaxError`, `TypeError`, or `URIError` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
		     * @example
		     *
		     * _.isError(new Error);
		     * // => true
		     *
		     * _.isError(Error);
		     * // => false
		     */
		    function isError(value) {
		      if (!isObjectLike(value)) {
		        return false;
		      }
		      var tag = baseGetTag(value);
		      return tag == errorTag || tag == domExcTag ||
		        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
		    }

		    /**
		     * Checks if `value` is a finite primitive number.
		     *
		     * **Note:** This method is based on
		     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
		     * @example
		     *
		     * _.isFinite(3);
		     * // => true
		     *
		     * _.isFinite(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isFinite(Infinity);
		     * // => false
		     *
		     * _.isFinite('3');
		     * // => false
		     */
		    function isFinite(value) {
		      return typeof value == 'number' && nativeIsFinite(value);
		    }

		    /**
		     * Checks if `value` is classified as a `Function` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
		     * @example
		     *
		     * _.isFunction(_);
		     * // => true
		     *
		     * _.isFunction(/abc/);
		     * // => false
		     */
		    function isFunction(value) {
		      if (!isObject(value)) {
		        return false;
		      }
		      // The use of `Object#toString` avoids issues with the `typeof` operator
		      // in Safari 9 which returns 'object' for typed arrays and other constructors.
		      var tag = baseGetTag(value);
		      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
		    }

		    /**
		     * Checks if `value` is an integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
		     * @example
		     *
		     * _.isInteger(3);
		     * // => true
		     *
		     * _.isInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isInteger(Infinity);
		     * // => false
		     *
		     * _.isInteger('3');
		     * // => false
		     */
		    function isInteger(value) {
		      return typeof value == 'number' && value == toInteger(value);
		    }

		    /**
		     * Checks if `value` is a valid array-like length.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
		     * @example
		     *
		     * _.isLength(3);
		     * // => true
		     *
		     * _.isLength(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isLength(Infinity);
		     * // => false
		     *
		     * _.isLength('3');
		     * // => false
		     */
		    function isLength(value) {
		      return typeof value == 'number' &&
		        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is the
		     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
		     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
		     * @example
		     *
		     * _.isObject({});
		     * // => true
		     *
		     * _.isObject([1, 2, 3]);
		     * // => true
		     *
		     * _.isObject(_.noop);
		     * // => true
		     *
		     * _.isObject(null);
		     * // => false
		     */
		    function isObject(value) {
		      var type = typeof value;
		      return value != null && (type == 'object' || type == 'function');
		    }

		    /**
		     * Checks if `value` is object-like. A value is object-like if it's not `null`
		     * and has a `typeof` result of "object".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
		     * @example
		     *
		     * _.isObjectLike({});
		     * // => true
		     *
		     * _.isObjectLike([1, 2, 3]);
		     * // => true
		     *
		     * _.isObjectLike(_.noop);
		     * // => false
		     *
		     * _.isObjectLike(null);
		     * // => false
		     */
		    function isObjectLike(value) {
		      return value != null && typeof value == 'object';
		    }

		    /**
		     * Checks if `value` is classified as a `Map` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
		     * @example
		     *
		     * _.isMap(new Map);
		     * // => true
		     *
		     * _.isMap(new WeakMap);
		     * // => false
		     */
		    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

		    /**
		     * Performs a partial deep comparison between `object` and `source` to
		     * determine if `object` contains equivalent property values.
		     *
		     * **Note:** This method is equivalent to `_.matches` when `source` is
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2 };
		     *
		     * _.isMatch(object, { 'b': 2 });
		     * // => true
		     *
		     * _.isMatch(object, { 'b': 1 });
		     * // => false
		     */
		    function isMatch(object, source) {
		      return object === source || baseIsMatch(object, source, getMatchData(source));
		    }

		    /**
		     * This method is like `_.isMatch` except that it accepts `customizer` which
		     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
		     * are handled by the method instead. The `customizer` is invoked with five
		     * arguments: (objValue, srcValue, index|key, object, source).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {Object} object The object to inspect.
		     * @param {Object} source The object of property values to match.
		     * @param {Function} [customizer] The function to customize comparisons.
		     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
		     * @example
		     *
		     * function isGreeting(value) {
		     *   return /^h(?:i|ello)$/.test(value);
		     * }
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
		     *     return true;
		     *   }
		     * }
		     *
		     * var object = { 'greeting': 'hello' };
		     * var source = { 'greeting': 'hi' };
		     *
		     * _.isMatchWith(object, source, customizer);
		     * // => true
		     */
		    function isMatchWith(object, source, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return baseIsMatch(object, source, getMatchData(source), customizer);
		    }

		    /**
		     * Checks if `value` is `NaN`.
		     *
		     * **Note:** This method is based on
		     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
		     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
		     * `undefined` and other non-number values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
		     * @example
		     *
		     * _.isNaN(NaN);
		     * // => true
		     *
		     * _.isNaN(new Number(NaN));
		     * // => true
		     *
		     * isNaN(undefined);
		     * // => true
		     *
		     * _.isNaN(undefined);
		     * // => false
		     */
		    function isNaN(value) {
		      // An `NaN` primitive is the only value that is not equal to itself.
		      // Perform the `toStringTag` check first to avoid errors with some
		      // ActiveX objects in IE.
		      return isNumber(value) && value != +value;
		    }

		    /**
		     * Checks if `value` is a pristine native function.
		     *
		     * **Note:** This method can't reliably detect native functions in the presence
		     * of the core-js package because core-js circumvents this kind of detection.
		     * Despite multiple requests, the core-js maintainer has made it clear: any
		     * attempt to fix the detection will be obstructed. As a result, we're left
		     * with little choice but to throw an error. Unfortunately, this also affects
		     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
		     * which rely on core-js.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a native function,
		     *  else `false`.
		     * @example
		     *
		     * _.isNative(Array.prototype.push);
		     * // => true
		     *
		     * _.isNative(_);
		     * // => false
		     */
		    function isNative(value) {
		      if (isMaskable(value)) {
		        throw new Error(CORE_ERROR_TEXT);
		      }
		      return baseIsNative(value);
		    }

		    /**
		     * Checks if `value` is `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
		     * @example
		     *
		     * _.isNull(null);
		     * // => true
		     *
		     * _.isNull(void 0);
		     * // => false
		     */
		    function isNull(value) {
		      return value === null;
		    }

		    /**
		     * Checks if `value` is `null` or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
		     * @example
		     *
		     * _.isNil(null);
		     * // => true
		     *
		     * _.isNil(void 0);
		     * // => true
		     *
		     * _.isNil(NaN);
		     * // => false
		     */
		    function isNil(value) {
		      return value == null;
		    }

		    /**
		     * Checks if `value` is classified as a `Number` primitive or object.
		     *
		     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
		     * classified as numbers, use the `_.isFinite` method.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
		     * @example
		     *
		     * _.isNumber(3);
		     * // => true
		     *
		     * _.isNumber(Number.MIN_VALUE);
		     * // => true
		     *
		     * _.isNumber(Infinity);
		     * // => true
		     *
		     * _.isNumber('3');
		     * // => false
		     */
		    function isNumber(value) {
		      return typeof value == 'number' ||
		        (isObjectLike(value) && baseGetTag(value) == numberTag);
		    }

		    /**
		     * Checks if `value` is a plain object, that is, an object created by the
		     * `Object` constructor or one with a `[[Prototype]]` of `null`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.8.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * _.isPlainObject(new Foo);
		     * // => false
		     *
		     * _.isPlainObject([1, 2, 3]);
		     * // => false
		     *
		     * _.isPlainObject({ 'x': 0, 'y': 0 });
		     * // => true
		     *
		     * _.isPlainObject(Object.create(null));
		     * // => true
		     */
		    function isPlainObject(value) {
		      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
		        return false;
		      }
		      var proto = getPrototype(value);
		      if (proto === null) {
		        return true;
		      }
		      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
		      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
		        funcToString.call(Ctor) == objectCtorString;
		    }

		    /**
		     * Checks if `value` is classified as a `RegExp` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.1.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
		     * @example
		     *
		     * _.isRegExp(/abc/);
		     * // => true
		     *
		     * _.isRegExp('/abc/');
		     * // => false
		     */
		    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

		    /**
		     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
		     * double precision number which isn't the result of a rounded unsafe integer.
		     *
		     * **Note:** This method is based on
		     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
		     * @example
		     *
		     * _.isSafeInteger(3);
		     * // => true
		     *
		     * _.isSafeInteger(Number.MIN_VALUE);
		     * // => false
		     *
		     * _.isSafeInteger(Infinity);
		     * // => false
		     *
		     * _.isSafeInteger('3');
		     * // => false
		     */
		    function isSafeInteger(value) {
		      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
		    }

		    /**
		     * Checks if `value` is classified as a `Set` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
		     * @example
		     *
		     * _.isSet(new Set);
		     * // => true
		     *
		     * _.isSet(new WeakSet);
		     * // => false
		     */
		    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

		    /**
		     * Checks if `value` is classified as a `String` primitive or object.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
		     * @example
		     *
		     * _.isString('abc');
		     * // => true
		     *
		     * _.isString(1);
		     * // => false
		     */
		    function isString(value) {
		      return typeof value == 'string' ||
		        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
		    }

		    /**
		     * Checks if `value` is classified as a `Symbol` primitive or object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
		     * @example
		     *
		     * _.isSymbol(Symbol.iterator);
		     * // => true
		     *
		     * _.isSymbol('abc');
		     * // => false
		     */
		    function isSymbol(value) {
		      return typeof value == 'symbol' ||
		        (isObjectLike(value) && baseGetTag(value) == symbolTag);
		    }

		    /**
		     * Checks if `value` is classified as a typed array.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
		     * @example
		     *
		     * _.isTypedArray(new Uint8Array);
		     * // => true
		     *
		     * _.isTypedArray([]);
		     * // => false
		     */
		    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

		    /**
		     * Checks if `value` is `undefined`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
		     * @example
		     *
		     * _.isUndefined(void 0);
		     * // => true
		     *
		     * _.isUndefined(null);
		     * // => false
		     */
		    function isUndefined(value) {
		      return value === undefined$1;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakMap` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
		     * @example
		     *
		     * _.isWeakMap(new WeakMap);
		     * // => true
		     *
		     * _.isWeakMap(new Map);
		     * // => false
		     */
		    function isWeakMap(value) {
		      return isObjectLike(value) && getTag(value) == weakMapTag;
		    }

		    /**
		     * Checks if `value` is classified as a `WeakSet` object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.3.0
		     * @category Lang
		     * @param {*} value The value to check.
		     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
		     * @example
		     *
		     * _.isWeakSet(new WeakSet);
		     * // => true
		     *
		     * _.isWeakSet(new Set);
		     * // => false
		     */
		    function isWeakSet(value) {
		      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
		    }

		    /**
		     * Checks if `value` is less than `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than `other`,
		     *  else `false`.
		     * @see _.gt
		     * @example
		     *
		     * _.lt(1, 3);
		     * // => true
		     *
		     * _.lt(3, 3);
		     * // => false
		     *
		     * _.lt(3, 1);
		     * // => false
		     */
		    var lt = createRelationalOperation(baseLt);

		    /**
		     * Checks if `value` is less than or equal to `other`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.9.0
		     * @category Lang
		     * @param {*} value The value to compare.
		     * @param {*} other The other value to compare.
		     * @returns {boolean} Returns `true` if `value` is less than or equal to
		     *  `other`, else `false`.
		     * @see _.gte
		     * @example
		     *
		     * _.lte(1, 3);
		     * // => true
		     *
		     * _.lte(3, 3);
		     * // => true
		     *
		     * _.lte(3, 1);
		     * // => false
		     */
		    var lte = createRelationalOperation(function(value, other) {
		      return value <= other;
		    });

		    /**
		     * Converts `value` to an array.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the converted array.
		     * @example
		     *
		     * _.toArray({ 'a': 1, 'b': 2 });
		     * // => [1, 2]
		     *
		     * _.toArray('abc');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toArray(1);
		     * // => []
		     *
		     * _.toArray(null);
		     * // => []
		     */
		    function toArray(value) {
		      if (!value) {
		        return [];
		      }
		      if (isArrayLike(value)) {
		        return isString(value) ? stringToArray(value) : copyArray(value);
		      }
		      if (symIterator && value[symIterator]) {
		        return iteratorToArray(value[symIterator]());
		      }
		      var tag = getTag(value),
		          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

		      return func(value);
		    }

		    /**
		     * Converts `value` to a finite number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.12.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted number.
		     * @example
		     *
		     * _.toFinite(3.2);
		     * // => 3.2
		     *
		     * _.toFinite(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toFinite(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toFinite('3.2');
		     * // => 3.2
		     */
		    function toFinite(value) {
		      if (!value) {
		        return value === 0 ? value : 0;
		      }
		      value = toNumber(value);
		      if (value === INFINITY || value === -INFINITY) {
		        var sign = (value < 0 ? -1 : 1);
		        return sign * MAX_INTEGER;
		      }
		      return value === value ? value : 0;
		    }

		    /**
		     * Converts `value` to an integer.
		     *
		     * **Note:** This method is loosely based on
		     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toInteger(3.2);
		     * // => 3
		     *
		     * _.toInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toInteger(Infinity);
		     * // => 1.7976931348623157e+308
		     *
		     * _.toInteger('3.2');
		     * // => 3
		     */
		    function toInteger(value) {
		      var result = toFinite(value),
		          remainder = result % 1;

		      return result === result ? (remainder ? result - remainder : result) : 0;
		    }

		    /**
		     * Converts `value` to an integer suitable for use as the length of an
		     * array-like object.
		     *
		     * **Note:** This method is based on
		     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toLength(3.2);
		     * // => 3
		     *
		     * _.toLength(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toLength(Infinity);
		     * // => 4294967295
		     *
		     * _.toLength('3.2');
		     * // => 3
		     */
		    function toLength(value) {
		      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
		    }

		    /**
		     * Converts `value` to a number.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to process.
		     * @returns {number} Returns the number.
		     * @example
		     *
		     * _.toNumber(3.2);
		     * // => 3.2
		     *
		     * _.toNumber(Number.MIN_VALUE);
		     * // => 5e-324
		     *
		     * _.toNumber(Infinity);
		     * // => Infinity
		     *
		     * _.toNumber('3.2');
		     * // => 3.2
		     */
		    function toNumber(value) {
		      if (typeof value == 'number') {
		        return value;
		      }
		      if (isSymbol(value)) {
		        return NAN;
		      }
		      if (isObject(value)) {
		        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
		        value = isObject(other) ? (other + '') : other;
		      }
		      if (typeof value != 'string') {
		        return value === 0 ? value : +value;
		      }
		      value = baseTrim(value);
		      var isBinary = reIsBinary.test(value);
		      return (isBinary || reIsOctal.test(value))
		        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
		        : (reIsBadHex.test(value) ? NAN : +value);
		    }

		    /**
		     * Converts `value` to a plain object flattening inherited enumerable string
		     * keyed properties of `value` to own properties of the plain object.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {Object} Returns the converted plain object.
		     * @example
		     *
		     * function Foo() {
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.assign({ 'a': 1 }, new Foo);
		     * // => { 'a': 1, 'b': 2 }
		     *
		     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
		     * // => { 'a': 1, 'b': 2, 'c': 3 }
		     */
		    function toPlainObject(value) {
		      return copyObject(value, keysIn(value));
		    }

		    /**
		     * Converts `value` to a safe integer. A safe integer can be compared and
		     * represented correctly.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.toSafeInteger(3.2);
		     * // => 3
		     *
		     * _.toSafeInteger(Number.MIN_VALUE);
		     * // => 0
		     *
		     * _.toSafeInteger(Infinity);
		     * // => 9007199254740991
		     *
		     * _.toSafeInteger('3.2');
		     * // => 3
		     */
		    function toSafeInteger(value) {
		      return value
		        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
		        : (value === 0 ? value : 0);
		    }

		    /**
		     * Converts `value` to a string. An empty string is returned for `null`
		     * and `undefined` values. The sign of `-0` is preserved.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Lang
		     * @param {*} value The value to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.toString(null);
		     * // => ''
		     *
		     * _.toString(-0);
		     * // => '-0'
		     *
		     * _.toString([1, 2, 3]);
		     * // => '1,2,3'
		     */
		    function toString(value) {
		      return value == null ? '' : baseToString(value);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Assigns own enumerable string keyed properties of source objects to the
		     * destination object. Source objects are applied from left to right.
		     * Subsequent sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object` and is loosely based on
		     * [`Object.assign`](https://mdn.io/Object/assign).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assignIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assign({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var assign = createAssigner(function(object, source) {
		      if (isPrototype(source) || isArrayLike(source)) {
		        copyObject(source, keys(source), object);
		        return;
		      }
		      for (var key in source) {
		        if (hasOwnProperty.call(source, key)) {
		          assignValue(object, key, source[key]);
		        }
		      }
		    });

		    /**
		     * This method is like `_.assign` except that it iterates over own and
		     * inherited source properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extend
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.assign
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     * }
		     *
		     * function Bar() {
		     *   this.c = 3;
		     * }
		     *
		     * Foo.prototype.b = 2;
		     * Bar.prototype.d = 4;
		     *
		     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
		     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
		     */
		    var assignIn = createAssigner(function(object, source) {
		      copyObject(source, keysIn(source), object);
		    });

		    /**
		     * This method is like `_.assignIn` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias extendWith
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignInWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keysIn(source), object, customizer);
		    });

		    /**
		     * This method is like `_.assign` except that it accepts `customizer`
		     * which is invoked to produce the assigned values. If `customizer` returns
		     * `undefined`, assignment is handled by the method instead. The `customizer`
		     * is invoked with five arguments: (objValue, srcValue, key, object, source).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @see _.assignInWith
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   return _.isUndefined(objValue) ? srcValue : objValue;
		     * }
		     *
		     * var defaults = _.partialRight(_.assignWith, customizer);
		     *
		     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
		      copyObject(source, keys(source), object, customizer);
		    });

		    /**
		     * Creates an array of values corresponding to `paths` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Array} Returns the picked values.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
		     *
		     * _.at(object, ['a[0].b.c', 'a[1]']);
		     * // => [3, 4]
		     */
		    var at = flatRest(baseAt);

		    /**
		     * Creates an object that inherits from the `prototype` object. If a
		     * `properties` object is given, its own enumerable string keyed properties
		     * are assigned to the created object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Object
		     * @param {Object} prototype The object to inherit from.
		     * @param {Object} [properties] The properties to assign to the object.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * function Shape() {
		     *   this.x = 0;
		     *   this.y = 0;
		     * }
		     *
		     * function Circle() {
		     *   Shape.call(this);
		     * }
		     *
		     * Circle.prototype = _.create(Shape.prototype, {
		     *   'constructor': Circle
		     * });
		     *
		     * var circle = new Circle;
		     * circle instanceof Circle;
		     * // => true
		     *
		     * circle instanceof Shape;
		     * // => true
		     */
		    function create(prototype, properties) {
		      var result = baseCreate(prototype);
		      return properties == null ? result : baseAssign(result, properties);
		    }

		    /**
		     * Assigns own and inherited enumerable string keyed properties of source
		     * objects to the destination object for all destination properties that
		     * resolve to `undefined`. Source objects are applied from left to right.
		     * Once a property is set, additional values of the same property are ignored.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaultsDeep
		     * @example
		     *
		     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
		     * // => { 'a': 1, 'b': 2 }
		     */
		    var defaults = baseRest(function(object, sources) {
		      object = Object(object);

		      var index = -1;
		      var length = sources.length;
		      var guard = length > 2 ? sources[2] : undefined$1;

		      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
		        length = 1;
		      }

		      while (++index < length) {
		        var source = sources[index];
		        var props = keysIn(source);
		        var propsIndex = -1;
		        var propsLength = props.length;

		        while (++propsIndex < propsLength) {
		          var key = props[propsIndex];
		          var value = object[key];

		          if (value === undefined$1 ||
		              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
		            object[key] = source[key];
		          }
		        }
		      }

		      return object;
		    });

		    /**
		     * This method is like `_.defaults` except that it recursively assigns
		     * default properties.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @see _.defaults
		     * @example
		     *
		     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
		     * // => { 'a': { 'b': 2, 'c': 3 } }
		     */
		    var defaultsDeep = baseRest(function(args) {
		      args.push(undefined$1, customDefaultsMerge);
		      return apply(mergeWith, undefined$1, args);
		    });

		    /**
		     * This method is like `_.find` except that it returns the key of the first
		     * element `predicate` returns truthy for instead of the element itself.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findKey(users, function(o) { return o.age < 40; });
		     * // => 'barney' (iteration order is not guaranteed)
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findKey(users, { 'age': 1, 'active': true });
		     * // => 'pebbles'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findKey(users, 'active');
		     * // => 'barney'
		     */
		    function findKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
		    }

		    /**
		     * This method is like `_.findKey` except that it iterates over elements of
		     * a collection in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @param {Function} [predicate=_.identity] The function invoked per iteration.
		     * @returns {string|undefined} Returns the key of the matched element,
		     *  else `undefined`.
		     * @example
		     *
		     * var users = {
		     *   'barney':  { 'age': 36, 'active': true },
		     *   'fred':    { 'age': 40, 'active': false },
		     *   'pebbles': { 'age': 1,  'active': true }
		     * };
		     *
		     * _.findLastKey(users, function(o) { return o.age < 40; });
		     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.findLastKey(users, { 'age': 36, 'active': true });
		     * // => 'barney'
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.findLastKey(users, ['active', false]);
		     * // => 'fred'
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.findLastKey(users, 'active');
		     * // => 'pebbles'
		     */
		    function findLastKey(object, predicate) {
		      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
		    }

		    /**
		     * Iterates over own and inherited enumerable string keyed properties of an
		     * object and invokes `iteratee` for each property. The iteratee is invoked
		     * with three arguments: (value, key, object). Iteratee functions may exit
		     * iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forInRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forIn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
		     */
		    function forIn(object, iteratee) {
		      return object == null
		        ? object
		        : baseFor(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * This method is like `_.forIn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forInRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
		     */
		    function forInRight(object, iteratee) {
		      return object == null
		        ? object
		        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
		    }

		    /**
		     * Iterates over own enumerable string keyed properties of an object and
		     * invokes `iteratee` for each property. The iteratee is invoked with three
		     * arguments: (value, key, object). Iteratee functions may exit iteration
		     * early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwnRight
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwn(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
		     */
		    function forOwn(object, iteratee) {
		      return object && baseForOwn(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * This method is like `_.forOwn` except that it iterates over properties of
		     * `object` in the opposite order.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.0.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns `object`.
		     * @see _.forOwn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.forOwnRight(new Foo, function(value, key) {
		     *   console.log(key);
		     * });
		     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
		     */
		    function forOwnRight(object, iteratee) {
		      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
		    }

		    /**
		     * Creates an array of function property names from own enumerable properties
		     * of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functionsIn
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functions(new Foo);
		     * // => ['a', 'b']
		     */
		    function functions(object) {
		      return object == null ? [] : baseFunctions(object, keys(object));
		    }

		    /**
		     * Creates an array of function property names from own and inherited
		     * enumerable properties of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to inspect.
		     * @returns {Array} Returns the function names.
		     * @see _.functions
		     * @example
		     *
		     * function Foo() {
		     *   this.a = _.constant('a');
		     *   this.b = _.constant('b');
		     * }
		     *
		     * Foo.prototype.c = _.constant('c');
		     *
		     * _.functionsIn(new Foo);
		     * // => ['a', 'b', 'c']
		     */
		    function functionsIn(object) {
		      return object == null ? [] : baseFunctions(object, keysIn(object));
		    }

		    /**
		     * Gets the value at `path` of `object`. If the resolved value is
		     * `undefined`, the `defaultValue` is returned in its place.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.get(object, 'a[0].b.c');
		     * // => 3
		     *
		     * _.get(object, ['a', '0', 'b', 'c']);
		     * // => 3
		     *
		     * _.get(object, 'a.b.c', 'default');
		     * // => 'default'
		     */
		    function get(object, path, defaultValue) {
		      var result = object == null ? undefined$1 : baseGet(object, path);
		      return result === undefined$1 ? defaultValue : result;
		    }

		    /**
		     * Checks if `path` is a direct property of `object`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = { 'a': { 'b': 2 } };
		     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.has(object, 'a');
		     * // => true
		     *
		     * _.has(object, 'a.b');
		     * // => true
		     *
		     * _.has(object, ['a', 'b']);
		     * // => true
		     *
		     * _.has(other, 'a');
		     * // => false
		     */
		    function has(object, path) {
		      return object != null && hasPath(object, path, baseHas);
		    }

		    /**
		     * Checks if `path` is a direct or inherited property of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path to check.
		     * @returns {boolean} Returns `true` if `path` exists, else `false`.
		     * @example
		     *
		     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
		     *
		     * _.hasIn(object, 'a');
		     * // => true
		     *
		     * _.hasIn(object, 'a.b');
		     * // => true
		     *
		     * _.hasIn(object, ['a', 'b']);
		     * // => true
		     *
		     * _.hasIn(object, 'b');
		     * // => false
		     */
		    function hasIn(object, path) {
		      return object != null && hasPath(object, path, baseHasIn);
		    }

		    /**
		     * Creates an object composed of the inverted keys and values of `object`.
		     * If `object` contains duplicate values, subsequent values overwrite
		     * property assignments of previous values.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invert(object);
		     * // => { '1': 'c', '2': 'b' }
		     */
		    var invert = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      result[value] = key;
		    }, constant(identity));

		    /**
		     * This method is like `_.invert` except that the inverted object is generated
		     * from the results of running each element of `object` thru `iteratee`. The
		     * corresponding inverted value of each inverted key is an array of keys
		     * responsible for generating the inverted value. The iteratee is invoked
		     * with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.1.0
		     * @category Object
		     * @param {Object} object The object to invert.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {Object} Returns the new inverted object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': 2, 'c': 1 };
		     *
		     * _.invertBy(object);
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     *
		     * _.invertBy(object, function(value) {
		     *   return 'group' + value;
		     * });
		     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
		     */
		    var invertBy = createInverter(function(result, value, key) {
		      if (value != null &&
		          typeof value.toString != 'function') {
		        value = nativeObjectToString.call(value);
		      }

		      if (hasOwnProperty.call(result, value)) {
		        result[value].push(key);
		      } else {
		        result[value] = [key];
		      }
		    }, getIteratee);

		    /**
		     * Invokes the method at `path` of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {*} Returns the result of the invoked method.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
		     *
		     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
		     * // => [2, 3]
		     */
		    var invoke = baseRest(baseInvoke);

		    /**
		     * Creates an array of the own enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects. See the
		     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
		     * for more details.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keys(new Foo);
		     * // => ['a', 'b'] (iteration order is not guaranteed)
		     *
		     * _.keys('hi');
		     * // => ['0', '1']
		     */
		    function keys(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
		    }

		    /**
		     * Creates an array of the own and inherited enumerable property names of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property names.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.keysIn(new Foo);
		     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
		     */
		    function keysIn(object) {
		      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
		    }

		    /**
		     * The opposite of `_.mapValues`; this method creates an object with the
		     * same values as `object` and keys generated by running each own enumerable
		     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
		     * with three arguments: (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.8.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapValues
		     * @example
		     *
		     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
		     *   return key + value;
		     * });
		     * // => { 'a1': 1, 'b2': 2 }
		     */
		    function mapKeys(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, iteratee(value, key, object), value);
		      });
		      return result;
		    }

		    /**
		     * Creates an object with the same keys as `object` and values generated
		     * by running each own enumerable string keyed property of `object` thru
		     * `iteratee`. The iteratee is invoked with three arguments:
		     * (value, key, object).
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Object} Returns the new mapped object.
		     * @see _.mapKeys
		     * @example
		     *
		     * var users = {
		     *   'fred':    { 'user': 'fred',    'age': 40 },
		     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
		     * };
		     *
		     * _.mapValues(users, function(o) { return o.age; });
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.mapValues(users, 'age');
		     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
		     */
		    function mapValues(object, iteratee) {
		      var result = {};
		      iteratee = getIteratee(iteratee, 3);

		      baseForOwn(object, function(value, key, object) {
		        baseAssignValue(result, key, iteratee(value, key, object));
		      });
		      return result;
		    }

		    /**
		     * This method is like `_.assign` except that it recursively merges own and
		     * inherited enumerable string keyed properties of source objects into the
		     * destination object. Source properties that resolve to `undefined` are
		     * skipped if a destination value exists. Array and plain object properties
		     * are merged recursively. Other objects and value types are overridden by
		     * assignment. Source objects are applied from left to right. Subsequent
		     * sources overwrite property assignments of previous sources.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.5.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} [sources] The source objects.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {
		     *   'a': [{ 'b': 2 }, { 'd': 4 }]
		     * };
		     *
		     * var other = {
		     *   'a': [{ 'c': 3 }, { 'e': 5 }]
		     * };
		     *
		     * _.merge(object, other);
		     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
		     */
		    var merge = createAssigner(function(object, source, srcIndex) {
		      baseMerge(object, source, srcIndex);
		    });

		    /**
		     * This method is like `_.merge` except that it accepts `customizer` which
		     * is invoked to produce the merged values of the destination and source
		     * properties. If `customizer` returns `undefined`, merging is handled by the
		     * method instead. The `customizer` is invoked with six arguments:
		     * (objValue, srcValue, key, object, source, stack).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The destination object.
		     * @param {...Object} sources The source objects.
		     * @param {Function} customizer The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * function customizer(objValue, srcValue) {
		     *   if (_.isArray(objValue)) {
		     *     return objValue.concat(srcValue);
		     *   }
		     * }
		     *
		     * var object = { 'a': [1], 'b': [2] };
		     * var other = { 'a': [3], 'b': [4] };
		     *
		     * _.mergeWith(object, other, customizer);
		     * // => { 'a': [1, 3], 'b': [2, 4] }
		     */
		    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
		      baseMerge(object, source, srcIndex, customizer);
		    });

		    /**
		     * The opposite of `_.pick`; this method creates an object composed of the
		     * own and inherited enumerable property paths of `object` that are not omitted.
		     *
		     * **Note:** This method is considerably slower than `_.pick`.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to omit.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omit(object, ['a', 'c']);
		     * // => { 'b': '2' }
		     */
		    var omit = flatRest(function(object, paths) {
		      var result = {};
		      if (object == null) {
		        return result;
		      }
		      var isDeep = false;
		      paths = arrayMap(paths, function(path) {
		        path = castPath(path, object);
		        isDeep || (isDeep = path.length > 1);
		        return path;
		      });
		      copyObject(object, getAllKeysIn(object), result);
		      if (isDeep) {
		        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
		      }
		      var length = paths.length;
		      while (length--) {
		        baseUnset(result, paths[length]);
		      }
		      return result;
		    });

		    /**
		     * The opposite of `_.pickBy`; this method creates an object composed of
		     * the own and inherited enumerable string keyed properties of `object` that
		     * `predicate` doesn't return truthy for. The predicate is invoked with two
		     * arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.omitBy(object, _.isNumber);
		     * // => { 'b': '2' }
		     */
		    function omitBy(object, predicate) {
		      return pickBy(object, negate(getIteratee(predicate)));
		    }

		    /**
		     * Creates an object composed of the picked `object` properties.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {...(string|string[])} [paths] The property paths to pick.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pick(object, ['a', 'c']);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    var pick = flatRest(function(object, paths) {
		      return object == null ? {} : basePick(object, paths);
		    });

		    /**
		     * Creates an object composed of the `object` properties `predicate` returns
		     * truthy for. The predicate is invoked with two arguments: (value, key).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The source object.
		     * @param {Function} [predicate=_.identity] The function invoked per property.
		     * @returns {Object} Returns the new object.
		     * @example
		     *
		     * var object = { 'a': 1, 'b': '2', 'c': 3 };
		     *
		     * _.pickBy(object, _.isNumber);
		     * // => { 'a': 1, 'c': 3 }
		     */
		    function pickBy(object, predicate) {
		      if (object == null) {
		        return {};
		      }
		      var props = arrayMap(getAllKeysIn(object), function(prop) {
		        return [prop];
		      });
		      predicate = getIteratee(predicate);
		      return basePickBy(object, props, function(value, path) {
		        return predicate(value, path[0]);
		      });
		    }

		    /**
		     * This method is like `_.get` except that if the resolved value is a
		     * function it's invoked with the `this` binding of its parent object and
		     * its result is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @param {Array|string} path The path of the property to resolve.
		     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
		     *
		     * _.result(object, 'a[0].b.c1');
		     * // => 3
		     *
		     * _.result(object, 'a[0].b.c2');
		     * // => 4
		     *
		     * _.result(object, 'a[0].b.c3', 'default');
		     * // => 'default'
		     *
		     * _.result(object, 'a[0].b.c3', _.constant('default'));
		     * // => 'default'
		     */
		    function result(object, path, defaultValue) {
		      path = castPath(path, object);

		      var index = -1,
		          length = path.length;

		      // Ensure the loop is entered when path is empty.
		      if (!length) {
		        length = 1;
		        object = undefined$1;
		      }
		      while (++index < length) {
		        var value = object == null ? undefined$1 : object[toKey(path[index])];
		        if (value === undefined$1) {
		          index = length;
		          value = defaultValue;
		        }
		        object = isFunction(value) ? value.call(object) : value;
		      }
		      return object;
		    }

		    /**
		     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
		     * it's created. Arrays are created for missing index properties while objects
		     * are created for all other missing properties. Use `_.setWith` to customize
		     * `path` creation.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.set(object, 'a[0].b.c', 4);
		     * console.log(object.a[0].b.c);
		     * // => 4
		     *
		     * _.set(object, ['x', '0', 'y', 'z'], 5);
		     * console.log(object.x[0].y.z);
		     * // => 5
		     */
		    function set(object, path, value) {
		      return object == null ? object : baseSet(object, path, value);
		    }

		    /**
		     * This method is like `_.set` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {*} value The value to set.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.setWith(object, '[0][1]', 'a', Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function setWith(object, path, value, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseSet(object, path, value, customizer);
		    }

		    /**
		     * Creates an array of own enumerable string keyed-value pairs for `object`
		     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
		     * entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entries
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairs(new Foo);
		     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
		     */
		    var toPairs = createToPairs(keys);

		    /**
		     * Creates an array of own and inherited enumerable string keyed-value pairs
		     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
		     * or set, its entries are returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @alias entriesIn
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the key-value pairs.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.toPairsIn(new Foo);
		     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
		     */
		    var toPairsIn = createToPairs(keysIn);

		    /**
		     * An alternative to `_.reduce`; this method transforms `object` to a new
		     * `accumulator` object which is the result of running each of its own
		     * enumerable string keyed properties thru `iteratee`, with each invocation
		     * potentially mutating the `accumulator` object. If `accumulator` is not
		     * provided, a new object with the same `[[Prototype]]` will be used. The
		     * iteratee is invoked with four arguments: (accumulator, value, key, object).
		     * Iteratee functions may exit iteration early by explicitly returning `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.3.0
		     * @category Object
		     * @param {Object} object The object to iterate over.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @param {*} [accumulator] The custom accumulator value.
		     * @returns {*} Returns the accumulated value.
		     * @example
		     *
		     * _.transform([2, 3, 4], function(result, n) {
		     *   result.push(n *= n);
		     *   return n % 2 == 0;
		     * }, []);
		     * // => [4, 9]
		     *
		     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
		     *   (result[value] || (result[value] = [])).push(key);
		     * }, {});
		     * // => { '1': ['a', 'c'], '2': ['b'] }
		     */
		    function transform(object, iteratee, accumulator) {
		      var isArr = isArray(object),
		          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

		      iteratee = getIteratee(iteratee, 4);
		      if (accumulator == null) {
		        var Ctor = object && object.constructor;
		        if (isArrLike) {
		          accumulator = isArr ? new Ctor : [];
		        }
		        else if (isObject(object)) {
		          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
		        }
		        else {
		          accumulator = {};
		        }
		      }
		      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
		        return iteratee(accumulator, value, index, object);
		      });
		      return accumulator;
		    }

		    /**
		     * Removes the property at `path` of `object`.
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to unset.
		     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
		     * _.unset(object, 'a[0].b.c');
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     *
		     * _.unset(object, ['a', '0', 'b', 'c']);
		     * // => true
		     *
		     * console.log(object);
		     * // => { 'a': [{ 'b': {} }] };
		     */
		    function unset(object, path) {
		      return object == null ? true : baseUnset(object, path);
		    }

		    /**
		     * This method is like `_.set` except that accepts `updater` to produce the
		     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
		     * is invoked with one argument: (value).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
		     *
		     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
		     * console.log(object.a[0].b.c);
		     * // => 9
		     *
		     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
		     * console.log(object.x[0].y.z);
		     * // => 0
		     */
		    function update(object, path, updater) {
		      return object == null ? object : baseUpdate(object, path, castFunction(updater));
		    }

		    /**
		     * This method is like `_.update` except that it accepts `customizer` which is
		     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
		     * path creation is handled by the method instead. The `customizer` is invoked
		     * with three arguments: (nsValue, key, nsObject).
		     *
		     * **Note:** This method mutates `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.6.0
		     * @category Object
		     * @param {Object} object The object to modify.
		     * @param {Array|string} path The path of the property to set.
		     * @param {Function} updater The function to produce the updated value.
		     * @param {Function} [customizer] The function to customize assigned values.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var object = {};
		     *
		     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
		     * // => { '0': { '1': 'a' } }
		     */
		    function updateWith(object, path, updater, customizer) {
		      customizer = typeof customizer == 'function' ? customizer : undefined$1;
		      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
		    }

		    /**
		     * Creates an array of the own enumerable string keyed property values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.values(new Foo);
		     * // => [1, 2] (iteration order is not guaranteed)
		     *
		     * _.values('hi');
		     * // => ['h', 'i']
		     */
		    function values(object) {
		      return object == null ? [] : baseValues(object, keys(object));
		    }

		    /**
		     * Creates an array of the own and inherited enumerable string keyed property
		     * values of `object`.
		     *
		     * **Note:** Non-object values are coerced to objects.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Object
		     * @param {Object} object The object to query.
		     * @returns {Array} Returns the array of property values.
		     * @example
		     *
		     * function Foo() {
		     *   this.a = 1;
		     *   this.b = 2;
		     * }
		     *
		     * Foo.prototype.c = 3;
		     *
		     * _.valuesIn(new Foo);
		     * // => [1, 2, 3] (iteration order is not guaranteed)
		     */
		    function valuesIn(object) {
		      return object == null ? [] : baseValues(object, keysIn(object));
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Clamps `number` within the inclusive `lower` and `upper` bounds.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Number
		     * @param {number} number The number to clamp.
		     * @param {number} [lower] The lower bound.
		     * @param {number} upper The upper bound.
		     * @returns {number} Returns the clamped number.
		     * @example
		     *
		     * _.clamp(-10, -5, 5);
		     * // => -5
		     *
		     * _.clamp(10, -5, 5);
		     * // => 5
		     */
		    function clamp(number, lower, upper) {
		      if (upper === undefined$1) {
		        upper = lower;
		        lower = undefined$1;
		      }
		      if (upper !== undefined$1) {
		        upper = toNumber(upper);
		        upper = upper === upper ? upper : 0;
		      }
		      if (lower !== undefined$1) {
		        lower = toNumber(lower);
		        lower = lower === lower ? lower : 0;
		      }
		      return baseClamp(toNumber(number), lower, upper);
		    }

		    /**
		     * Checks if `n` is between `start` and up to, but not including, `end`. If
		     * `end` is not specified, it's set to `start` with `start` then set to `0`.
		     * If `start` is greater than `end` the params are swapped to support
		     * negative ranges.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.3.0
		     * @category Number
		     * @param {number} number The number to check.
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
		     * @see _.range, _.rangeRight
		     * @example
		     *
		     * _.inRange(3, 2, 4);
		     * // => true
		     *
		     * _.inRange(4, 8);
		     * // => true
		     *
		     * _.inRange(4, 2);
		     * // => false
		     *
		     * _.inRange(2, 2);
		     * // => false
		     *
		     * _.inRange(1.2, 2);
		     * // => true
		     *
		     * _.inRange(5.2, 4);
		     * // => false
		     *
		     * _.inRange(-3, -2, -6);
		     * // => true
		     */
		    function inRange(number, start, end) {
		      start = toFinite(start);
		      if (end === undefined$1) {
		        end = start;
		        start = 0;
		      } else {
		        end = toFinite(end);
		      }
		      number = toNumber(number);
		      return baseInRange(number, start, end);
		    }

		    /**
		     * Produces a random number between the inclusive `lower` and `upper` bounds.
		     * If only one argument is provided a number between `0` and the given number
		     * is returned. If `floating` is `true`, or either `lower` or `upper` are
		     * floats, a floating-point number is returned instead of an integer.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @memberOf _
		     * @since 0.7.0
		     * @category Number
		     * @param {number} [lower=0] The lower bound.
		     * @param {number} [upper=1] The upper bound.
		     * @param {boolean} [floating] Specify returning a floating-point number.
		     * @returns {number} Returns the random number.
		     * @example
		     *
		     * _.random(0, 5);
		     * // => an integer between 0 and 5
		     *
		     * _.random(5);
		     * // => also an integer between 0 and 5
		     *
		     * _.random(5, true);
		     * // => a floating-point number between 0 and 5
		     *
		     * _.random(1.2, 5.2);
		     * // => a floating-point number between 1.2 and 5.2
		     */
		    function random(lower, upper, floating) {
		      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
		        upper = floating = undefined$1;
		      }
		      if (floating === undefined$1) {
		        if (typeof upper == 'boolean') {
		          floating = upper;
		          upper = undefined$1;
		        }
		        else if (typeof lower == 'boolean') {
		          floating = lower;
		          lower = undefined$1;
		        }
		      }
		      if (lower === undefined$1 && upper === undefined$1) {
		        lower = 0;
		        upper = 1;
		      }
		      else {
		        lower = toFinite(lower);
		        if (upper === undefined$1) {
		          upper = lower;
		          lower = 0;
		        } else {
		          upper = toFinite(upper);
		        }
		      }
		      if (lower > upper) {
		        var temp = lower;
		        lower = upper;
		        upper = temp;
		      }
		      if (floating || lower % 1 || upper % 1) {
		        var rand = nativeRandom();
		        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
		      }
		      return baseRandom(lower, upper);
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the camel cased string.
		     * @example
		     *
		     * _.camelCase('Foo Bar');
		     * // => 'fooBar'
		     *
		     * _.camelCase('--foo-bar--');
		     * // => 'fooBar'
		     *
		     * _.camelCase('__FOO_BAR__');
		     * // => 'fooBar'
		     */
		    var camelCase = createCompounder(function(result, word, index) {
		      word = word.toLowerCase();
		      return result + (index ? capitalize(word) : word);
		    });

		    /**
		     * Converts the first character of `string` to upper case and the remaining
		     * to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to capitalize.
		     * @returns {string} Returns the capitalized string.
		     * @example
		     *
		     * _.capitalize('FRED');
		     * // => 'Fred'
		     */
		    function capitalize(string) {
		      return upperFirst(toString(string).toLowerCase());
		    }

		    /**
		     * Deburrs `string` by converting
		     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
		     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
		     * letters to basic Latin letters and removing
		     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to deburr.
		     * @returns {string} Returns the deburred string.
		     * @example
		     *
		     * _.deburr('dÃ©jÃ  vu');
		     * // => 'deja vu'
		     */
		    function deburr(string) {
		      string = toString(string);
		      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
		    }

		    /**
		     * Checks if `string` ends with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=string.length] The position to search up to.
		     * @returns {boolean} Returns `true` if `string` ends with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.endsWith('abc', 'c');
		     * // => true
		     *
		     * _.endsWith('abc', 'b');
		     * // => false
		     *
		     * _.endsWith('abc', 'b', 2);
		     * // => true
		     */
		    function endsWith(string, target, position) {
		      string = toString(string);
		      target = baseToString(target);

		      var length = string.length;
		      position = position === undefined$1
		        ? length
		        : baseClamp(toInteger(position), 0, length);

		      var end = position;
		      position -= target.length;
		      return position >= 0 && string.slice(position, end) == target;
		    }

		    /**
		     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
		     * corresponding HTML entities.
		     *
		     * **Note:** No other characters are escaped. To escape additional
		     * characters use a third-party library like [_he_](https://mths.be/he).
		     *
		     * Though the ">" character is escaped for symmetry, characters like
		     * ">" and "/" don't need escaping in HTML and have no special meaning
		     * unless they're part of a tag or unquoted attribute value. See
		     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
		     * (under "semi-related fun fact") for more details.
		     *
		     * When working with HTML you should always
		     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
		     * XSS vectors.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escape('fred, barney, & pebbles');
		     * // => 'fred, barney, &amp; pebbles'
		     */
		    function escape(string) {
		      string = toString(string);
		      return (string && reHasUnescapedHtml.test(string))
		        ? string.replace(reUnescapedHtml, escapeHtmlChar)
		        : string;
		    }

		    /**
		     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
		     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to escape.
		     * @returns {string} Returns the escaped string.
		     * @example
		     *
		     * _.escapeRegExp('[lodash](https://lodash.com/)');
		     * // => '\[lodash\]\(https://lodash\.com/\)'
		     */
		    function escapeRegExp(string) {
		      string = toString(string);
		      return (string && reHasRegExpChar.test(string))
		        ? string.replace(reRegExpChar, '\\$&')
		        : string;
		    }

		    /**
		     * Converts `string` to
		     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the kebab cased string.
		     * @example
		     *
		     * _.kebabCase('Foo Bar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('fooBar');
		     * // => 'foo-bar'
		     *
		     * _.kebabCase('__FOO_BAR__');
		     * // => 'foo-bar'
		     */
		    var kebabCase = createCompounder(function(result, word, index) {
		      return result + (index ? '-' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts `string`, as space separated words, to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.lowerCase('--Foo-Bar--');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('fooBar');
		     * // => 'foo bar'
		     *
		     * _.lowerCase('__FOO_BAR__');
		     * // => 'foo bar'
		     */
		    var lowerCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toLowerCase();
		    });

		    /**
		     * Converts the first character of `string` to lower case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.lowerFirst('Fred');
		     * // => 'fred'
		     *
		     * _.lowerFirst('FRED');
		     * // => 'fRED'
		     */
		    var lowerFirst = createCaseFirst('toLowerCase');

		    /**
		     * Pads `string` on the left and right sides if it's shorter than `length`.
		     * Padding characters are truncated if they can't be evenly divided by `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.pad('abc', 8);
		     * // => '  abc   '
		     *
		     * _.pad('abc', 8, '_-');
		     * // => '_-abc_-_'
		     *
		     * _.pad('abc', 3);
		     * // => 'abc'
		     */
		    function pad(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      if (!length || strLength >= length) {
		        return string;
		      }
		      var mid = (length - strLength) / 2;
		      return (
		        createPadding(nativeFloor(mid), chars) +
		        string +
		        createPadding(nativeCeil(mid), chars)
		      );
		    }

		    /**
		     * Pads `string` on the right side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padEnd('abc', 6);
		     * // => 'abc   '
		     *
		     * _.padEnd('abc', 6, '_-');
		     * // => 'abc_-_'
		     *
		     * _.padEnd('abc', 3);
		     * // => 'abc'
		     */
		    function padEnd(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (string + createPadding(length - strLength, chars))
		        : string;
		    }

		    /**
		     * Pads `string` on the left side if it's shorter than `length`. Padding
		     * characters are truncated if they exceed `length`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to pad.
		     * @param {number} [length=0] The padding length.
		     * @param {string} [chars=' '] The string used as padding.
		     * @returns {string} Returns the padded string.
		     * @example
		     *
		     * _.padStart('abc', 6);
		     * // => '   abc'
		     *
		     * _.padStart('abc', 6, '_-');
		     * // => '_-_abc'
		     *
		     * _.padStart('abc', 3);
		     * // => 'abc'
		     */
		    function padStart(string, length, chars) {
		      string = toString(string);
		      length = toInteger(length);

		      var strLength = length ? stringSize(string) : 0;
		      return (length && strLength < length)
		        ? (createPadding(length - strLength, chars) + string)
		        : string;
		    }

		    /**
		     * Converts `string` to an integer of the specified radix. If `radix` is
		     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
		     * hexadecimal, in which case a `radix` of `16` is used.
		     *
		     * **Note:** This method aligns with the
		     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
		     *
		     * @static
		     * @memberOf _
		     * @since 1.1.0
		     * @category String
		     * @param {string} string The string to convert.
		     * @param {number} [radix=10] The radix to interpret `value` by.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {number} Returns the converted integer.
		     * @example
		     *
		     * _.parseInt('08');
		     * // => 8
		     *
		     * _.map(['6', '08', '10'], _.parseInt);
		     * // => [6, 8, 10]
		     */
		    function parseInt(string, radix, guard) {
		      if (guard || radix == null) {
		        radix = 0;
		      } else if (radix) {
		        radix = +radix;
		      }
		      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
		    }

		    /**
		     * Repeats the given string `n` times.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to repeat.
		     * @param {number} [n=1] The number of times to repeat the string.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the repeated string.
		     * @example
		     *
		     * _.repeat('*', 3);
		     * // => '***'
		     *
		     * _.repeat('abc', 2);
		     * // => 'abcabc'
		     *
		     * _.repeat('abc', 0);
		     * // => ''
		     */
		    function repeat(string, n, guard) {
		      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
		        n = 1;
		      } else {
		        n = toInteger(n);
		      }
		      return baseRepeat(toString(string), n);
		    }

		    /**
		     * Replaces matches for `pattern` in `string` with `replacement`.
		     *
		     * **Note:** This method is based on
		     * [`String#replace`](https://mdn.io/String/replace).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to modify.
		     * @param {RegExp|string} pattern The pattern to replace.
		     * @param {Function|string} replacement The match replacement.
		     * @returns {string} Returns the modified string.
		     * @example
		     *
		     * _.replace('Hi Fred', 'Fred', 'Barney');
		     * // => 'Hi Barney'
		     */
		    function replace() {
		      var args = arguments,
		          string = toString(args[0]);

		      return args.length < 3 ? string : string.replace(args[1], args[2]);
		    }

		    /**
		     * Converts `string` to
		     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the snake cased string.
		     * @example
		     *
		     * _.snakeCase('Foo Bar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('fooBar');
		     * // => 'foo_bar'
		     *
		     * _.snakeCase('--FOO-BAR--');
		     * // => 'foo_bar'
		     */
		    var snakeCase = createCompounder(function(result, word, index) {
		      return result + (index ? '_' : '') + word.toLowerCase();
		    });

		    /**
		     * Splits `string` by `separator`.
		     *
		     * **Note:** This method is based on
		     * [`String#split`](https://mdn.io/String/split).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to split.
		     * @param {RegExp|string} separator The separator pattern to split by.
		     * @param {number} [limit] The length to truncate results to.
		     * @returns {Array} Returns the string segments.
		     * @example
		     *
		     * _.split('a-b-c', '-', 2);
		     * // => ['a', 'b']
		     */
		    function split(string, separator, limit) {
		      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
		        separator = limit = undefined$1;
		      }
		      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
		      if (!limit) {
		        return [];
		      }
		      string = toString(string);
		      if (string && (
		            typeof separator == 'string' ||
		            (separator != null && !isRegExp(separator))
		          )) {
		        separator = baseToString(separator);
		        if (!separator && hasUnicode(string)) {
		          return castSlice(stringToArray(string), 0, limit);
		        }
		      }
		      return string.split(separator, limit);
		    }

		    /**
		     * Converts `string` to
		     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
		     *
		     * @static
		     * @memberOf _
		     * @since 3.1.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the start cased string.
		     * @example
		     *
		     * _.startCase('--foo-bar--');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('fooBar');
		     * // => 'Foo Bar'
		     *
		     * _.startCase('__FOO_BAR__');
		     * // => 'FOO BAR'
		     */
		    var startCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + upperFirst(word);
		    });

		    /**
		     * Checks if `string` starts with the given target string.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {string} [target] The string to search for.
		     * @param {number} [position=0] The position to search from.
		     * @returns {boolean} Returns `true` if `string` starts with `target`,
		     *  else `false`.
		     * @example
		     *
		     * _.startsWith('abc', 'a');
		     * // => true
		     *
		     * _.startsWith('abc', 'b');
		     * // => false
		     *
		     * _.startsWith('abc', 'b', 1);
		     * // => true
		     */
		    function startsWith(string, target, position) {
		      string = toString(string);
		      position = position == null
		        ? 0
		        : baseClamp(toInteger(position), 0, string.length);

		      target = baseToString(target);
		      return string.slice(position, position + target.length) == target;
		    }

		    /**
		     * Creates a compiled template function that can interpolate data properties
		     * in "interpolate" delimiters, HTML-escape interpolated data properties in
		     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
		     * properties may be accessed as free variables in the template. If a setting
		     * object is given, it takes precedence over `_.templateSettings` values.
		     *
		     * **Note:** In the development build `_.template` utilizes
		     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
		     * for easier debugging.
		     *
		     * For more information on precompiling templates see
		     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
		     *
		     * For more information on Chrome extension sandboxes see
		     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category String
		     * @param {string} [string=''] The template string.
		     * @param {Object} [options={}] The options object.
		     * @param {RegExp} [options.escape=_.templateSettings.escape]
		     *  The HTML "escape" delimiter.
		     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
		     *  The "evaluate" delimiter.
		     * @param {Object} [options.imports=_.templateSettings.imports]
		     *  An object to import into the template as free variables.
		     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
		     *  The "interpolate" delimiter.
		     * @param {string} [options.sourceURL='lodash.templateSources[n]']
		     *  The sourceURL of the compiled template.
		     * @param {string} [options.variable='obj']
		     *  The data object variable name.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Function} Returns the compiled template function.
		     * @example
		     *
		     * // Use the "interpolate" delimiter to create a compiled template.
		     * var compiled = _.template('hello <%= user %>!');
		     * compiled({ 'user': 'fred' });
		     * // => 'hello fred!'
		     *
		     * // Use the HTML "escape" delimiter to escape data property values.
		     * var compiled = _.template('<b><%- value %></b>');
		     * compiled({ 'value': '<script>' });
		     * // => '<b>&lt;script&gt;</b>'
		     *
		     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
		     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the internal `print` function in "evaluate" delimiters.
		     * var compiled = _.template('<% print("hello " + user); %>!');
		     * compiled({ 'user': 'barney' });
		     * // => 'hello barney!'
		     *
		     * // Use the ES template literal delimiter as an "interpolate" delimiter.
		     * // Disable support by replacing the "interpolate" delimiter.
		     * var compiled = _.template('hello ${ user }!');
		     * compiled({ 'user': 'pebbles' });
		     * // => 'hello pebbles!'
		     *
		     * // Use backslashes to treat delimiters as plain text.
		     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
		     * compiled({ 'value': 'ignored' });
		     * // => '<%- value %>'
		     *
		     * // Use the `imports` option to import `jQuery` as `jq`.
		     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
		     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
		     * compiled({ 'users': ['fred', 'barney'] });
		     * // => '<li>fred</li><li>barney</li>'
		     *
		     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
		     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
		     * compiled(data);
		     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
		     *
		     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
		     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
		     * compiled.source;
		     * // => function(data) {
		     * //   var __t, __p = '';
		     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
		     * //   return __p;
		     * // }
		     *
		     * // Use custom template delimiters.
		     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
		     * var compiled = _.template('hello {{ user }}!');
		     * compiled({ 'user': 'mustache' });
		     * // => 'hello mustache!'
		     *
		     * // Use the `source` property to inline compiled templates for meaningful
		     * // line numbers in error messages and stack traces.
		     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
		     *   var JST = {\
		     *     "main": ' + _.template(mainText).source + '\
		     *   };\
		     * ');
		     */
		    function template(string, options, guard) {
		      // Based on John Resig's `tmpl` implementation
		      // (http://ejohn.org/blog/javascript-micro-templating/)
		      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
		      var settings = lodash.templateSettings;

		      if (guard && isIterateeCall(string, options, guard)) {
		        options = undefined$1;
		      }
		      string = toString(string);
		      options = assignInWith({}, options, settings, customDefaultsAssignIn);

		      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
		          importsKeys = keys(imports),
		          importsValues = baseValues(imports, importsKeys);

		      var isEscaping,
		          isEvaluating,
		          index = 0,
		          interpolate = options.interpolate || reNoMatch,
		          source = "__p += '";

		      // Compile the regexp to match each delimiter.
		      var reDelimiters = RegExp(
		        (options.escape || reNoMatch).source + '|' +
		        interpolate.source + '|' +
		        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
		        (options.evaluate || reNoMatch).source + '|$'
		      , 'g');

		      // Use a sourceURL for easier debugging.
		      // The sourceURL gets injected into the source that's eval-ed, so be careful
		      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
		      // and escape the comment, thus injecting code that gets evaled.
		      var sourceURL = '//# sourceURL=' +
		        (hasOwnProperty.call(options, 'sourceURL')
		          ? (options.sourceURL + '').replace(/\s/g, ' ')
		          : ('lodash.templateSources[' + (++templateCounter) + ']')
		        ) + '\n';

		      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
		        interpolateValue || (interpolateValue = esTemplateValue);

		        // Escape characters that can't be included in string literals.
		        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

		        // Replace delimiters with snippets.
		        if (escapeValue) {
		          isEscaping = true;
		          source += "' +\n__e(" + escapeValue + ") +\n'";
		        }
		        if (evaluateValue) {
		          isEvaluating = true;
		          source += "';\n" + evaluateValue + ";\n__p += '";
		        }
		        if (interpolateValue) {
		          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
		        }
		        index = offset + match.length;

		        // The JS engine embedded in Adobe products needs `match` returned in
		        // order to produce the correct `offset` value.
		        return match;
		      });

		      source += "';\n";

		      // If `variable` is not specified wrap a with-statement around the generated
		      // code to add the data object to the top of the scope chain.
		      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
		      if (!variable) {
		        source = 'with (obj) {\n' + source + '\n}\n';
		      }
		      // Throw an error if a forbidden character was found in `variable`, to prevent
		      // potential command injection attacks.
		      else if (reForbiddenIdentifierChars.test(variable)) {
		        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
		      }

		      // Cleanup code by stripping empty strings.
		      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
		        .replace(reEmptyStringMiddle, '$1')
		        .replace(reEmptyStringTrailing, '$1;');

		      // Frame code as the function body.
		      source = 'function(' + (variable || 'obj') + ') {\n' +
		        (variable
		          ? ''
		          : 'obj || (obj = {});\n'
		        ) +
		        "var __t, __p = ''" +
		        (isEscaping
		           ? ', __e = _.escape'
		           : ''
		        ) +
		        (isEvaluating
		          ? ', __j = Array.prototype.join;\n' +
		            "function print() { __p += __j.call(arguments, '') }\n"
		          : ';\n'
		        ) +
		        source +
		        'return __p\n}';

		      var result = attempt(function() {
		        return Function(importsKeys, sourceURL + 'return ' + source)
		          .apply(undefined$1, importsValues);
		      });

		      // Provide the compiled function's source by its `toString` method or
		      // the `source` property as a convenience for inlining compiled templates.
		      result.source = source;
		      if (isError(result)) {
		        throw result;
		      }
		      return result;
		    }

		    /**
		     * Converts `string`, as a whole, to lower case just like
		     * [String#toLowerCase](https://mdn.io/toLowerCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the lower cased string.
		     * @example
		     *
		     * _.toLower('--Foo-Bar--');
		     * // => '--foo-bar--'
		     *
		     * _.toLower('fooBar');
		     * // => 'foobar'
		     *
		     * _.toLower('__FOO_BAR__');
		     * // => '__foo_bar__'
		     */
		    function toLower(value) {
		      return toString(value).toLowerCase();
		    }

		    /**
		     * Converts `string`, as a whole, to upper case just like
		     * [String#toUpperCase](https://mdn.io/toUpperCase).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.toUpper('--foo-bar--');
		     * // => '--FOO-BAR--'
		     *
		     * _.toUpper('fooBar');
		     * // => 'FOOBAR'
		     *
		     * _.toUpper('__foo_bar__');
		     * // => '__FOO_BAR__'
		     */
		    function toUpper(value) {
		      return toString(value).toUpperCase();
		    }

		    /**
		     * Removes leading and trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trim('  abc  ');
		     * // => 'abc'
		     *
		     * _.trim('-_-abc-_-', '_-');
		     * // => 'abc'
		     *
		     * _.map(['  foo  ', '  bar  '], _.trim);
		     * // => ['foo', 'bar']
		     */
		    function trim(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return baseTrim(string);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          chrSymbols = stringToArray(chars),
		          start = charsStartIndex(strSymbols, chrSymbols),
		          end = charsEndIndex(strSymbols, chrSymbols) + 1;

		      return castSlice(strSymbols, start, end).join('');
		    }

		    /**
		     * Removes trailing whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimEnd('  abc  ');
		     * // => '  abc'
		     *
		     * _.trimEnd('-_-abc-_-', '_-');
		     * // => '-_-abc'
		     */
		    function trimEnd(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.slice(0, trimmedEndIndex(string) + 1);
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

		      return castSlice(strSymbols, 0, end).join('');
		    }

		    /**
		     * Removes leading whitespace or specified characters from `string`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to trim.
		     * @param {string} [chars=whitespace] The characters to trim.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {string} Returns the trimmed string.
		     * @example
		     *
		     * _.trimStart('  abc  ');
		     * // => 'abc  '
		     *
		     * _.trimStart('-_-abc-_-', '_-');
		     * // => 'abc-_-'
		     */
		    function trimStart(string, chars, guard) {
		      string = toString(string);
		      if (string && (guard || chars === undefined$1)) {
		        return string.replace(reTrimStart, '');
		      }
		      if (!string || !(chars = baseToString(chars))) {
		        return string;
		      }
		      var strSymbols = stringToArray(string),
		          start = charsStartIndex(strSymbols, stringToArray(chars));

		      return castSlice(strSymbols, start).join('');
		    }

		    /**
		     * Truncates `string` if it's longer than the given maximum string length.
		     * The last characters of the truncated string are replaced with the omission
		     * string which defaults to "...".
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to truncate.
		     * @param {Object} [options={}] The options object.
		     * @param {number} [options.length=30] The maximum string length.
		     * @param {string} [options.omission='...'] The string to indicate text is omitted.
		     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
		     * @returns {string} Returns the truncated string.
		     * @example
		     *
		     * _.truncate('hi-diddly-ho there, neighborino');
		     * // => 'hi-diddly-ho there, neighbo...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': ' '
		     * });
		     * // => 'hi-diddly-ho there,...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'length': 24,
		     *   'separator': /,? +/
		     * });
		     * // => 'hi-diddly-ho there...'
		     *
		     * _.truncate('hi-diddly-ho there, neighborino', {
		     *   'omission': ' [...]'
		     * });
		     * // => 'hi-diddly-ho there, neig [...]'
		     */
		    function truncate(string, options) {
		      var length = DEFAULT_TRUNC_LENGTH,
		          omission = DEFAULT_TRUNC_OMISSION;

		      if (isObject(options)) {
		        var separator = 'separator' in options ? options.separator : separator;
		        length = 'length' in options ? toInteger(options.length) : length;
		        omission = 'omission' in options ? baseToString(options.omission) : omission;
		      }
		      string = toString(string);

		      var strLength = string.length;
		      if (hasUnicode(string)) {
		        var strSymbols = stringToArray(string);
		        strLength = strSymbols.length;
		      }
		      if (length >= strLength) {
		        return string;
		      }
		      var end = length - stringSize(omission);
		      if (end < 1) {
		        return omission;
		      }
		      var result = strSymbols
		        ? castSlice(strSymbols, 0, end).join('')
		        : string.slice(0, end);

		      if (separator === undefined$1) {
		        return result + omission;
		      }
		      if (strSymbols) {
		        end += (result.length - end);
		      }
		      if (isRegExp(separator)) {
		        if (string.slice(end).search(separator)) {
		          var match,
		              substring = result;

		          if (!separator.global) {
		            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
		          }
		          separator.lastIndex = 0;
		          while ((match = separator.exec(substring))) {
		            var newEnd = match.index;
		          }
		          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
		        }
		      } else if (string.indexOf(baseToString(separator), end) != end) {
		        var index = result.lastIndexOf(separator);
		        if (index > -1) {
		          result = result.slice(0, index);
		        }
		      }
		      return result + omission;
		    }

		    /**
		     * The inverse of `_.escape`; this method converts the HTML entities
		     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
		     * their corresponding characters.
		     *
		     * **Note:** No other HTML entities are unescaped. To unescape additional
		     * HTML entities use a third-party library like [_he_](https://mths.be/he).
		     *
		     * @static
		     * @memberOf _
		     * @since 0.6.0
		     * @category String
		     * @param {string} [string=''] The string to unescape.
		     * @returns {string} Returns the unescaped string.
		     * @example
		     *
		     * _.unescape('fred, barney, &amp; pebbles');
		     * // => 'fred, barney, & pebbles'
		     */
		    function unescape(string) {
		      string = toString(string);
		      return (string && reHasEscapedHtml.test(string))
		        ? string.replace(reEscapedHtml, unescapeHtmlChar)
		        : string;
		    }

		    /**
		     * Converts `string`, as space separated words, to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the upper cased string.
		     * @example
		     *
		     * _.upperCase('--foo-bar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('fooBar');
		     * // => 'FOO BAR'
		     *
		     * _.upperCase('__foo_bar__');
		     * // => 'FOO BAR'
		     */
		    var upperCase = createCompounder(function(result, word, index) {
		      return result + (index ? ' ' : '') + word.toUpperCase();
		    });

		    /**
		     * Converts the first character of `string` to upper case.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category String
		     * @param {string} [string=''] The string to convert.
		     * @returns {string} Returns the converted string.
		     * @example
		     *
		     * _.upperFirst('fred');
		     * // => 'Fred'
		     *
		     * _.upperFirst('FRED');
		     * // => 'FRED'
		     */
		    var upperFirst = createCaseFirst('toUpperCase');

		    /**
		     * Splits `string` into an array of its words.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category String
		     * @param {string} [string=''] The string to inspect.
		     * @param {RegExp|string} [pattern] The pattern to match words.
		     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
		     * @returns {Array} Returns the words of `string`.
		     * @example
		     *
		     * _.words('fred, barney, & pebbles');
		     * // => ['fred', 'barney', 'pebbles']
		     *
		     * _.words('fred, barney, & pebbles', /[^, ]+/g);
		     * // => ['fred', 'barney', '&', 'pebbles']
		     */
		    function words(string, pattern, guard) {
		      string = toString(string);
		      pattern = guard ? undefined$1 : pattern;

		      if (pattern === undefined$1) {
		        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
		      }
		      return string.match(pattern) || [];
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Attempts to invoke `func`, returning either the result or the caught error
		     * object. Any additional arguments are provided to `func` when it's invoked.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Function} func The function to attempt.
		     * @param {...*} [args] The arguments to invoke `func` with.
		     * @returns {*} Returns the `func` result or error object.
		     * @example
		     *
		     * // Avoid throwing errors for invalid selectors.
		     * var elements = _.attempt(function(selector) {
		     *   return document.querySelectorAll(selector);
		     * }, '>_>');
		     *
		     * if (_.isError(elements)) {
		     *   elements = [];
		     * }
		     */
		    var attempt = baseRest(function(func, args) {
		      try {
		        return apply(func, undefined$1, args);
		      } catch (e) {
		        return isError(e) ? e : new Error(e);
		      }
		    });

		    /**
		     * Binds methods of an object to the object itself, overwriting the existing
		     * method.
		     *
		     * **Note:** This method doesn't set the "length" property of bound functions.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Object} object The object to bind and assign the bound methods to.
		     * @param {...(string|string[])} methodNames The object method names to bind.
		     * @returns {Object} Returns `object`.
		     * @example
		     *
		     * var view = {
		     *   'label': 'docs',
		     *   'click': function() {
		     *     console.log('clicked ' + this.label);
		     *   }
		     * };
		     *
		     * _.bindAll(view, ['click']);
		     * jQuery(element).on('click', view.click);
		     * // => Logs 'clicked docs' when clicked.
		     */
		    var bindAll = flatRest(function(object, methodNames) {
		      arrayEach(methodNames, function(key) {
		        key = toKey(key);
		        baseAssignValue(object, key, bind(object[key], object));
		      });
		      return object;
		    });

		    /**
		     * Creates a function that iterates over `pairs` and invokes the corresponding
		     * function of the first predicate to return truthy. The predicate-function
		     * pairs are invoked with the `this` binding and arguments of the created
		     * function.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Array} pairs The predicate-function pairs.
		     * @returns {Function} Returns the new composite function.
		     * @example
		     *
		     * var func = _.cond([
		     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
		     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
		     *   [_.stubTrue,                      _.constant('no match')]
		     * ]);
		     *
		     * func({ 'a': 1, 'b': 2 });
		     * // => 'matches A'
		     *
		     * func({ 'a': 0, 'b': 1 });
		     * // => 'matches B'
		     *
		     * func({ 'a': '1', 'b': '2' });
		     * // => 'no match'
		     */
		    function cond(pairs) {
		      var length = pairs == null ? 0 : pairs.length,
		          toIteratee = getIteratee();

		      pairs = !length ? [] : arrayMap(pairs, function(pair) {
		        if (typeof pair[1] != 'function') {
		          throw new TypeError(FUNC_ERROR_TEXT);
		        }
		        return [toIteratee(pair[0]), pair[1]];
		      });

		      return baseRest(function(args) {
		        var index = -1;
		        while (++index < length) {
		          var pair = pairs[index];
		          if (apply(pair[0], this, args)) {
		            return apply(pair[1], this, args);
		          }
		        }
		      });
		    }

		    /**
		     * Creates a function that invokes the predicate properties of `source` with
		     * the corresponding property values of a given object, returning `true` if
		     * all predicates return truthy, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.conformsTo` with
		     * `source` partially applied.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {Object} source The object of property predicates to conform to.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 2, 'b': 1 },
		     *   { 'a': 1, 'b': 2 }
		     * ];
		     *
		     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
		     * // => [{ 'a': 1, 'b': 2 }]
		     */
		    function conforms(source) {
		      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that returns `value`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {*} value The value to return from the new function.
		     * @returns {Function} Returns the new constant function.
		     * @example
		     *
		     * var objects = _.times(2, _.constant({ 'a': 1 }));
		     *
		     * console.log(objects);
		     * // => [{ 'a': 1 }, { 'a': 1 }]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => true
		     */
		    function constant(value) {
		      return function() {
		        return value;
		      };
		    }

		    /**
		     * Checks `value` to determine whether a default value should be returned in
		     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
		     * or `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.14.0
		     * @category Util
		     * @param {*} value The value to check.
		     * @param {*} defaultValue The default value.
		     * @returns {*} Returns the resolved value.
		     * @example
		     *
		     * _.defaultTo(1, 10);
		     * // => 1
		     *
		     * _.defaultTo(undefined, 10);
		     * // => 10
		     */
		    function defaultTo(value, defaultValue) {
		      return (value == null || value !== value) ? defaultValue : value;
		    }

		    /**
		     * Creates a function that returns the result of invoking the given functions
		     * with the `this` binding of the created function, where each successive
		     * invocation is supplied the return value of the previous.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flowRight
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flow([_.add, square]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flow = createFlow();

		    /**
		     * This method is like `_.flow` except that it creates a function that
		     * invokes the given functions from right to left.
		     *
		     * @static
		     * @since 3.0.0
		     * @memberOf _
		     * @category Util
		     * @param {...(Function|Function[])} [funcs] The functions to invoke.
		     * @returns {Function} Returns the new composite function.
		     * @see _.flow
		     * @example
		     *
		     * function square(n) {
		     *   return n * n;
		     * }
		     *
		     * var addSquare = _.flowRight([square, _.add]);
		     * addSquare(1, 2);
		     * // => 9
		     */
		    var flowRight = createFlow(true);

		    /**
		     * This method returns the first argument it receives.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {*} value Any value.
		     * @returns {*} Returns `value`.
		     * @example
		     *
		     * var object = { 'a': 1 };
		     *
		     * console.log(_.identity(object) === object);
		     * // => true
		     */
		    function identity(value) {
		      return value;
		    }

		    /**
		     * Creates a function that invokes `func` with the arguments of the created
		     * function. If `func` is a property name, the created function returns the
		     * property value for a given element. If `func` is an array or object, the
		     * created function returns `true` for elements that contain the equivalent
		     * source properties, otherwise it returns `false`.
		     *
		     * @static
		     * @since 4.0.0
		     * @memberOf _
		     * @category Util
		     * @param {*} [func=_.identity] The value to convert to a callback.
		     * @returns {Function} Returns the callback.
		     * @example
		     *
		     * var users = [
		     *   { 'user': 'barney', 'age': 36, 'active': true },
		     *   { 'user': 'fred',   'age': 40, 'active': false }
		     * ];
		     *
		     * // The `_.matches` iteratee shorthand.
		     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
		     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
		     *
		     * // The `_.matchesProperty` iteratee shorthand.
		     * _.filter(users, _.iteratee(['user', 'fred']));
		     * // => [{ 'user': 'fred', 'age': 40 }]
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.map(users, _.iteratee('user'));
		     * // => ['barney', 'fred']
		     *
		     * // Create custom iteratee shorthands.
		     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
		     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
		     *     return func.test(string);
		     *   };
		     * });
		     *
		     * _.filter(['abc', 'def'], /ef/);
		     * // => ['def']
		     */
		    function iteratee(func) {
		      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between a given
		     * object and `source`, returning `true` if the given object has equivalent
		     * property values, else `false`.
		     *
		     * **Note:** The created function is equivalent to `_.isMatch` with `source`
		     * partially applied.
		     *
		     * Partial comparisons will match empty array and empty object `source`
		     * values against any array or object value, respectively. See `_.isEqual`
		     * for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} source The object of property values to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
		     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matches(source) {
		      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that performs a partial deep comparison between the
		     * value at `path` of a given object to `srcValue`, returning `true` if the
		     * object value is equivalent, else `false`.
		     *
		     * **Note:** Partial comparisons will match empty array and empty object
		     * `srcValue` values against any array or object value, respectively. See
		     * `_.isEqual` for a list of supported value comparisons.
		     *
		     * **Note:** Multiple values can be checked by combining several matchers
		     * using `_.overSome`
		     *
		     * @static
		     * @memberOf _
		     * @since 3.2.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @param {*} srcValue The value to match.
		     * @returns {Function} Returns the new spec function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': 1, 'b': 2, 'c': 3 },
		     *   { 'a': 4, 'b': 5, 'c': 6 }
		     * ];
		     *
		     * _.find(objects, _.matchesProperty('a', 4));
		     * // => { 'a': 4, 'b': 5, 'c': 6 }
		     *
		     * // Checking for several possible values
		     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
		     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
		     */
		    function matchesProperty(path, srcValue) {
		      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
		    }

		    /**
		     * Creates a function that invokes the method at `path` of a given object.
		     * Any additional arguments are provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Array|string} path The path of the method to invoke.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': _.constant(2) } },
		     *   { 'a': { 'b': _.constant(1) } }
		     * ];
		     *
		     * _.map(objects, _.method('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(objects, _.method(['a', 'b']));
		     * // => [2, 1]
		     */
		    var method = baseRest(function(path, args) {
		      return function(object) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * The opposite of `_.method`; this method creates a function that invokes
		     * the method at a given path of `object`. Any additional arguments are
		     * provided to the invoked method.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.7.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @param {...*} [args] The arguments to invoke the method with.
		     * @returns {Function} Returns the new invoker function.
		     * @example
		     *
		     * var array = _.times(3, _.constant),
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
		     * // => [2, 0]
		     */
		    var methodOf = baseRest(function(object, args) {
		      return function(path) {
		        return baseInvoke(object, path, args);
		      };
		    });

		    /**
		     * Adds all own enumerable string keyed function properties of a source
		     * object to the destination object. If `object` is a function, then methods
		     * are added to its prototype as well.
		     *
		     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
		     * avoid conflicts caused by modifying the original.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {Function|Object} [object=lodash] The destination object.
		     * @param {Object} source The object of functions to add.
		     * @param {Object} [options={}] The options object.
		     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
		     * @returns {Function|Object} Returns `object`.
		     * @example
		     *
		     * function vowels(string) {
		     *   return _.filter(string, function(v) {
		     *     return /[aeiou]/i.test(v);
		     *   });
		     * }
		     *
		     * _.mixin({ 'vowels': vowels });
		     * _.vowels('fred');
		     * // => ['e']
		     *
		     * _('fred').vowels().value();
		     * // => ['e']
		     *
		     * _.mixin({ 'vowels': vowels }, { 'chain': false });
		     * _('fred').vowels();
		     * // => ['e']
		     */
		    function mixin(object, source, options) {
		      var props = keys(source),
		          methodNames = baseFunctions(source, props);

		      if (options == null &&
		          !(isObject(source) && (methodNames.length || !props.length))) {
		        options = source;
		        source = object;
		        object = this;
		        methodNames = baseFunctions(source, keys(source));
		      }
		      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
		          isFunc = isFunction(object);

		      arrayEach(methodNames, function(methodName) {
		        var func = source[methodName];
		        object[methodName] = func;
		        if (isFunc) {
		          object.prototype[methodName] = function() {
		            var chainAll = this.__chain__;
		            if (chain || chainAll) {
		              var result = object(this.__wrapped__),
		                  actions = result.__actions__ = copyArray(this.__actions__);

		              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
		              result.__chain__ = chainAll;
		              return result;
		            }
		            return func.apply(object, arrayPush([this.value()], arguments));
		          };
		        }
		      });

		      return object;
		    }

		    /**
		     * Reverts the `_` variable to its previous value and returns a reference to
		     * the `lodash` function.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @returns {Function} Returns the `lodash` function.
		     * @example
		     *
		     * var lodash = _.noConflict();
		     */
		    function noConflict() {
		      if (root._ === this) {
		        root._ = oldDash;
		      }
		      return this;
		    }

		    /**
		     * This method returns `undefined`.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.3.0
		     * @category Util
		     * @example
		     *
		     * _.times(2, _.noop);
		     * // => [undefined, undefined]
		     */
		    function noop() {
		      // No operation performed.
		    }

		    /**
		     * Creates a function that gets the argument at index `n`. If `n` is negative,
		     * the nth argument from the end is returned.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [n=0] The index of the argument to return.
		     * @returns {Function} Returns the new pass-thru function.
		     * @example
		     *
		     * var func = _.nthArg(1);
		     * func('a', 'b', 'c', 'd');
		     * // => 'b'
		     *
		     * var func = _.nthArg(-2);
		     * func('a', 'b', 'c', 'd');
		     * // => 'c'
		     */
		    function nthArg(n) {
		      n = toInteger(n);
		      return baseRest(function(args) {
		        return baseNth(args, n);
		      });
		    }

		    /**
		     * Creates a function that invokes `iteratees` with the arguments it receives
		     * and returns their results.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [iteratees=[_.identity]]
		     *  The iteratees to invoke.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.over([Math.max, Math.min]);
		     *
		     * func(1, 2, 3, 4);
		     * // => [4, 1]
		     */
		    var over = createOver(arrayMap);

		    /**
		     * Creates a function that checks if **all** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overEvery([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => false
		     *
		     * func(NaN);
		     * // => false
		     */
		    var overEvery = createOver(arrayEvery);

		    /**
		     * Creates a function that checks if **any** of the `predicates` return
		     * truthy when invoked with the arguments it receives.
		     *
		     * Following shorthands are possible for providing predicates.
		     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
		     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {...(Function|Function[])} [predicates=[_.identity]]
		     *  The predicates to check.
		     * @returns {Function} Returns the new function.
		     * @example
		     *
		     * var func = _.overSome([Boolean, isFinite]);
		     *
		     * func('1');
		     * // => true
		     *
		     * func(null);
		     * // => true
		     *
		     * func(NaN);
		     * // => false
		     *
		     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
		     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
		     */
		    var overSome = createOver(arraySome);

		    /**
		     * Creates a function that returns the value at `path` of a given object.
		     *
		     * @static
		     * @memberOf _
		     * @since 2.4.0
		     * @category Util
		     * @param {Array|string} path The path of the property to get.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var objects = [
		     *   { 'a': { 'b': 2 } },
		     *   { 'a': { 'b': 1 } }
		     * ];
		     *
		     * _.map(objects, _.property('a.b'));
		     * // => [2, 1]
		     *
		     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
		     * // => [1, 2]
		     */
		    function property(path) {
		      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
		    }

		    /**
		     * The opposite of `_.property`; this method creates a function that returns
		     * the value at a given path of `object`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.0.0
		     * @category Util
		     * @param {Object} object The object to query.
		     * @returns {Function} Returns the new accessor function.
		     * @example
		     *
		     * var array = [0, 1, 2],
		     *     object = { 'a': array, 'b': array, 'c': array };
		     *
		     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
		     * // => [2, 0]
		     *
		     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
		     * // => [2, 0]
		     */
		    function propertyOf(object) {
		      return function(path) {
		        return object == null ? undefined$1 : baseGet(object, path);
		      };
		    }

		    /**
		     * Creates an array of numbers (positive and/or negative) progressing from
		     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
		     * `start` is specified without an `end` or `step`. If `end` is not specified,
		     * it's set to `start` with `start` then set to `0`.
		     *
		     * **Note:** JavaScript follows the IEEE-754 standard for resolving
		     * floating-point values which can produce unexpected results.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.rangeRight
		     * @example
		     *
		     * _.range(4);
		     * // => [0, 1, 2, 3]
		     *
		     * _.range(-4);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 5);
		     * // => [1, 2, 3, 4]
		     *
		     * _.range(0, 20, 5);
		     * // => [0, 5, 10, 15]
		     *
		     * _.range(0, -4, -1);
		     * // => [0, -1, -2, -3]
		     *
		     * _.range(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.range(0);
		     * // => []
		     */
		    var range = createRange();

		    /**
		     * This method is like `_.range` except that it populates values in
		     * descending order.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {number} [start=0] The start of the range.
		     * @param {number} end The end of the range.
		     * @param {number} [step=1] The value to increment or decrement by.
		     * @returns {Array} Returns the range of numbers.
		     * @see _.inRange, _.range
		     * @example
		     *
		     * _.rangeRight(4);
		     * // => [3, 2, 1, 0]
		     *
		     * _.rangeRight(-4);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 5);
		     * // => [4, 3, 2, 1]
		     *
		     * _.rangeRight(0, 20, 5);
		     * // => [15, 10, 5, 0]
		     *
		     * _.rangeRight(0, -4, -1);
		     * // => [-3, -2, -1, 0]
		     *
		     * _.rangeRight(1, 4, 0);
		     * // => [1, 1, 1]
		     *
		     * _.rangeRight(0);
		     * // => []
		     */
		    var rangeRight = createRange(true);

		    /**
		     * This method returns a new empty array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Array} Returns the new empty array.
		     * @example
		     *
		     * var arrays = _.times(2, _.stubArray);
		     *
		     * console.log(arrays);
		     * // => [[], []]
		     *
		     * console.log(arrays[0] === arrays[1]);
		     * // => false
		     */
		    function stubArray() {
		      return [];
		    }

		    /**
		     * This method returns `false`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `false`.
		     * @example
		     *
		     * _.times(2, _.stubFalse);
		     * // => [false, false]
		     */
		    function stubFalse() {
		      return false;
		    }

		    /**
		     * This method returns a new empty object.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {Object} Returns the new empty object.
		     * @example
		     *
		     * var objects = _.times(2, _.stubObject);
		     *
		     * console.log(objects);
		     * // => [{}, {}]
		     *
		     * console.log(objects[0] === objects[1]);
		     * // => false
		     */
		    function stubObject() {
		      return {};
		    }

		    /**
		     * This method returns an empty string.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {string} Returns the empty string.
		     * @example
		     *
		     * _.times(2, _.stubString);
		     * // => ['', '']
		     */
		    function stubString() {
		      return '';
		    }

		    /**
		     * This method returns `true`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.13.0
		     * @category Util
		     * @returns {boolean} Returns `true`.
		     * @example
		     *
		     * _.times(2, _.stubTrue);
		     * // => [true, true]
		     */
		    function stubTrue() {
		      return true;
		    }

		    /**
		     * Invokes the iteratee `n` times, returning an array of the results of
		     * each invocation. The iteratee is invoked with one argument; (index).
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {number} n The number of times to invoke `iteratee`.
		     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
		     * @returns {Array} Returns the array of results.
		     * @example
		     *
		     * _.times(3, String);
		     * // => ['0', '1', '2']
		     *
		     *  _.times(4, _.constant(0));
		     * // => [0, 0, 0, 0]
		     */
		    function times(n, iteratee) {
		      n = toInteger(n);
		      if (n < 1 || n > MAX_SAFE_INTEGER) {
		        return [];
		      }
		      var index = MAX_ARRAY_LENGTH,
		          length = nativeMin(n, MAX_ARRAY_LENGTH);

		      iteratee = getIteratee(iteratee);
		      n -= MAX_ARRAY_LENGTH;

		      var result = baseTimes(length, iteratee);
		      while (++index < n) {
		        iteratee(index);
		      }
		      return result;
		    }

		    /**
		     * Converts `value` to a property path array.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Util
		     * @param {*} value The value to convert.
		     * @returns {Array} Returns the new property path array.
		     * @example
		     *
		     * _.toPath('a.b.c');
		     * // => ['a', 'b', 'c']
		     *
		     * _.toPath('a[0].b.c');
		     * // => ['a', '0', 'b', 'c']
		     */
		    function toPath(value) {
		      if (isArray(value)) {
		        return arrayMap(value, toKey);
		      }
		      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
		    }

		    /**
		     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Util
		     * @param {string} [prefix=''] The value to prefix the ID with.
		     * @returns {string} Returns the unique ID.
		     * @example
		     *
		     * _.uniqueId('contact_');
		     * // => 'contact_104'
		     *
		     * _.uniqueId();
		     * // => '105'
		     */
		    function uniqueId(prefix) {
		      var id = ++idCounter;
		      return toString(prefix) + id;
		    }

		    /*------------------------------------------------------------------------*/

		    /**
		     * Adds two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {number} augend The first number in an addition.
		     * @param {number} addend The second number in an addition.
		     * @returns {number} Returns the total.
		     * @example
		     *
		     * _.add(6, 4);
		     * // => 10
		     */
		    var add = createMathOperation(function(augend, addend) {
		      return augend + addend;
		    }, 0);

		    /**
		     * Computes `number` rounded up to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round up.
		     * @param {number} [precision=0] The precision to round up to.
		     * @returns {number} Returns the rounded up number.
		     * @example
		     *
		     * _.ceil(4.006);
		     * // => 5
		     *
		     * _.ceil(6.004, 2);
		     * // => 6.01
		     *
		     * _.ceil(6040, -2);
		     * // => 6100
		     */
		    var ceil = createRound('ceil');

		    /**
		     * Divide two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} dividend The first number in a division.
		     * @param {number} divisor The second number in a division.
		     * @returns {number} Returns the quotient.
		     * @example
		     *
		     * _.divide(6, 4);
		     * // => 1.5
		     */
		    var divide = createMathOperation(function(dividend, divisor) {
		      return dividend / divisor;
		    }, 1);

		    /**
		     * Computes `number` rounded down to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round down.
		     * @param {number} [precision=0] The precision to round down to.
		     * @returns {number} Returns the rounded down number.
		     * @example
		     *
		     * _.floor(4.006);
		     * // => 4
		     *
		     * _.floor(0.046, 2);
		     * // => 0.04
		     *
		     * _.floor(4060, -2);
		     * // => 4000
		     */
		    var floor = createRound('floor');

		    /**
		     * Computes the maximum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * _.max([4, 2, 8, 6]);
		     * // => 8
		     *
		     * _.max([]);
		     * // => undefined
		     */
		    function max(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseGt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.max` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the maximum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.maxBy(objects, function(o) { return o.n; });
		     * // => { 'n': 2 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.maxBy(objects, 'n');
		     * // => { 'n': 2 }
		     */
		    function maxBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
		        : undefined$1;
		    }

		    /**
		     * Computes the mean of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * _.mean([4, 2, 8, 6]);
		     * // => 5
		     */
		    function mean(array) {
		      return baseMean(array, identity);
		    }

		    /**
		     * This method is like `_.mean` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be averaged.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the mean.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.meanBy(objects, function(o) { return o.n; });
		     * // => 5
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.meanBy(objects, 'n');
		     * // => 5
		     */
		    function meanBy(array, iteratee) {
		      return baseMean(array, getIteratee(iteratee, 2));
		    }

		    /**
		     * Computes the minimum value of `array`. If `array` is empty or falsey,
		     * `undefined` is returned.
		     *
		     * @static
		     * @since 0.1.0
		     * @memberOf _
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * _.min([4, 2, 8, 6]);
		     * // => 2
		     *
		     * _.min([]);
		     * // => undefined
		     */
		    function min(array) {
		      return (array && array.length)
		        ? baseExtremum(array, identity, baseLt)
		        : undefined$1;
		    }

		    /**
		     * This method is like `_.min` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the criterion by which
		     * the value is ranked. The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {*} Returns the minimum value.
		     * @example
		     *
		     * var objects = [{ 'n': 1 }, { 'n': 2 }];
		     *
		     * _.minBy(objects, function(o) { return o.n; });
		     * // => { 'n': 1 }
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.minBy(objects, 'n');
		     * // => { 'n': 1 }
		     */
		    function minBy(array, iteratee) {
		      return (array && array.length)
		        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
		        : undefined$1;
		    }

		    /**
		     * Multiply two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.7.0
		     * @category Math
		     * @param {number} multiplier The first number in a multiplication.
		     * @param {number} multiplicand The second number in a multiplication.
		     * @returns {number} Returns the product.
		     * @example
		     *
		     * _.multiply(6, 4);
		     * // => 24
		     */
		    var multiply = createMathOperation(function(multiplier, multiplicand) {
		      return multiplier * multiplicand;
		    }, 1);

		    /**
		     * Computes `number` rounded to `precision`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.10.0
		     * @category Math
		     * @param {number} number The number to round.
		     * @param {number} [precision=0] The precision to round to.
		     * @returns {number} Returns the rounded number.
		     * @example
		     *
		     * _.round(4.006);
		     * // => 4
		     *
		     * _.round(4.006, 2);
		     * // => 4.01
		     *
		     * _.round(4060, -2);
		     * // => 4100
		     */
		    var round = createRound('round');

		    /**
		     * Subtract two numbers.
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {number} minuend The first number in a subtraction.
		     * @param {number} subtrahend The second number in a subtraction.
		     * @returns {number} Returns the difference.
		     * @example
		     *
		     * _.subtract(6, 4);
		     * // => 2
		     */
		    var subtract = createMathOperation(function(minuend, subtrahend) {
		      return minuend - subtrahend;
		    }, 0);

		    /**
		     * Computes the sum of the values in `array`.
		     *
		     * @static
		     * @memberOf _
		     * @since 3.4.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * _.sum([4, 2, 8, 6]);
		     * // => 20
		     */
		    function sum(array) {
		      return (array && array.length)
		        ? baseSum(array, identity)
		        : 0;
		    }

		    /**
		     * This method is like `_.sum` except that it accepts `iteratee` which is
		     * invoked for each element in `array` to generate the value to be summed.
		     * The iteratee is invoked with one argument: (value).
		     *
		     * @static
		     * @memberOf _
		     * @since 4.0.0
		     * @category Math
		     * @param {Array} array The array to iterate over.
		     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
		     * @returns {number} Returns the sum.
		     * @example
		     *
		     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
		     *
		     * _.sumBy(objects, function(o) { return o.n; });
		     * // => 20
		     *
		     * // The `_.property` iteratee shorthand.
		     * _.sumBy(objects, 'n');
		     * // => 20
		     */
		    function sumBy(array, iteratee) {
		      return (array && array.length)
		        ? baseSum(array, getIteratee(iteratee, 2))
		        : 0;
		    }

		    /*------------------------------------------------------------------------*/

		    // Add methods that return wrapped values in chain sequences.
		    lodash.after = after;
		    lodash.ary = ary;
		    lodash.assign = assign;
		    lodash.assignIn = assignIn;
		    lodash.assignInWith = assignInWith;
		    lodash.assignWith = assignWith;
		    lodash.at = at;
		    lodash.before = before;
		    lodash.bind = bind;
		    lodash.bindAll = bindAll;
		    lodash.bindKey = bindKey;
		    lodash.castArray = castArray;
		    lodash.chain = chain;
		    lodash.chunk = chunk;
		    lodash.compact = compact;
		    lodash.concat = concat;
		    lodash.cond = cond;
		    lodash.conforms = conforms;
		    lodash.constant = constant;
		    lodash.countBy = countBy;
		    lodash.create = create;
		    lodash.curry = curry;
		    lodash.curryRight = curryRight;
		    lodash.debounce = debounce;
		    lodash.defaults = defaults;
		    lodash.defaultsDeep = defaultsDeep;
		    lodash.defer = defer;
		    lodash.delay = delay;
		    lodash.difference = difference;
		    lodash.differenceBy = differenceBy;
		    lodash.differenceWith = differenceWith;
		    lodash.drop = drop;
		    lodash.dropRight = dropRight;
		    lodash.dropRightWhile = dropRightWhile;
		    lodash.dropWhile = dropWhile;
		    lodash.fill = fill;
		    lodash.filter = filter;
		    lodash.flatMap = flatMap;
		    lodash.flatMapDeep = flatMapDeep;
		    lodash.flatMapDepth = flatMapDepth;
		    lodash.flatten = flatten;
		    lodash.flattenDeep = flattenDeep;
		    lodash.flattenDepth = flattenDepth;
		    lodash.flip = flip;
		    lodash.flow = flow;
		    lodash.flowRight = flowRight;
		    lodash.fromPairs = fromPairs;
		    lodash.functions = functions;
		    lodash.functionsIn = functionsIn;
		    lodash.groupBy = groupBy;
		    lodash.initial = initial;
		    lodash.intersection = intersection;
		    lodash.intersectionBy = intersectionBy;
		    lodash.intersectionWith = intersectionWith;
		    lodash.invert = invert;
		    lodash.invertBy = invertBy;
		    lodash.invokeMap = invokeMap;
		    lodash.iteratee = iteratee;
		    lodash.keyBy = keyBy;
		    lodash.keys = keys;
		    lodash.keysIn = keysIn;
		    lodash.map = map;
		    lodash.mapKeys = mapKeys;
		    lodash.mapValues = mapValues;
		    lodash.matches = matches;
		    lodash.matchesProperty = matchesProperty;
		    lodash.memoize = memoize;
		    lodash.merge = merge;
		    lodash.mergeWith = mergeWith;
		    lodash.method = method;
		    lodash.methodOf = methodOf;
		    lodash.mixin = mixin;
		    lodash.negate = negate;
		    lodash.nthArg = nthArg;
		    lodash.omit = omit;
		    lodash.omitBy = omitBy;
		    lodash.once = once;
		    lodash.orderBy = orderBy;
		    lodash.over = over;
		    lodash.overArgs = overArgs;
		    lodash.overEvery = overEvery;
		    lodash.overSome = overSome;
		    lodash.partial = partial;
		    lodash.partialRight = partialRight;
		    lodash.partition = partition;
		    lodash.pick = pick;
		    lodash.pickBy = pickBy;
		    lodash.property = property;
		    lodash.propertyOf = propertyOf;
		    lodash.pull = pull;
		    lodash.pullAll = pullAll;
		    lodash.pullAllBy = pullAllBy;
		    lodash.pullAllWith = pullAllWith;
		    lodash.pullAt = pullAt;
		    lodash.range = range;
		    lodash.rangeRight = rangeRight;
		    lodash.rearg = rearg;
		    lodash.reject = reject;
		    lodash.remove = remove;
		    lodash.rest = rest;
		    lodash.reverse = reverse;
		    lodash.sampleSize = sampleSize;
		    lodash.set = set;
		    lodash.setWith = setWith;
		    lodash.shuffle = shuffle;
		    lodash.slice = slice;
		    lodash.sortBy = sortBy;
		    lodash.sortedUniq = sortedUniq;
		    lodash.sortedUniqBy = sortedUniqBy;
		    lodash.split = split;
		    lodash.spread = spread;
		    lodash.tail = tail;
		    lodash.take = take;
		    lodash.takeRight = takeRight;
		    lodash.takeRightWhile = takeRightWhile;
		    lodash.takeWhile = takeWhile;
		    lodash.tap = tap;
		    lodash.throttle = throttle;
		    lodash.thru = thru;
		    lodash.toArray = toArray;
		    lodash.toPairs = toPairs;
		    lodash.toPairsIn = toPairsIn;
		    lodash.toPath = toPath;
		    lodash.toPlainObject = toPlainObject;
		    lodash.transform = transform;
		    lodash.unary = unary;
		    lodash.union = union;
		    lodash.unionBy = unionBy;
		    lodash.unionWith = unionWith;
		    lodash.uniq = uniq;
		    lodash.uniqBy = uniqBy;
		    lodash.uniqWith = uniqWith;
		    lodash.unset = unset;
		    lodash.unzip = unzip;
		    lodash.unzipWith = unzipWith;
		    lodash.update = update;
		    lodash.updateWith = updateWith;
		    lodash.values = values;
		    lodash.valuesIn = valuesIn;
		    lodash.without = without;
		    lodash.words = words;
		    lodash.wrap = wrap;
		    lodash.xor = xor;
		    lodash.xorBy = xorBy;
		    lodash.xorWith = xorWith;
		    lodash.zip = zip;
		    lodash.zipObject = zipObject;
		    lodash.zipObjectDeep = zipObjectDeep;
		    lodash.zipWith = zipWith;

		    // Add aliases.
		    lodash.entries = toPairs;
		    lodash.entriesIn = toPairsIn;
		    lodash.extend = assignIn;
		    lodash.extendWith = assignInWith;

		    // Add methods to `lodash.prototype`.
		    mixin(lodash, lodash);

		    /*------------------------------------------------------------------------*/

		    // Add methods that return unwrapped values in chain sequences.
		    lodash.add = add;
		    lodash.attempt = attempt;
		    lodash.camelCase = camelCase;
		    lodash.capitalize = capitalize;
		    lodash.ceil = ceil;
		    lodash.clamp = clamp;
		    lodash.clone = clone;
		    lodash.cloneDeep = cloneDeep;
		    lodash.cloneDeepWith = cloneDeepWith;
		    lodash.cloneWith = cloneWith;
		    lodash.conformsTo = conformsTo;
		    lodash.deburr = deburr;
		    lodash.defaultTo = defaultTo;
		    lodash.divide = divide;
		    lodash.endsWith = endsWith;
		    lodash.eq = eq;
		    lodash.escape = escape;
		    lodash.escapeRegExp = escapeRegExp;
		    lodash.every = every;
		    lodash.find = find;
		    lodash.findIndex = findIndex;
		    lodash.findKey = findKey;
		    lodash.findLast = findLast;
		    lodash.findLastIndex = findLastIndex;
		    lodash.findLastKey = findLastKey;
		    lodash.floor = floor;
		    lodash.forEach = forEach;
		    lodash.forEachRight = forEachRight;
		    lodash.forIn = forIn;
		    lodash.forInRight = forInRight;
		    lodash.forOwn = forOwn;
		    lodash.forOwnRight = forOwnRight;
		    lodash.get = get;
		    lodash.gt = gt;
		    lodash.gte = gte;
		    lodash.has = has;
		    lodash.hasIn = hasIn;
		    lodash.head = head;
		    lodash.identity = identity;
		    lodash.includes = includes;
		    lodash.indexOf = indexOf;
		    lodash.inRange = inRange;
		    lodash.invoke = invoke;
		    lodash.isArguments = isArguments;
		    lodash.isArray = isArray;
		    lodash.isArrayBuffer = isArrayBuffer;
		    lodash.isArrayLike = isArrayLike;
		    lodash.isArrayLikeObject = isArrayLikeObject;
		    lodash.isBoolean = isBoolean;
		    lodash.isBuffer = isBuffer;
		    lodash.isDate = isDate;
		    lodash.isElement = isElement;
		    lodash.isEmpty = isEmpty;
		    lodash.isEqual = isEqual;
		    lodash.isEqualWith = isEqualWith;
		    lodash.isError = isError;
		    lodash.isFinite = isFinite;
		    lodash.isFunction = isFunction;
		    lodash.isInteger = isInteger;
		    lodash.isLength = isLength;
		    lodash.isMap = isMap;
		    lodash.isMatch = isMatch;
		    lodash.isMatchWith = isMatchWith;
		    lodash.isNaN = isNaN;
		    lodash.isNative = isNative;
		    lodash.isNil = isNil;
		    lodash.isNull = isNull;
		    lodash.isNumber = isNumber;
		    lodash.isObject = isObject;
		    lodash.isObjectLike = isObjectLike;
		    lodash.isPlainObject = isPlainObject;
		    lodash.isRegExp = isRegExp;
		    lodash.isSafeInteger = isSafeInteger;
		    lodash.isSet = isSet;
		    lodash.isString = isString;
		    lodash.isSymbol = isSymbol;
		    lodash.isTypedArray = isTypedArray;
		    lodash.isUndefined = isUndefined;
		    lodash.isWeakMap = isWeakMap;
		    lodash.isWeakSet = isWeakSet;
		    lodash.join = join;
		    lodash.kebabCase = kebabCase;
		    lodash.last = last;
		    lodash.lastIndexOf = lastIndexOf;
		    lodash.lowerCase = lowerCase;
		    lodash.lowerFirst = lowerFirst;
		    lodash.lt = lt;
		    lodash.lte = lte;
		    lodash.max = max;
		    lodash.maxBy = maxBy;
		    lodash.mean = mean;
		    lodash.meanBy = meanBy;
		    lodash.min = min;
		    lodash.minBy = minBy;
		    lodash.stubArray = stubArray;
		    lodash.stubFalse = stubFalse;
		    lodash.stubObject = stubObject;
		    lodash.stubString = stubString;
		    lodash.stubTrue = stubTrue;
		    lodash.multiply = multiply;
		    lodash.nth = nth;
		    lodash.noConflict = noConflict;
		    lodash.noop = noop;
		    lodash.now = now;
		    lodash.pad = pad;
		    lodash.padEnd = padEnd;
		    lodash.padStart = padStart;
		    lodash.parseInt = parseInt;
		    lodash.random = random;
		    lodash.reduce = reduce;
		    lodash.reduceRight = reduceRight;
		    lodash.repeat = repeat;
		    lodash.replace = replace;
		    lodash.result = result;
		    lodash.round = round;
		    lodash.runInContext = runInContext;
		    lodash.sample = sample;
		    lodash.size = size;
		    lodash.snakeCase = snakeCase;
		    lodash.some = some;
		    lodash.sortedIndex = sortedIndex;
		    lodash.sortedIndexBy = sortedIndexBy;
		    lodash.sortedIndexOf = sortedIndexOf;
		    lodash.sortedLastIndex = sortedLastIndex;
		    lodash.sortedLastIndexBy = sortedLastIndexBy;
		    lodash.sortedLastIndexOf = sortedLastIndexOf;
		    lodash.startCase = startCase;
		    lodash.startsWith = startsWith;
		    lodash.subtract = subtract;
		    lodash.sum = sum;
		    lodash.sumBy = sumBy;
		    lodash.template = template;
		    lodash.times = times;
		    lodash.toFinite = toFinite;
		    lodash.toInteger = toInteger;
		    lodash.toLength = toLength;
		    lodash.toLower = toLower;
		    lodash.toNumber = toNumber;
		    lodash.toSafeInteger = toSafeInteger;
		    lodash.toString = toString;
		    lodash.toUpper = toUpper;
		    lodash.trim = trim;
		    lodash.trimEnd = trimEnd;
		    lodash.trimStart = trimStart;
		    lodash.truncate = truncate;
		    lodash.unescape = unescape;
		    lodash.uniqueId = uniqueId;
		    lodash.upperCase = upperCase;
		    lodash.upperFirst = upperFirst;

		    // Add aliases.
		    lodash.each = forEach;
		    lodash.eachRight = forEachRight;
		    lodash.first = head;

		    mixin(lodash, (function() {
		      var source = {};
		      baseForOwn(lodash, function(func, methodName) {
		        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
		          source[methodName] = func;
		        }
		      });
		      return source;
		    }()), { 'chain': false });

		    /*------------------------------------------------------------------------*/

		    /**
		     * The semantic version number.
		     *
		     * @static
		     * @memberOf _
		     * @type {string}
		     */
		    lodash.VERSION = VERSION;

		    // Assign default placeholders.
		    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
		      lodash[methodName].placeholder = lodash;
		    });

		    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
		    arrayEach(['drop', 'take'], function(methodName, index) {
		      LazyWrapper.prototype[methodName] = function(n) {
		        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

		        var result = (this.__filtered__ && !index)
		          ? new LazyWrapper(this)
		          : this.clone();

		        if (result.__filtered__) {
		          result.__takeCount__ = nativeMin(n, result.__takeCount__);
		        } else {
		          result.__views__.push({
		            'size': nativeMin(n, MAX_ARRAY_LENGTH),
		            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
		          });
		        }
		        return result;
		      };

		      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
		        return this.reverse()[methodName](n).reverse();
		      };
		    });

		    // Add `LazyWrapper` methods that accept an `iteratee` value.
		    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
		      var type = index + 1,
		          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

		      LazyWrapper.prototype[methodName] = function(iteratee) {
		        var result = this.clone();
		        result.__iteratees__.push({
		          'iteratee': getIteratee(iteratee, 3),
		          'type': type
		        });
		        result.__filtered__ = result.__filtered__ || isFilter;
		        return result;
		      };
		    });

		    // Add `LazyWrapper` methods for `_.head` and `_.last`.
		    arrayEach(['head', 'last'], function(methodName, index) {
		      var takeName = 'take' + (index ? 'Right' : '');

		      LazyWrapper.prototype[methodName] = function() {
		        return this[takeName](1).value()[0];
		      };
		    });

		    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
		    arrayEach(['initial', 'tail'], function(methodName, index) {
		      var dropName = 'drop' + (index ? '' : 'Right');

		      LazyWrapper.prototype[methodName] = function() {
		        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
		      };
		    });

		    LazyWrapper.prototype.compact = function() {
		      return this.filter(identity);
		    };

		    LazyWrapper.prototype.find = function(predicate) {
		      return this.filter(predicate).head();
		    };

		    LazyWrapper.prototype.findLast = function(predicate) {
		      return this.reverse().find(predicate);
		    };

		    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
		      if (typeof path == 'function') {
		        return new LazyWrapper(this);
		      }
		      return this.map(function(value) {
		        return baseInvoke(value, path, args);
		      });
		    });

		    LazyWrapper.prototype.reject = function(predicate) {
		      return this.filter(negate(getIteratee(predicate)));
		    };

		    LazyWrapper.prototype.slice = function(start, end) {
		      start = toInteger(start);

		      var result = this;
		      if (result.__filtered__ && (start > 0 || end < 0)) {
		        return new LazyWrapper(result);
		      }
		      if (start < 0) {
		        result = result.takeRight(-start);
		      } else if (start) {
		        result = result.drop(start);
		      }
		      if (end !== undefined$1) {
		        end = toInteger(end);
		        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
		      }
		      return result;
		    };

		    LazyWrapper.prototype.takeRightWhile = function(predicate) {
		      return this.reverse().takeWhile(predicate).reverse();
		    };

		    LazyWrapper.prototype.toArray = function() {
		      return this.take(MAX_ARRAY_LENGTH);
		    };

		    // Add `LazyWrapper` methods to `lodash.prototype`.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
		          isTaker = /^(?:head|last)$/.test(methodName),
		          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
		          retUnwrapped = isTaker || /^find/.test(methodName);

		      if (!lodashFunc) {
		        return;
		      }
		      lodash.prototype[methodName] = function() {
		        var value = this.__wrapped__,
		            args = isTaker ? [1] : arguments,
		            isLazy = value instanceof LazyWrapper,
		            iteratee = args[0],
		            useLazy = isLazy || isArray(value);

		        var interceptor = function(value) {
		          var result = lodashFunc.apply(lodash, arrayPush([value], args));
		          return (isTaker && chainAll) ? result[0] : result;
		        };

		        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
		          // Avoid lazy use if the iteratee has a "length" value other than `1`.
		          isLazy = useLazy = false;
		        }
		        var chainAll = this.__chain__,
		            isHybrid = !!this.__actions__.length,
		            isUnwrapped = retUnwrapped && !chainAll,
		            onlyLazy = isLazy && !isHybrid;

		        if (!retUnwrapped && useLazy) {
		          value = onlyLazy ? value : new LazyWrapper(this);
		          var result = func.apply(value, args);
		          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
		          return new LodashWrapper(result, chainAll);
		        }
		        if (isUnwrapped && onlyLazy) {
		          return func.apply(this, args);
		        }
		        result = this.thru(interceptor);
		        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
		      };
		    });

		    // Add `Array` methods to `lodash.prototype`.
		    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
		      var func = arrayProto[methodName],
		          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
		          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

		      lodash.prototype[methodName] = function() {
		        var args = arguments;
		        if (retUnwrapped && !this.__chain__) {
		          var value = this.value();
		          return func.apply(isArray(value) ? value : [], args);
		        }
		        return this[chainName](function(value) {
		          return func.apply(isArray(value) ? value : [], args);
		        });
		      };
		    });

		    // Map minified method names to their real names.
		    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
		      var lodashFunc = lodash[methodName];
		      if (lodashFunc) {
		        var key = lodashFunc.name + '';
		        if (!hasOwnProperty.call(realNames, key)) {
		          realNames[key] = [];
		        }
		        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
		      }
		    });

		    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
		      'name': 'wrapper',
		      'func': undefined$1
		    }];

		    // Add methods to `LazyWrapper`.
		    LazyWrapper.prototype.clone = lazyClone;
		    LazyWrapper.prototype.reverse = lazyReverse;
		    LazyWrapper.prototype.value = lazyValue;

		    // Add chain sequence methods to the `lodash` wrapper.
		    lodash.prototype.at = wrapperAt;
		    lodash.prototype.chain = wrapperChain;
		    lodash.prototype.commit = wrapperCommit;
		    lodash.prototype.next = wrapperNext;
		    lodash.prototype.plant = wrapperPlant;
		    lodash.prototype.reverse = wrapperReverse;
		    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

		    // Add lazy aliases.
		    lodash.prototype.first = lodash.prototype.head;

		    if (symIterator) {
		      lodash.prototype[symIterator] = wrapperToIterator;
		    }
		    return lodash;
		  });

		  /*--------------------------------------------------------------------------*/

		  // Export lodash.
		  var _ = runInContext();

		  // Some AMD build optimizers, like r.js, check for condition patterns like:
		  if (freeModule) {
		    // Export for Node.js.
		    (freeModule.exports = _)._ = _;
		    // Export for CommonJS support.
		    freeExports._ = _;
		  }
		  else {
		    // Export to the global object.
		    root._ = _;
		  }
		}.call(lodash)); 
	} (lodash$1, lodash$1.exports));
	return lodash$1.exports;
}

var lodashExports = requireLodash();
var _ = /*@__PURE__*/getDefaultExportFromCjs(lodashExports);

// èŽ·å–å½¢çŠ¶è¾¹ç•Œ
const getBounds = (shape, doodle) => {
  const shapeTypeGetBoundsFuncMap = {
    // çŸ©å½¢
    [doodle.tools.rect]: (shape) => {
      return {
        minX: shape.pos[0],
        minY: shape.pos[1],
        maxX: shape.pos[0] + shape.pos[2],
        maxY: shape.pos[1] + shape.pos[3],
        id: shape.id,
      }
    },
    // å¤šè¾¹å½¢
    [doodle.tools.polygon]: (shape) => {
      return {
        ...getPolygonBounds(shape.pos),
        id: shape.id,
      }
    },
    // åœ†
    [doodle.tools.circle]: (shape) => {
      return {
        minX: shape.pos[0] - shape.pos[2],
        minY: shape.pos[1] - shape.pos[2],
        maxX: shape.pos[0] + shape.pos[2],
        maxY: shape.pos[1] + shape.pos[2],
        id: shape.id,
      }
    },
    // æ¤­åœ†
    [doodle.tools.ellipse]: (shape) => {
      return {
        minX: shape.pos[0] - shape.pos[2],
        minY: shape.pos[1] - shape.pos[3],
        maxX: shape.pos[0] + shape.pos[2],
        maxY: shape.pos[1] + shape.pos[3],
        id: shape.id,
      }
    },
    // è·¯å¾„
    [doodle.tools.path]: (shape) => {
      return {
        ...getPolygonBounds(shape.pos),
        id: shape.id,
      }
    },
    // é—­åˆè·¯å¾„
    [doodle.tools.closed_path]: (shape) => {
      return {
        ...getPolygonBounds(shape.pos),
        id: shape.id,
      }
    },
    // ç›´çº¿
    [doodle.tools.line]: (shape) => {
      return {
        minX: Math.min(shape.pos[0], shape.pos[2]),
        minY: Math.min(shape.pos[1], shape.pos[3]),
        maxX: Math.max(shape.pos[0], shape.pos[2]),
        maxY: Math.max(shape.pos[1], shape.pos[3]),
        id: shape.id,
      }
    },
    // ç®­å¤´ç›´çº¿
    [doodle.tools.arrow_line]: (shape) => {
      return {
        minX: Math.min(shape.pos[0], shape.pos[2]),
        minY: Math.min(shape.pos[1], shape.pos[3]),
        maxX: Math.max(shape.pos[0], shape.pos[2]),
        maxY: Math.max(shape.pos[1], shape.pos[3]),
        id: shape.id,
      }
    },
    // ç‚¹
    [doodle.tools.point]: (shape) => {
      return {
        minX: shape.pos[0],
        minY: shape.pos[1],
        maxX: shape.pos[0],
        maxY: shape.pos[1],
        id: shape.id,
      }
    },
  };
  return shapeTypeGetBoundsFuncMap[shape.type](shape)
};

// èŽ·å–å¤šè¾¹å½¢è¾¹ç•Œ
const getPolygonBounds = (pos) => {
  const xMap = pos.filter((item, i) => i % 2 === 0);
  const yMap = pos.filter((item, i) => i % 2 !== 0);
  return {
    minX: Math.min(...xMap),
    minY: Math.min(...yMap),
    maxX: Math.max(...xMap),
    maxY: Math.max(...yMap),
  }
};

// ç‚¹æ˜¯å¦åœ¨shapeå†…
const pointInShape = (doodle, point, shape, buffer) => {
  if (!shape) {
    return false
  }
  const groupPairs = (arr) => {
    return arr.reduce((result, item, index) => {
      if (index % 2 === 0) {
        result.push(arr.slice(index, index + 2));
      }
      return result
    }, [])
  };
  const shapeTypePointInShapeFuncMap = {
    // ç§»åŠ¨
    [doodle.tools.move]: (point, shape, buffer) => {},
    // çŸ©å½¢
    [doodle.tools.rect]: (point, shape, buffer) => {
      return (
        point.x >= shape.pos[0] &&
        point.x <= shape.pos[0] + shape.pos[2] &&
        point.y >= shape.pos[1] &&
        point.y <= shape.pos[1] + shape.pos[3]
      )
    },
    // å¤šè¾¹å½¢
    [doodle.tools.polygon]: (point, shape, buffer) => {
      return pointInPolygon([point.x, point.y], groupPairs(shape.pos))
    },
    // åœ†
    [doodle.tools.circle]: (point, shape, buffer, rotation = 0) => {
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const dx = point.x - shape.pos[0];
      const dy = point.y - shape.pos[1];
      const tdx = cos * dx + sin * dy;
      const tdy = sin * dx - cos * dy;
      return (
        (tdx * tdx) / (shape.pos[2] * shape.pos[2]) +
          (tdy * tdy) / (shape.pos[2] * shape.pos[2]) <=
        1
      )
    },
    // æ¤­åœ†
    [doodle.tools.ellipse]: (point, shape, buffer, rotation = 0) => {
      const cos = Math.cos(rotation);
      const sin = Math.sin(rotation);
      const dx = point.x - shape.pos[0];
      const dy = point.y - shape.pos[1];
      const tdx = cos * dx + sin * dy;
      const tdy = sin * dx - cos * dy;
      return (
        (tdx * tdx) / (shape.pos[2] * shape.pos[2]) +
          (tdy * tdy) / (shape.pos[3] * shape.pos[3]) <=
        1
      )
    },
    // è·¯å¾„
    [doodle.tools.path]: (point, shape, buffer) => {
      return pointInPolygon([point.x, point.y], groupPairs(shape.pos))
    },
    // é—­åˆè·¯å¾„
    [doodle.tools.closed_path]: (point, shape, buffer) => {
      return pointInPolygon([point.x, point.y], groupPairs(shape.pos))
    },
    // ç›´çº¿
    [doodle.tools.line]: (point, shape, buffer) => {
      const { x, y } = point;
      const dx = shape.pos[2] - shape.pos[0];
      const dy = shape.pos[3] - shape.pos[1];
      const d = Math.sqrt(dx * dx + dy * dy);
      const cross = Math.abs((x - shape.pos[0]) * dy - (y - shape.pos[1]) * dx);
      const dist = cross / d;
      return dist <= buffer
    },
    // ç®­å¤´ç›´çº¿
    [doodle.tools.arrow_line]: (point, shape, buffer) => {
      const { x, y } = point;
      const dx = shape.pos[2] - shape.pos[0];
      const dy = shape.pos[3] - shape.pos[1];
      const d = Math.sqrt(dx * dx + dy * dy);
      const cross = Math.abs((x - shape.pos[0]) * dy - (y - shape.pos[1]) * dx);
      const dist = cross / d;
      return dist <= buffer
    },
    // ç‚¹
    [doodle.tools.point]: (point, shape, buffer) => {},
  };
  return shapeTypePointInShapeFuncMap[shape.type](point, shape, buffer)
};

// èŽ·å–shapeçš„é¢ç§¯
const getShapeArea = (doodle, shape) => {
  const shapeTypeGetShapeAreaFuncMap = {
    // ç§»åŠ¨
    [doodle.tools.move]: (shape) => {},
    // çŸ©å½¢
    [doodle.tools.rect]: (shape) => {
      return shape.pos[2] * shape.pos[3]
    },
    // å¤šè¾¹å½¢
    [doodle.tools.polygon]: (shape) => {
      return getPolygonArea(shape.pos)
    },
    // åœ†
    [doodle.tools.circle]: (shape) => {
      return shape.pos[2] * shape.pos[2] * Math.PI
    },
    // æ¤­åœ†
    [doodle.tools.ellipse]: (shape) => {
      return shape.pos[2] * shape.pos[3] * Math.PI
    },
    // è·¯å¾„
    [doodle.tools.path]: (shape) => {
      return getPolygonArea(shape.pos)
    },
    // é—­åˆè·¯å¾„
    [doodle.tools.closed_path]: (shape) => {
      return getPolygonArea(shape.pos)
    },
    // ç›´çº¿
    [doodle.tools.line]: (shape) => {
      return 0
    },
    // ç®­å¤´ç›´çº¿
    [doodle.tools.arrow_line]: (shape) => {
      return 0
    },
    // ç‚¹
    [doodle.tools.point]: (shape) => {
      return -1
    },
  };
  return shapeTypeGetShapeAreaFuncMap[shape.type](shape)
};

// èŽ·å–å¤šè¾¹å½¢é¢ç§¯
const getPolygonArea = (pos) => {
  let area = 0;
  const n = pos.length / 2;
  for (let i = 0; i < n; i++) {
    const x1 = pos[2 * i];
    const y1 = pos[2 * i + 1];
    const x2 = pos[2 * ((i + 1) % n)];
    const y2 = pos[2 * ((i + 1) % n) + 1];
    area += x1 * y2 - x2 * y1;
  }
  return Math.abs(area) / 2
};

// å¤šè¾¹å½¢å·¥å…·ä¸‹è·ç¦»åˆå§‹ç‚¹è¿‡è¿‘
const isPolygonToolToStartPointTooClose = (doodle) => {
  if (!doodle.tempShape) {
    return false
  }
  if (doodle.tempShape.type !== doodle.tools.polygon) {
    return false
  }
  return (
    lineLength([
      [doodle.tempShape.pos[0], doodle.tempShape.pos[1]],
      [doodle.mouse.dx, doodle.mouse.dy],
    ]) <
    14 / doodle.scale
  )
};

// èŽ·å–æ‚¬æµ®çš„shape
const getHoverShape = (doodle) => {
  if (doodle.readonly) return
  let ret = null;
  if (doodle.mode !== doodle.tools.move) {
    ret = null;
  }
  const scale = doodle.scale;
  const buffer = scale ? doodle.hitRadius / scale : doodle.hitRadius;
  const { dx, dy } = doodle.mouse;
  const mouseBounds = {
    minX: dx - buffer,
    minY: dy - buffer,
    maxX: dx + buffer,
    maxY: dy + buffer,
  };
  // å¤–æŽ¥çŸ©å½¢çš„ç²—ç•¥å‘½ä¸­
  const cursoryHitBounds = doodle.bounds.search(mouseBounds);
  // è¯¦ç»†çš„å‘½ä¸­
  // ä¿®æ­£ä¸´æ—¶shape
  const shapes = [...doodle.shapes];
  if (doodle.tempShape && doodle.tempShape.id) {
    shapes.splice(
      shapes.findIndex((item) => item.id === doodle.tempShape.id),
      1
    );
    shapes.push(doodle.tempShape);
  }
  const detailedHitBounds = cursoryHitBounds.filter((bounds) => {
    const shape = shapes.find((item) => item.id === bounds.id);
    if (shape?.type === doodle.tools.point) {
      return true
    }
    return pointInShape(doodle, { x: dx, y: dy }, shape, buffer)
  });
  // è¿”å›žè¯¦ç»†å‘½ä¸­ä¸­çš„é¢ç§¯æœ€å°çš„é‚£ä¸€ä¸ª
  if (detailedHitBounds.length) {
    if (detailedHitBounds.length === 1) {
      ret = shapes.find((item) => item.id === detailedHitBounds[0].id);
    }
    detailedHitBounds.sort((a, b) => {
      const shapeA = shapes.find((item) => item.id === a.id);
      const shapeB = shapes.find((item) => item.id === b.id);
      // @ts-ignore
      return getShapeArea(doodle, shapeA) - getShapeArea(doodle, shapeB)
    });
    ret = shapes.find((item) => item.id === detailedHitBounds[0].id);
  }
  // å•ä¸ªshapeåªè¯»çš„æŽ§åˆ¶
  if (ret && ret.readonly) {
    ret = null;
  }
  return ret
};

// ç”Ÿæˆé”šç‚¹åˆ—è¡¨
const generateAnchors = (doodle) => {
  let getAnchors = (doodle) => {
    if (!doodle.tempShape) {
      return []
    }
    if (!doodle.tempShape.id) {
      return []
    }
    const shapeGetAnchorsFuncMap = {
      // çŸ©å½¢
      [doodle.tools.rect]: (shape) => {
        return [
          // å·¦ä¸Š
          { x: shape.pos[0], y: shape.pos[1] },
          // å³ä¸Š
          { x: shape.pos[0] + shape.pos[2], y: shape.pos[1] },
          // å·¦ä¸‹
          { x: shape.pos[0], y: shape.pos[1] + shape.pos[3] },
          // å³ä¸‹
          {
            x: shape.pos[0] + shape.pos[2],
            y: shape.pos[1] + shape.pos[3],
          },
        ]
      },
      // å¤šè¾¹å½¢
      [doodle.tools.polygon]: (shape) => {
        let ret = [];
        for (let i = 0; i < shape.pos.length; i += 2) {
          ret.push({
            x: shape.pos[i],
            y: shape.pos[i + 1],
          });
        }
        return ret
      },
      // åœ†
      [doodle.tools.circle]: (shape) => {
        return [
          {
            x: shape.pos[0] + shape.pos[2],
            y: shape.pos[1],
          },
        ]
      },
      // æ¤­åœ†
      [doodle.tools.ellipse]: (shape) => {
        return [
          {
            x: shape.pos[0],
            y: shape.pos[1] - shape.pos[3],
          },
          {
            x: shape.pos[0] + shape.pos[2],
            y: shape.pos[1],
          },
        ]
      },
      // ç›´çº¿
      [doodle.tools.line]: (shape) => {
        return [
          { x: shape.pos[0], y: shape.pos[1] },
          { x: shape.pos[2], y: shape.pos[3] },
        ]
      },
      // ç®­å¤´ç›´çº¿
      [doodle.tools.arrow_line]: (shape) => {
        return [
          { x: shape.pos[0], y: shape.pos[1] },
          { x: shape.pos[2], y: shape.pos[3] },
        ]
      },
    };
    if (shapeGetAnchorsFuncMap[doodle.tempShape.type]) {
      return shapeGetAnchorsFuncMap[doodle.tempShape.type](doodle.tempShape)
    }
    return []
  };
  doodle.anchors = getAnchors(doodle);
};
// æ‚¬æµ®çš„é”šç‚¹
const getHoverAnchor = (doodle) => {
  if (!doodle.anchors.length) {
    return null
  }
  for (const v of doodle.anchors) {
    if (
      lineLength([
        [v.x, v.y],
        [doodle.mouse.dx, doodle.mouse.dy],
      ]) <
      (doodle.anchorRadius + 2) / doodle.scale
    ) {
      return v
    }
  }
  return null
};

const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] +
        byteToHex[arr[offset + 1]] +
        byteToHex[arr[offset + 2]] +
        byteToHex[arr[offset + 3]] +
        '-' +
        byteToHex[arr[offset + 4]] +
        byteToHex[arr[offset + 5]] +
        '-' +
        byteToHex[arr[offset + 6]] +
        byteToHex[arr[offset + 7]] +
        '-' +
        byteToHex[arr[offset + 8]] +
        byteToHex[arr[offset + 9]] +
        '-' +
        byteToHex[arr[offset + 10]] +
        byteToHex[arr[offset + 11]] +
        byteToHex[arr[offset + 12]] +
        byteToHex[arr[offset + 13]] +
        byteToHex[arr[offset + 14]] +
        byteToHex[arr[offset + 15]]).toLowerCase();
}

let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues) {
        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {
            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
        getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = { randomUUID };

function v4(options, buf, offset) {
    if (native.randomUUID && true && !options) {
        return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) {
        throw new Error('Random bytes length must be >= 16');
    }
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return unsafeStringify(rnds);
}

// é¼ æ ‡æŒ‰ä¸‹
const handleMouseDown = (doodle) => {
  getMouseHandler(doodle).handleMouseDown();
};
// é¼ æ ‡æŠ¬èµ·
const handleMouseUp = (doodle) => {
  getMouseHandler(doodle).handleMouseUp();
};
// é¼ æ ‡ç§»åŠ¨
const handleMouseMove = (doodle) => {
  getMouseHandler(doodle).handleMouseMove();
};

let lastMouseDownTimestamp = 0; // å¤šè¾¹å½¢å·¥å…·ä¸‹åˆ¤æ–­åŒå‡»å®Œæˆå½¢çŠ¶çš„æ—¶é—´æˆ³
let tempCurMousePoint = null; // å¼€å§‹ç¼–è¾‘å‰çš„é¼ æ ‡ä½ç½®
let tempShape = null; // å¼€å§‹ç¼–è¾‘å‰å½¢çŠ¶çš„å‰¯æœ¬
let tempAnchor = null; // å¼€å§‹ç¼–è¾‘å‰é”šç‚¹çš„å‰¯æœ¬

// èŽ·å–é¼ æ ‡å¤„ç†å™¨
const getMouseHandler = (doodle) => {
  // å·¥å…·å¯¹åº”çš„é¼ æ ‡å¤„ç†å‡½æ•°
  const toolsMouseMap = {
    // ç§»åŠ¨
    [doodle.tools.move]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        const curMouseDownTimestamp = Date.now();
        lastMouseDownTimestamp = curMouseDownTimestamp; // å¤šè¾¹å½¢å·¥å…·ä¸‹åˆ¤æ–­åŒå‡»å®Œæˆå½¢çŠ¶çš„æ—¶é—´æˆ³
        // åœ¨é”šç‚¹ä¸ŠæŒ‰ä¸‹
        if (doodle.tempShape && doodle.hoverAnchor) {
          doodle.setPan(false);
          tempCurMousePoint = {
            x: doodle.mouse.dx,
            y: doodle.mouse.dy,
          };
          tempAnchor = _.cloneDeep(doodle.hoverAnchor);
          tempShape = _.cloneDeep(doodle.tempShape);
          return
        }
        // åœ¨ç¼–è¾‘çš„shapeä¸ŠæŒ‰ä¸‹
        if (
          doodle.tempShape &&
          doodle.hoverShape &&
          doodle.tempShape.id === doodle.hoverShape.id
        ) {
          doodle.setPan(false);
          tempCurMousePoint = {
            x: doodle.mouse.dx,
            y: doodle.mouse.dy,
          };
          tempAnchor = null;
          tempShape = _.cloneDeep(doodle.tempShape);
          return
        }
        tempCurMousePoint = null;
        tempShape = null;
        tempAnchor = null;
        doodle.setPan(true);
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        const curMouseDownTimestamp = Date.now();
        const diff = curMouseDownTimestamp - lastMouseDownTimestamp;
        if (diff < 150) {
          // çŸ­æŒ‰
          // çŸ­æŒ‰äº†é”šç‚¹
          if (doodle.hoverAnchor) {
            return
          }
          // çŸ­æŒ‰äº†å½¢çŠ¶
          if (doodle.hoverShape) {
            // å½“å‰æœ‰ç¼–è¾‘ä¸­çš„å½¢çŠ¶
            if (doodle.tempShape) {
              if (doodle.tempShape.id !== doodle.hoverShape.id) {
                const originalShape = doodle.shapes.find(
                  (item) => item.id === doodle.tempShape.id
                );
                if (
                  JSON.stringify(originalShape) !==
                  JSON.stringify(doodle.tempShape)
                ) {
                  doodle.conf.onUpdate &&
                    doodle.conf.onUpdate(_.cloneDeep(doodle.tempShape));
                }
                doodle.tempShape = _.cloneDeep(doodle.hoverShape);
                if (doodle.tempShape.type === doodle.tools.point) {
                  doodle.generatePoints();
                }
                doodle.conf.onSelect &&
                  doodle.conf.onSelect(_.cloneDeep(doodle.tempShape));
              }
              // å½“å‰æ²¡æœ‰ç¼–è¾‘ä¸­çš„å½¢çŠ¶
            } else {
              doodle.tempShape = _.cloneDeep(doodle.hoverShape);
              if (doodle.tempShape.type === doodle.tools.point) {
                doodle.generatePoints();
              }
              doodle.conf.onSelect &&
                doodle.conf.onSelect(_.cloneDeep(doodle.tempShape));
            }
            return
          }
          // çŸ­æŒ‰ç©ºç™½åŒºåŸŸ
          if (doodle.tempShape) {
            // å¦‚æžœæœ‰ä¸´æ—¶shapeåˆ™è§¦å‘ç¼–è¾‘ä¿å­˜
            const originalShape = doodle.shapes.find(
              (item) => item.id === doodle.tempShape.id
            );
            const cloneTempShape = _.cloneDeep(doodle.tempShape);
            // ä¿®æ­£ä¸´æ—¶shapeçš„boundsä½ç½®
            doodle.correctionTempShapeBounds(originalShape);
            // è§¦å‘å–æ¶ˆé€‰æ‹©äº‹ä»¶
            doodle.conf.onCancelSelect &&
              doodle.conf.onCancelSelect(cloneTempShape);
            if (
              JSON.stringify(originalShape) !== JSON.stringify(doodle.tempShape)
            ) {
              doodle.conf.onUpdate && doodle.conf.onUpdate(cloneTempShape);
            }
            doodle.tempShape = null;
            if (originalShape.type === doodle.tools.point) {
              doodle.generatePoints();
            }
          }
        }
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        // åœ¨é”šç‚¹ä¸Šç§»åŠ¨
        if (doodle.tempShape && tempAnchor && doodle.mouse.isPressed) {
          const diff = {
            x: doodle.mouse.dx - tempCurMousePoint.x,
            y: doodle.mouse.dy - tempCurMousePoint.y,
          };
          const anchorHandleMoveFuncMap = {
            // çŸ©å½¢
            [doodle.tools.rect]: (shape, cloneShape, tempAnchor, diff) => {
              // å·¦ä¸Š
              if (
                tempAnchor.x === cloneShape.pos[0] &&
                tempAnchor.y === cloneShape.pos[1]
              ) {
                if (diff.x < cloneShape.pos[2]) {
                  shape.pos[0] = cloneShape.pos[0] + diff.x;
                  shape.pos[2] = cloneShape.pos[2] - diff.x;
                } else {
                  shape.pos[0] = cloneShape.pos[0] + cloneShape.pos[2];
                  shape.pos[2] = diff.x - cloneShape.pos[2];
                }
                if (diff.y < cloneShape.pos[3]) {
                  shape.pos[1] = cloneShape.pos[1] + diff.y;
                  shape.pos[3] = cloneShape.pos[3] - diff.y;
                } else {
                  shape.pos[1] = cloneShape.pos[1] + cloneShape.pos[3];
                  shape.pos[3] = diff.y - cloneShape.pos[3];
                }
                return
              }
              // å³ä¸Š
              if (
                tempAnchor.x === cloneShape.pos[0] + cloneShape.pos[2] &&
                tempAnchor.y === cloneShape.pos[1]
              ) {
                if (diff.x < -cloneShape.pos[2]) {
                  shape.pos[0] = cloneShape.pos[0] + cloneShape.pos[2] + diff.x;
                  shape.pos[2] = -diff.x - cloneShape.pos[2];
                } else {
                  shape.pos[2] = cloneShape.pos[2] + diff.x;
                }
                if (diff.y > cloneShape.pos[3]) {
                  shape.pos[1] = cloneShape.pos[1] + cloneShape.pos[3];
                  shape.pos[3] = diff.y - cloneShape.pos[3];
                } else {
                  shape.pos[1] = cloneShape.pos[1] + diff.y;
                  shape.pos[3] = cloneShape.pos[3] - diff.y;
                }
                return
              }
              // å·¦ä¸‹
              if (
                tempAnchor.x === cloneShape.pos[0] &&
                tempAnchor.y === cloneShape.pos[1] + cloneShape.pos[3]
              ) {
                if (diff.x < cloneShape.pos[2]) {
                  shape.pos[0] = cloneShape.pos[0] + diff.x;
                  shape.pos[2] = cloneShape.pos[2] - diff.x;
                } else {
                  shape.pos[0] = cloneShape.pos[0] + cloneShape.pos[2];
                  shape.pos[2] = diff.x - cloneShape.pos[2];
                }
                if (-diff.y > cloneShape.pos[3]) {
                  shape.pos[1] = cloneShape.pos[1] + cloneShape.pos[3] + diff.y;
                  shape.pos[3] = -diff.y - cloneShape.pos[3];
                } else {
                  shape.pos[3] = cloneShape.pos[3] + diff.y;
                }
              }
              // å³ä¸‹
              if (
                tempAnchor.x === cloneShape.pos[0] + cloneShape.pos[2] &&
                tempAnchor.y === cloneShape.pos[1] + cloneShape.pos[3]
              ) {
                if (diff.x < -cloneShape.pos[2]) {
                  shape.pos[0] = cloneShape.pos[0] + cloneShape.pos[2] + diff.x;
                  shape.pos[2] = -diff.x - cloneShape.pos[2];
                } else {
                  shape.pos[2] = cloneShape.pos[2] + diff.x;
                }
                if (-diff.y > cloneShape.pos[3]) {
                  shape.pos[1] = cloneShape.pos[1] + cloneShape.pos[3] + diff.y;
                  shape.pos[3] = -diff.y - cloneShape.pos[3];
                } else {
                  shape.pos[3] = cloneShape.pos[3] + diff.y;
                }
                return
              }
            },
            // å¤šè¾¹å½¢
            [doodle.tools.polygon]: (shape, cloneShape, tempAnchor, diff) => {
              let targetIndex = 0;
              for (const _i in cloneShape.pos) {
                let i = Number(_i);
                const item = cloneShape.pos[i];
                const next = cloneShape.pos[i + 1];
                if (
                  i % 2 === 0 &&
                  item === tempAnchor.x &&
                  next === tempAnchor.y
                ) {
                  targetIndex = Number(i);
                  break
                }
              }
              shape.pos[targetIndex] = tempAnchor.x + diff.x;
              shape.pos[targetIndex + 1] = tempAnchor.y + diff.y;
            },
            // åœ†
            [doodle.tools.circle]: (shape, cloneShape, tempAnchor, diff) => {
              const ret = Math.max(cloneShape.pos[2] + diff.x, 1);
              shape.pos[2] = ret;
            },
            // æ¤­åœ†
            [doodle.tools.ellipse]: (shape, cloneShape, tempAnchor, diff) => {
              // ä¸Šè¾¹çš„ç‚¹
              if (
                tempAnchor.x === cloneShape.pos[0] &&
                tempAnchor.y === cloneShape.pos[1] - cloneShape.pos[3]
              ) {
                const ret = Math.max(cloneShape.pos[3] - diff.y, 1);
                shape.pos[3] = ret;
                return
              }
              // å³è¾¹çš„ç‚¹
              if (
                tempAnchor.x === cloneShape.pos[0] + cloneShape.pos[2] &&
                tempAnchor.y === cloneShape.pos[1]
              ) {
                const ret = Math.max(cloneShape.pos[2] + diff.x, 1);
                shape.pos[2] = ret;
                return
              }
            },
            // ç›´çº¿
            [doodle.tools.line]: (shape, cloneShape, tempAnchor, diff) => {
              // èµ·å§‹ç‚¹
              if (
                tempAnchor.x === cloneShape.pos[0] &&
                tempAnchor.y === cloneShape.pos[1]
              ) {
                shape.pos[0] = cloneShape.pos[0] + diff.x;
                shape.pos[1] = cloneShape.pos[1] + diff.y;
                return
              }
              // ç»“æŸç‚¹
              if (
                tempAnchor.x === cloneShape.pos[2] &&
                tempAnchor.y === cloneShape.pos[3]
              ) {
                shape.pos[2] = cloneShape.pos[2] + diff.x;
                shape.pos[3] = cloneShape.pos[3] + diff.y;
                return
              }
            },
            // ç®­å¤´ç›´çº¿
            [doodle.tools.arrow_line]: (
              shape,
              cloneShape,
              tempAnchor,
              diff
            ) => {
              // èµ·å§‹ç‚¹
              if (
                tempAnchor.x === cloneShape.pos[0] &&
                tempAnchor.y === cloneShape.pos[1]
              ) {
                shape.pos[0] = cloneShape.pos[0] + diff.x;
                shape.pos[1] = cloneShape.pos[1] + diff.y;
                return
              }
              // ç»“æŸç‚¹
              if (
                tempAnchor.x === cloneShape.pos[2] &&
                tempAnchor.y === cloneShape.pos[3]
              ) {
                shape.pos[2] = cloneShape.pos[2] + diff.x;
                shape.pos[3] = cloneShape.pos[3] + diff.y;
                return
              }
            },
          };
          anchorHandleMoveFuncMap[doodle.tempShape.type](
            doodle.tempShape,
            tempShape,
            tempAnchor,
            diff
          );
          // ä¿®æ­£ä¸´æ—¶shapeçš„boundsä½ç½®
          doodle.correctionTempShapeBounds(doodle.tempShape);
          return
        }
        // åœ¨ç¼–è¾‘çš„shapeä¸Šç§»åŠ¨
        if (doodle.tempShape && tempShape && doodle.mouse.isPressed) {
          const diff = {
            x: doodle.mouse.dx - tempCurMousePoint.x,
            y: doodle.mouse.dy - tempCurMousePoint.y,
          };
          const shapeHandleMoveFuncMap = {
            // çŸ©å½¢
            [doodle.tools.rect]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
            },
            // å¤šè¾¹å½¢
            [doodle.tools.polygon]: (shape, cloneShape, diff) => {
              shape.pos = cloneShape.pos.map((item, i) => {
                if (i % 2 === 0) {
                  return item + diff.x
                } else {
                  return item + diff.y
                }
              });
            },
            // åœ†
            [doodle.tools.circle]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
            },
            // æ¤­åœ†
            [doodle.tools.ellipse]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
            },
            // è·¯å¾„
            [doodle.tools.path]: (shape, cloneShape, diff) => {
              shape.pos = cloneShape.pos.map((item, i) => {
                if (i % 2 === 0) {
                  return item + diff.x
                } else {
                  return item + diff.y
                }
              });
            },
            // é—­åˆè·¯å¾„
            [doodle.tools.closed_path]: (shape, cloneShape, diff) => {
              shape.pos = cloneShape.pos.map((item, i) => {
                if (i % 2 === 0) {
                  return item + diff.x
                } else {
                  return item + diff.y
                }
              });
            },
            // ç›´çº¿
            [doodle.tools.line]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
              shape.pos[2] = cloneShape.pos[2] + diff.x;
              shape.pos[3] = cloneShape.pos[3] + diff.y;
            },
            // ç®­å¤´ç›´çº¿
            [doodle.tools.arrow_line]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
              shape.pos[2] = cloneShape.pos[2] + diff.x;
              shape.pos[3] = cloneShape.pos[3] + diff.y;
            },
            // ç‚¹
            [doodle.tools.point]: (shape, cloneShape, diff) => {
              shape.pos[0] = cloneShape.pos[0] + diff.x;
              shape.pos[1] = cloneShape.pos[1] + diff.y;
            },
          };
          shapeHandleMoveFuncMap[doodle.tempShape.type](
            doodle.tempShape,
            tempShape,
            diff
          );
          // ä¿®æ­£ä¸´æ—¶shapeçš„boundsä½ç½®
          doodle.correctionTempShapeBounds(doodle.tempShape);
          return
        }
      },
    },
    // çŸ©å½¢
    [doodle.tools.rect]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.rect,
          pos: [doodle.mouse.dx, doodle.mouse.dy, 0, 0],
          // ä¸´æ—¶å˜é‡
          temp: {
            start: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
            end: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
          },
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (!doodle.tempShape.pos[2] || !doodle.tempShape.pos[3]) {
          doodle.tempShape = null;
          return
        }
        delete doodle.tempShape.temp;
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.temp.end = {
          x: doodle.mouse.dx,
          y: doodle.mouse.dy,
        };
        doodle.tempShape.pos[0] = Math.min(
          doodle.tempShape.temp.end.x,
          doodle.tempShape.temp.start.x
        );
        doodle.tempShape.pos[1] = Math.min(
          doodle.tempShape.temp.end.y,
          doodle.tempShape.temp.start.y
        );
        doodle.tempShape.pos[2] = Math.abs(
          doodle.tempShape.temp.end.x - doodle.tempShape.temp.start.x
        );
        doodle.tempShape.pos[3] = Math.abs(
          doodle.tempShape.temp.end.y - doodle.tempShape.temp.start.y
        );
      },
    },
    // å¤šè¾¹å½¢
    [doodle.tools.polygon]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        const curMouseDownTimestamp = Date.now();
        const diff = curMouseDownTimestamp - lastMouseDownTimestamp;
        lastMouseDownTimestamp = curMouseDownTimestamp;
        const clickPoint = isPolygonToolToStartPointTooClose(doodle)
          ? {
              x: doodle.tempShape.pos[0],
              y: doodle.tempShape.pos[1],
            }
          : {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            };
        const x = clickPoint.x;
        const y = clickPoint.y;
        const initPolygonShape = () => {
          doodle.tempShape = {
            id: null,
            type: doodle.tools.polygon,
            pos: [x, y, x, y],
            color: doodle.brushColor,
          };
        };
        const completeShape = () => {
          doodle.tempShape.pos.pop();
          doodle.tempShape.pos.pop();
          doodle.tempShape.id = v4();
          doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
          doodle.tempShape = null;
        };
        const addPoint = () => {
          for (let _i in doodle.tempShape.pos.slice(0, -2)) {
            let i = Number(_i);
            if (
              i % 2 === 0 &&
              doodle.tempShape.pos[i] === x &&
              doodle.tempShape.pos[i + 1] === y
            ) {
              return
            }
          }
          doodle.tempShape.pos.push(x);
          doodle.tempShape.pos.push(y);
        };
        if (doodle.tempShape === null) {
          initPolygonShape();
        } else {
          // å¦‚æžœç¦»åˆå§‹ç‚¹é çš„å¤ªè¿‘ ç›´æŽ¥å®Œæˆ
          if (
            doodle.tempShape.pos.length > 6 &&
            isPolygonToolToStartPointTooClose(doodle)
          ) {
            completeShape();
          } else {
            addPoint();
          }
        }
        if (diff < 300) {
          lastMouseDownTimestamp = 0;
          if (doodle.tempShape === null) {
            return
          }
          if (doodle.tempShape.pos.length > 6) {
            completeShape();
          }
        }
      },
      // æŠ¬èµ·
      handleMouseUp: () => {},
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        if (isPolygonToolToStartPointTooClose(doodle)) {
          doodle.tempShape.pos[doodle.tempShape.pos.length - 1] =
            doodle.tempShape.pos[1];
          doodle.tempShape.pos[doodle.tempShape.pos.length - 2] =
            doodle.tempShape.pos[0];
          return
        }
        doodle.tempShape.pos[doodle.tempShape.pos.length - 1] = doodle.mouse.dy;
        doodle.tempShape.pos[doodle.tempShape.pos.length - 2] = doodle.mouse.dx;
      },
    },
    // åœ†
    [doodle.tools.circle]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.circle,
          pos: [doodle.mouse.dx, doodle.mouse.dy, 0],
          // ä¸´æ—¶å˜é‡
          temp: {
            start: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
            end: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
          },
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (!doodle.tempShape.pos[2]) {
          doodle.tempShape = null;
          return
        }
        delete doodle.tempShape.temp;
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.temp.end = {
          x: doodle.mouse.dx,
          y: doodle.mouse.dy,
        };
        const diffX = Math.abs(
          doodle.tempShape.temp.end.x - doodle.tempShape.temp.start.x
        );
        const diffY = Math.abs(
          doodle.tempShape.temp.end.y - doodle.tempShape.temp.start.y
        );
        const maxDiff = Math.max(diffX, diffY);
        const r = maxDiff / 2;
        const circleCenterPoint = {
          x: (doodle.tempShape.temp.end.x + doodle.tempShape.temp.start.x) / 2,
          y: (doodle.tempShape.temp.end.y + doodle.tempShape.temp.start.y) / 2,
        };
        doodle.tempShape.pos[0] = circleCenterPoint.x;
        doodle.tempShape.pos[1] = circleCenterPoint.y;
        doodle.tempShape.pos[2] = r;
      },
    },
    // æ¤­åœ†
    [doodle.tools.ellipse]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.ellipse,
          pos: [doodle.mouse.dx, doodle.mouse.dy, 0, 0],
          // ä¸´æ—¶å˜é‡
          temp: {
            start: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
            end: {
              x: doodle.mouse.dx,
              y: doodle.mouse.dy,
            },
          },
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (!doodle.tempShape.pos[2] || !doodle.tempShape.pos[3]) {
          doodle.tempShape = null;
          return
        }
        delete doodle.tempShape.temp;
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.temp.end = {
          x: doodle.mouse.dx,
          y: doodle.mouse.dy,
        };
        const circleCenterPoint = {
          x: (doodle.tempShape.temp.end.x + doodle.tempShape.temp.start.x) / 2,
          y: (doodle.tempShape.temp.end.y + doodle.tempShape.temp.start.y) / 2,
        };
        doodle.tempShape.pos[0] = circleCenterPoint.x;
        doodle.tempShape.pos[1] = circleCenterPoint.y;
        doodle.tempShape.pos[2] =
          Math.abs(
            doodle.tempShape.temp.end.x - doodle.tempShape.temp.start.x
          ) / 2;
        doodle.tempShape.pos[3] =
          Math.abs(
            doodle.tempShape.temp.end.y - doodle.tempShape.temp.start.y
          ) / 2;
      },
    },
    // è·¯å¾„
    [doodle.tools.path]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.path,
          pos: [doodle.mouse.dx, doodle.mouse.dy],
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (doodle.tempShape.pos.length < 4) {
          doodle.tempShape = null;
          return
        }
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.pos.push(doodle.mouse.dx);
        doodle.tempShape.pos.push(doodle.mouse.dy);
      },
    },
    // é—­åˆè·¯å¾„
    [doodle.tools.closed_path]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.closed_path,
          pos: [doodle.mouse.dx, doodle.mouse.dy],
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (doodle.tempShape.pos.length < 4) {
          doodle.tempShape = null;
          return
        }
        doodle.tempShape.id = v4();
        doodle.conf.onAdd & doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.pos.push(doodle.mouse.dx);
        doodle.tempShape.pos.push(doodle.mouse.dy);
      },
    },
    // ç›´çº¿
    [doodle.tools.line]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.line,
          pos: [
            doodle.mouse.dx,
            doodle.mouse.dy,
            doodle.mouse.dx,
            doodle.mouse.dy,
          ],
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (
          doodle.tempShape.pos[0] === doodle.tempShape.pos[2] &&
          doodle.tempShape.pos[1] === doodle.tempShape.pos[3]
        ) {
          doodle.tempShape = null;
          return
        }
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.pos[2] = doodle.mouse.dx;
        doodle.tempShape.pos[3] = doodle.mouse.dy;
      },
    },
    // ç®­å¤´ç›´çº¿
    [doodle.tools.arrow_line]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        if (doodle.tempShape !== null) {
          return
        }
        doodle.tempShape = {
          id: null,
          type: doodle.tools.arrow_line,
          pos: [
            doodle.mouse.dx,
            doodle.mouse.dy,
            doodle.mouse.dx,
            doodle.mouse.dy,
          ],
          color: doodle.brushColor,
        };
      },
      // æŠ¬èµ·
      handleMouseUp: () => {
        if (!doodle.tempShape) {
          return
        }
        if (
          doodle.tempShape.pos[0] === doodle.tempShape.pos[2] &&
          doodle.tempShape.pos[1] === doodle.tempShape.pos[3]
        ) {
          doodle.tempShape = null;
          return
        }
        doodle.tempShape.id = v4();
        doodle.conf.onAdd && doodle.conf.onAdd(_.cloneDeep(doodle.tempShape));
        doodle.tempShape = null;
      },
      // ç§»åŠ¨
      handleMouseMove: () => {
        if (!doodle.tempShape) {
          return
        }
        doodle.tempShape.pos[2] = doodle.mouse.dx;
        doodle.tempShape.pos[3] = doodle.mouse.dy;
      },
    },
    // ç‚¹
    [doodle.tools.point]: {
      // æŒ‰ä¸‹
      handleMouseDown: () => {
        doodle.conf.onAdd &&
          doodle.conf.onAdd({
            id: v4(),
            type: doodle.tools.point,
            pos: [doodle.mouse.dx, doodle.mouse.dy],
            color: doodle.brushColor,
          });
      },
      // æŠ¬èµ·
      handleMouseUp: () => {},
      // ç§»åŠ¨
      handleMouseMove: () => {},
    },
  };
  return toolsMouseMap[doodle.mode]
};

/**
 * Rearranges items so that all items in the [left, k] are the smallest.
 * The k-th element will have the (k - left + 1)-th smallest value in [left, right].
 *
 * @template T
 * @param {T[]} arr the array to partially sort (in place)
 * @param {number} k middle index for partial sorting (as defined above)
 * @param {number} [left=0] left index of the range to sort
 * @param {number} [right=arr.length-1] right index
 * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function
 */
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {

    while (right > left) {
        if (right - left > 600) {
            const n = right - left + 1;
            const m = k - left + 1;
            const z = Math.log(n);
            const s = 0.5 * Math.exp(2 * z / 3);
            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselect(arr, k, newLeft, newRight, compare);
        }

        const t = arr[k];
        let i = left;
        /** @type {number} */
        let j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

/**
 * @template T
 * @param {T[]} arr
 * @param {number} i
 * @param {number} j
 */
function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

/**
 * @template T
 * @param {T} a
 * @param {T} b
 * @returns {number}
 */
function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

class RBush {
    constructor(maxEntries = 9) {
        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
    }

    all() {
        return this._all(this.data, []);
    }

    search(bbox) {
        let node = this.data;
        const result = [];

        if (!intersects(bbox, node)) return result;

        const toBBox = this.toBBox;
        const nodesToSearch = [];

        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    }

    collides(bbox) {
        let node = this.data;

        if (!intersects(bbox, node)) return false;

        const nodesToSearch = [];
        while (node) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childBBox = node.leaf ? this.toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    }

    load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (let i = 0; i < data.length; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        let node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                const tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    }

    insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    }

    clear() {
        this.data = createNode([]);
        return this;
    }

    remove(item, equalsFn) {
        if (!item) return this;

        let node = this.data;
        const bbox = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                const index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    }

    toBBox(item) { return item; }

    compareMinX(a, b) { return a.minX - b.minX; }
    compareMinY(a, b) { return a.minY - b.minY; }

    toJSON() { return this.data; }

    fromJSON(data) {
        this.data = data;
        return this;
    }

    _all(node, result) {
        const nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push(...node.children);
            else nodesToSearch.push(...node.children);

            node = nodesToSearch.pop();
        }
        return result;
    }

    _build(items, left, right, height) {

        const N = right - left + 1;
        let M = this._maxEntries;
        let node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));

        multiSelect(items, left, right, N1, this.compareMinX);

        for (let i = left; i <= right; i += N1) {

            const right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (let j = i; j <= right2; j += N2) {

                const right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    }

    _chooseSubtree(bbox, node, level, path) {
        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            let minArea = Infinity;
            let minEnlargement = Infinity;
            let targetNode;

            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const area = bboxArea(child);
                const enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    }

    _insert(item, level, isNode) {
        const bbox = isNode ? item : this.toBBox(item);
        const insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        const node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend$1(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    }

    // split overflowed node into two
    _split(insertPath, level) {
        const node = insertPath[level];
        const M = node.children.length;
        const m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        const splitIndex = this._chooseSplitIndex(node, m, M);

        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    }

    _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    }

    _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;

        for (let i = m; i <= M - m; i++) {
            const bbox1 = distBBox(node, 0, i, this.toBBox);
            const bbox2 = distBBox(node, i, M, this.toBBox);

            const overlap = intersectionArea(bbox1, bbox2);
            const area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index || M - m;
    }

    // sorts node children by the best axis for split
    _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    }

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);

        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

        for (let i = m; i < M - m; i++) {
            const child = node.children[i];
            extend$1(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (let i = M - m - 1; i >= m; i--) {
            const child = node.children[i];
            extend$1(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    }

    _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (let i = level; i >= 0; i--) {
            extend$1(path[i], bbox);
        }
    }

    _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (let i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    }
}

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (let i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (let i = k; i < p; i++) {
        const child = node.children[i];
        extend$1(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend$1(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    const minX = Math.max(a.minX, b.minX);
    const minY = Math.max(a.minY, b.minY);
    const maxX = Math.min(a.maxX, b.maxX);
    const maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    const stack = [left, right];

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        const mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}

/**
* @vue/shared v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/


const EMPTY_OBJ = !!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
!!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
const NOOP = () => {
};
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const extend = Object.assign;
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}

/**
* @vue/reactivity v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if (!!(process.env.NODE_ENV !== "production") && activeSub !== this) {
        warn(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        );
      }
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || hasChanged(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (!!(process.env.NODE_ENV !== "production") && dep.subsHead === link) {
    dep.subsHead = nextSub;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
    /**
     * @internal
     */
    this.__v_skip = true;
    if (!!(process.env.NODE_ENV !== "production")) {
      this.subsHead = void 0;
    }
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (!!(process.env.NODE_ENV !== "production") && activeSub.onTrack) {
      activeSub.onTrack(
        extend(
          {
            effect: activeSub
          },
          debugInfo
        )
      );
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (!!(process.env.NODE_ENV !== "production")) {
        for (let head = this.subsHead; head; head = head.nextSub) {
          if (head.sub.onTrigger && !(head.sub.flags & 8)) {
            head.sub.onTrigger(
              extend(
                {
                  effect: head.sub
                },
                debugInfo
              )
            );
          }
        }
      }
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if (!!(process.env.NODE_ENV !== "production") && link.dep.subsHead === void 0) {
      link.dep.subsHead = link;
    }
    link.dep.subs = link;
  }
}
/* @__PURE__ */ Symbol(
  !!(process.env.NODE_ENV !== "production") ? "Object iterate" : ""
);
/* @__PURE__ */ Symbol(
  !!(process.env.NODE_ENV !== "production") ? "Map keys iterate" : ""
);
/* @__PURE__ */ Symbol(
  !!(process.env.NODE_ENV !== "production") ? "Array iterate" : ""
);
new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
// @__NO_SIDE_EFFECTS__
function isReactive(value) {
  if (/* @__PURE__ */ isReadonly(value)) {
    return /* @__PURE__ */ isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
// @__NO_SIDE_EFFECTS__
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
// @__NO_SIDE_EFFECTS__
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
// @__NO_SIDE_EFFECTS__
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
// @__NO_SIDE_EFFECTS__
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? /* @__PURE__ */ toRaw(raw) : observed;
}

// @__NO_SIDE_EFFECTS__
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function unref(ref2) {
  return /* @__PURE__ */ isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    } else if (!!(process.env.NODE_ENV !== "production")) ;
  }
  get value() {
    const link = !!(process.env.NODE_ENV !== "production") ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn("Write operation failed: computed value is readonly");
    }
  }
}
// @__NO_SIDE_EFFECTS__
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  if (!!(process.env.NODE_ENV !== "production") && debugOptions) ;
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  } else if (!!(process.env.NODE_ENV !== "production") && !failSilently) {
    warn(
      `onWatcherCleanup() was called when there was no active watcher to associate with.`
    );
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const warnInvalidSource = (s) => {
    (options.onWarn || warn)(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction(s)) {
        return call ? call(s, 2) : s();
      } else {
        !!(process.env.NODE_ENV !== "production") && warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
    !!(process.env.NODE_ENV !== "production") && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const watchHandle = () => {
    effect.stop();
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (!!(process.env.NODE_ENV !== "production")) {
    effect.onTrack = options.onTrack;
    effect.onTrigger = options.onTrigger;
  }
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Map();
  if ((seen.get(value) || 0) >= depth) {
    return value;
  }
  seen.set(value, depth);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}

/**
* @vue/runtime-core v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  } else if (!!(process.env.NODE_ENV !== "production")) {
    warn$1(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`
    );
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = !!(process.env.NODE_ENV !== "production") ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (!!(process.env.NODE_ENV !== "production")) {
    const info = ErrorTypeStrings$1[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}

const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (!!(process.env.NODE_ENV !== "production")) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  if (!!(process.env.NODE_ENV !== "production")) {
    seen = seen || /* @__PURE__ */ new Map();
  }
  const check = !!(process.env.NODE_ENV !== "production") ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (!!(process.env.NODE_ENV !== "production") && check(job)) {
          continue;
        }
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs(seen);
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  const count = seen.get(fn) || 0;
  if (count > RECURSION_LIMIT) {
    const instance = fn.i;
    const componentName = instance && getComponentName(instance.type);
    handleError(
      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    );
    return true;
  }
  seen.set(fn, count + 1);
  return false;
}
const hmrDirtyComponents = /* @__PURE__ */ new Map();
if (!!(process.env.NODE_ENV !== "production")) {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    if (!(instance.job.flags & 8)) {
      instance.update();
    }
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (let i = 0; i < instances.length; i++) {
    const instance = instances[i];
    const oldComp = normalizeClassComponent(instance.type);
    let dirtyInstances = hmrDirtyComponents.get(oldComp);
    if (!dirtyInstances) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
    }
    dirtyInstances.add(instance);
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      dirtyInstances.add(instance);
      instance.ceReload(newComp.styles);
      dirtyInstances.delete(instance);
    } else if (instance.parent) {
      queueJob(() => {
        if (!(instance.job.flags & 8)) {
          instance.parent.update();
          dirtyInstances.delete(instance);
        }
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
    if (instance.root.ce && instance !== instance.root) {
      instance.root.ce._removeChildStyle(oldComp);
    }
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear();
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}

let devtools$1;
let buffer = [];
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}

let currentRenderingInstance = null;
let currentScopeId = null;
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = getCurrentInstance();
  if (instance || currentApp) {
    let provides = instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1(`injection "${String(key)}" not found.`);
    }
  } else if (!!(process.env.NODE_ENV !== "production")) {
    warn$1(`inject() can only be used inside setup() or functional components.`);
  }
}

const ssrContextKey = /* @__PURE__ */ Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      !!(process.env.NODE_ENV !== "production") && warn$1(
        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`
      );
    }
    return ctx;
  }
};
function watch(source, cb, options) {
  if (!!(process.env.NODE_ENV !== "production") && !isFunction(cb)) {
    warn$1(
      `\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`
    );
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  if (!!(process.env.NODE_ENV !== "production") && !cb) {
    if (immediate !== void 0) {
      warn$1(
        `watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (deep !== void 0) {
      warn$1(
        `watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
    if (once !== void 0) {
      warn$1(
        `watch() "once" option is only respected when using the watch(source, callback, options?) signature.`
      );
    }
  }
  const baseWatchOptions = extend({}, options);
  if (!!(process.env.NODE_ENV !== "production")) baseWatchOptions.onWarn = warn$1;
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
const isTeleport = (type) => type.__isTeleport;
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}

getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const NULL_DYNAMIC_COMPONENT = /* @__PURE__ */ Symbol.for("v-ndc");
const PublicInstanceProxyHandlers = {
  };
if (!!(process.env.NODE_ENV !== "production") && true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn$1(
      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`
    );
    return Reflect.ownKeys(target);
  };
}
let currentApp = null;

const internalObjectProto = {};
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

const queuePostRenderEffect = queueEffectWithSuspense ;

const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}

const Fragment = /* @__PURE__ */ Symbol.for("v-fgt");
const Text = /* @__PURE__ */ Symbol.for("v-txt");
const Comment = /* @__PURE__ */ Symbol.for("v-cmt");
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...args
  );
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (!!(process.env.NODE_ENV !== "production") && vnode.key !== vnode.key) {
    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  return vnode;
}
const createVNode = !!(process.env.NODE_ENV !== "production") ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (!!(process.env.NODE_ENV !== "production") && !type) {
      warn$1(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  if (!!(process.env.NODE_ENV !== "production") && shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn$1(
      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`,
      `
Component that was made reactive: `,
      type
    );
  }
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: !!(process.env.NODE_ENV !== "production") && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    placeholder: vnode.placeholder,
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
let isInSSRComponentSetup = false;
!!(process.env.NODE_ENV !== "production") ? {
  } : {
  };
const classifyRE = /(?:^|[-_])\w/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components) || instance.parent && inferFromRegistry(
      instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (!!(process.env.NODE_ENV !== "production")) {
    const i = getCurrentInstance();
    if (i && i.appContext.config.warnRecursiveComputed) {
      c._warnRecursive = true;
    }
  }
  return c;
};

function initCustomFormatter() {
  if (!!!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#1677ff" };
  const stringStyle = { style: "color:#f5222d" };
  const keywordStyle = { style: "color:#eb2f96" };
  const formatter = {
    __vue_custom_formatter: true,
    header(obj) {
      if (!isObject$1(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        pauseTracking();
        const value = obj.value;
        resetTracking();
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject$1(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject$1(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
!!(process.env.NODE_ENV !== "production") ? warn$1 : NOOP;
!!(process.env.NODE_ENV !== "production") || true ? devtools$1 : void 0;
!!(process.env.NODE_ENV !== "production") || true ? setDevtoolsHook$1 : NOOP;

/**
* vue v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/

function initDev() {
  {
    initCustomFormatter();
  }
}

if (!!(process.env.NODE_ENV !== "production")) {
  initDev();
}

const isClient = typeof window !== "undefined" && typeof document !== "undefined";
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const toString = Object.prototype.toString;
const isObject = (val) => toString.call(val) === "[object Object]";
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}

function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}

const defaultWindow = isClient ? window : void 0;

function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}

function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test = toArray(toValue(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  return stop;
}

function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}

// é¡¶ç‚¹ç€è‰²å™¨
const vertex = `
  in vec2 aPosition;
  in vec2 aPositionOffset;
  in vec3 aColor;

  out vec3 vColor;

  uniform mat3 uProjectionMatrix;
  uniform mat3 uWorldTransformMatrix;
  uniform mat3 uTransformMatrix;

  void main() {
      mat3 mvp = uProjectionMatrix * uWorldTransformMatrix * uTransformMatrix;
      gl_Position = vec4((mvp * vec3(aPosition + aPositionOffset, 1.0)).xy, 0.0, 1.0);
      vColor = aColor;
  }
`;
// ç‰‡å…ƒç€è‰²å™¨
const fragment = `
  in vec3 vColor;

  void main() {
    gl_FragColor = vec4(vColor, 1.0);
  }
`;

// é¢œè‰²è½¬æ¢
const hexToRGB = (hex) => {
  // åŽ»æŽ‰å¯èƒ½å­˜åœ¨çš„ #
  hex = hex.replace(/^#/, "");
  // å°† 3 ä½ç®€å†™è½¬ä¸º 6 ä½
  if (hex.length === 3) {
    hex = hex
      .split("")
      .map((c) => c + c)
      .join("");
  }
  const intVal = parseInt(hex, 16);
  const r = ((intVal >> 16) & 255) / 255;
  const g = ((intVal >> 8) & 255) / 255;
  const b = (intVal & 255) / 255;
  return [r, g, b]
};
// ç”Ÿæˆåœ†å½¢çš„geometry
const generateCircleGeometry = (segments = 40, radius = 6) => {
  const vertexCount = segments + 2; // ä¸­å¿ƒç‚¹ + åœ†å‘¨ä¸Š (segments + 1) ä¸ªç‚¹ï¼ˆé—­åˆåœ†å‘¨ï¼‰
  // åˆ›å»ºé¡¶ç‚¹æ•°ç»„ï¼Œæ¯ä¸ªé¡¶ç‚¹ 2 ä¸ªåˆ†é‡ (x, y)
  const positions = new Float32Array(vertexCount * 2);
  // ç¬¬ä¸€ä¸ªé¡¶ç‚¹ä¸ºåœ†å¿ƒï¼Œä½ç½® (0, 0)ï¼›å¯¹åº”çš„ UV ä¸º (0.5, 0.5)
  positions[0] = 0;
  positions[1] = 0;
  // ç”Ÿæˆåœ†å‘¨ä¸Šçš„é¡¶ç‚¹æ•°æ®
  for (let i = 0; i <= segments; i++) {
    const angle = (i / segments) * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const y = Math.sin(angle) * radius;
    // å°†é¡¶ç‚¹æ•°æ®å­˜å…¥ positions æ•°ç»„
    positions[(i + 1) * 2] = x;
    positions[(i + 1) * 2 + 1] = y;
  }
  // å¦‚æžœä¸æŒ‡å®šç»˜åˆ¶æ¨¡å¼ï¼Œéœ€è¦ç”Ÿæˆç´¢å¼•æ•°ç»„å°†ä¸‰è§’æ‰‡è½¬æ¢ä¸ºä¸‰è§’å½¢åˆ—è¡¨
  // æ¯ä¸ªä¸‰è§’å½¢ä½¿ç”¨åœ†å¿ƒï¼ˆç´¢å¼• 0ï¼‰å’Œåœ†å‘¨ä¸Šç›¸é‚»çš„ä¸¤ä¸ªç‚¹
  const indices = new Uint16Array(segments * 3);
  for (let i = 0; i < segments; i++) {
    indices[i * 3] = 0; // åœ†å¿ƒ
    indices[i * 3 + 1] = i + 1; // å½“å‰åœ†å‘¨ç‚¹
    indices[i * 3 + 2] = i + 2; // ä¸‹ä¸€ä¸ªåœ†å‘¨ç‚¹
  }
  return { positions, indices }
};

class Doodle {
  // ç»˜å›¾å·¥å…·åˆ—è¡¨
  tools = {
    move: "move", // ç§»åŠ¨
    rect: "rect", // çŸ©å½¢
    polygon: "polygon", // å¤šè¾¹å½¢
    circle: "circle", // åœ†
    ellipse: "ellipse", // æ¤­åœ†
    path: "path", // è·¯å¾„
    closed_path: "closed_path", // é—­åˆè·¯å¾„
    line: "line", // ç›´çº¿
    arrow_line: "arrow_line", // ç®­å¤´ç›´çº¿
    point: "point", // ç‚¹
  }
  // é…ç½®
  conf = {
    viewer: null,
  }
  pixiApp // pixi app
  graphics // pixi graphics
  pointMesh // ç‚¹çš„Mesh
  points = [] // ç‚¹é›†åˆ
  mode = this.tools.move // æ¨¡å¼
  viewer // osdçš„ç”»å¸ƒ
  shapes = [] // å½¢çŠ¶æ•°ç»„
  bounds // è¾¹ç•Œ
  anchors = [] // é”šç‚¹æ•°ç»„
  scale = 1 // ç¼©æ”¾
  // å¹³ç§»
  translate = {
    x: 0,
    y: 0,
  }
  strokeWidth = 2 // çº¿å®½
  defaultColor = "#FF0000" // é»˜è®¤é¢œè‰²
  brushColor = "#FF0000" // ç”»ç¬”é¢œè‰²
  hitRadius = 5 // å…‰æ ‡çš„ç¢°æ’žåŠå¾„
  anchorRadius = 5 // é”šç‚¹åŠå¾„
  pointRadius = 6 // ç‚¹åŠå¾„
  tempShape = null // ä¸´æ—¶shapeï¼ˆæ–°å¢žå’Œç¼–è¾‘æ—¶ï¼‰
  hoverShape = null // æ‚¬æµ®çš„shape
  hoverAnchor = null // æ‚¬æµ®çš„é”šç‚¹
  readonly = false // åªè¯»æ¨¡å¼
  // é¼ æ ‡
  mouse = {
    x: 0, // è§†å£x
    y: 0, // è§†å£y
    dx: 0, // ç”»å¸ƒx
    dy: 0, // ç”»å¸ƒy
    isPressed: false, // æ˜¯å¦æŒ‰ä¸‹
  }
  constructor(conf) {
    // å­˜å‚¨é…ç½®
    this.conf = {
      ...this.conf,
      ...conf,
    };
    this.viewer = this.conf.viewer;
    // åˆå§‹åŒ– è¾¹ç•Œ
    this.createBounds();
    // ç›‘å¬é”®ç›˜
    this.listenKeyboard()
    // ç”»å¸ƒ
    ;(async () => {
      // åˆå§‹åŒ– pxii
      await this.createPixi();
      // åˆå§‹åŒ– é¼ æ ‡è·Ÿè¸ªå™¨
      this.createMouseTracker();
      // å¼€å§‹å¾ªçŽ¯
      this.startLoop();
    })();
  }
  // æ¸…ç©ºæ ‡æ³¨
  clear() {
    this.tempShape = null;
    this.shapes = [];
    this.anchors = [];
    this.bounds.clear();
    this.generatePoints();
  }
  // åˆå§‹åŒ–è¾¹ç•Œ
  createBounds() {
    this.bounds = new RBush();
  }
  // ç§»åŠ¨å¤„ç†å™¨
  moveHandler = (e) => {
    const viewport = this.viewer.viewport; // osd è§†å£å¯¹è±¡
    let x, y;
    if (e.position) {
      x = e.position.x;
      y = e.position.y;
    } else {
      x = e.offsetX;
      y = e.offsetY;
    }
    const flipped = viewport.getFlip(); // ç¿»è½¬
    if (flipped) {
      x = viewport._containerInnerSize.x - x;
    }
    this.mouse.x = x;
    this.mouse.y = y;
    const viewportPoint = viewport.pointFromPixel(
      new osd.Point(this.mouse.x, this.mouse.y),
      true
    );
    const dp = viewport._viewportToImageDelta(
      viewportPoint.x - viewport._contentBoundsNoRotate.x,
      viewportPoint.y - viewport._contentBoundsNoRotate.y
    );
    this.mouse.dx = dp.x;
    this.mouse.dy = dp.y;
    handleMouseMove(this);
    // æ‚¬æµ®çš„shape
    this.hoverShape = getHoverShape(this);
    // æ‚¬æµ®çš„é”šç‚¹
    this.hoverAnchor = getHoverAnchor(this);
    // è®¡ç®—é”šç‚¹
    generateAnchors(this);
    // æ›´æ–°é¼ æ ‡æ ·å¼
    this.updateCursor();
  }
  // æŒ‰ä¸‹å¤„ç†å™¨
  pressHandler = () => {
    this.mouse.isPressed = true;
    handleMouseDown(this);
    // è®¡ç®—é”šç‚¹
    generateAnchors(this);
    // æ›´æ–°é¼ æ ‡æ ·å¼
    this.updateCursor();
  }
  // é‡Šæ”¾å¤„ç†å™¨
  releaseHandler = () => {
    this.mouse.isPressed = false;
    handleMouseUp(this);
    // è®¡ç®—é”šç‚¹
    generateAnchors(this);
    // æ›´æ–°é¼ æ ‡æ ·å¼
    this.updateCursor();
  }
  // åˆ›å»ºé¼ æ ‡è·Ÿè¸ªå™¨
  createMouseTracker() {
    this.viewer.canvas.addEventListener("mousemove", this.moveHandler);
    this.viewer.addHandler("canvas-drag", this.moveHandler);
    this.viewer.addHandler("canvas-press", this.pressHandler);
    this.viewer.addHandler("canvas-release", this.releaseHandler);
  }
  // è®¾ç½®æ¨¡å¼
  setMode(mode) {
    this.mode = mode;
    this.setPan(mode === this.tools.move);
    this.cancelSelectShape();
  }
  // è®¾ç½®å…è®¸æ‹–åŠ¨
  setPan(pan) {
    this.viewer.panHorizontal = pan;
    this.viewer.panVertical = pan;
  }
  // é”€æ¯
  destroy() {
    this.viewer.canvas.removeEventListener("mousemove", this.moveHandler);
    this.viewer.removeHandler("canvas-drag", this.moveHandler);
    this.viewer.removeHandler("canvas-press", this.pressHandler);
    this.viewer.removeHandler("canvas-release", this.releaseHandler);
    this.pixiApp.canvas.remove();
    this.pixiApp.destroy();
  }
  // ç›‘å¬é”®ç›˜
  listenKeyboard() {
    onKeyStroke(["Delete"], async (e) => {
      switch (e.code) {
        case "Delete":
          // @ts-ignore
          if (this.tempShape && this.tempShape.id) {
            this.conf.onRemove(this.tempShape);
          }
          break
      }
    });
  }
  // å¸§å¾ªçŽ¯
  startLoop() {
    this.pixiApp.ticker.add(() => {
      render(this);
    });
  }
  // ç”Ÿæˆç‚¹
  generatePoints() {
    this.points = this.shapes.filter(
      // @ts-ignore
      (item) => item.type === this.tools.point && item.id !== this.tempShape?.id
    );
    if (this.pointMesh) {
      this.pixiApp.stage.removeChild(this.pointMesh);
    }
    this.pointMesh = this.createPointMesh(this.points);
    if (this.pointMesh) {
      this.pixiApp.stage.addChild(this.pointMesh);
    }
  }
  // æ·»åŠ å›¾å½¢ï¼ˆæ‰¹é‡ï¼‰
  addShapes(shapes) {
    const _shapes = _.cloneDeep(shapes);
    this.shapes.push(..._shapes);
    for (const shape of _shapes) {
      this.bounds.insert(getBounds(shape, this));
    }
    if (shapes.find((shape) => shape.type === this.tools.point)) {
      this.generatePoints();
    }
  }
  // æ·»åŠ å›¾å½¢
  addShape(shape) {
    const _shape = _.cloneDeep(shape);
    this.shapes.push(_shape);
    this.bounds.insert(getBounds(_shape, this));
    if (shape.type === this.tools.point) {
      this.generatePoints();
    }
  }
  // åˆ é™¤å›¾å½¢ï¼ˆæ‰¹é‡ï¼‰
  removeShapes(shapes) {
    const ids = shapes.map((item) => item.id);
    this.shapes = this.shapes.filter((item) => !ids.includes(item.id));
    for (const shape of shapes) {
      this.bounds.remove(getBounds(shape, this), (a, b) => {
        return a.id === b.id
      });
    }
    if (shapes.find((shape) => shape.type === this.tools.point)) {
      this.generatePoints();
    }
    // @ts-ignore
    if (shapes.find((shape) => shape.id === this.tempShape?.id)) {
      this.tempShape = null;
    }
  }
  // åˆ é™¤å›¾å½¢
  removeShape(shape) {
    this.shapes = this.shapes.filter((item) => item.id !== shape.id);
    this.bounds.remove(getBounds(shape, this), (a, b) => {
      return a.id === b.id
    });
    if (shape.type === this.tools.point) {
      this.generatePoints();
    }
    // @ts-ignore
    if (shape.id === this.tempShape?.id) {
      this.tempShape = null;
    }
    // è®¡ç®—é”šç‚¹
    generateAnchors(this);
  }
  // æ›´æ–°å›¾å½¢ï¼ˆæ‰¹é‡ï¼‰
  updateShapes(shapes) {
    this.removeShapes(shapes);
    this.addShapes(shapes);
  }
  // æ›´æ–°å›¾å½¢
  updateShape(shape) {
    this.removeShape(shape);
    this.addShape(shape);
  }
  // é€‰æ‹©å›¾å½¢
  selectShape(shape) {
    this.tempShape = _.cloneDeep(shape);
    // è®¡ç®—é”šç‚¹
    generateAnchors(this);
  }
  // å–æ¶ˆé€‰æ‹©å›¾å½¢
  cancelSelectShape() {
    // å¦‚æžœæœ‰ä¸´æ—¶shapeåˆ™ä¿®æ­£boundsä½ç½®
    const originalShape = this.shapes.find(
      // @ts-ignore
      (item) => item.id === this.tempShape?.id
    );
    if (originalShape) {
      // ä¿®æ­£ä¸´æ—¶shapeçš„boundsä½ç½®
      this.correctionTempShapeBounds(originalShape);
    }
    this.tempShape = null;
    this.anchors = [];
  }
  // åˆ›å»ºpixi
  async createPixi() {
    const osdDom = this.viewer.canvas;
    const app = new Application();
    this.pixiApp = app;
    await app.init({
      resizeTo: osdDom,
      backgroundAlpha: 0,
      antialias: true, // æŠ—é”¯é½¿
    });
    // @ts-ignore
    osdDom.appendChild(app.canvas);
    app.canvas.style.pointerEvents = "none";
    app.canvas.style.position = "absolute";
    app.canvas.style.top = "0";
    app.canvas.style.left = "0";

    // å›¾å½¢
    const graphics = new Graphics();
    this.graphics = graphics;
    app.stage.addChild(graphics);

    // ç‚¹çš„Mesh
    this.generatePoints();

    // @ts-ignore
    window.__PIXI_DEVTOOLS__ = {
      app: app,
    };
  }
  // èŽ·å–æ¯”ä¾‹
  getScale() {
    const viewer = this.viewer;
    const containerWidth = viewer.viewport.getContainerSize().x;
    const zoom = viewer.viewport.getZoom(true);
    return (zoom * containerWidth) / viewer.world.getContentFactor()
  }
  // è§£æžé¢œè‰²
  parseColor(color) {
    return parseInt(color.replace("#", "0x"), 16)
  }
  // èŽ·å–æ‰€æœ‰å›¾å½¢
  getShapes() {
    return _.cloneDeep(this.shapes)
  }
  // è®¾ç½®é»˜è®¤é¢œè‰²
  setDefaultColor(color) {
    this.defaultColor = color;
  }
  // è®¾ç½®ç”»ç¬”é¢œè‰²
  setBrushColor(color) {
    this.brushColor = color;
  }
  // æ›´æ–°é¼ æ ‡æ ·å¼
  updateCursor() {
    let cursor = "default";
    if (this.mode !== this.tools.move) {
      // ç»˜åˆ¶ä¸­ï¼Œä½¿ç”¨åå­—çº¿
      cursor = "crosshair";
    } else if (this.hoverAnchor) {
      // æ‚¬æµ®åœ¨é”šç‚¹ä¸Š
      cursor = "pointer";
    } else if (this.hoverShape) {
      // æ‚¬æµ®åœ¨shapeä¸Š
      // @ts-ignore
      if (this.tempShape && this.hoverShape?.id === this.tempShape?.id) {
        // æ‚¬æµ®çš„shapeæ˜¯ç¼–è¾‘çŠ¶æ€
        if (this.mouse.isPressed) {
          // æŒ‰ä¸‹çŠ¶æ€
          cursor = "grabbing";
        } else {
          // æœªæŒ‰ä¸‹çŠ¶æ€
          cursor = "grab";
        }
      } else {
        // æ™®é€šæ‚¬æµ®
        cursor = "pointer";
      }
    }
    this.viewer.canvas.style.cursor = cursor;
  }
  // åˆ›å»ºç‚¹Mesh
  createPointMesh(points) {
    const length = points.length;
    if (!length) {
      return null
    }
    const instancePositionBuffer = new Buffer({
      data: new Float32Array(length * 2),
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
    });
    const instanceColorBuffer = new Buffer({
      data: new Float32Array(length * 3), // æ¯ä¸ªä¸‰è§’å½¢ä¸‰ä¸ªå€¼ï¼ˆr, g, bï¼‰
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
    });
    const colorData = instanceColorBuffer.data;
    for (let _i in points) {
      let i = Number(_i);
      const point = points[i];
      point.rgbColor = hexToRGB(point.color || this.defaultColor);
      const index = i * 3;
      colorData[index] = point.rgbColor[0];
      colorData[index + 1] = point.rgbColor[1];
      colorData[index + 2] = point.rgbColor[2];
    }
    instanceColorBuffer.update();
    const { positions, indices } = generateCircleGeometry(40, this.pointRadius);
    const geometry = new Geometry({
      attributes: {
        aPosition: positions,
        aPositionOffset: {
          buffer: instancePositionBuffer,
          instance: true,
        },
        aColor: {
          buffer: instanceColorBuffer,
          instance: true,
        },
      },
      indexBuffer: indices,
      instanceCount: length,
    });
    const gl = { vertex, fragment };
    const shader = Shader.from({
      gl,
    });
    const pointMesh = new Mesh({
      geometry,
      shader,
    });
    return pointMesh
  }
  // ä¿®æ­£ä¸´æ—¶shapeçš„boundsä½ç½®
  correctionTempShapeBounds = (shape) => {
    this.bounds.remove(getBounds(shape, this), (a, b) => {
      return a.id === b.id
    });
    this.bounds.insert(getBounds(shape, this));
  }
  // è®¾ç½®åªè¯»æ¨¡å¼
  setReadOnly = (readonly) => {
    this.readonly = readonly;
    if (this.readonly) {
      this.cancelSelectShape();
    }
  }
  // èŽ·å–ä¸€ä¸ªå½¢çŠ¶çš„ä¸­å¿ƒç‚¹
  getShapeCenter(shape) {
    const { maxX, minX, maxY, minY } = getBounds(shape, this);
    return {
      x: (maxX + minX) / 2,
      y: (maxY + minY) / 2,
    }
  }
  // ç§»åŠ¨è§†é‡Žåˆ°æŸä¸ªshape
  moveToShape(shape = null, immediately = false) {
    if (!shape) return
    // @ts-ignore
    if (shape.id === this.tempShape?.id) {
      shape = this.tempShape;
    }
    const viewport = this.viewer.viewport;
    const center = this.getShapeCenter(shape);
    const osdPoint = viewport.imageToViewportCoordinates(center.x, center.y);
    this.viewer.viewport.panTo(osdPoint, immediately);
  }
}

// åˆ›å»ºæ¶‚é¸¦å®žä¾‹
const createDoodle = (conf) => {
  return new Doodle(conf)
};

extensions.add(AccessibilitySystem);
extensions.mixin(Container, accessibilityTarget);

extensions.add(EventSystem);
extensions.mixin(Container, FederatedContainer);

extensions.add(FilterSystem);
extensions.add(FilterPipe);

var browserAll = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var webworkerAll = /*#__PURE__*/Object.freeze({
  __proto__: null
});

export { Doodle, createDoodle, createDoodle as default };
